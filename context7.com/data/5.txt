TITLE: Invalid Conditional useState Hook in React
DESCRIPTION: This code snippet demonstrates incorrect usage of the `useState` hook. The `useState` hook is called inside a conditional statement (`if (a) return;`), which violates the Rules of Hooks.  Hooks must always be called in the same order in every component render to maintain internal state correctly.  This conditional call can lead to inconsistent state management and is therefore flagged as an error by React's linting rules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-f3d6c5e9c83d.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook() {
  if (b) {
    console.log('true');
  } else {
    console.log('false');
  }
  if (a) return;
  useState();
}

```

----------------------------------------

TITLE: Using Refs as Props without forwardRef
DESCRIPTION: In React 19, refs can be directly used as props, eliminating the need for forwardRef. This simplifies component API design and makes ref forwarding more straightforward.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_4

LANGUAGE: jsx
CODE:
```
// Before React 19 - using forwardRef
const ButtonBefore = React.forwardRef((props, ref) => {
  return <button ref={ref} {...props} />;
});

// React 19 - direct ref passing
function ButtonAfter(props) {
  // ref can be received directly as a prop
  return <button {...props} />;
}

// Usage
function App() {
  const buttonRef = useRef(null);
  
  return <ButtonAfter ref={buttonRef}>Click me</ButtonAfter>;
}
```

----------------------------------------

TITLE: Installing React DOM with npm
DESCRIPTION: Command for installing both react and react-dom packages using npm.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-dom/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
npm install react react-dom
```

----------------------------------------

TITLE: React Component with useEffect and useState
DESCRIPTION: This code defines a React functional component named Foo that uses the useEffect and useState hooks. The useEffect hook updates the state to 2 when the component mounts, and the useState hook initializes the state to 0.  The component renders a Stringify component, passing the state as a prop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-setstate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';
import {Stringify} from 'shared-runtime';

function Foo() {
  /**
   * Previously, this lowered to
   * $1 = LoadContext capture setState
   * $2 = FunctionExpression deps=$1 context=setState
   *  [[ at this point, we freeze the `LoadContext setState` instruction, but it will never be referenced again ]]
   * 
   * Now, this function expression directly references `setState`, which freezes
   * the source `DeclareContext HoistedConst setState`. Freezing source identifiers
   * (instead of the one level removed `LoadContext`) is more semantically correct
   * for everything *other* than hoisted context declarations.
   * 
   * $2 = Function context=setState
   */
  useEffect(() => setState(2), []);

  const [state, setState] = useState(0);
  return <Stringify state={state} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
  sequentialRenders: [{}, {}],
};

```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React Component
DESCRIPTION: This code shows an incorrect implementation where a hook (created by makeObject_Primitives) is called conditionally inside an if statement, which violates React's Rules of Hooks. Hooks must be called in the same order on every render and cannot be placed inside conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-conditionally-call-local-named-like-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives} from 'shared-runtime';

function Component(props) {
  const useFoo = makeObject_Primitives();
  if (props.cond) {
    useFoo();
  }
}
```

LANGUAGE: text
CODE:
```
  4 |   const useFoo = makeObject_Primitives();
  5 |   if (props.cond) {
> 6 |     useFoo();
    |     ^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)
  7 |   }
  8 | }
  9 |
```

----------------------------------------

TITLE: Creating a React Hook with Hook Usage (JavaScript)
DESCRIPTION: This code defines a function `createHook` that returns another function, `useHookWithHook`. The returned function represents a custom React hook that internally calls the `useHook` function. This demonstrates that React hooks can indeed call other hooks within their implementation, which is a valid and common pattern for creating more complex and reusable hook logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-33a6e23edac1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
// Valid because hooks can use hooks.
function createHook() {
  return function useHookWithHook() {
    useHook();
  };
}
```

----------------------------------------

TITLE: Using Action State in React Component (Initial Version)
DESCRIPTION: This snippet demonstrates a functional component 'Component' that uses the 'useActionState' hook from React. It manages an action state, defining an 'onSubmitAction' function to dispatch actions. The component renders the 'Foo' component, passing the action handler as a prop. Prerequisites include the React library where 'useActionState' is defined. Expected inputs are user actions that trigger the submission, while the output is the 'Foo' component rendered with the submission handler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useActionState-dispatch-considered-as-non-reactive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useActionState} from 'react';

function Component() {
  const [actionState, dispatchAction] = useActionState();
  const onSubmitAction = () => {
    dispatchAction();
  };
  return <Foo onSubmitAction={onSubmitAction} />;
}

function Foo() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: React useState Hook Usage in Component
DESCRIPTION: This code snippet demonstrates the correct usage of the `useState` hook within a React component. The hook is called outside of any conditional statements or loops, which is required for React hooks to function correctly. The component `App` is a functional component that uses the useState hook to manage a state variable.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-69521d94fa03.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because the neither the condition nor the loop affect the hook call.
function App(props) {
  const someObject = {propA: true};
  for (const propName in someObject) {
    if (propName === true) {
    } else {
    }
  }
  const [myState, setMyState] = useState(null);
}

```

----------------------------------------

TITLE: Starting Stream Flow in React
DESCRIPTION: Method to begin streaming render output to a destination (Node or Web stream). Handles continuous writing of chunks as they become available after async operations complete.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_8

LANGUAGE: typescript
CODE:
```
startFlowing(request: Request, destination: Destination): void
```

----------------------------------------

TITLE: Implementing Optimistic Updates with useOptimistic Hook
DESCRIPTION: The useOptimistic hook provides a way to update state immediately while a transition is in progress, creating a better user experience. It returns the current state and a setter function that can be called inside a transition.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_2

LANGUAGE: jsx
CODE:
```
function CommentList() {
  const [comments, setComments] = useState([]);
  const [optimisticComments, addOptimisticComment] = useOptimistic(comments);
  
  async function handleAddComment(newComment) {
    startTransition(async () => {
      // Optimistically update the UI immediately
      addOptimisticComment([...comments, newComment]);
      
      // Actually send the comment to the server
      await submitComment(newComment);
      
      // When transition is complete, the real state will be updated
      setComments([...comments, newComment]);
    });
  }
  
  return (
    <div>
      {optimisticComments.map(comment => <Comment data={comment} />)}
      <AddCommentForm onSubmit={handleAddComment} />
    </div>
  );
}
```

----------------------------------------

TITLE: Simplified React Component Implementation
DESCRIPTION: Shows a minimalist version of the component function with empty conditional block and exports the same fixture structure. Used to demonstrate basic component structure without implementation details.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-args-test-binary-operator.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  if (a > b) {
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Using useMemo Hook in React
DESCRIPTION: This code snippet showcases the correct usage of the `useMemo` hook in a React component. It defines a custom hook `useFoo` that conditionally memoizes a value based on the input `cond`. The `useMemo` hook ensures that the value is only recomputed when `cond` changes, preserving memoization guarantees.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo-mult-returns-primitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';
import {identity} from 'shared-runtime';

function useFoo(cond) {
  useMemo(() => {
    if (cond) {
      return 2;
    } else {
      return identity(5);
    }
  }, [cond]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};

```

----------------------------------------

TITLE: Incorrect useState Usage in React
DESCRIPTION: This code demonstrates an anti-pattern in React where the state object `x` obtained from `useState` is directly mutated.  The `onChange` handler directly modifies `x.value` which is against React's principle of immutability.  This mutation is then followed by calling `setX` with the mutated object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-function-expression-mutates-immutable-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [x, setX] = useState({value: ''});
  const onChange = e => {
    // INVALID! should use copy-on-write and pass the new value
    x.value = e.target.value;
    setX(x);
  };
  return <input value={x.value} onChange={onChange} />;
}

```

----------------------------------------

TITLE: Utilizing Optional Chaining in React Component - JavaScript
DESCRIPTION: This code sample shows a React component function making use of optional chaining for safe property access within a JavaScript object. It expects 'a' to be declared in outer scope and its structure 'a?.b.c[0]' to potentially provide the desired value or undefined. Optional chaining requires compatibility with ES2020 or higher.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-computed-load-static.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = a?.b.c[0];
  return x;
}
```

----------------------------------------

TITLE: Installing react-devtools Globally with Package Managers
DESCRIPTION: Commands for installing the react-devtools package globally using either Yarn or NPM package managers. This is the recommended approach for development tools that will be used across multiple projects.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
# Yarn
yarn global add react-devtools

# NPM
npm install -g react-devtools
```

----------------------------------------

TITLE: Root Rendering with createRoot and hydrateRoot
DESCRIPTION: New root rendering methods for improved React application initialization and hydration, supporting concurrent mode and better performance.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_15

LANGUAGE: javascript
CODE:
```
const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that renders a 'hello world' div element, using TypeScript type annotations and JSX syntax.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-type-import.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import type {ReactElement} from 'react';

function Component(_props: {}): ReactElement {
  return <div>hello world</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Using the new use API with Promises and Context
DESCRIPTION: The use API allows reading resources during render and supports both promises and Context. When provided a promise, it will suspend until a value is resolved. Unlike hooks, use can be called conditionally within render.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_3

LANGUAGE: jsx
CODE:
```
// With Promise
function ProfileDetails({ userId }) {
  const userDataPromise = fetchUserData(userId);
  
  // Will suspend component until promise resolves
  const userData = use(userDataPromise);
  
  return <div>{userData.name}</div>;
}

// With Context
function ThemeText({ children }) {
  // Can be used conditionally unlike useContext
  const theme = use(ThemeContext);
  
  if (theme.dark) {
    return <span className="dark-text">{children}</span>;
  } else {
    return <span className="light-text">{children}</span>;
  }
}
```

----------------------------------------

TITLE: React Hook: Using a Hook Within Another Hook (JavaScript)
DESCRIPTION: This code snippet demonstrates a valid React custom hook, `useHookWithHook`, which internally calls another hook, `useHook`.  This pattern is permitted and allows for the composition of hook logic. The assumption is that `useHook` is a previously defined hook in the same scope or imported from elsewhere.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-844a496db20b.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because hooks can use hooks.
function useHookWithHook() {
  useHook();
}

```

----------------------------------------

TITLE: Creating Composable React Custom Hook
DESCRIPTION: Demonstrates how hooks can be nested and call other hooks, enabling complex hook interactions and logic reuse in React applications
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-23dc7fffde57.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because hooks can call hooks.\nfunction useHook() {\n  return useHook1() + useHook2();\n}
```

----------------------------------------

TITLE: Creating a Custom React Hook in JavaScript
DESCRIPTION: This code snippet demonstrates the creation of a custom React hook. The `createHook` function returns a `useHook` function which in turn calls other hooks (`useHook1` and `useHook2`). This illustrates a valid pattern in React where hooks can invoke other hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-2bec02ac982b.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
// Valid because hooks can call hooks.
function createHook() {
  return function useHook() {
    useHook1();
    useHook2();
  };
}

```

----------------------------------------

TITLE: JSX Transformation Change
DESCRIPTION: This snippet describes a breaking change in the JSX transformation process. The `class` attribute is no longer automatically transformed to `className`. Developers must manually update their code to use `className` to avoid visual issues in their components.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_24

LANGUAGE: none
CODE:
```
"No longer transform `class` to `className` as part of the transform! This is a breaking change - if you were using `class`, you *must* change this to `className` or your components will be visually broken."
```

----------------------------------------

TITLE: React Hook Conditional Call Error
DESCRIPTION: This error message indicates that React hooks are being called conditionally.  React's rules of hooks state that hooks must be called in the same order on every render of a component.  Calling a hook inside an `if` statement violates this rule and can lead to unexpected behavior and errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-aliased-react-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  4 |   let s;
  5 |   if (props.cond) {
> 6 |     [s] = state();
    |           ^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)
  7 |   }     
  8 |   return s;
  9 | }

```

----------------------------------------

TITLE: Adding Transition Hooks in React
DESCRIPTION: Introduction of new hooks `useTransition` and `useDeferredValue` to manage urgent and non-urgent updates in React applications, improving rendering performance and user experience.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_13

LANGUAGE: javascript
CODE:
```
const [isPending, startTransition] = useTransition();
const deferredValue = useDeferredValue(value);
```

----------------------------------------

TITLE: Server-Side Rendering with React DOM
DESCRIPTION: Example of server-side rendering using react-dom/server's renderToPipeableStream function. Shows how to create a stream and pipe it to an HTTP response.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-dom/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { renderToPipeableStream } from 'react-dom/server';

function App() {
  return <div>Hello World</div>;
}

function handleRequest(res) {
  // ... in your server handler ...
  const stream = renderToPipeableStream(<App />, {
    onShellReady() {
      res.statusCode = 200;
      res.setHeader('Content-type', 'text/html');
      stream.pipe(res);
    },
    // ...
  });
}
```

----------------------------------------

TITLE: Invalid React Hook Implementation with Side Effects
DESCRIPTION: An example of incorrect React hook implementation that modifies state outside component scope. The hook violates React's rule about pure components by reassigning an external variable, which should instead be managed with useState.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.update-global-should-bailout.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
let renderCount = 0;
function useFoo() {
  renderCount += 1;
  return renderCount;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: React Hook Invocation Error Demonstration
DESCRIPTION: Shows an error message from React indicating that hooks cannot be passed around as regular values and must be called directly
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-property-load-local-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values
```

----------------------------------------

TITLE: Creating a Basic React Component with JSX
DESCRIPTION: This example demonstrates how to create a simple React component that renders a personalized greeting message. It shows importing the createRoot API from react-dom/client, defining a functional component with props, and rendering it to a DOM container.
SOURCE: https://github.com/facebook/react/blob/main/README.md#2025-04-21_snippet_0

LANGUAGE: jsx
CODE:
```
import { createRoot } from 'react-dom/client';

function HelloMessage({ name }) {
  return <div>Hello {name}</div>;
}

const root = createRoot(document.getElementById('container'));
root.render(<HelloMessage name="Taylor" />);
```

----------------------------------------

TITLE: Rendering React Components in Browser
DESCRIPTION: Example of how to use react-dom/client to render a React component in the browser. Shows importing createRoot, defining a simple component, and rendering it to a DOM element.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-dom/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { createRoot } from 'react-dom/client';

function App() {
  return <div>Hello World</div>;
}

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

----------------------------------------

TITLE: Using the new useActionState Hook in React 19
DESCRIPTION: useActionState is a new hook that manages actions inside transitions with access to the action's state and pending state. It accepts a reducer for calling actions and an initial state, with an optional string for form progressive enhancement.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_1

LANGUAGE: jsx
CODE:
```
function MyComponent() {
  const [state, dispatch] = useActionState(
    (state, action) => {
      // Handle different actions
      switch(action.type) {
        case 'update':
          return { ...state, data: action.data };
        default:
          return state;
      }
    },
    { data: null, loading: false },
    'optional-form-action-id'
  );

  return (
    <div>
      {state.loading ? 'Loading...' : state.data}
      <button onClick={() => startTransition(async () => {
        dispatch({ type: 'update', data: await fetchData() });
      })}>Load Data</button>
    </div>
  );
}
```

----------------------------------------

TITLE: Defining React Component with Hooks and Rendering Logic
DESCRIPTION: This snippet defines a React component using hooks and includes rendering logic. It demonstrates the use of useEffect, state management, and JSX rendering with dynamic content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-memoize-array-with-mutable-map-after-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';
import {mutate} from 'shared-runtime';

function Component(props) {
  const x = [{...props.value}];
  useEffect(() => {}, []);
  const onClick = () => {
    console.log(x.length);
  };
  let y;
  return (
    <div onClick={onClick}>
      {x.map(item => {
        item.flag = true;
        return <span key={item.id}>{item.text}</span>;
      })}
      {mutate(y)}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: {id: 0, text: 'Hello', flag: false}}],
  isComponent: true,
};
```

----------------------------------------

TITLE: React Hook Error Message
DESCRIPTION: Error message showing the invalid reassignment of a variable outside component scope. The error explains that components and hooks must be pure and side-effect free, suggesting useState as the proper solution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.update-global-should-bailout.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  1 | let renderCount = 0;
  2 | function useFoo() {
> 3 |   renderCount += 1;
    |   ^^^^^^^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)
  4 |   return renderCount;
  5 | }
  6 |
```

----------------------------------------

TITLE: Implementing React Counter Component
DESCRIPTION: This snippet defines a React component that uses useState to manage a counter. It renders a button that increments the count when clicked.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expr-directive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  'use strict';
  let [count, setCount] = React.useState(0);
  function update() {
    'worklet';
    setCount(count => count + 1);
  }
  return <button onClick={update}>{count}</button>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Creating Root for Rendering in React 18
DESCRIPTION: New method to create a root for rendering or unmounting in React 18. It replaces ReactDOM.render and is required for new React 18 features.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_8

LANGUAGE: javascript
CODE:
```
createRoot
```

----------------------------------------

TITLE: React Component Definition and Export (Input)
DESCRIPTION: Defines a functional React component named `Component` that renders a div containing the text "Hello world".  It exports this component as `FIXTURE_ENTRYPOINT` with metadata indicating it's a component and requires no parameters. This version is intended for internal meta usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/target-flag-meta-internal.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @target="donotuse_meta_internal"

function Component() {
  return <div>Hello world</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component implementing useDispatch and useEffect hooks with a memoized callback function. Shows the basic implementation pattern before compilation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-arg-memoized.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const dispatch = useDispatch();
  useFreeze(dispatch);

  // onUpdate should be memoized even though it doesn't
  // flow into the return value
  const onUpdate = () => {
    dispatch({kind: 'update'});
  };

  useEffect(() => {
    onUpdate();
  }, [onUpdate]);

  return <div />;
}
```

----------------------------------------

TITLE: Importing useCallback in JavaScript
DESCRIPTION: Illustrates the import of useCallback from React, defining a custom hook function that returns a memoized function based on specified dependencies. The code snippet shows the function useFoo that takes two arguments and memoizes a function with the primary dependency being the first argument.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-fewer-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useCallback} from 'react';

// It's correct to produce memo blocks with fewer deps than source
function useFoo(a, b) {
  return useCallback(() => [a], [a, b]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [1, 2],
};

```

----------------------------------------

TITLE: Rendering React Component with Props
DESCRIPTION: This React component receives `props` as an argument. It accesses the `post` property, then navigates through `feedback`, `comments`, and `edges` to potentially map over these edges using the `render` function. The optional chaining operator (`?.`) is used to avoid errors if any of the intermediate properties are null or undefined.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependencies-non-optional-properties-inside-optional-chain.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return props.post.feedback.comments?.edges?.map(render);
}
```

----------------------------------------

TITLE: Initializing React Component with useRef in JavaScript
DESCRIPTION: The snippet illustrates how to use the useRef hook to create a mutable ref object in a React component. Its current property should be accessed outside the render phase to avoid errors. The example demonstrates a common issue where ref.current is set during rendering, which is flagged as invalid. No specific dependencies beyond React and JavaScript are required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-disallow-mutating-ref-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function Component() {
  const ref = useRef(null);
  ref.current = false;

  return <button ref={ref} />;
}

```

----------------------------------------

TITLE: Defining React Component with Custom Hook
DESCRIPTION: This code defines a React component `SomeName` that uses a custom hook `useSomeHook`. The component also demonstrates conditional rendering, returning `null` if `anyConditionCanEvenBeFalse` is true. The hook call is placed before the conditional return to ensure it's always called in the same order.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-6949b255e7eb.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Unsupported input

// Valid because the neither the conditions before or after the hook affect the hook call
// Failed prior to implementing BigInt because pathsFromStartToEnd and allPathsFromStartToEnd were too big and had rounding errors
const useSomeHook = () => {};

const SomeName = () => {
  const filler = FILLER ?? FILLER ?? FILLER;
  const filler2 = FILLER ?? FILLER ?? FILLER;
  const filler3 = FILLER ?? FILLER ?? FILLER;
  const filler4 = FILLER ?? FILLER ?? FILLER;
  const filler5 = FILLER ?? FILLER ?? FILLER;
  const filler6 = FILLER ?? FILLER ?? FILLER;
  const filler7 = FILLER ?? FILLER ?? FILLER;
  const filler8 = FILLER ?? FILLER ?? FILLER;

  useSomeHook();

  if (anyConditionCanEvenBeFalse) {
    return null;
  }

  return (
    <React.Fragment>
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
      {FILLER ? FILLER : FILLER}
    </React.Fragment>
  );
};

```

----------------------------------------

TITLE: Initializing New React 18 Hooks
DESCRIPTION: Introduction of new React 18 hooks including useId for generating unique IDs, startTransition and useTransition for marking non-urgent updates, useDeferredValue for deferred rendering, useSyncExternalStore for external store management, and useInsertionEffect for CSS-in-JS optimization.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_6

LANGUAGE: javascript
CODE:
```
// Generate unique IDs
const id = useId();

// Mark updates as non-urgent
startTransition(() => {
  setSearchQuery(input);
});

// Defer re-rendering
const deferredValue = useDeferredValue(value);

// Sync external store
const state = useSyncExternalStore(subscribe, getSnapshot);

// CSS-in-JS optimization
useInsertionEffect(() => {
  // inject styles here
});
```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React Component
DESCRIPTION: Example of incorrect React Hook implementation where useConditionalHook is called inside a conditional statement. This violates React's Rules of Hooks which require hooks to be called in the same order on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-2aabd222fc6a.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function ComponentWithConditionalHook() {
  if (cond) {
    useConditionalHook();
  }
}
```

LANGUAGE: plaintext
CODE:
```
   5 | function ComponentWithConditionalHook() {
   6 |   if (cond) {
>  7 |     useConditionalHook();
     |     ^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)
   8 |   }
   9 | }
  10 |
```

----------------------------------------

TITLE: Conditional Hook Call in React Component (JavaScript)
DESCRIPTION: This code shows a React component `Component` that conditionally calls the `useArray` hook based on the `props.cond` value. This violates the Rules of Hooks, as hooks must be called in the same order on every render. The `useArray` hook is imported as `makeArray` from the `other` module.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-non-hook-imported-as-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray as useArray} from 'other';

function Component(props) {
  let data;
  if (props.cond) {
    data = useArray();
  }
  return data;
}

```

----------------------------------------

TITLE: Initializing React Hook with Conditional State Update
DESCRIPTION: A React functional component demonstrating useMemo hook with parameter destructuring. The function checks width condition and potentially updates styles based on input parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/maybe-invalid-useMemo-no-memoblock-sideeffect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({minWidth, styles, setStyles}) {
  useMemo(() => {
    if (styles.width > minWidth) {
      setStyles(styles);
    }
  }, [styles, minWidth, setStyles]);
}
```

LANGUAGE: javascript
CODE:
```
function useFoo(t0) {
  const { minWidth, styles, setStyles } = t0;
  let t1;
  if (styles.width > minWidth) {
    setStyles(styles);
  }
  t1 = undefined;
}
```

----------------------------------------

TITLE: Validating Ref Access During Render in React JavaScript
DESCRIPTION: The code snippet demonstrates a React component that incorrectly accesses a ref during the render phase, which is against React's rules. This example aims to highlight the pitfalls of accessing the ref's current property during rendering, which can lead to errors. It showcases the use of the `useRef` hook and emphasizes the necessity of adhering to React's rules to avoid invalid operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-use-ref-added-to-dep-without-type-info.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function Foo({a}) {
  const ref = useRef();
  // type information is lost here as we don't track types of fields
  const val = {ref};
  // without type info, we don't know that val.ref.current is a ref value so we
  // *would* end up depending on val.ref.current
  // however, this is an instance of accessing a ref during render and is disallowed
  // under React's rules, so we reject this input
  const x = {a, val: val.ref.current};

  return <VideoList videos={x} />;
}

```

----------------------------------------

TITLE: Using new Context API in React 16.3+
DESCRIPTION: Example of using the new officially supported context API introduced in React 16.3.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_18

LANGUAGE: JavaScript
CODE:
```
const MyContext = React.createContext(defaultValue);

// In a class component:
static contextType = MyContext;

// In a function component:
const value = useContext(MyContext);
```

----------------------------------------

TITLE: Defining Component Logic with Props in JavaScript
DESCRIPTION: This snippet defines a functional React component that takes `props` as an argument. It initializes an array `a`, conditionally fills it with values from `props`, and returns the modified array. This component reacts to the presence of `props.b` to decide whether to push another property `props.c` into the array. Dependencies include React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-break-labeled.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
/**
 * props.b *does* influence `a`
 */
function Component(props) {
  const a = [];
  a.push(props.a);
  label: {
    if (props.b) {
      break label;
    }
    a.push(props.c);
  }
  a.push(props.d);
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining a Component Function in React
DESCRIPTION: This snippet defines a simple React component function that utilizes an auxiliary function to create an object from props and then calls an optional method if it exists. It accepts props as an argument and returns the result of the method call.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-method-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeObject(props);
  const y = makeObject(props);
  const z = x.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));
  return z;
}
```

----------------------------------------

TITLE: Defining a React Component with Ref Usage
DESCRIPTION: This snippet defines a React functional component that incorrectly accesses the 'current' property of a ref during the render phase, triggering a warning. The use of the `useRef` hook is demonstrated, and the resulting behavior highlights the violation of React's rules regarding ref access in the render cycle.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-ref-to-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function Component(props) {
  const ref = useRef(null);
  const x = foo(ref);
  return x.current;
}
```

----------------------------------------

TITLE: Original React Component with useState Hook
DESCRIPTION: A simple React component that uses the useState hook to initialize a state variable with null and returns it in an array. The input component shows the code before compilation optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-hook-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function Component(props) {
  const [state, _] = useState(null);
  return [state];
}
```

----------------------------------------

TITLE: Original React Component with Memoization
DESCRIPTION: React component implementing memoization of an object containing event handlers. Uses useMemo to optimize performance by preventing unnecessary recreation of handlers when config prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reordering-across-blocks.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component({config}) {
  const object = useMemo(() => {
    const a = event => {
      config?.onA?.(event);
    };

    const b = event => {
      config?.onB?.(event);
    };

    return {
      b,
      a,
    };
  }, [config]);

  return <Stringify value={object} />;
}
```

----------------------------------------

TITLE: Original React Component with Reactive References in useEffect
DESCRIPTION: This code demonstrates a React component that uses references conditionally and includes them in an effect. The challenge is that setState variables cannot be automatically omitted from dependencies based on types alone - reactivity must be considered.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-setState.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect, useState} from 'react';
import {print} from 'shared-runtime';

/*
 * setState types are not enough to determine to omit from deps. Must also take reactivity into account.
 */
function ReactiveRefInEffect(props) {
  const [_state1, setState1] = useRef('initial value');
  const [_state2, setState2] = useRef('initial value');
  let setState;
  if (props.foo) {
    setState = setState1;
  } else {
    setState = setState2;
  }
  useEffect(() => print(setState));
}
```

----------------------------------------

TITLE: React Component with Impure Calls
DESCRIPTION: This code defines a React component named `Component` that calls impure functions `Date.now()`, `performance.now()`, and `Math.random()` directly within its body. This violates React's purity rule, which requires components to be idempotent and predictable. The component returns a `<Foo>` element with props derived from these impure function calls.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-impure-functions-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoImpureFunctionsInRender

function Component() {
  const date = Date.now();
  const now = performance.now();
  const rand = Math.random();
  return <Foo date={date} now={now} rand={rand} />;
}

```

----------------------------------------

TITLE: Invalid React Hook Usage Component
DESCRIPTION: Example of incorrect hook usage where a hook is passed as a prop to a component. This violates React's rules of hooks as hooks must be the same function on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-as-prop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({useFoo}) {
  useFoo();
}

```

LANGUAGE: text
CODE:
```
  1 | function Component({useFoo}) {
> 2 |   useFoo();
    |   ^^^^^^ InvalidReact: Hooks must be the same function on every render, but this value may change over time to a different function. See https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks (2:2)
  3 | }
  4 |

```

----------------------------------------

TITLE: Reading Contexts in outer tree
DESCRIPTION: This snippet demonstrates where to find the logic for reading React Contexts in the outer React tree and combining them into a single object for passing down to the inner tree. It points to the `src/modern/lazyLegacyRoot.js` file as the location for this functionality, specifically highlighting the `useContext` calls and their aggregation.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_4

LANGUAGE: javascript
CODE:
```
/*
* `src/modern/lazyLegacyRoot.js`: Look for `useContext` calls, and how their results are combined into a single object that is passed through. **You can read more Contexts there** if your app requires them.
*/
```

----------------------------------------

TITLE: React Error: Invalid Variable Modification
DESCRIPTION: This error message indicates that the code attempts to modify `window.href` directly within the component's function body. React recommends using effect hooks for side effects to manage component lifecycle and avoid direct DOM manipulation. The error highlights the specific line where the invalid modification occurs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.object-capture-global-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Foo() {
  2 |   const x = () => {
> 3 |     window.href = 'foo';
    |     ^^^^^^ InvalidReact: Writing to a variable defined outside a component or hook is not allowed. Consider using an effect (3:3)
  4 |   };
  5 |   const y = {x};
  6 |   return <Bar y={y} />;

```

----------------------------------------

TITLE: Implementing Flight Render Function in React Server Components
DESCRIPTION: This code demonstrates how to implement a render function for React Server Components using the Flight renderer. It creates a request and returns a ReadableStream for streaming the rendered output, handling starting, flowing, and aborting the render process.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  createRequest,
  startWork,
  startFlowing,
  stopFlowing,
  abort,
} from 'react-server/src/ReactFlightServer'

function render(
  model: ReactClientValue,
  clientManifest: ClientManifest,
  options?: Options,
): ReadableStream {
  const request = createRequest(
    model,
    clientManifest,
    options ? options.onError : undefined,
    options ? options.identifierPrefix : undefined,
    options ? options.onPostpone : undefined,
    options ? options.temporaryReferences : undefined,
    __DEV__ && options ? options.environmentName : undefined,
    __DEV__ && options ? options.filterStackFrame : undefined,
  );
  const stream = new ReadableStream(
    {
      type: 'bytes',
      start: (controller): ?Promise<void> => {
        startWork(request);
      },
      pull: (controller): ?Promise<void> => {
        startFlowing(request, controller);
      },
      cancel: (reason): ?Promise<void> => {
        stopFlowing(request);
        abort(request, reason);
      },
    },
    {highWaterMark: 0},
  );
  return stream;
}
```

----------------------------------------

TITLE: Defining React Component with Hook and Callback
DESCRIPTION: This snippet defines a React component that uses a custom hook to get an entity ID and creates a callback function for logging. It then renders a child component with the callback as a prop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-maybe-mutates-hook-return-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const id = useSelectedEntitytId();
  // this example should infer `id` as mutable, and then infer `onLoad` as mutable,
  // and be rejected because onLoad cannot be passed as a frozen value in the JSX.
  // however, we likely have to allow this example to work, because hook return
  // values are generally immutable in practice and are also widely referenced in
  // callbacks.
  const onLoad = () => {
    log(id);
  };
  return <Foo onLoad={onLoad} />;
}
```

----------------------------------------

TITLE: React Component Definition with Props and Mapping
DESCRIPTION: Defines a React component named `Component2` that accepts a `props` object with an `items` array. It uses the `map` function to iterate through the `items` array and renders each item as a list item (`<li>`) within an unordered list (`<ul>`).  The `key` prop is set to `item.id` for efficient React rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-func-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const Component2 = props => {
  return (
    <ul>
      {props.items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );}

```

----------------------------------------

TITLE: Flight Rendering Examples with Primitive and Complex Types
DESCRIPTION: Examples of rendering different data types with React Server Components, including primitives, objects, arrays, and collection types like Maps and Sets using the createResponse function.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// primitives
createResponse(123, ...)

// objects and Arrays
createResponse({ messages: ['hello', 'react'] }, ...)

// Maps, Sets, and more
createResponse({ m: Map(['k', 'v'])}, ...)
```

----------------------------------------

TITLE: React Invalid Reassignment Error
DESCRIPTION: This error message highlights the invalid reassignment of the `local` variable within the `reassignLocal` function.  It indicates that reassigning a variable after render has completed can lead to inconsistent behavior. The suggestion is to use state instead of local variables for values needing persistence across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-jsx-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  3 |
  4 |   const reassignLocal = newValue => {
> 5 |     local = newValue;
    |     ^^^^^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `local` cannot be reassigned after render (5:5)
  6 |   };
  7 |
  8 |   const onClick = newValue => {
```

----------------------------------------

TITLE: Error Message for Invalid React Component Implementation
DESCRIPTION: This error message is generated when analyzing the React component. It points out the specific line where setState is called unconditionally during render, which would trigger an infinite loop. The error provides a link to the React documentation for further information.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-after-loop.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  4 |   for (const _ of props) {
  5 |   }
> 6 |   setState(true);
    |   ^^^^^^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (6:6)
  7 |   return state;
  8 | }
  9 |
```

----------------------------------------

TITLE: Defining Component with useState - JavaScript
DESCRIPTION: This code snippet defines a functional React component that uses the useState hook to manage state. It includes three inner functions: foo to update the state, bar to conditionally call foo based on props, and baz to invoke bar. The useState hook initializes the state variable x to 0, and the component returns the current state value in an array. This example is designed to validate that setState is not called during the render cycle.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/validate-no-set-state-in-render-unconditional-lambda-which-conditionally-sets-state-ok.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoSetStateInRender
import {useState} from 'react';

function Component(props) {
  const [x, setX] = useState(0);

  const foo = () => {
    setX(1);
  };

  const bar = () => {
    if (props.cond) {
      // This call is now conditional, so this should pass validation
      foo();
    }
  };

  const baz = () => {
    bar();
  };
  baz();

  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: false}],
};

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateNoSetStateInRender
import { useState } from "react";

function Component(props) {
  const $ = _c(2);
  const [x, setX] = useState(0);

  const foo = () => {
    setX(1);
  };

  const bar = () => {
    if (props.cond) {
      foo();
    }
  };

  const baz = () => {
    bar();
  };

  baz();
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: false }],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that processes props into a JSON string, performs early return checks, and renders a Stringify component with various array values. Uses useMemo for performance optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-renaming-conflicting-decls.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify, identity, makeArray, toJSON} from 'shared-runtime';
import {useMemo} from 'react';

function Component(props) {
  const propsString = useMemo(() => toJSON(props), [props]);
  if (propsString.length <= 2) {
    return null;
  }

  const linkProps = {
    url: identity(propsString),
  };
  const x = {};

  // reactive scope ends at makeArray, as it is inferred as maybeMutate
  return (
    <Stringify
      link={linkProps}
      val1={[1]}
      val2={[2]}
      val3={[3]}
      val4={[4]}
      val5={[5]}>
      {makeArray(x, 2)}
    </Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{val: 2}],
};
```

----------------------------------------

TITLE: Inferring Compilation Mode in React Components
DESCRIPTION: This snippet demonstrates the usage of a function with a 'use' prefix inside an unnamed function argument, explaining that it is not treated as a hook. There are no prerequisites beyond basic JavaScript and React knowledge. It accepts a function with parameters 'foo' and 'bar', calls 'useNotAHook(bar)' if 'foo' is truthy, and does not return any output. The snippet requires no special dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-fe6042f7628b.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)\n// This is valid because \"use\"-prefixed functions called in\n// unnamed function arguments are not assumed to be hooks.\nunknownFunction(function (foo, bar) {\n  if (foo) {\n    useNotAHook(bar);\n  }\n});
```

----------------------------------------

TITLE: Server Reference with 'use server' Directive
DESCRIPTION: Example demonstrating server references with the 'use server' directive. This shows a function that can be called from both server components and client components but is executed on the server in both cases.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_5

LANGUAGE: jsx
CODE:
```
async function logOnServer(message) {
  "use server"
  console.log(message)
}

async function App({ children }) {
  // logOnServer can be used in a Server Component
  logOnServer('used from server')
  return children
}

createResponse(
  <App >
    <ClientComp onClick={logOnServer} message={"used from client"} />
  </App>,
...)
```

----------------------------------------

TITLE: React Component with useRef and onChange handler
DESCRIPTION: This React component uses useRef to store a mutable value and an onChange handler to update it. The onChange handler updates the ref's current value based on the event's target value. The useEffect hook logs the current value of the ref after each render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-in-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const ref = useRef(null);
  const onChange = e => {
    const newValue = e.target.value ?? ref.current;
    ref.current = newValue;
  };
  useEffect(() => {
    console.log(ref.current);
  });
  return <Foo onChange={onChange} />;
}

```

----------------------------------------

TITLE: React Component using useMemo
DESCRIPTION: This snippet defines a React component named `Component` that utilizes `useMemo` to memoize the `props.value`. The `useMemo` hook ensures that the value is only recalculated when `props.value` changes. The `FIXTURE_ENTRYPOINT` is an object used for testing and specifies the component, its parameters, and component identifier.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-labeled-statement-unconditional-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = useMemo(() => {
    label: {
      return props.value;
    }
  });
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Streaming Server Rendering in Node Environments
DESCRIPTION: New API for streaming server-side rendering in Node environments with full support for Suspense.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_10

LANGUAGE: javascript
CODE:
```
renderToPipeableStream
```

----------------------------------------

TITLE: Implementing Original React Component with Array Mapping
DESCRIPTION: This snippet defines a React component that maps over an array of items from props and returns an array with a fixed value and the mapped items. It also exports a fixture for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-hoisting-variable-collision.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const items = props.items.map(x => x);
  const x = 42;
  return [x, items];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{items: [0, 42, null, undefined, {object: true}]}],
};
```

----------------------------------------

TITLE: Creating a custom hook with useCallback in React
DESCRIPTION: This snippet demonstrates the use of the 'useCallback' hook from React to create a custom hook named 'useFoo'. It memoizes a function that returns an array containing a constant string. This provides performance optimizations by preventing unnecessary re-renders when the component using this hook re-renders, as long as 'CONST_STRING0' remains unchanged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-scope-global.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useCallback} from 'react';
import {CONST_STRING0} from 'shared-runtime';

// It's correct to infer a useCallback block has no reactive dependencies
function useFoo() {
  return useCallback(() => [CONST_STRING0], [CONST_STRING0]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Creating Conditional Render Component with Props in React
DESCRIPTION: This snippet defines a React functional component that conditionally renders one of two static text components based on the boolean prop 'showText1'. It utilizes the 'RenderPropAsChild' component to render the selected text dynamically. The component is exported with a predefined parameter for use in other parts of the application.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-ternary-local-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {RenderPropAsChild, StaticText1, StaticText2} from 'shared-runtime';

function Component(props: {showText1: boolean}) {
  const Foo = props.showText1 ? StaticText1 : StaticText2;

  return <RenderPropAsChild items={[() => <Foo key="0" />]} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{showText1: false}],
};
```

----------------------------------------

TITLE: Defining Component with Hook - JavaScript
DESCRIPTION: This snippet defines a React component that correctly utilizes a hook. It demonstrates the use of hooks within functional components in React, ensuring that components adhere to best practices when incorporating React hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-1ff6c3fbbc94.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because components can use hooks.
function ComponentWithHook() {
  useHook();
}

```

----------------------------------------

TITLE: Configuring additionalHooks option for exhaustive-deps rule
DESCRIPTION: Advanced configuration for the exhaustive-deps rule to validate dependencies of custom Hooks using a regex pattern to match custom Hook names.
SOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_7

LANGUAGE: javascript
CODE:
```
{
  rules: {
    // ...
    "react-hooks/exhaustive-deps": ["warn", {
      additionalHooks: "(useMyCustomHook|useMyOtherCustomHook)"
    }]
  }
}
```

----------------------------------------

TITLE: Subscribing to RxJS BehaviorSubject with use-subscription in React
DESCRIPTION: Code example showing how to use the useSubscription hook to subscribe to an RxJS BehaviorSubject. The component will re-render automatically when the subject emits a new value.
SOURCE: https://github.com/facebook/react/blob/main/packages/use-subscription/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
const subscription = useMemo(
  () => ({
    getCurrentValue: () => behaviorSubject.getValue(),
    subscribe: callback => {
      const subscription = behaviorSubject.subscribe(callback);
      return () => subscription.unsubscribe();
    }
  }),

  // Re-subscribe any time the behaviorSubject changes
  [behaviorSubject]
);

const value = useSubscription(subscription);
```

----------------------------------------

TITLE: Defining a React Component in JavaScript
DESCRIPTION: Defines a React functional component using useState to manage state and useCallback for memoizing the increment function. The component renders a Foo element that triggers the increment function on click.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-callback-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  const [count, setCount] = useState(0);
  const increment = useCallback(() => setCount(count + 1));

  return <Foo onClick={increment}></Foo>;
}

```

----------------------------------------

TITLE: React Component with onClick handler
DESCRIPTION: This code defines a React component named `Component` that includes an `onClick` handler. The initial implementation attempts to define and then reassign the `onClick` variable inside the callback function, which leads to an error in React. The error suggests using state instead to manage changes after the render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-function-expression-references-later-variable-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let callback = () => {
    onClick = () => {};
  };
  let onClick;

  return <div onClick={callback} />;
}
```

----------------------------------------

TITLE: Initializing React Component with useRef and useEffect - JavaScript
DESCRIPTION: This snippet initializes a React component using the useEffect and useRef hooks. It defines a useFoo function that is intended to perform an action on a ref value, setting it to 42. The Component function is exported as part of a FIXTURE_ENTRYPOINT for integration or testing purposes. Dependencies include react and the custom useFoo hook. Inputs include component props, and changes are reflected in the current value of the ref.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-ref-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useRef} from 'react';

function Component(props) {
  const ref = useRef();
  useFoo(() => {
    ref.current = 42;
  });
}

function useFoo(x) {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: Rendering Conditional React Component (Input Version)
DESCRIPTION: This snippet defines a React component that renders different content based on the value of 'v1' prop and other conditions. It uses ternary operators for conditional rendering within JSX.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-propagate-type-of-ternary-nested.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function V0({v1}: V2<{v1?: V3}>): V2b.V2a {
  const v4 = v5(V6.v7({v8: V9.va}));
  const vb = (
    <ComponentC cd="TxqUy" ce="oh`]uc" cf="Bdbo" c10={!V9.va && v11.v12}>
      gmhubcw
      {v1 === V3.V13 ? (
        <c14 c15="L^]w\T\qrGmqrlQyrvBgf\inuRdkEqwVPwixiriYGSZmKJf]E]RdT{N[WyVPiEJIbdFzvDohJV[BV`H[[K^xoy[HOGKDqVzUJ^h">
          iawyneijcgamsfgrrjyvhjrrqvzexxwenxqoknnilmfloafyvnvkqbssqnxnexqvtcpvjysaiovjxyqrorqskfph
        </c14>
      ) : v16.v17('pyorztRC]EJzVuP^e') ? (
        <c14 c15="CRinMqvmOknWRAKERI]RBzB_LXGKQe{SUpoN[\gL[`bLMOhvFqDVVMNOdY">
          goprinbjmmjhfserfuqyluxcewpyjihektogc
        </c14>
      ) : (
        <c14 c15="H\\GAcTc\lfGMW[yHriCpvW`w]niSIKj\kdgFI">
          yejarlvudihqdrdgpvahovggdnmgnueedxpbwbkdvvkdhqwrtoiual
        </c14>
      )}
      hflmn
    </ComponentC>
  );
  return vb;
}
```

----------------------------------------

TITLE: Utilizing Hooks in React with TypeScript
DESCRIPTION: The `useFoo` function is a custom React hook that accepts a props object with a value potentially containing properties `x` and `y` as strings or `null`. It creates an array using the `createArray` function and attempts to join the values with a comma delimiter. The `createArray` function is a utility to aggregate the given arguments into an array. There is a known issue related to handling optional properties in TypeScript, indicated by the error snippet. No specific external libraries are required other than TypeScript and React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-call-chain-in-optional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function useFoo(props: {value: {x: string; y: string} | null}) {
  const value = props.value;
  return createArray(value?.x, value?.y)?.join(', ');
}

function createArray<T>(...args: Array<T>): Array<T> {
  return args;
}

export const FIXTURE_ENTRYPONT = {
  fn: useFoo,
  props: [{value: null}],
};

```

----------------------------------------

TITLE: Error Handling for Invalid Side Effects in React Component
DESCRIPTION: This section outlines the error message generated by the React library when a variable defined outside of a component is reassigned within the component. It emphasizes that components and hooks should be pure and free of side effects, recommending the use of 'useState' for managing state within components instead of directly modifying global variables.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-jsx-children.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Component() {
  2 |   const foo = () => {
> 3 |     someGlobal = true;
    |     ^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)
  4 |   };
  5 |   // Children are generally access/called during render, so
  6 |   // modifying a global in a children function is almost

```

----------------------------------------

TITLE: React Component: Using Hooks Incorrectly
DESCRIPTION: This React component attempts to conditionally assign a hook (`useA` or `useB`) to a variable `x` and then call `x`. This is an invalid usage pattern because React hooks must be called directly within the component and not assigned to variables for later execution. The component receives `props` as input, including a `cond` property to determine which hook to use.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ternary-with-hook-values.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = props.cond ? useA : useB;
  return x();
}

```

----------------------------------------

TITLE: Defining React Functional Component for Post Displaying Author and Text
DESCRIPTION: This snippet defines a React functional component named Component that renders a Post component with predefined author and text properties. It demonstrates basic component usage within React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-string-attribute-non-ascii.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  return (
    <Post
      author="potetotes"
      text="in addition to understanding JavaScript semantics and the rules of React, the compiler team also understands , , ,  and i think thats pretty cool"
    />
  );
}

function Post({author, text}) {
  return (
    <div>
      <h1>{author}</h1>
      <span>{text}</span>
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Counter Component Implementation - Input Source
DESCRIPTION: Original React component implementation using useState hook to manage counter state with increment and decrement buttons. Shows the clean source code before compilation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-deps-subset-of-decls.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';

function Component() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      /**
       * The scope for the <button> depends on just the scope for the callback,
       * but the previous scope (after merging) will declare both the above
       * <button> and the callback.
       */
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining a Basic Component in React using Optional Chaining
DESCRIPTION: This snippet defines a basic React functional component which employs optional chaining to safely access properties 'a', 'b', and 'c' from the received props. The use of optional chaining prevents the code from throwing errors if any of the properties are undefined.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-chained.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return call?.(props.a)?.(props.b)?.(props.c);
}
```

----------------------------------------

TITLE: Defining a React Component with Hooks in JavaScript
DESCRIPTION: This snippet defines a functional component in React that uses useEffect and useRef hooks for handling state and side effects. It shows how to log props and creates a button that uses a ref. Dependencies include React itself and related hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-eslint-suppressions.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire @panicThreshold(none)
import {useRef} from 'react';

function Component({props, bar}) {
  const foo = () => {
    console.log(props);
  };
  useEffect(() => {
    fire(foo(props));
    fire(foo());
    fire(bar());
  });

  const ref = useRef(null);
  // eslint-disable-next-line react-hooks/rules-of-hooks
  ref.current = 'bad';
  return <button ref={ref} />;
}

```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React Component
DESCRIPTION: Example of incorrect React Hook implementation where useHook() is called conditionally inside an else block. This violates React's Rules of Hooks which require hooks to be called in the same order on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-if-alternate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = null;
  if (props.cond) {
  } else {
    x = useHook();
  }
  return x;
}
```

LANGUAGE: text
CODE:
```
  3 |   if (props.cond) {
  4 |   } else {
> 5 |     x = useHook();
    |         ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (5:5)
  6 |   }
  7 |   return x;
  8 | }
```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React
DESCRIPTION: Demonstrates an invalid pattern where React Hooks are called conditionally using && operators. This violates the Rules of Hooks which require hooks to be called in a consistent order and not within conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-9bf17c174134.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook() {
  a && useHook1();
  b && useHook2();
}
```

LANGUAGE: text
CODE:
```
  4 | // This *must* be invalid.
  5 | function useHook() {
> 6 |   a && useHook1();
    |        ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)

InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)
  7 |   b && useHook2();
  8 | }
  9 |
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component using useState hook and defining a handler function to update state, rendered with a Foo component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/concise-arrow-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let [x, setX] = useState(0);
  const handler = v => setX(v);
  return <Foo handler={handler}></Foo>;
}
```

----------------------------------------

TITLE: Creating a Counter Component with React Hooks
DESCRIPTION: This example demonstrates how to create a simple counter component using React's useState hook and render it to the DOM. It shows the basic pattern of component creation, state management, and DOM rendering with the createRoot API.
SOURCE: https://github.com/facebook/react/blob/main/packages/react/README.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { useState } from 'react';
import { createRoot } from 'react-dom/client';

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </>
  );
}

const root = createRoot(document.getElementById('root'));
root.render(<Counter />);
```

----------------------------------------

TITLE: Configuring eslint-plugin-react-hooks with modern flat config (ESLint 6.0+)
DESCRIPTION: Setup for ESLint 6.0 and newer using the modern flat config format with the recommended configuration in eslint.config.js.
SOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import * as reactHooks from 'eslint-plugin-react-hooks';

export default [
  // ...
  reactHooks.configs.recommended,
];
```

----------------------------------------

TITLE: Defining useFoo Function with Optional Chaining - JavaScript
DESCRIPTION: This snippet defines the 'useFoo' function which takes an object with property 'a', checks for nested properties using optional chaining, and returns an array of results. The function handles potential null or undefined values gracefully by utilizing the optional chaining operator.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({a}) {
  let x = [];
  x.push(a?.b.c?.d.e);
  x.push(a.b?.c.d?.e);
  return x;
}
```

----------------------------------------

TITLE: Initializing React Component with Incorrect State Mutation
DESCRIPTION: Example of an anti-pattern where state is directly mutated instead of using the setter function. This approach violates React's immutability principles and will trigger rendering issues.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.modify-state.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';

function Foo() {
  let [state, setState] = useState({});
  state.foo = 1;
  return state;
}
```

LANGUAGE: text
CODE:
```
  3 | function Foo() {
  4 |   let [state, setState] = useState({});
> 5 |   state.foo = 1;
    |   ^^^^^ InvalidReact: Mutating a value returned from 'useState()', which should not be mutated. Use the setter function to update instead (5:5)
  6 |   return state;
  7 | }
```

----------------------------------------

TITLE: Invalid React Hook Usage Example
DESCRIPTION: Example showing incorrect implementation of React Hooks where useState is called after conditional statements, violating the Rules of Hooks. This code is intentionally written to demonstrate the error case.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-9718e30b856c.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook() {
  if (a) return;
  if (b) {
    console.log('true');
  } else {
    console.log('false');
  }
  useState();
}
```

LANGUAGE: plaintext
CODE:
```
  10 |     console.log('false');
  11 |   }
> 12 |   useState();
     |   ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (12:12)
  13 | }
  14 |

```

----------------------------------------

TITLE: Implementing Custom React Hook with useMemo and useState
DESCRIPTION: This snippet defines a custom React hook 'useFoo' that utilizes useState and useMemo for efficient state management and memoization. It calculates a style object based on input parameters and current state, demonstrating how useMemo can be used in nested reactive blocks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-in-other-reactive-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo, useState} from 'react';
import {arrayPush} from 'shared-runtime';

// useMemo-produced values can exist in nested reactive blocks, as long
// as their reactive dependencies are a subset of depslist from source
function useFoo(minWidth, otherProp) {
  const [width, setWidth] = useState(1);
  const x = [];
  const style = useMemo(() => {
    return {
      width: Math.max(minWidth, width),
    };
  }, [width, minWidth]);
  arrayPush(x, otherProp);
  return [style, x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [2, 'other'],
};
```

----------------------------------------

TITLE: Defining useHook Function Utilizing React Hooks
DESCRIPTION: This snippet defines a function 'useHook' which demonstrates the valid use of React's useState hook within a custom hook. This illustrates the rule that hooks can be called inside other hooks, maintaining compliance with React's rules for hooks. The expected input scenario is a React component context where hooks are permitted.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-2e405c78cb80.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because hooks can call hooks.
function useHook() {
  useState() && a;
}

```

----------------------------------------

TITLE: Defining Functional Components in React - JavaScript
DESCRIPTION: This snippet defines a functional Component that conditionally renders a Foo component with a list of Item components wrapped in a Bar. It ensures that Fragment elements are not used as JSX attribute values to maintain compatibility with various tools. The Component receives a prop 'items' which is expected to be an array of objects, each containing an 'id' and 'name'. This functionality leverages React's rendering capabilities to efficiently display dynamically generated content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-element-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow
function Component({items}) {
  // Per the spec, <Foo value=<>{...}</> /> is valid.
  // But many tools don't allow fragments as jsx attribute values,
  // so we ensure not to emit them wrapped in an expression container
  return items.length > 0 ? (
    <Foo
      value={
        <Bar>
          {items.map(item => (
            <Item key={item.id} item={item} />
          ))}
        </Bar>
      }></Foo>
  ) : null;
}

function Foo({value}) {
  return value;
}

function Bar({children}) {
  return <div>{children}</div>;
}

function Item({item}) {
  return <div>{item.name}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{items: [{id: 1, name: 'One!'}]}],
};

```

----------------------------------------

TITLE: Implementing React Component with useState Hook
DESCRIPTION: This snippet demonstrates a basic React component using the useState hook to manage a counter state. It renders the current count and a button to increment it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/resolve-react-hooks-based-on-import-name.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState as useReactState} from 'react';

function Component() {
  const [state, setState] = useReactState(0);

  const onClick = () => {
    setState(s => s + 1);
  };

  return (
    <>
      Count {state}
      <button onClick={onClick}>Increment</button>
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Error Message for Invalid React Hook Usage in JavaScript
DESCRIPTION: This snippet captures the error output generated when the 'useHook' function is executed. It indicates that hooks must be called in a consistent order and may not be called conditionally according to the React Hooks rules. The error message also provides a link to the relevant documentation for further reading. This is critical for developers to understand the consequences of hook violations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-c906cace44e9.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  5 | function useHook() {
  6 |   if (a) return;
> 7 |   useState();
    |   ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)
  8 | }
  9 |
```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React
DESCRIPTION: This code snippet demonstrates the incorrect usage of a React Hook (useConditionalHook) within a conditional statement.  React Hooks must be called unconditionally, in the same order, on every render. Calling a hook conditionally violates this rule and can lead to unexpected behavior and errors during runtime.  The 'cond' variable is assumed to be defined elsewhere and controls whether the hook is called.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-ea7c2fb545a9.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHookWithConditionalHook() {
  if (cond) {
    useConditionalHook();
  }
}

```

----------------------------------------

TITLE: Connecting React DevTools to React DOM in HTML
DESCRIPTION: HTML snippet showing how to connect React DevTools to a React DOM application by adding a script tag that loads the DevTools client. This should be the first script in the head of the document during development.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_5

LANGUAGE: html
CODE:
```
<!doctype html>
<html lang="en">
  <head>
    <script src="http://localhost:8097"></script>
```

----------------------------------------

TITLE: React Component with useMemo and useEffect
DESCRIPTION: This code snippet demonstrates a React component `useFoo` that utilizes the `useMemo` hook to memoize a function. This memoized function then invokes `someGlobal`. The `useEffect` hook is used to call the memoized function, ensuring it runs only when the function reference changes. This pattern can be used to prevent unnecessary re-renders or side effects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-namespace-pruned.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as React from 'react';

function someGlobal() {}
function useFoo() {
  const fn = React.useMemo(
    () =>
      function () {
        someGlobal();
      },
    []
  );
  React.useEffect(() => {
    fn();
  }, [fn]);

  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Building and Serving Production React Application
DESCRIPTION: Commands for building the React application for production and serving it using 'serve'. The build process optimizes resources for production, and 'serve' creates a local server to host the optimized build.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_1

LANGUAGE: Shell
CODE:
```
npm install
npm run build
npx serve -s build
```

----------------------------------------

TITLE: React Component Definition (Input)
DESCRIPTION: Defines a simple React component named `Component` that takes `props` as input. It creates a `MaybeMutable` object and renders a `div` containing the result of calling `maybeMutate` with the `MaybeMutable` object. This snippet represents the initial, unoptimized component definition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/builtin-jsx-tag-lowered-between-mutations.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const maybeMutable = new MaybeMutable();
  return <div>{maybeMutate(maybeMutable)}</div>;
}
```

----------------------------------------

TITLE: Client Reference Examples with 'use client' Directive
DESCRIPTION: Two examples of client references using the 'use client' directive. The first exports a simple function to be used on the client, and the second exports a client component. These are references that will be loaded on the client rather than executed on the server.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
'use client'

export function alert(message) {
  alert(message)
}
```

LANGUAGE: jsx
CODE:
```
'use client'

export function ClientComp({ onClick, message }) {
  return <button onClick={onClick}>Alert</button>
}
```

----------------------------------------

TITLE: Implementing React Component with Invalid State Update
DESCRIPTION: This snippet defines a React functional component using the useState hook. It includes a loop that processes props and an invalid state update that occurs unconditionally during render, which can cause an infinite loop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-with-loop-throw.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoSetStateInRender
function Component(props) {
  const [state, setState] = useState(false);
  for (const _ of props) {
    if (props.cond) {
      break;
    } else {
      throw new Error('bye!');
    }
  }
  setState(true);
  return state;
}
```

----------------------------------------

TITLE: Original React useMemo Implementation
DESCRIPTION: Original implementation using React's useMemo hook to memoize the minimum value between two numbers. The hook prevents unnecessary recalculations by caching the result based on the dependency array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-nonallocating.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';

// It's correct to infer a useMemo value is non-allocating
// and not provide it with a reactive scope
function useFoo(num1, num2) {
  return useMemo(() => Math.min(num1, num2), [num1, num2]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [2, 3],
};
```

----------------------------------------

TITLE: Validating Ref Access During Render in React - JavaScript
DESCRIPTION: This code demonstrates a React component using hooks to validate ref access during rendering. The Component function uses useRef to hold a mutable value updated within a useEffect hook, forcing a re-render and checking ref updates. The example illustrates how state changes trigger effects and check the impact of ref updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
import {useEffect, useRef, useState} from 'react';

function Component() {
  const ref = useRef(null);
  const [state, setState] = useState(false);
  useEffect(() => {
    ref.current = 'Ok';
  }, []);

  useEffect(() => {
    setState(true);
  }, []);

  // We use state to force a re-render and observe whether the
  // ref updated. This lets us check that the effect actually ran
  // and wasn't DCE'd
  return <Child key={String(state)} ref={ref} />;
}

function Child({ref}) {
  // This violates the rules of React, so we access the ref in a child
  // component
  return ref.current;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Original React Counter Component Implementation
DESCRIPTION: Basic React component implementation of a counter with useState hook. Renders a counter display with an increment button and uses the Stringify component for the header text.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-reordering.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableInstructionReordering
import {useState} from 'react';
import {Stringify} from 'shared-runtime';

function Component() {
  let [state, setState] = useState(0);
  return (
    <div>
      <Stringify text="Counter" />
      <span>{state}</span>
      <button data-testid="button" onClick={() => setState(state + 1)}>
        increment
      </button>
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Defining a Basic React Component in JavaScript
DESCRIPTION: This snippet defines a simple React functional component that takes props and renders a div containing a prop value. It serves as a foundation for understanding component creation in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-empty-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
export function Component(props) {
  return (
    <div>
      {}
      {props.a}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 'hello'}],
};
```

----------------------------------------

TITLE: Implementing useFoo with useMemo
DESCRIPTION: This snippet defines a custom hook `useFoo` that uses `useMemo` to memoize the concatenation of two arrays, `arr1` and `arr2`.  The result `{y}` is memoized based on changes to `y`, which is the concatenated array. It also exports a `FIXTURE_ENTRYPOINT` to specify function and params.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-reordering-depslist-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';

function useFoo(arr1, arr2) {
  const x = [arr1];

  let y;
  return useMemo(() => {
    return {y};
  }, [((y = x.concat(arr2)), y)]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [
    [1, 2],
    [3, 4],
  ],
};

```

----------------------------------------

TITLE: Initial VideoTab Component Implementation
DESCRIPTION: A basic React functional component using useRef to create a reference and define a logging function passed to VideoList
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-not-added-to-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function VideoTab() {
  const ref = useRef();
  let x = () => {
    console.log(ref.current);
  };

  return <VideoList videos={x} />;
}
```

----------------------------------------

TITLE: Invalid React Hooks Implementation in Loops
DESCRIPTION: Example of a function that incorrectly calls React hooks inside a while loop, which breaks the fundamental rules of hooks usage. This code will trigger a static analysis error due to inconsistent hook call order.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-d85c144bdf40.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useHookInLoops() {
  while (a) {
    useHook1();
    if (b) continue;
    useHook2();
  }
}
```

----------------------------------------

TITLE: React useRef Hook and onClick Handler
DESCRIPTION: This snippet demonstrates the usage of the `useRef` hook in React to access a DOM element and modify its value via an onClick handler. The `useRef` hook is initialized with `null`, and the current property of the ref is accessed to interact with the DOM node.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-property-in-callback-passed-to-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
import {useRef} from 'react';

function Component() {
  const ref = useRef(null);

  const onClick = () => {
    if (ref.current !== null) {
      ref.current.value = '';
    }
  };

  return (
    <>
      <input ref={ref} />
      <button onClick={onClick} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: React useCallback Input
DESCRIPTION: This code snippet demonstrates a React component named 'Foo' that uses the useCallback hook. The component initializes a variable 'x', pushes a prop into it, reassigns 'x' to a new array created by 'makeArray', and then defines a useCallback hook that returns an array containing 'x'. The useCallback dependency array includes 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-captures-reassigned-context.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useCallback} from 'react';
import {makeArray} from 'shared-runtime';

// This case is fine, as all reassignments happen before the useCallback
function Foo(props) {
  let x = [];
  x.push(props);
  x = makeArray();

  const cb = useCallback(() => [x], [x]);

  return cb;
}
export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}]
};
```

----------------------------------------

TITLE: Defining a React Hook
DESCRIPTION: This code snippet defines a custom React hook named `useHook`. This hook demonstrates that hooks can call other hooks, such as `useHook1` and `useHook2`, which promotes code reusability and composability within React functional components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-cfdfe5572fc7.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because hooks can call hooks.
function useHook() {
  useHook1();
  useHook2();
}

```

----------------------------------------

TITLE: Original React Counter Component
DESCRIPTION: A simple React component implementing a counter with useState hook and worklet annotation. The component renders a button that increments a counter when clicked.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-expr-directive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  'use strict';
  let [count, setCount] = React.useState(0);
  const update = () => {
    'worklet';
    setCount(count => count + 1);
  };
  return <button onClick={update}>{count}</button>;
}
```

----------------------------------------

TITLE: Defining React Component with Mapped Rendering
DESCRIPTION: A React functional component that renders an array of items using map, with nested Bar and Baz components and a custom hook useX
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({arr}) {
  const x = useX();
  return (
    <>
      {arr.map((i, id) => {
        return (
          <Bar key={id} x={x}>
            <Baz i={i}></Baz>
          </Bar>
        );
      })}
    </>
  );
}
```

----------------------------------------

TITLE: Original React Component with Context
DESCRIPTION: Basic React component implementation using Context API and a memoized click handler that reads context value. Demonstrates the pattern of creating and consuming context with a callback function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-read-context-in-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createContext, useContext} from 'react';

const FooContext = createContext({current: null});

function Component(props) {
  const foo = useContext(FooContext);
  // This function should be memoized since it is only reading the context value
  const onClick = () => {
    console.log(foo.current);
  };
  return <div onClick={onClick}>{props.children}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{children: <div>Hello</div>}],
};
```

----------------------------------------

TITLE: Generating Unique IDs with useId Hook
DESCRIPTION: New `useId` hook for generating unique, stable identifiers across client and server rendering, useful for form inputs and accessibility attributes.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_14

LANGUAGE: javascript
CODE:
```
const id = useId();
return <label htmlFor={id}>Name</label>;
```

----------------------------------------

TITLE: Installing eslint-plugin-react-hooks via npm or yarn
DESCRIPTION: Commands to install the eslint-plugin-react-hooks package as a development dependency using either npm or yarn package managers.
SOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
# npm
npm install eslint-plugin-react-hooks --save-dev

# yarn
yarn add eslint-plugin-react-hooks --dev
```

----------------------------------------

TITLE: React Hook Source Implementation
DESCRIPTION: Original source code for a React hook that uses useMemo to memoize two values derived from input parameters. Takes an object with 'a' and 'b' properties and returns them in processed form.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/consecutive-use-memo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {identity} from 'shared-runtime';

function useHook({a, b}) {
  const valA = useMemo(() => identity({a}), [a]);
  const valB = useMemo(() => identity([b]), [b]);
  return [valA, valB];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{a: 2, b: 3}],
};
```

----------------------------------------

TITLE: Tracking Overlapping Dependencies in React - JavaScript
DESCRIPTION: This function tracks and returns overlapping property dependencies from nested objects passed as props. It modifies the behavior based on whether the current props have been previously tracked, providing optimized access to the nested properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-overlap-direct.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Test that we correctly track a subpath if the subpath itself is accessed as
// a dependency
function TestOverlappingTracked(props) {
  let x = {};
  x.b = props.a.b;
  x.c = props.a.c;
  x.a = props.a;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: TestOverlappingTracked,
  params: [{a: {c: 2}}],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Test that we correctly track a subpath if the subpath itself is accessed as
// a dependency
function TestOverlappingTracked(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.a) {
    x = {};
    x.b = props.a.b;
    x.c = props.a.c;
    x.a = props.a;
    $[0] = props.a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: TestOverlappingTracked,
  params: [{ a: { c: 2 } }],
};
```

----------------------------------------

TITLE: React Reassignment Error
DESCRIPTION: This code shows the error generated by React when a variable is reassigned after the component has rendered. The error message "InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `onClick` cannot be reassigned after render" is displayed. This highlights the anti-pattern of mutating variables directly after rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-function-expression-references-later-variable-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Component() {
  2 |   let callback = () => {
> 3 |     onClick = () => {};
    |     ^^^^^^^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `onClick` cannot be reassigned after render (3:3)
  4 |   };
  5 |   let onClick;
  6 |
```

----------------------------------------

TITLE: Invalid Hook Usage in Nested Functions - React Component
DESCRIPTION: Example of incorrect React hook implementation where useFoo() hook is called within deeply nested function expressions, violating the Rules of Hooks. Hooks must be called at the top level of a function component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-in-nested-function-expression-object-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function Component() {
  'use memo';
  const f = () => {
    const x = {
      outer() {
        const g = () => {
          const y = {
            inner() {
              return useFoo();
            },
          };
          return y;
        };
      },
    };
    return x;
  };
}
```

LANGUAGE: text
CODE:
```
   8 |           const y = {
   9 |             inner() {
> 10 |               return useFoo();
     |                      ^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (10:10)
  11 |             },
  12 |           };
  13 |           return y;
```

----------------------------------------

TITLE: Using Client References in Server Components
DESCRIPTION: Example showing how to import and use client references (both component and function) within a server component. Client references are passed as props to client components and will be executed on the client side.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_4

LANGUAGE: jsx
CODE:
```
// client references don't have to just be components, anything can be 
// a reference, in this case we're importing a function that will be
// passed to the ClientComp component
import { alert } from '...'
import { ClientComp } from '...'

async function App({ children }) {
  return children
}

createResponse(
  <App >
    <ClientComp onClick={alert} message={"hello world"} />
  </App>,
...)
```

----------------------------------------

TITLE: Memoizing a React Component with useMemo
DESCRIPTION: This code defines a React component that uses `useMemo` to memoize a value based on dependencies `propA.a` and `propB.x.y`.  The memoized value is an object with a `value` property, which is assigned the value of `propB.x.y`.  The `identity` and `mutate` functions are assumed to be imported from `shared-runtime` and might affect the memoization behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-infer-less-specific-conditional-value-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {identity, mutate} from 'shared-runtime';

function Component({propA, propB}) {
  return useMemo(() => {
    const x = {};
    if (identity(null) ?? propA.a) {
      mutate(x);
      return {
        value: propB.x.y,
      };
    }
  }, [propA.a, propB.x.y]);
}

```

----------------------------------------

TITLE: Invalid React State Update During Render
DESCRIPTION: Example of incorrect useState implementation where setState is called unconditionally during component render. This pattern violates React's principles and causes infinite rendering loops since each state update triggers a new render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoSetStateInRender
function Component(props) {
  const [x, setX] = useState(0);

  const foo = () => {
    setX(1);
  };
  foo();

  return [x];
}
```

LANGUAGE: plaintext
CODE:
```
   6 |     setX(1);
   7 |   };
>  8 |   foo();
     |   ^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (8:8)
   9 |
  10 |   return [x];
  11 | }
```

----------------------------------------

TITLE: Initializing React Component with useMemo
DESCRIPTION: Initial implementation of a React component using React.useMemo for expensive number calculation and state management
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-runtime-import.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as React from 'react';
import {someImport} from 'react/compiler-runtime';
import {calculateExpensiveNumber} from 'shared-runtime';

function Component(props) {
  const [x] = React.useState(0);
  const expensiveNumber = React.useMemo(() => calculateExpensiveNumber(x), [x]);

  return (
    <div>
      {expensiveNumber}
      {`${someImport}`}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Defining a Functional Component and Identifying State Management Errors - JavaScript
DESCRIPTION: This snippet defines a React functional component named 'Component' that includes a nested functional component 'Foo'. The 'Foo' component attempts to reassign a variable defined outside its scope, which raises an error related to React's purity rules for components. Instead of directly modifying the global variable, it suggests using React's state management with useState for managing side effects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-component-tag-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const Foo = () => {
    someGlobal = true;
  };
  return <Foo />;
}

```

----------------------------------------

TITLE: React useRef Hook Usage with Render Error
DESCRIPTION: This snippet demonstrates how to initialize a ref with `useRef` and then incorrectly attempts to read and modify the `current` value of the ref during the render phase of a React component. This practice is not allowed and will trigger a React error as refs should only be accessed in event handlers or effects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-arbitrary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow
import {useRef} from 'react';

const DEFAULT_VALUE = 1;

component C() {
  const r = useRef(DEFAULT_VALUE);
  if (r.current == DEFAULT_VALUE) {
    r.current = 1;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{}]}],
};
```

----------------------------------------

TITLE: Defining a React Component - JavaScript
DESCRIPTION: This snippet defines a functional component in React and shows an improper reassignment attempt of a global variable, which results in an error. The comment clarifies that globals should not be assigned within React components to maintain purity.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassignment-to-global.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  // Cannot assign to globals
  someUnknownGlobal = true;
  moduleLocal = true;
}

```

----------------------------------------

TITLE: Defining React Component with useEffect (JS)
DESCRIPTION: Defines a simple React functional component 'Component' that takes a 'foo' prop. Inside the component, an empty array 'arr' is created. A 'useEffect' hook is used to push the 'foo' prop into 'arr' when the effect runs. The effect is declared without explicit dependencies. Outside the effect, the value '2' is also pushed into 'arr'. The component returns the modified 'arr'. This setup is often used to demonstrate how missing dependencies can lead to issues or how analysis tools behave.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/mutate-after-useeffect.expect.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import {useEffect} from 'react';

function Component({foo}) {
  const arr = [];
  useEffect(() => arr.push(foo));
  arr.push(2);
  return arr;
}
```

----------------------------------------

TITLE: Original React Hook with useCallback
DESCRIPTION: This snippet defines a React hook `useFoo` that uses `useCallback` to memoize a function. The memoized function calculates the sum of the elements in the `val` array.  The `FIXTURE_ENTRYPOINT` exports the hook for testing or usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-read-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';
import {sum} from 'shared-runtime';

function useFoo() {
  const val = [1, 2, 3];

  return useCallback(() => {
    return sum(...val);
  }, [val]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Defining a React Component Using useState and useMemo - JavaScript
DESCRIPTION: This snippet defines a React functional component that uses the useState hook to manage component state and the useMemo hook to create a memoized array from the state value. The component serializes an object to JSON and renders both the doubled array and the JSON string.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-with-prefix.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @hookPattern:".*\b(use[^$]+)$"

import * as React from 'react';
import {makeArray, useHook} from 'shared-runtime';

const React$useState = React.useState;
const React$useMemo = React.useMemo;
const Internal$Reassigned$useHook = useHook;

function Component() {
  const [state, setState] = React$useState(0);
  const object = Internal$Reassigned$useHook();
  const json = JSON.stringify(object);
  const doubledArray = React$useMemo(() => {
    return makeArray(state);
  }, [state]);
  return (
    <div>
      {doubledArray.join('')}
      {json}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Error Handling for Prop Mutation in React
DESCRIPTION: This snippet captures an error message that arises when the `Foo` component tries to mutate its `props`. It points out that mutating props directly is not allowed in React, advising to use local variables instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-props.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Foo(props) {
> 2 |   props.test = 1;
    |   ^^^^^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead (2:2)
  3 |   return null;
  4 | }
  5 |
```

----------------------------------------

TITLE: Initializing React Component with State Hooks
DESCRIPTION: A functional React component using useState and useMemo hooks to manage component state. The snippet demonstrates state initialization and conditional state updates, but contains a potential anti-pattern of calling setState within useMemo.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-setState-in-useMemo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({item, cond}) {
  const [prevItem, setPrevItem] = useState(item);
  const [state, setState] = useState(0);

  useMemo(() => {
    if (cond) {
      setPrevItem(item);
      setState(0);
    }
  }, [cond, key, init]);

  return state;
}
```

----------------------------------------

TITLE: React Component Implementation with useState
DESCRIPTION: Original React component implementation showing variable declarations, state management with useState hook, and array return pattern. Demonstrates different variable declaration and reassignment patterns using const, let, and class.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/module-scoped-bindings.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import React from 'react';
import {useState} from 'react';

const CONST = true;

let NON_REASSIGNED_LET = true;

let REASSIGNED_LET = false;
REASSIGNED_LET = true;

function reassignedFunction() {}
reassignedFunction = true;

function nonReassignedFunction() {}

class ReassignedClass {}
ReassignedClass = true;

class NonReassignedClass {}

function Component() {
  const [state] = useState(null);
  return [
    React,
    state,
    CONST,
    NON_REASSIGNED_LET,
    REASSIGNED_LET,
    reassignedFunction,
    nonReassignedFunction,
    ReassignedClass,
    NonReassignedClass,
  ];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Basic React Component with useState and useEffect
DESCRIPTION: Initial implementation of a React functional component using useState and useEffect hooks to manage and update component state
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-snap-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';

function Component() {
  const [state, setState] = useState('hello');
  useEffect(() => {
    setState('goodbye');
  }, []);

  return <div>{state}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Error: Unexpected Variable Reassignment
DESCRIPTION: This code block presents the error output generated when attempting to reassign values to variables defined outside of the React component. The error message suggests that components and hooks should be pure and side-effect free, which is violated by variable reassignment. It recommends using `useState` hook if variable is used in rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassignment-to-global-indirect.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  2 |   const foo = () => {
  3 |     // Cannot assign to globals
> 4 |     someUnknownGlobal = true;
    |     ^^^^^^^^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (4:4)
  5 |     moduleLocal = true;
  6 |   };
  7 |   foo();
```

----------------------------------------

TITLE: Using Refs and State in React Component
DESCRIPTION: This code snippet defines a React component that manages a ref and state using various hooks. It demonstrates how to access a ref within a child component while adhering to the rules of React. Key functionalities include setting a ref value when the component mounts and updating the state to trigger re-renders, allowing validation of ref access.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-effect-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender @validateNoSetStateInRender:false
import {useCallback, useEffect, useRef, useState} from 'react';

function Component() {
  const ref = useRef(null);
  const [state, setState] = useState(false);
  const setRef = useCallback(() => {
    ref.current = 'Ok';
  }, []);

  useEffect(() => {
    setRef();
  }, []);

  useEffect(() => {
    setState(true);
  }, []);

  // We use state to force a re-render and observe whether the
  // ref updated. This lets us check that the effect actually ran
  // and wasn't DCE'd
  return <Child key={String(state)} ref={ref} />;
}

function Child({ref}) {
  // This violates the rules of React, so we access the ref in a child
  // component
  return ref.current;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender @validateNoSetStateInRender:false
import { useCallback, useEffect, useRef, useState } from "react";

function Component() {
  const $ = _c(7);
  const ref = useRef(null);
  const [state, setState] = useState(false);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      ref.current = "Ok";
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const setRef = t0;
  let t1;
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      setRef();
    };
    t2 = [];
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useEffect(t1, t2);
  let t3;
  let t4;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = () => {
      setState(true);
    };
    t4 = [];
    $[3] = t3;
    $[4] = t4;
  } else {
    t3 = $[3];
    t4 = $[4];
  }
  useEffect(t3, t4);

  const t5 = String(state);
  let t6;
  if ($[5] !== t5) {
    t6 = <Child key={t5} ref={ref} />;
    $[5] = t5;
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  return t6;
}

function Child(t0) {
  const { ref } = t0;
  return ref.current;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Using useState and useEffect in React Component - JavaScript
DESCRIPTION: This snippet defines a React functional component using useState and useEffect hooks to manage its state. The useEffect hook updates the state whenever the component mounts or updates, incrementing the state by 1 each time.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-setState-in-useEffect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger @validateNoSetStateInPassiveEffects
import {useEffect, useState} from 'react';

function Component() {
  const [state, setState] = useState(0);
  useEffect(() => {
    setState(s => s + 1);
  });
  return state;
}

```

----------------------------------------

TITLE: Implementing React Component with Test Fixture
DESCRIPTION: Defines a React component that processes props and exports a test fixture configuration. The component performs conditional rendering based on props.a, props.b and props.c values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-conditional-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [props.a];
  const y = x ? props.b : props.c;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [props.a];
  const y = x ? props.b : props.c;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Error Handling for Invalid React State Mutation in JavaScript
DESCRIPTION: This snippet contains an error message generated by the React framework when attempting to delete a property from an object that is being used in JSX. The error highlights the issue with updating values in JSX and provides guidance for resolving it by suggesting mutations should be done before the JSX is rendered.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-delete-property-of-frozen-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  3 |   // freeze
  4 |   <div>{x}</div>;
> 5 |   delete x.y;
    |          ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (5:5)
  6 |   return x;
  7 | }
  8 |

```

----------------------------------------

TITLE: Implementing an Invalid React Component with Unconditional setState in JavaScript
DESCRIPTION: This code snippet shows a React functional component that incorrectly uses the useState hook. It sets state unconditionally during render, which can cause an infinite loop. The component takes props, initializes state, and attempts to update it immediately.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-after-loop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoSetStateInRender
function Component(props) {
  const [state, setState] = useState(false);
  for (const _ of props) {
  }
  setState(true);
  return state;
}
```

----------------------------------------

TITLE: React Component Utilizing Optimized Custom Hook - JavaScript
DESCRIPTION: This snippet represents a functional React component that employs the enhanced custom useState hook. It initializes its state to 'hello' and updates the state on user interaction by clicking the rendered div. The component efficiently re-renders based on state changes achieved through memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-dont-resolve-local-useState.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
function Component() {
  const $ = _c(5);
  const [state, setState] = useState("hello");
  let t0;
  if ($[0] !== setState) {
    t0 = () => setState("goodbye");
    $[0] = setState;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== state || $[3] !== t0) {
    t1 = <div onClick={t0}>{state}</div>;
    $[2] = state;
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component that manages arrays based on input parameters. Creates and manipulates arrays conditionally while rendering a div element with dynamic content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dependencies-outputs.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  const x = [];
  x.push(a);
  <div>{x}</div>;

  const y = [];
  if (x.length) {
    y.push(x);
  }
  if (b) {
    y.push(b);
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Initial React Component Implementation
DESCRIPTION: A React component using hooks for state management, event listening, and dispatching actions with conditional rendering
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-nested-lambdas.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableTransitivelyFreezeFunctionExpressions:false

function Component(props) {
  const item = useMutable(props.itemId);
  const dispatch = useDispatch();
  useFreeze(dispatch);

  const exit = useCallback(() => {
    dispatch(createExitAction());
  }, [dispatch]);

  useEffect(() => {
    const cleanup = GlobalEventEmitter.addListener('onInput', () => {
      if (item.value) {
        exit();
      }
    });
    return () => cleanup.remove();
  }, [exit, item]);

  maybeMutate(item);

  return <div />;
}
```

----------------------------------------

TITLE: Defining Custom Hook and Component Structure - JavaScript
DESCRIPTION: This snippet showcases the definition of a custom hook 'useFreeze' and a simple functional component 'Component'. The 'Component' utilizes the 'useFreeze' hook to manage its state. The 'foo' function is also included, but its specific purpose is not defined. Notably, 'Component' returns JSX that incorporates the results of the hook and other variables.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFreeze() {}
function foo() {}

function Component(props) {
  const x = [];
  const y = useFreeze(x);
  foo(y, x);
  return (
    <Component>
      {x}
      {y}
    </Component>
  );
}
```

----------------------------------------

TITLE: Initializing React Component with Memoized Array
DESCRIPTION: Creates a React component that generates an array using useMemo and makeArray function. Designed to optimize array creation and prevent unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-named-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {makeArray} from 'shared-runtime';

function Component() {
  const x = useMemo(makeArray, []);
  return x;
}
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { makeArray } from "shared-runtime";

function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = makeArray();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  return x;
}
```

----------------------------------------

TITLE: React Component with Async Variable Reassignment
DESCRIPTION: This React component demonstrates an anti-pattern: reassigning a local variable (`value`) within an async function (`reassign`). This function is called when the user clicks on the div. The anti-pattern leads to a React error because direct reassignment in async functions may cause unexpected component behavior and incorrect rendering results. The error suggests the usage of state instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-async-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let value = null;
  const reassign = async () => {
    await foo().then(result => {
      // Reassigning a local variable in an async function is *always* mutating
      // after render, so this should error regardless of where this ends up
      // getting called
      value = result;
    });
  };

  const onClick = async () => {
    await reassign();
  };
  return <div onClick={onClick}>Click</div>;
}

```

----------------------------------------

TITLE: Managing Functional Components in React - JavaScript
DESCRIPTION: This snippet defines a React component `Component` where a prop is incorrectly mutated within a function. It highlights a common pitfall of directly changing `props`, which should be avoided as it results in an error. The proper approach is to use a local state or derive the value from the props without mutation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-prop-mutation-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const f = () => {
    props.value = true;
  };
  const g = () => {
    f();
  };
  g();
}
```

----------------------------------------

TITLE: Validating Ref Access During Component Render - React - JavaScript
DESCRIPTION: This code snippet defines a functional React component that attempts to access a ref's current value during the render phase, which leads to a runtime error. The component expects a `ref` prop and attempts to display its current value inside a div. However, accessing `ref.current` during render violates React rules, causing an error that emphasizes this limitation. The expected inputs are a valid React ref object, while the output should ideally be the contained value in the UI, but an error occurs instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-read-ref-prop-in-render-destructure.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender @compilationMode(infer)
function Component({ref}) {
  const value = ref.current;
  return <div>{value}</div>;
}

```

----------------------------------------

TITLE: Using Default Export in React Component
DESCRIPTION: This snippet imports a default export from a module and uses it within a functional React component. The primary purpose is to illustrate how to return rendered content from the component. Dependencies include React and the specified module, which should ideally export a hook. Expected input is the default export function, and the output is a div containing the result of that function. It highlights a common mistake of not adhering to the expected type configuration for hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hooklike-module-default-not-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import foo from 'useDefaultExportNotTypedAsHook';

function Component() {
  return <div>{foo()}</div>;
}

```

----------------------------------------

TITLE: Implementing React Component with useRef and Event Handling
DESCRIPTION: This snippet defines a React component that uses the useRef hook to manage an input field's reference. It includes a button that, when clicked, clears the input field's value. The component demonstrates proper ref handling and event management in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-property-in-callback-passed-to-jsx-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
import {useRef} from 'react';

function Component() {
  const ref = useRef(null);

  const setRef = () => {
    if (ref.current !== null) {
      ref.current.value = '';
    }
  };

  const onClick = () => {
    setRef();
  };

  return (
    <>
      <input ref={ref} />
      <button onClick={onClick} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining useFoo Hook in React with JavaScript
DESCRIPTION: This snippet defines a custom React hook called useFoo, which is designed to demonstrate and address scoping issues in a functional component. Dependencies include React's useCallback and a custom Stringify component from a shared runtime. The hook takes two parameters, arr1 and arr2, and returns a JSX component that utilizes a memoized getVal function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-reordering-depslist-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useCallback} from 'react';
import {Stringify} from 'shared-runtime';

// We currently produce invalid output (incorrect scoping for `y` declaration)
function useFoo(arr1, arr2) {
  const x = [arr1];

  let y;
  const getVal = useCallback(() => {
    return {y};
  }, [((y = x.concat(arr2)), y)]);

  return <Stringify getVal={getVal} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [
    [1, 2],
    [3, 4],
  ],
};

```

----------------------------------------

TITLE: Defining a React Component with Hooks in JavaScript
DESCRIPTION: This code snippet demonstrates the creation of a React component using the useState hook to manage a state variable. It includes a function 'onChange' to update the state based on user input. The snippet also showcases the use of a hypothetical custom hook 'useOtherHook' and the 'foo' function, which highlights a memoization technique applied to 'x' and 'onChange'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inadvertent-mutability-readonly-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [value, setValue] = useState(null);
  // NOTE: this lambda does not capture any mutable values (only the state setter)
  // and thus should be treated as readonly
  const onChange = e => setValue(value => value + e.target.value);

  useOtherHook();

  // x should be independently memoizeable, since foo(x, onChange) cannot modify onChange
  const x = {};
  foo(x, onChange);
  return x;
}

```

----------------------------------------

TITLE: Defining a Functional Component in React
DESCRIPTION: This snippet defines a functional component 'Component' that takes an array as a prop and uses a custom hook 'useX'. It maps through the array to render child components 'Bar', 'Baz', 'Joe', and 'Foo' while passing the necessary props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-separate-nested.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableJsxOutlining
function Component({arr}) {
  const x = useX();
  return (
    <>
      {arr.map((i, id) => {
        return (
          <Bar key={id} x={x}>
            <Baz i={i}></Baz>
            <Joe j={i}></Joe>
            <Foo k={i}></Foo>
          </Bar>
        );
      })}
    </>
  );
}
function Bar({x, children}) {
  return (
    <>
      {x}
      {children}
    </>
  );
}

function Baz({i}) {
  return i;
}

function Joe({j}) {
  return j;
}

function Foo({k}) {
  return k;
}

function useX() {
  return 'x';
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arr: ['foo', 'bar']}],
};

```

----------------------------------------

TITLE: Defining Component with useMemo
DESCRIPTION: This code defines a React functional component that attempts to use the useMemo hook with an async function. However, the code violates React's rules since the callback for useMemo cannot be an async function. The error message illustrates this violation and indicates that the async function should be refactored.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ReactUseMemo-async-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  let x = React.useMemo(async () => {
    await a;
  }, []);
  return x;
}
```

----------------------------------------

TITLE: Custom React Ref Hook Implementation
DESCRIPTION: Creates a custom useRef hook that initializes a ref with a default click method, demonstrating React Compiler's memoization approach
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useCustomRef() {
  return useRef({click: () => {}});
}
```

----------------------------------------

TITLE: React Component Definition with Simple Destructuring
DESCRIPTION: Defines a React functional component `t` that takes props as input and destructures it to extract the first value using simple destructuring. It returns the extracted value `foo`. The component is then exported as part of a fixture entry point, which includes the component function, parameters and isComponent property.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-pattern-dce-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function t(props) {
  const [foo] = props;
  return foo;
}

export const FIXTURE_ENTRYPOINT = {
  fn: t,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Invalid Hook Usage in React Component Callback
DESCRIPTION: Shows an invalid pattern where a hook (useHookInsideCallback) is called inside a useEffect callback function. This violates React's Rules of Hooks which require hooks to be called at the top level of function components or custom hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.bail.rules-of-hooks-8503ca76d6f8.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Unsupported input

// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
const ComponentWithHookInsideCallback = React.memo(props => {
  useEffect(() => {
    useHookInsideCallback();
  });
  return <button {...props} />;
});
```

LANGUAGE: text
CODE:
```
   6 | const ComponentWithHookInsideCallback = React.memo(props => {
   7 |   useEffect(() => {
>  8 |     useHookInsideCallback();
     |     ^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (8:8)
   9 |   });
  10 |   return <button {...props} />;
  11 | });
```

----------------------------------------

TITLE: React Component with useCallback
DESCRIPTION: This code defines a React component named Foo that utilizes useCallback to memoize a function (onFoo). The onFoo function logs the current router location whenever it's called. The useCallback hook ensures that the function is only recreated when the router location changes, preventing unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-member-expr-arguments.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  const onFoo = useCallback(
    reason => {
      log(props.router.location);
    },
    [props.router.location]
  );

  return onFoo;
}

```

----------------------------------------

TITLE: Defining Basic React Components with ESLint Configuration
DESCRIPTION: Demonstrates the definition of two React functional components with ESLint hooks rule disabled. Contains a basic static component and a component that renders props. Includes ESLint configuration comments to disable hooks-related rules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unclosed-eslint-suppression-skips-all-components.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @panicThreshold(none)

// unclosed disable rule should affect all components
/* eslint-disable react-hooks/rules-of-hooks */

function ValidComponent1(props) {
  return <div>Hello World!</div>;
}

function ValidComponent2(props) {
  return <div>{props.greeting}</div>;
}

```

----------------------------------------

TITLE: Error Message for Invalid React State Update
DESCRIPTION: This snippet shows the error message generated when attempting to update state unconditionally during render in a React component. It highlights the line causing the error and provides a link to the React documentation for further information.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-with-loop-throw.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
   9 |     }
  10 |   }
> 11 |   setState(true);
     |   ^^^^^^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (11:11)
  12 |   return state;
  13 | }
  14 |
```

----------------------------------------

TITLE: Invalid React Mutation Error Message - JavaScript
DESCRIPTION: The error message signals that mutating component props or hook arguments is not permitted in React. Instead, it suggests that developers should use local variables to maintain state without breaking React's reactivity model. The error points specifically to the line where 'y.foo' is being modified.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-props-in-effect-fixpoint.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
   8 |   let y = x;
   9 |   let mutateProps = () => {
> 10 |     y.foo = true;
     |     ^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead. Found mutation of `y` (10:10)
  11 |   };
  12 |   let mutatePropsIndirect = () => {
  13 |     mutateProps();

```

----------------------------------------

TITLE: Defining Dynamic Components with JSX in JavaScript
DESCRIPTION: This code defines a functional React component 'Component' that takes an array as a prop and dynamically renders child components 'Bar', 'Foo', and 'Baz' based on the array contents. The 'useX' function provides a constant 'x' which is used in the rendering process. It also implements optimized rendering with memoization practices.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dupe-attr-after-rename.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableJsxOutlining
function Component({arr}) {
  const x = useX();
  return (
    <>
      {arr.map((i, id) => {
        return (
          <Bar key={id} x={x}>
            <Foo k={i + 'i'}></Foo>
            <Foo k={i + 'j'}></Foo>
            <Baz k1={i + 'j'}></Baz>
          </Bar>
        );
      })}
    </>
  );
}
function Bar({x, children}) {
  return (
    <>
      {x}
      {children}
    </>
  );
}

function Baz({k1}) {
  return k1;
}

function Foo({k}) {
  return k;
}

function useX() {
  return 'x';
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arr: ['foo', 'bar']}],
};
```

----------------------------------------

TITLE: Error Handling for Reassignment in React - JavaScript
DESCRIPTION: This snippet evaluates the potential error that arises when `x` is reassigned after the component has rendered. The error message suggests that such reassignments can lead to inconsistent behavior in React and recommends using state management techniques to handle variable updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.declare-reassign-variable-in-function-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 |   let x = null;
  3 |   function foo() {
> 4 |     x = 9;
    |     ^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `x` cannot be reassigned after render (4:4)
  5 |   }
  6 |   const y = bar(foo);
  7 |   return <Child y={y} />;

```

----------------------------------------

TITLE: Implementing useKeyCommand React Hook - Original Version
DESCRIPTION: A custom React hook that manages cursor position and provides left/right movement handlers. It uses useRef to maintain position state and returns an array of movement command objects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/original-reactive-scopes-fork/capture-ref-for-later-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableReactiveScopesInHIR:false
import {useRef} from 'react';
import {addOne} from 'shared-runtime';

function useKeyCommand() {
  const currentPosition = useRef(0);
  const handleKey = direction => () => {
    const position = currentPosition.current;
    const nextPosition = direction === 'left' ? addOne(position) : position;
    currentPosition.current = nextPosition;
  };
  const moveLeft = {
    handler: handleKey('left'),
  };
  const moveRight = {
    handler: handleKey('right'),
  };
  return [moveLeft, moveRight];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useKeyCommand,
  params: [],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that renders a filtered list of unique items up to a maximum count, with a header showing the total count. Takes props for items array and maximum items to display.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const items = props.items;
  const maxItems = props.maxItems;

  const renderedItems = [];
  const seen = new Set();
  const max = Math.max(0, maxItems);
  for (let i = 0; i < items.length; i += 1) {
    const item = items.at(i);
    if (item == null || seen.has(item)) {
      continue;
    }
    seen.add(item);
    renderedItems.push(<div>{item}</div>);
    if (renderedItems.length >= max) {
      break;
    }
  }
  const count = renderedItems.length;
  return (
    <div>
      <h1>{count} Items</h1>
      {renderedItems}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Invalid React Component with setState During Render
DESCRIPTION: This example demonstrates a React component that incorrectly calls setState (via setX) during render. The component defines a call chain (baz calls bar, which calls foo, which calls setX) and then invokes this chain during render, triggering an infinite loop error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-nested-function-expressions.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoSetStateInRender
function Component(props) {
  const [x, setX] = useState(0);

  const foo = () => {
    setX(1);
  };

  const bar = () => {
    foo();
  };

  const baz = () => {
    bar();
  };
  baz();

  return [x];
}
```

----------------------------------------

TITLE: Using Memoization with useCallback in React (JavaScript)
DESCRIPTION: This snippet implements a custom hook `useHook` utilizing `useCallback` for memoization. It returns an array consisting of a deeply nested property of the input object. The hook ensures that it only recalculates when the specific property changes, thus optimizing performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-more-specific.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useCallback} from 'react';

// More specific memoization always results in fewer memo block
// executions.
// Precisely:
//  x_new != x_prev does NOT imply x.y.z_new != x.y.z_prev
//  x.y.z_new != x.y.z_prev does imply x_new != x_prev
function useHook(x) {
  return useCallback(() => [x.y.z], [x]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{y: {z: 2}}],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { useCallback } from "react";

// More specific memoization always results in fewer memo block
// executions.
// Precisely:
//  x_new != x_prev does NOT imply x.y.z_new != x.y.z_prev
//  x.y.z_new != x.y.z_prev does imply x_new != x_prev
function useHook(x) {
  const $ = _c(2);
  let t0;
  if ($[0] !== x.y.z) {
    t0 = () => [x.y.z];
    $[0] = x.y.z;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ y: { z: 2 } }],
};
```

----------------------------------------

TITLE: React Error Handling for useKeyedState Hook (JavaScript)
DESCRIPTION: This snippet captures an error related to the 'useKeyedState' hook. The error states that calling 'setState' from within 'useMemo' can potentially trigger an infinite loop, highlighting the need for caution when using state updates in React hooks. It provides context around the specific line of code to help developers troubleshoot.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-setState-in-useMemo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  4 |
  5 |   useMemo(() => {
> 6 |     setPrevKey(key);
    |     ^^^^^^^^^^ InvalidReact: Calling setState from useMemo may trigger an infinite loop. (https://react.dev/reference/react/useState) (6:6)

InvalidReact: Calling setState from useMemo may trigger an infinite loop. (https://react.dev/reference/react/useState) (7:7)
  7 |     setState(init);
  8 |   }, [key, init]);
  9 |
```

----------------------------------------

TITLE: Conditional Lazy Loading with Suspense
DESCRIPTION: Uses the Suspense component to conditionally render and lazy-load legacy React components. This pattern delays loading until the component is actually needed, which is configured with a button click event.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_3

LANGUAGE: JavaScript
CODE:
```
<>
  <button onClick={() => setShowGreeting(true)}>
    Say hi
  </button>
  {showGreeting && (
    <Suspense fallback={<Spinner />}>
      <Greeting />
    </Suspense>
  )}
</>
```

----------------------------------------

TITLE: React Component with useReducer
DESCRIPTION: This code defines a React component named `f` that utilizes the `useReducer` hook to manage state. It also includes a simple `onClick` handler that dispatches an action when the `div` element is clicked. The component is then exported as `FIXTURE_ENTRYPOINT` with metadata indicating it is a React component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useReducer-returned-dispatcher-is-non-reactive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useReducer} from 'react';

function f() {
  const [state, dispatch] = useReducer();

  const onClick = () => {
    dispatch();
  };

  return <div onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: [],
  isComponent: true,
};

```

----------------------------------------

TITLE: React Compiler Error Logs for Dynamic Component Creation
DESCRIPTION: Compiler error logs showing why the dynamic component creation pattern is invalid. The logs indicate that components created during render will reset their state each time they're created and should be declared outside the render function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-new.expect.md#2025-04-21_snippet_2

LANGUAGE: json
CODE:
```
{"kind":"CompileError","detail":{"options":{"reason":"Components created during render will reset their state each time they are created. Declare components outside of render. ","description":null,"severity":"InvalidReact","suggestions":null,"loc":{"start":{"line":4,"column":10,"index":117},"end":{"line":4,"column":19,"index":126},"filename":"invalid-dynamically-constructed-component-new.ts"}}}},"fnLoc":null}
{"kind":"CompileError","detail":{"options":{"reason":"The component may be created during render","description":null,"severity":"InvalidReact","suggestions":null,"loc":{"start":{"line":3,"column":20,"index":83},"end":{"line":3,"column":42,"index":105},"filename":"invalid-dynamically-constructed-component-new.ts"}}}},"fnLoc":null}
{"kind":"CompileSuccess","fnLoc":{"start":{"line":2,"column":0,"index":37},"end":{"line":5,"column":1,"index":132},"filename":"invalid-dynamically-constructed-component-new.ts"}},"fnName":"Example","memoSlots":1,"memoBlocks":1,"memoValues":1,"prunedMemoBlocks":0,"prunedMemoValues":0}
```

----------------------------------------

TITLE: ESLint Error for Mutating React Props
DESCRIPTION: This is the ESLint error message generated when attempting to mutate React component props. The error highlights the line of code where the mutation occurs and suggests using a local variable instead. The error message informs the developer that directly modifying props is invalid and provides guidance on alternative approaches, such as using local component state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-props-mutation-in-effect-indirect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Component(props) {
  2 |   const mutateProps = () => {
> 3 |     props.value = true;
    |     ^^^^^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead. Found mutation of `props` (3:3)
  4 |   };
  5 |   const indirectMutateProps = () => {
  6 |     mutateProps();
```

----------------------------------------

TITLE: React Component with useMemo
DESCRIPTION: This React component uses `useMemo` to memoize the creation of an array based on the component's props.  The array is conditionally populated with `props.a` and `props.b` based on `props.cond` and `props.cond2`. The component returns the memoized array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-multiple-if-else.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';

function Component(props) {
  const x = useMemo(() => {
    let y = [];
    if (props.cond) {
      y.push(props.a);
    }
    if (props.cond2) {
      return y;
    }
    y.push(props.b);
    return y;
  });
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1, b: 2, cond2: false}],
};
```

----------------------------------------

TITLE: React Component with Memoized View (Input)
DESCRIPTION: This snippet defines a React component that renders a list of items using a memoized `View` component. The `View` component uses `React.memo` to prevent unnecessary re-renders when the `items` prop doesn't change. `FIXTURE_ENTRYPOINT` specifies the initial data for the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-react-memo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return <View {...props} />;
}

const View = React.memo(({items}) => {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
});

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      items: [
        {id: 2, name: 'foo'},
        {id: 3, name: 'bar'},
      ],
    },
  ],
};

```

----------------------------------------

TITLE: React Component with JSX and Array Mapping
DESCRIPTION: This React component, `Component`, takes an array (`arr`) as a prop, maps over it, and renders a `Bar` component for each item. Inside `Bar`, `Baz` and `Foo` components are rendered with props derived from the array item and a custom hook `useX`. The component uses JSX syntax and functional components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dup-key-diff-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableJsxOutlining
function Component({arr}) {
  const x = useX();
  return (
    <>
      {arr.map((i, id) => {
        return (
          <Bar key={id} x={x}>
            <Baz i={i + 'i'}></Baz>
            <Foo k={i + 'j'}></Foo>
          </Bar>
        );
      })}
    </>
  );}
function Bar({x, children}) {
  return (
    <>
      {x}
      {children}
    </>
  );
}

function Baz({i}) {
  return i;
}

function Foo({k}) {
  return k;
}

function useX() {
  return 'x';
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arr: ['foo', 'bar']}],
};

```

----------------------------------------

TITLE: Creating React Component with Context and Ref
DESCRIPTION: This code defines a React component named `Component` that consumes a context `FooContext`, uses a ref, and updates state on click. The component clones the `children` prop and renders it within a div with an `onClick` handler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/react-namespace.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const FooContext = React.createContext({current: null});

function Component(props) {
  const foo = React.useContext(FooContext);
  const ref = React.useRef();
  const [x, setX] = React.useState(false);
  const onClick = () => {
    setX(true);
    ref.current = true;
  };
  return <div onClick={onClick}>{React.cloneElement(props.children)}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{children: <div>Hello</div>}],
};

```

----------------------------------------

TITLE: Invalid Hook Usage Inside Loop - JavaScript React
DESCRIPTION: Example of incorrect React Hook implementation where a hook is called inside a while loop. This violates the Rules of Hooks by potentially calling the hook conditionally and in an inconsistent order.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-79128a755612.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function ComponentWithHookInsideLoop() {
  while (cond) {
    useHookInsideLoop();
  }
}
```

LANGUAGE: text
CODE:
```
   5 | function ComponentWithHookInsideLoop() {
   6 |   while (cond) {
>  7 |     useHookInsideLoop();
     |     ^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)
   8 |   }
   9 | }
  10 |

```

----------------------------------------

TITLE: Hydrating Server-Rendered App in React 18
DESCRIPTION: New method to hydrate a server-rendered application in React 18. It replaces ReactDOM.hydrate and works with new React DOM Server APIs.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_9

LANGUAGE: javascript
CODE:
```
hydrateRoot
```

----------------------------------------

TITLE: Subscribing to RxJS ReplaySubject with use-subscription in React
DESCRIPTION: Code example demonstrating how to use the useSubscription hook with an RxJS ReplaySubject. Since ReplaySubject lacks a sync data getter, it requires a temporary subscription to retrieve the current value.
SOURCE: https://github.com/facebook/react/blob/main/packages/use-subscription/README.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
const subscription = useMemo(
  () => ({
    getCurrentValue: () => {
      let currentValue;
      // ReplaySubject does not have a sync data getter,
      // So we need to temporarily subscribe to retrieve the most recent value.
      replaySubject
        .subscribe(value => {
          currentValue = value;
        })
        .unsubscribe();
      return currentValue;
    },
    subscribe: callback => {
      const subscription = replaySubject.subscribe(callback);
      return () => subscription.unsubscribe();
    }
  }),

  // Re-subscribe any time the replaySubject changes
  [replaySubject]
);

const value = useSubscription(subscription);
```

----------------------------------------

TITLE: React Component with useContext Mutation
DESCRIPTION: This React component attempts to modify the value obtained from `useContext` within the `onClick` handler.  This is an anti-pattern because context values should be updated using state management techniques or by dispatching actions to a reducer. The `FooContext` is directly mutated, which is flagged as an invalid operation in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-context-in-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const FooContext = useContext(Foo);
  // This function should be memoized, but its mutable range is entangled
  // with the useContext call. We can't memoize hooks, therefore the
  // reactive scope around the hook + callback is pruned and we're left
  // w no memoization of the callback.
  //
  // Ideally we'd determine that this isn't called during render and can
  // therefore be considered "immutable" or otherwise safe to memoize
  // independently
  const onClick = () => {
    FooContext.current = true;
  };
  return <div onClick={onClick} />;
}

```

----------------------------------------

TITLE: Accessing useRef current Property During Render in React
DESCRIPTION: This JavaScript code demonstrates an error case where a ref's current property is accessed during component rendering. The code initializes a ref with useRef, conditionally sets its value, and then tries to use the ref value in a way that violates React's rules about accessing ref.current during render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-post-access-2.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow
import {useRef} from 'react';

component C() {
  const r = useRef(null);
  if (r.current == null) {
    r.current = 1;
  }
  f(r.current);
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with Global State - Input Source
DESCRIPTION: A React component that demonstrates global state management using hooks. It shows how to safely mutate global state within effects and handle state updates. The component uses useState and useEffect hooks to manage and respond to global state changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutate-global-in-effect-fixpoint.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';

let someGlobal = {value: null};

function Component() {
  const [state, setState] = useState(someGlobal);

  // NOTE: if we initialize to eg null or a local, then it won't be a definitively global
  // mutation below when we modify `y`. The point of this is example is that if all control
  // flow paths produce a global, we allow the mutation in an effect
  let x = someGlobal;
  while (x == null) {
    x = someGlobal;
  }

  // capture into a separate variable that is not a context variable.
  const y = x;
  /**
   * Note that this fixture currently produces a stale effect closure if `y = x
   * = someGlobal` changes between renders. Under current compiler assumptions,
   * that would be a rule of react violation.
   */
  useEffect(() => {
    y.value = 'hello';
  });

  useEffect(() => {
    setState(someGlobal.value);
  }, [someGlobal]);

  return <div>{String(state)}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Handling Object Immutability in React Component
DESCRIPTION: This JavaScript snippet defines a React component that attempts to modify an object after it has been used in JSX, leading to an immutability error. React components should avoid mutating objects that have been rendered in JSX to prevent inconsistencies. This example exemplifies the need to reorder the steps, ensuring mutations occur before being used in JSX.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-property-store-to-frozen-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeObject();
  // freeze
  <div>{x}</div>;
  x.y = true;
  return x;
}

```

----------------------------------------

TITLE: Using useRef with useCallback in React Component
DESCRIPTION: This code demonstrates a React component that incorrectly mutates a ref's current value during render. It shows how useRef and useCallback interact, and why modifying a ref during render violates React's rules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-useCallback-set-ref-nested-property-ref-modified-later-preserve-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees @validateRefAccessDuringRender
import {useCallback, useRef} from 'react';

function Component(props) {
  const ref = useRef({inner: null});

  const onChange = useCallback(event => {
    // The ref should still be mutable here even though function deps are frozen in
    // @enablePreserveExistingMemoizationGuarantees mode
    ref.current.inner = event.target.value;
  });

  // The ref is modified later, extending its range and preventing memoization of onChange
  ref.current.inner = null;

  return <input onChange={onChange} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component Definition with Early Return
DESCRIPTION: Defines a React functional component `MyApp` that conditionally returns `undefined` (implicitly) based on the value of the `cond` prop. If `props.cond` is truthy, the component returns nothing. The component is exported as part of a `FIXTURE_ENTRYPOINT` object, providing metadata such as the component function, parameters, and component name for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function MyApp(props) {
  if (props.cond) {
    return;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Defining a Functional Component in React
DESCRIPTION: This snippet defines a functional component named `Foo` that takes `props` as an argument. It attempts to mutate the `test` property of `props`, which is against React's rules. Instead, local variables should be used for managing state or computations from props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-props.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  props.test = 1;
  return null;
}
```

----------------------------------------

TITLE: Original React Component with useMemo
DESCRIPTION: React component implementing useMemo for object memoization with validation. Demonstrates memoization of two separate objects based on individual props with validation components to verify proper memoization behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-log.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {typedLog, ValidateMemoization} from 'shared-runtime';

export function Component({a, b}) {
  const item1 = useMemo(() => ({a}), [a]);
  const item2 = useMemo(() => ({b}), [b]);
  typedLog(item1, item2);

  return (
    <>
      <ValidateMemoization inputs={[a]} output={item1} />
      <ValidateMemoization inputs={[b]} output={item2} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 0, b: 0}],
  sequentialRenders: [
    {a: 0, b: 0},
    {a: 1, b: 0},
    {a: 1, b: 1},
    {a: 1, b: 2},
    {a: 2, b: 2},
    {a: 3, b: 2},
    {a: 0, b: 0},
  ],
};
```

----------------------------------------

TITLE: Initializing React Component with Global Variable Mutation
DESCRIPTION: A React component that attempts to modify a global variable, which is considered an anti-pattern and violates React's component purity principles. This approach can lead to unexpected rendering and state management issues.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-jsx-spread-attribute.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const foo = () => {
    someGlobal = true;
  };
  return <div {...foo} />;
}
```

----------------------------------------

TITLE: React Component Rendering
DESCRIPTION: This example shows how different React components can now be rendered using the same DOM node. It demonstrates the ability to render one component, such as a `div`, and then subsequently render another component, such as a `span`, into the same DOM node without issues.  This allows for more dynamic and flexible rendering scenarios.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_28

LANGUAGE: JavaScript
CODE:
```
"React.renderComponent(<div/>, domNode); React.renderComponent(<span/>, domNode);"
```

----------------------------------------

TITLE: Initializing React Component with Invalid State Update
DESCRIPTION: Demonstrates a React component that incorrectly updates state directly during render, which triggers an infinite render loop and violates React's rendering rules
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-unconditional-set-state-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoSetStateInRender
function Component(props) {
  const [x, setX] = useState(0);
  const aliased = setX;

  setX(1);
  aliased(2);

  return x;
}
```

----------------------------------------

TITLE: React Component with Side-Effect
DESCRIPTION: This snippet defines a React component `MyApp` that reassigns the value of a variable `b` defined outside the component's scope.  This is flagged as an error because React components should be pure functions without side effects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassign-global-fn-arg.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
let b = 1;

export default function MyApp() {
  const fn = () => {
    b = 2;
  };
  return foo(fn);
}

function foo(fn) {}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [],
};
```

----------------------------------------

TITLE: Declaring React Components with JSX in JavaScript
DESCRIPTION: This snippet defines a set of React components using JSX syntax, built to render elements based on an array input. Dependencies include React and a mock \'useX\' hook providing a constant string. The main component \'Component\' maps over an array \'arr\' passed as a prop, embedding JSX elements \'Bar\', \'Baz\', and \'Foo\'. Expected input is a component render with props containing an \'arr\'. Outputs are React element trees based on 'arr'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-with-non-jsx-children.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableJsxOutlining
function Component({arr}) {
  const x = useX();
  return (
    <>
      {arr.map((i, id) => {
        return (
          <Bar key={id} x={x}>
            <Baz i={i}>Test</Baz>
            <Foo k={i} />
          </Bar>
        );
      })}
    </>
  );
}

function Bar({x, children}) {
  return (
    <>
      {x}
      {children}
    </>
  );
}

function Baz({i, children}) {
  return (
    <>
      {i}
      {children}
    </>
  );
}

function Foo({k}) {
  return k;
}

function useX() {
  return 'x';
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arr: ['foo', 'bar']}],
};

```

----------------------------------------

TITLE: Defining a Simple React Component with useState
DESCRIPTION: This snippet defines a basic React component using the useState hook for state management. It imports useState from React and includes a component receiving props, an initial state setup, and a simple output structure. The component takes a props object with a key 'x' and returns a JSX element displaying the current state and a computed value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-unpruned-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react'; // @enableChangeDetectionForDebugging

function Component(props) {
  const w = f(props.x);
  const [x, _] = useState(w);
  return (
    <div>
      {x}
      {w}
    </div>
  );
}

function f(x) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: 42}],
  isComponent: true,
};

```

----------------------------------------

TITLE: Input React Component with useRef and useCallback
DESCRIPTION: Original React component implementation using useRef to store a nested object and useCallback for handling input changes. The component demonstrates memoization patterns while maintaining ref mutability.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-nested-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useCallback, useRef} from 'react';

// Identical to useCallback-set-ref-nested-property-preserve-memoization,
// but with a different set of compiler flags
function Component({}) {
  const ref = useRef({inner: null});

  const onChange = useCallback(event => {
    // The ref should still be mutable here even though function deps are frozen in
    // @enablePreserveExistingMemoizationGuarantees mode
    ref.current.inner = event.target.value;
  });

  return <input onChange={onChange} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized Conditional Component Creation with React.memo
DESCRIPTION: This snippet defines a React functional component that conditionally creates components using memoization to optimize rendering. It employs a custom cache to avoid re-creating components unnecessarily.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-conditionally-assigned-dynamically-constructed-component-in-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger @validateStaticComponents
function Example(props) {
  const $ = _c(3);
  let Component;
  if (props.cond) {
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = createComponent();
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    Component = t0;
  } else {
    Component = DefaultComponent;
  }
  let t0;
  if ($[1] !== Component) {
    t0 = <Component />;
    $[1] = Component;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

```

----------------------------------------

TITLE: React Hook Usage Error Message - JavaScript
DESCRIPTION: This snippet presents an error message that arises when the rules of hooks are violated, specifically when a hook is called conditionally. It highlights the importance of adhering to the Rules of Hooks to ensure consistent behavior across React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.conditional-hooks-as-method-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 |   let x = null;
  3 |   if (props.cond) {
> 4 |     x = Foo.useFoo();
    |         ^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (4:4)
  5 |   }
  6 |   return x;
  7 | }

```

----------------------------------------

TITLE: React Error Handling for State Mutation - JavaScript
DESCRIPTION: The accompanying error message highlights a violation of React's rules regarding state and props. It indicates that the attempt to push a value into the array 'x' after it has already been rendered within JSX is not permitted, thus demonstrating the need to manage mutations correctly within functional components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-after-freeze.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
   5 |
   6 |   // x is Frozen at this point
>  7 |   x.push(props.p2);
     |   ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (7:7)
   8 |
   9 |   return <div>{_}</div>;
  10 | }

```

----------------------------------------

TITLE: Implementing Memoization in a React Functional Component - JavaScript
DESCRIPTION: This snippet implements a functional component Foo that makes use of the React library and memoization techniques for performance optimization. By leveraging internal caching, it optimizes rendering by preventing unnecessary updates based on unchanged props. The code indicates a dependency on React's library functionalities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-fragment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <div>
        <>Text</>
      </div>
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props.greeting) {
    t1 = (
      <>
        Hello {props.greeting} {t0}
      </>
    );
    $[1] = props.greeting;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: React Error: Invalid Ref Access During Render
DESCRIPTION: This error message highlights the violation of accessing a ref's `current` property during the rendering phase. Specifically, the error points to the line where `renderItem` is called within the `map` function. This practice is discouraged in React because it can lead to unexpected side effects and make debugging difficult.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-aliased-ref-in-callback-invoked-during-render-.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   7 |     return <Foo item={item} current={current} />;
   8 |   };
>  9 |   return <Items>{props.items.map(item => renderItem(item))}</Items>;
     |                                  ^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (9:9)
  10 | }
  11 |

```

----------------------------------------

TITLE: Defining React Component with useState Hook in JavaScript
DESCRIPTION: This snippet shows a React component using the useState hook to manage a number state. It imports necessary types and functions from React, defines a Component function, and exports a FIXTURE_ENTRYPOINT object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-import-specifier.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import type {SetStateAction, Dispatch} from 'react';
import {useState} from 'react';

function Component(_props: {}) {
  const [x, _setX]: [number, Dispatch<SetStateAction<number>>] = useState(0);
  return {x};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with useMemo Hook
DESCRIPTION: This React component takes props as input and uses the `useMemo` hook to conditionally compute and memoize a value `x` based on the `a` and `b` properties of the props.  It returns the computed value. The component utilizes React's `useMemo` hook for performance optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-logical.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = useMemo(() => props.a && props.b);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Initializing React Component with useReducer
DESCRIPTION: Demonstrates incorrect usage of useReducer hook by attempting to directly mutate state, which is an anti-pattern in React
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.modify-useReducer-state.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useReducer} from 'react';

function Foo() {
  let [state, setState] = useReducer({foo: 1});
  state.foo = 1;
  return state;
}
```

----------------------------------------

TITLE: React Hook Error Message
DESCRIPTION: This error message highlights the problem of referencing a React hook as a normal value. The error indicates that hooks must be called directly and not passed around as regular values. The message also provides a link to the React documentation for more information.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.propertyload-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Component() {
> 2 |   const x = Foo.useFoo;
    |             ^^^^^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)

InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)
  3 |   return x();
  4 | }
  5 |

```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This code defines a React component named `Component` that receives a `statusName` as input. It utilizes helper functions `foo` and `getStyles` to determine text and styling based on the input. The component renders a `div` with a nested `span`, applying CSS classes determined by the styling functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequential-destructuring-both-mixed-local-and-scope-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(statusName) {
  // status is local, text is a scope declaration
  const {status, text} = foo(statusName);
  // color is local, font is a scope declaration
  const {color, font} = getStyles(status);
  // bg is a declaration
  const bg = identity(color);
  return (
    <div className={bg}>
      <span className={font}>{[text]}</span>
    </div>
  );
}
function foo(name) {
  return {
    status: `<status>`,
    text: `${name}!`,
  };
}

function getStyles(status) {
  return {
    font: 'comic-sans',
    color: '#657b83',
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['Sathya'],
};

```

----------------------------------------

TITLE: Rendering Async Function Components with Flight
DESCRIPTION: Example showing how to render async Function Components with Flight in React Server Components. The example demonstrates that components can be async and can return promises which are supported by the Flight renderer.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_2

LANGUAGE: jsx
CODE:
```
async function App({ children }) {
  return children
}

createResponse(<App ><Children /></App>, ...)
```

----------------------------------------

TITLE: Input: React Component with UseMemo
DESCRIPTION: Original React component using useMemo to memoize an array based on a prop
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple-preserved.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingManualUseMemo
import {useMemo} from 'react';

function Component({a}) {
  let x = useMemo(() => [a], []);
  return <div>{x}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 42}],
  isComponent: true,
};
```

----------------------------------------

TITLE: Error Reporting for Reassignment in React Component - JavaScript
DESCRIPTION: This snippet captures the error reported when the component tries to reassign a variable that is not locally defined. It explains that components should be pure and suggests using the React hook `useState` for state management instead of variable reassignment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassignment-to-global.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Component() {
  2 |   // Cannot assign to globals
> 3 |   someUnknownGlobal = true;
    |   ^^^^^^^^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)
  4 |   moduleLocal = true;
  5 | }
  6 |
```

----------------------------------------

TITLE: Defining Foo Component with Callbacks - JavaScript
DESCRIPTION: This snippet defines a React functional component Foo that accepts two arrays and a boolean prop. It uses the useCallback hook to create memoized functions getVal1 and getVal2, which determine the computed values based on the input arrays and the boolean flag. The component returns a Stringify element which displays the results of these functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-reordering-deplist-controlflow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useCallback} from 'react';
import {Stringify} from 'shared-runtime';

function Foo({arr1, arr2, foo}) {
  const x = [arr1];

  let y = [];

  const getVal1 = useCallback(() => {
    return {x: 2};
  }, []);

  const getVal2 = useCallback(() => {
    return [y];
  }, [foo ? (y = x.concat(arr2)) : y]);

  return <Stringify val1={getVal1} val2={getVal2} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{arr1: [1, 2], arr2: [3, 4], foo: true}],
  sequentialRenders: [
    {arr1: [1, 2], arr2: [3, 4], foo: true},
    {arr1: [1, 2], arr2: [3, 4], foo: false},
  ],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useCallback } from "react";
import { Stringify } from "shared-runtime";

function Foo(t0) {
  const $ = _c(8);
  const { arr1, arr2, foo } = t0;
  let getVal1;
  let t1;
  if ($[0] !== arr1 || $[1] !== arr2 || $[2] !== foo) {
    const x = [arr1];

    let y;
    y = [];

    getVal1 = _temp;

    t1 = () => [y];
    foo ? (y = x.concat(arr2)) : y;
    $[0] = arr1;
    $[1] = arr2;
    $[2] = foo;
    $[3] = getVal1;
    $[4] = t1;
  } else {
    getVal1 = $[3];
    t1 = $[4];
  }
  const getVal2 = t1;
  let t2;
  if ($[5] !== getVal1 || $[6] !== getVal2) {
    t2 = <Stringify val1={getVal1} val2={getVal2} shouldInvokeFns={true} />;
    $[5] = getVal1;
    $[6] = getVal2;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  return t2;
}
function _temp() {
  return { x: 2 };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ arr1: [1, 2], arr2: [3, 4], foo: true }],
  sequentialRenders: [
    { arr1: [1, 2], arr2: [3, 4], foo: true },
    { arr1: [1, 2], arr2: [3, 4], foo: false },
  ],
};
```

----------------------------------------

TITLE: Error Handling for Invalid Ref Access - React - JavaScript
DESCRIPTION: This code snippet provides an error comment detailing the invalid access of ref values in the render method of a React component. It highlights an important limitation of the React API regarding ref usage, indicating that `ref.current` should not be accessed during render. The output will be a console error rather than the intended display of the referenced value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-read-ref-prop-in-render-destructure.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```
  1 | // @validateRefAccessDuringRender @compilationMode(infer)
  2 | function Component({ref}) {
> 3 |   const value = ref.current;
    |                 ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (3:3)
  4 |   return <div>{value}</div>;
  5 | }
  6 |
```

```

----------------------------------------

TITLE: Validating React Ref Access During Render - JavaScript
DESCRIPTION: This code defines a React functional component named 'Component' which tries to access the 'current' property of a ref passed in through props during the render phase, causing a validation error. Ref access should be avoided in this context to adhere to React's best practices.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-read-ref-prop-in-render-property-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender @compilationMode(infer)
function Component(props) {
  const value = props.ref.current;
  return <div>{value}</div>;
}

```

----------------------------------------

TITLE: React Error for Invalid ref.current Access
DESCRIPTION: The error message shown when React detects an invalid access to ref.current during component rendering. This error points to the specific line where the violation occurs and provides a link to the React documentation about proper ref usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-mutate-ref-arg-in-render.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  1 | // @validateRefAccessDuringRender:true
  2 | function Foo(props, ref) {
> 3 |   console.log(ref.current);
    |               ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (3:3)
  4 |   return <div>{props.bar}</div>;
  5 | }
  6 |
```

----------------------------------------

TITLE: Defining App Component with React Context
DESCRIPTION: This snippet shows a basic React functional component (App) that uses the useContext hook to access values from MyContext. It renders a Bar component with the extracted context values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-access-hook-guard.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @lowerContextAccess @enableEmitHookGuards
function App() {
  const {foo} = useContext(MyContext);
  const {bar} = useContext(MyContext);
  return <Bar foo={foo} bar={bar} />;
}
```

----------------------------------------

TITLE: Preserving Memoization with useCallback and useRef in React
DESCRIPTION: Demonstrates the creation of a React hook function 'useFoo' using useCallback and useRef to ensure the preservation of existing memoization guarantees. The snippet includes the definition of the FIXTURE_ENTRYPOINT, which exports the 'useFoo' function with no additional parameters. React and its hooks are required for this implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/preserve-use-memo-ref-missing-ok.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';

function useFoo() {
  const ref = useRef<undefined | (() => undefined)>();

  return useCallback(() => {
    if (ref != null) {
      ref.current();
    }
  }, []);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Defining a Custom Hook for Keyboard Commands in React
DESCRIPTION: This snippet implements the 'useKeyCommand' custom hook which uses React's 'useRef' to track the current position. The hook defines two handlers for moving left and right based on keyboard commands, updating the reference to manage the current state without causing renders. It returns those handlers for use in components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capture-ref-for-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef} from 'react';
import {addOne} from 'shared-runtime';

function useKeyCommand() {
  const currentPosition = useRef(0);
  const handleKey = direction => () => {
    const position = currentPosition.current;
    const nextPosition = direction === 'left' ? addOne(position) : position;
    currentPosition.current = nextPosition;
  };
  const moveLeft = {
    handler: handleKey('left')(),
  };
  const moveRight = {
    handler: handleKey('right')(),
  };
  return [moveLeft, moveRight];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useKeyCommand,
  params: [],
};
```

----------------------------------------

TITLE: Defining React Components using JSX (JavaScript)
DESCRIPTION: Standard React functional components demonstrating common JSX patterns such as handling props, children, refs, keys, fragments, spreading props, conditional rendering, and ternary expressions. This block represents the source code before compiler transformation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inline-jsx-transform.expect.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// @inlineJsxTransform

function Parent({children, a: _a, b: _b, c: _c, ref}) {
  return <div ref={ref}>{children}</div>;
}

function Child({children}) {
  return <>{children}</>;
}

function GrandChild({className}) {
  return (
    <span className={className}>
      <React.Fragment key="fragmentKey">Hello world</React.Fragment>
    </span>
  );
}

function ParentAndRefAndKey(props) {
  const testRef = useRef();
  return <Parent a="a" b={{b: 'b'}} c={C} key="testKey" ref={testRef} />;
}

function ParentAndChildren(props) {
  const render = () => {
    return <div key="d">{props.foo}</div>;
  };
  return (
    <Parent>
      <Child key="a" {...props} />
      <Child key="b">
        <GrandChild key="c" className={props.foo} {...props} />
        {render()}
      </Child>
    </Parent>
  );
}

const propsToSpread = {a: 'a', b: 'b', c: 'c'};
function PropsSpread() {
  return (
    <>
      <Test key="a" {...propsToSpread} />
      <Test key="b" {...propsToSpread} a="z" />
    </>
  );
}

function ConditionalJsx({shouldWrap}) {
  let content = <div>Hello</div>;

  if (shouldWrap) {
    content = <Parent>{content}</Parent>;
  }

  return content;
}

function ComponentWithSpreadPropsAndRef({ref, ...other}) {
  return <Foo ref={ref} {...other} />;
}

// TODO: Support value blocks
function TernaryJsx({cond}) {
  return cond ? <div /> : null;
}

global.DEV = true;
export const FIXTURE_ENTRYPOINT = {
  fn: ParentAndChildren,
  params: [{foo: 'abc'}],
};
```

----------------------------------------

TITLE: React Component with useCallback and useRef
DESCRIPTION: This code defines a React component that uses `useCallback` to memoize an event handler and `useRef` to create a mutable reference to an object. The `onChange` handler updates the `inner` property of the ref's current value when the input value changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-nested-property-preserve-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';

function Component(props) {
  const ref = useRef({inner: null});

  const onChange = useCallback(event => {
    // The ref should still be mutable here even though function deps are frozen in
    // @enablePreserveExistingMemoizationGuarantees mode
    ref.current.inner = event.target.value;
  });

  return <input onChange={onChange} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]],
};

```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React Component
DESCRIPTION: Example of incorrect React Hook implementation where useHook() is called after a conditional return statement. This violates React's Rules of Hooks which require hooks to be called in the same order on every render and not within conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-after-early-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  if (props.cond) {
    return null;
  }
  return useHook();
}
```

LANGUAGE: plaintext
CODE:
```
  3 |     return null;
  4 |   }
> 5 |   return useHook();
    |          ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (5:5)
  6 | }
  7 |

```

----------------------------------------

TITLE: Launching Standalone React DevTools from Terminal
DESCRIPTION: Command to launch the standalone React DevTools application from the terminal. This is used for connecting to React Native applications or React DOM in non-standard browser environments.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_3

LANGUAGE: shell
CODE:
```
react-devtools
```

----------------------------------------

TITLE: React Component with Global Variable Reassignment
DESCRIPTION: This JavaScript code defines a React component `Component` that attempts to reassign values to variables (`someUnknownGlobal`, `moduleLocal`) that are assumed to be defined outside of the component's scope (either globally or in the module). React components should be pure functions and free of side effects. This is enforced by linting rules in modern React projects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassignment-to-global-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const foo = () => {
    // Cannot assign to globals
    someUnknownGlobal = true;
    moduleLocal = true;
  };
  foo();
}
```

----------------------------------------

TITLE: Invalid Conditional React Hook Call
DESCRIPTION: This JavaScript code snippet demonstrates the incorrect usage of React's `useState` hook within a conditional statement. The `useState` hook is called conditionally based on the value of the `bar` prop, which violates the rules of hooks and leads to an "InvalidReact" error. React hooks must be called in the same order on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-f69800950ff0.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook({bar}) {
  let foo1 = bar && useState();
  let foo2 = bar || useState();
  let foo3 = bar ?? useState();
}

```

----------------------------------------

TITLE: Initializing React Component with useRef Hook
DESCRIPTION: This snippet defines a React component 'C' that uses the useRef hook to create a mutable reference. The component initializes the reference to 1 if it's null. It also includes Flow type annotations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-initialization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow
import {useRef} from 'react';

component C() {
  const r = useRef(null);
  if (r.current == null) {
    r.current = 1;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with Update Error
DESCRIPTION: This React component initializes two arrays, x and y, where y is initially a reference to x. Based on the value of props.p1, x may be re-initialized. After rendering a component using x in JSX, it attempts to push a value into y. Since y might be an alias of the potentially frozen x due to its usage in JSX, this mutation throws an error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-after-aliased-freeze.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [];
  let y = x;

  if (props.p1) {
    x = [];
  }

  let _ = <Component x={x} />;

  // y is MaybeFrozen at this point, since it may alias to x
  // (which is the above line freezes)
  y.push(props.p2);

  return <Component x={x} y={y} />;
}

```

----------------------------------------

TITLE: Original React Component with useMemo Implementation
DESCRIPTION: A simple React component that uses useState and useMemo hooks to track state and compute a derived value. It validates the memoization using a ValidateMemoization component that checks inputs and outputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-reloading.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableResetCacheOnSourceFileChanges
import {useMemo, useState} from 'react';
import {ValidateMemoization} from 'shared-runtime';

function Component(props) {
  const [state, setState] = useState(0);
  const doubled = useMemo(() => [state * 2], [state]);
  return <ValidateMemoization inputs={[state]} output={doubled} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: React useRef Access Error
DESCRIPTION: This snippet shows an error message indicating that ref values (the `current` property) should not be accessed during render. The error occurs on line 13 of the component code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useCallback-set-ref-nested-property-dont-preserve-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  11 |   });
  12 |
> 13 |   ref.current.inner = null;
     |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (13:13)
  14 |
  15 |   return <input onChange={onChange} />;
  16 | }
```

----------------------------------------

TITLE: Using useMemo for Component Rendering in React
DESCRIPTION: This snippet defines a React functional component that utilizes the useMemo hook to optimize rendering based on the props passed to it. It memoizes the output from a function prop, ensuring that the component only re-renders when the input prop changes. This is useful for performance optimization in larger applications. The component also uses ValidateMemoization to validate the memoized output against the current props inputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/props-method-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
import {useMemo} from 'react';
import {ValidateMemoization} from 'shared-runtime';

function Component(props) {
  const x = useMemo(() => props.x(), [props.x]);
  return <ValidateMemoization inputs={[props.x]} output={x} />;
}

const f = () => ['React'];
const g = () => ['Compiler'];
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: () => ['React']}],
  sequentialRenders: [{x: f}, {x: g}, {x: g}, {x: f}],
};

```

----------------------------------------

TITLE: React Component with Conditional Logic
DESCRIPTION: This code defines a React component named `Component` that accepts `props` as input. It uses a conditional statement based on `props.cond` to assign either 1 or 2 to the variable `x`.  The component returns an array containing the value of `x`. This example highlights a scenario where `x` is treated as reactive due to its dependency on the reactive `props.cond` even though the assignment is not directly reactive.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  if (props.cond) {
    x = 1;
  } else {
    x = 2;
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `props.cond` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {cond: true},
    {cond: true},
    {cond: false},
    {cond: false},
    {cond: true},
    {cond: false},
    {cond: true},
    {cond: false},
  ],
};
```

----------------------------------------

TITLE: Implementing useCallback for Memoization in React Component - JavaScript
DESCRIPTION: This snippet demonstrates a React component that uses the useCallback hook to memoize a function based on an entity property. The memoization ensures that the function is not re-created unnecessarily unless its dependencies change. Dependencies include the React library and the useCallback hook. The Component is meant to render conditional content based on whether an entity is present and display a message using children nodes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-nonescaping-invoked-callback-escaping-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
import {useCallback} from 'react';

function Component({entity, children}) {
  const showMessage = useCallback(() => entity != null);

  // We currently model functions as if they could escape intor their return value
  // but if we ever changed that (or did optimization to figure out cases where they
  // are known not to) we could get a false positive validation error here, since
  // showMessage doesn't need to be memoized since it doesn't escape in this instance.
  const shouldShowMessage = showMessage();
  return (
    <div>
      <div>{shouldShowMessage}</div>
      <div>{children}</div>
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      entity: {name: 'Sathya'},
      children: [<div key="gsathya">Hi Sathya!</div>],
    },
  ],
};
```

----------------------------------------

TITLE: Defining a ForwardRef Component with Conditional Hook Call in React JavaScript
DESCRIPTION: This code snippet defines a React component using forwardRef that incorrectly calls a custom hook conditionally inside the component. The main focus is on showcasing improper usage of hooks, violating the rules of hooks by introducing conditional logic. There are no explicit dependencies listed in the code snippet except 'forwardRef' and potential custom hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.invalid-rules-of-hooks-368024110a58.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

// Invalid because it\'s dangerous and might not warn otherwise.
// This *must* be invalid.
const FancyButton = forwardRef(function (props, ref) {
  if (props.fancy) {
    useCustomHook();
  }
  return <button ref={ref}>{props.children}</button>;
});

```

----------------------------------------

TITLE: Defining a React Component with JSX
DESCRIPTION: This code defines a React component `Component` that receives an array `arr` as a prop and renders a list of `Bar` components, each containing two `Foo` components. The `useX` hook provides a value that's passed to each `Bar` component. This snippet showcases the initial component structure before any compilation or optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dupe-key-dupe-component.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableJsxOutlining
function Component({arr}) {
  const x = useX();
  return (
    <>
      {arr.map((i, id) => {
        return (
          <Bar key={id} x={x}>
            <Foo k={i + 'i'}></Foo>
            <Foo k={i + 'j'}></Foo>
          </Bar>
        );
      })}
    </>
  ); 
}
function Bar({x, children}) {
  return (
    <>
      {x}
      {children}
    </>
  ); 
}

function Foo({k}) {
  return k;
}

function useX() {
  return 'x';
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arr: ['foo', 'bar']}],
};
```

----------------------------------------

TITLE: Using Conditional Hook in React JavaScript Component
DESCRIPTION: This snippet demonstrates an improper usage of a hook called conditionally within a React component. It requires a conditional check ('cond') and uses the 'Namespace.useConditionalHook' function. The primary focus is to showcase an invalid pattern for hooks in React, which must always be used unconditionally at the top level of a React function component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.invalid-rules-of-hooks-a0058f0b446d.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function ComponentWithConditionalHook() {
  if (cond) {
    Namespace.useConditionalHook();
  }
}
```

----------------------------------------

TITLE: Invalid React Mutation Error
DESCRIPTION: This error message indicates that a value used previously in JSX is being updated, which is not allowed in React due to immutability principles. The error highlights the line of code where the mutation occurs (in this case, `delete x[y]`).  The suggestion is to move the mutation before the JSX element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-delete-computed-property-of-frozen-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  3 |   // freeze
  4 |   <div>{x}</div>;
> 5 |   delete x[y];
    |          ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (5:5)
  6 |   return x;
  7 | }
  8 |
```

----------------------------------------

TITLE: Managing Input State Using useRef in React
DESCRIPTION: This snippet implements a React functional component that uses the useRef hook to manage the value of an input element. The component sets up a ref to store the input's value and updates that value when the input changes. The input field is rendered in response to interaction via an onChange event.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-field-write-not-added-to-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef} from 'react';

function Component() {
  const ref = useRef({text: {value: null}});
  const inputChanged = e => {
    ref.current.text.value = e.target.value;
  };

  return <input onChange={inputChanged} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: TypeScript useReducer Type Simplification
DESCRIPTION: Demonstrates simplified type annotations for useReducer hook in React 19, removing explicit type arguments in most cases
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_5

LANGUAGE: typescript
CODE:
```
useReducer(reducer)
```

LANGUAGE: typescript
CODE:
```
useReducer<State, Action>(reducer)
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component implementation showing state management and event handling with a conditional render and form integration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-captures-value-later-frozen-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = {};
  // onChange should be inferred as immutable, because the value
  // it captures (`x`) is frozen by the time the function is referenced
  const onChange = e => {
    maybeMutate(x, e.target.value);
  };
  if (props.cond) {
    <div>{x}</div>;
  }
  return <Foo value={x} onChange={onChange} />;
}
```

----------------------------------------

TITLE: Defining a React Component Using Stringify - JavaScript
DESCRIPTION: This snippet demonstrates how to define a simple React component that takes a list of items as props and renders each item using the 'Stringify' component. It illustrates basic usage of the 'map' function within JSX and shows module import syntax. The 'Component' function expects an 'items' array as props, and outputs an HTML structure mapping each item to a 'Stringify' component. Dependencies include React and 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlined-helper.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component(props) {
  return (
    <div>
      {props.items.map(item => (
        <Stringify key={item.id} item={item.name} />
      ))}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{items: [{id: 1, name: 'one'}]}],
};

```

----------------------------------------

TITLE: Using useMemo in React Functional Components - JavaScript
DESCRIPTION: Demonstrates the creation of React functional components using the `useMemo` hook to cache expensive calculations depending on state `x`. This optimization ensures that expensive computations are only recalculated when necessary dependencies change. Dependencies include `useState` and `calculateExpensiveNumber`. The input is a React component property, and the output is a rendered component where the calculation reflects the latest state value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-import.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import {useState, useMemo} from 'react';

function Component(props) {
  const [x] = useState(0);
  const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);

  return <div>{expensiveNumber}</div>;
}

function Component2(props) {
  const [x] = useState(0);
  const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);

  return <div>{expensiveNumber}</div>;
}
```

----------------------------------------

TITLE: Modifying External Variable in React Component (JavaScript)
DESCRIPTION: This code snippet defines a function component `Foo` that attempts to modify a JavaScript object `wat` defined outside the component's scope.  This violates React's principles of state management and immutability, leading to the "InvalidReact" error. The error suggests using an effect or a more appropriate React state management approach.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.store-property-in-global.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
let wat = {};

function Foo() {
  wat.test = 1;
  return wat;
}

```

----------------------------------------

TITLE: Input React Component Implementation
DESCRIPTION: Original React component code showing state management with useState and useEffect hooks. Uses a global object for state storage and demonstrates effect dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-in-effect-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';

let someGlobal = {};

function Component() {
  const [state, setState] = useState(someGlobal);

  const setGlobal = () => {
    someGlobal.value = true;
  };
  useEffect(() => {
    setGlobal();
  }, []);

  useEffect(() => {
    setState(someGlobal.value);
  }, [someGlobal]);

  return <div>{String(state)}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with useRef
DESCRIPTION: This code defines a simple React component that uses the useRef hook to create a reference to a child component (Foo).  The ref is passed to the Foo component. The component is expected to render the Foo component and allow access to its underlying DOM node or React component instance via the ref.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-passing-refs-as-props.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const ref = useRef(null);
  return <Foo ref={ref} />;
}
```

----------------------------------------

TITLE: Defining a React Component with Conditional Hook Usage - JavaScript
DESCRIPTION: This snippet defines a functional component named Component that conditionally calls the useFoo hook from the Foo module based on the value of props. If the condition is true, it retrieves a value using the hook; otherwise, the value remains null. The snippet is intended to illustrate correct and incorrect usage patterns of hooks in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.conditional-hooks-as-method-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = null;
  if (props.cond) {
    x = Foo.useFoo();
  }
  return x;
}

```

----------------------------------------

TITLE: React Component with useRef and Render-Time Access
DESCRIPTION: This React component, `Component`, initializes a `useRef` and attempts to access its `current` property within a `renderItem` function, which is called during the rendering of a list of items. This pattern is flagged as invalid because accessing ref values during render can lead to unpredictable behavior and inconsistencies. The `renderItem` function creates an aliased reference and then accesses the `.current` property.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-aliased-ref-in-callback-invoked-during-render-.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function Component(props) {
  const ref = useRef(null);
  const renderItem = item => {
    const aliasedRef = ref;
    const current = aliasedRef.current;
    return <Foo item={item} current={current} />;
  };
  return <Items>{props.items.map(item => renderItem(item))}</Items>;
}

```

----------------------------------------

TITLE: Rendering Dynamic React Component with Hooks
DESCRIPTION: Creates a component that generates list items dynamically from input props, using a custom hook and onClick handlers
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-in-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useHook} from 'shared-runtime';

function Component(props) {
  const data = useHook();
  const items = [];
  // NOTE: `item` is a context variable because it's reassigned and also referenced
  // within a closure, the `onClick` handler of each item
  for (let key in props.data) {
    key = key ?? null; // no-op reassignment to force a context variable
    items.push(
      <div key={key} onClick={() => data.set(key)}>
        {key}
      </div>
    );
  }
  return <div>{items}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{data: {a: 'a', b: true, c: 'hello'}}],
};
```

----------------------------------------

TITLE: React useRef Access Error Message
DESCRIPTION: The error message produced when attempting to access a ref's current property during component rendering. It points to line 9 where f(r.current) is called, explaining that ref values may not be accessed during render and providing a link to the React documentation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-post-access-2.expect.md#2025-04-22_snippet_1

LANGUAGE: plaintext
CODE:
```
   7 |     r.current = 1;
   8 |   }
>  9 |   f(r.current);
     |     ^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (9:9)
  10 | }
  11 |
  12 | export const FIXTURE_ENTRYPOINT = {
```

----------------------------------------

TITLE: React Component Definition with useCallback
DESCRIPTION: This snippet defines a React component that utilizes `useCallback` to memoize a function that calculates the sum of `propA.x` and `propB.x.y`. The `useCallback` hook ensures that the function is only re-created when either `propA.x` or `propB.x.y` changes, optimizing performance by preventing unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-alias-property-load-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';
import {sum} from 'shared-runtime';

function Component({propA, propB}) {
  const x = propB.x.y;
  return useCallback(() => {
    return sum(propA.x, x);
  }, [propA.x, x]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{propA: {x: 2}, propB: {x: {y: 3}}}],
};

```

----------------------------------------

TITLE: Enhanced Custom Hook with State Management - JavaScript
DESCRIPTION: This snippet enhances the previous 'useHook' function by including internal state management using a closure. It checks if the passed props are different from the previous inputs and uses caching to improve performance by returning earlier results when appropriate. It also utilizes the same 'setProperty' function to combine results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-maybe-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper, setProperty } from "shared-runtime";
function useHook(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    const x = {
      getX() {
        return props;
      },
    };

    const y = {
      getY() {
        return "y";
      },
    };

    t0 = setProperty(x, y);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ value: 0 }],
};

```

----------------------------------------

TITLE: Initializing React Component with useMemo and Switch
DESCRIPTION: A React functional component that uses useMemo to memoize a computed value based on different prop switch cases, returning a value conditionally
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-switch-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = useMemo(() => {
    let y;
    switch (props.switch) {
      case 'foo': {
        return 'foo';
      }
      case 'bar': {
        y = 'bar';
        break;
      }
      default: {
        y = props.y;
      }
    }
    return y;
  });
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Implementing React Memoization Test Input
DESCRIPTION: Defines the input code for testing memoization behavior using React context and useMemo hook. Includes a Component that provides context and an Inner component that consumes and validates the memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-method-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {ValidateMemoization} from 'shared-runtime';
import {useMemo} from 'react';
import * as React from 'react';

const FooContext = React.createContext(null);
function Component(props) {
  return (
    <FooContext.Provider value={props.value}>
      <Inner />
    </FooContext.Provider>
  );
}

function Inner(props) {
  const input = React.use(FooContext);
  const output = useMemo(() => [input], [input]);
  return <ValidateMemoization inputs={[input]} output={output} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
  sequentialRenders: [
    {value: null},
    {value: 42},
    {value: 42},
    {value: null},
    {value: null},
    {value: 42},
    {value: null},
    {value: 42},
    {value: null},
  ],
};
```

----------------------------------------

TITLE: Rendering Condition Based on Feature Flag in React
DESCRIPTION: This snippet demonstrates a React class component that conditionally invokes a feature flagging function within its render method. The component will call 'useFeatureFlag()' only if 'foo' evaluates to true, demonstrating a basic control structure for feature flags. Ensure that 'foo' and 'useFeatureFlag' are defined in the surrounding scope for this component to function correctly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-99b5c750d1d1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

class ClassComponentWithFeatureFlag extends React.Component {
  render() {
    if (foo) {
      useFeatureFlag();
    }
  }
}

```

----------------------------------------

TITLE: Managing State with useState and useEffect in React - JavaScript
DESCRIPTION: This snippet demonstrates a basic React component named Component, utilizing useState and useEffect hooks. It initializes a state with value 0 and updates the state after a 10ms timeout using setTimeout. The component is exported as FIXTURE_ENTRYPOINT, allowing its use elsewhere. Dependencies include React's useEffect and useState hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/valid-setState-in-useEffect-listener.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoSetStateInPassiveEffects
import {useEffect, useState} from 'react';

function Component() {
  const [state, setState] = useState(0);
  useEffect(() => {
    setTimeout(setState, 10);
  });
  return state;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Input React.forwardRef Component Definition
DESCRIPTION: Simple React component using forwardRef that renders a div element. Uses compilation mode inference.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-forwardRef.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
React.forwardRef(props => {
  return <div />;
});
```

----------------------------------------

TITLE: React Component with Incorrect useRef Usage
DESCRIPTION: Example React component that demonstrates incorrect usage of useRef by directly mutating ref.current outside of event handlers or effects. Contains an ESLint rule disable comment for hooks rules violation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-forget-with-eslint-suppression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef} from 'react';

function Component() {
  'use no forget';
  const ref = useRef(null);
  // eslint-disable-next-line react-hooks/rules-of-hooks
  ref.current = 'bad';
  return <button ref={ref} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

LANGUAGE: javascript
CODE:
```
import { useRef } from "react";

function Component() {
  "use no forget";
  const ref = useRef(null);
  // eslint-disable-next-line react-hooks/rules-of-hooks
  ref.current = "bad";
  return <button ref={ref} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Incorrect Usage of useRef in useEffect Dependency Array
DESCRIPTION: This code demonstrates an error case where ref.current is used in a useEffect dependency array. In React, ref values should not be accessed during render, and including ref.current in the dependency array causes this violation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-ref-value.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useRef} from 'react';

function Component(props) {
  const ref = useRef();
  useEffect(() => {}, [ref.current]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: React Hook with State Updates and Memoization
DESCRIPTION: This code defines a React hook `useFoo` that manages state and returns a component and an onClick handler. It uses `useState` to manage the state and `useCallback` to memoize the `handleLogout` function, preventing unnecessary re-renders. The `getComponent` function returns a `ColumnItem` component that triggers the `handleLogout` function when pressed, with the hook ensuring memoization guarantees.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-setstate-captured-indirectly-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
function useFoo() {
  const onClick = response => {
    setState(DISABLED_FORM);
  };

  const [state, setState] = useState();
  const handleLogout = useCallback(() => {
    setState(DISABLED_FORM);
  }, [setState]);
  const getComponent = () => {
    return <ColumnItem onPress={() => handleLogout()} />;
  };

  // this `getComponent` call should not be inferred as mutating setState
  return [getComponent(), onClick]; // pass onClick to avoid dce
}
```

----------------------------------------

TITLE: Validating Ref Access During Render in React JavaScript
DESCRIPTION: This JavaScript snippet demonstrates an attempt to access the 'current' property of a ref during rendering in a React functional component. The code shows how the 'useRef' hook is incorrectly used to update the 'inner' property during render, which leads to an 'InvalidReact' error. This access is prohibited because ref values should only be modified in lifecycle methods or effects to ensure stability and predictability of component renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-set-and-read-ref-nested-property-during-render.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @validateRefAccessDuringRender
function Component(props) {
  const ref = useRef({inner: null});
  ref.current.inner = props.value;
  return ref.current.inner;
}
```

----------------------------------------

TITLE: Implementing React Component with Memoization Strategies
DESCRIPTION: This snippet shows a React component that demonstrates various memoization strategies for its internal variables. It includes comments explaining the rationale behind memoizing different values to optimize performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-allocating-nested-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a can be independently memoized, is not mutated later
  // but a is a dependnecy of b, which is a dependency of c.
  // we have to memoize a to avoid breaking memoization of b,
  // to avoid breaking memoization of c.
  const a = [props.a];

  // a can be independently memoized, is not mutated later,
  // but is a dependency of d which is part of c's scope.
  // we have to memoize b to avoid breaking memoization of c.
  const b = [a];

  // c and d are interleaved and grouped into a single scope,
  // but they are independent values. d does not escape, but
  // we need to ensure that b is memoized or else b will invalidate
  // on every render since a is a dependency. we also need to
  // ensure that a is memoized, since it's a dependency of b.
  const c = [];
  const d = {};
  d.b = b;
  c.push(props.b);

  return c;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Using useMemo for Value Calculation in React (JavaScript)
DESCRIPTION: This snippet defines a React component that calculates a sum of two properties from the passed props using the useMemo hook to memoize the computed result. Dependencies include React and a shared runtime for the sum function. The function expects propA and propB structured such that propA.x and propB.x.y are defined, returning the memoized sum of these values. The memoization optimizes performance by avoiding unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-alias-property-load-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {sum} from 'shared-runtime';

function Component({propA, propB}) {
  const x = propB.x.y;
  return useMemo(() => {
    return sum(propA.x, x);
  }, [propA.x, x]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{propA: {x: 2}, propB: {x: {y: 3}}}],
};

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useMemo } from "react";
import { sum } from "shared-runtime";

function Component(t0) {
  const $ = _c(3);
  const { propA, propB } = t0;
  const x = propB.x.y;
  let t1;
  let t2;
  if ($[0] !== propA.x || $[1] !== x) {
    t2 = sum(propA.x, x);
    $[0] = propA.x;
    $[1] = x;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  t1 = t2;
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ propA: { x: 2 }, propB: { x: { y: 3 } } }],
};

```

----------------------------------------

TITLE: Using useEffectWrapper in non-React function (JavaScript)
DESCRIPTION: This code defines a function, `nonReactFn`, that calls a custom hook `useMyEffect` outside of a React component. The `useMyEffect` hook is used to create an effect, and its dependencies are intended to be automatically inferred. However, because the hook is called within a non-React function, the React Compiler is unable to infer the dependencies, resulting in a compiler error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.callsite-in-non-react-fn-default-import.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @compilationMode(infer) @panicThreshold(none)
import useMyEffect from 'useEffectWrapper';

function nonReactFn(arg) {
  useMyEffect(() => [1, 2, arg]);
}

```

----------------------------------------

TITLE: Defining Basic React Component - JavaScript
DESCRIPTION: This snippet defines a basic React functional component that accepts props, creates an object, converts it to a string, and returns both the object and the string. It serves as a simple demonstration of React component structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-String.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {};
  const y = String(x);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Using Custom Hooks - JavaScript
DESCRIPTION: This snippet showcases a valid usage of hooks in React, where one custom hook can call another. It demonstrates the principle that hooks can be nested, allowing for modular and reusable logic within components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-9d7879272ff6.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because hooks can call hooks.
function useHook() {
  return useHook1(useHook2());
}
```

----------------------------------------

TITLE: Creating a Custom Hook with State Management - JavaScript
DESCRIPTION: This snippet defines a custom React hook, `useHook`, which initializes a state variable and returns an object containing methods to retrieve state and a given value. It requires React and shared runtime dependencies. The expected input is an object with a `value` property, and the output includes an object with `getX` and its associated methods.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-nested.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';
import {createHookWrapper} from 'shared-runtime';

function useHook({value}) {
  const [state] = useState(false);

  return {
    getX() {
      return {
        a: [],
        getY() {
          return value;
        },
        state,
      };
    },
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{value: 0}],
};
```

----------------------------------------

TITLE: Implementing Custom Hook with Optional Chaining in React
DESCRIPTION: This snippet defines a custom hook 'useFoo' that handles multiple props with optional chaining and nullish coalescing. It demonstrates complex prop handling and type definitions for null and object types.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-optional-chains.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

/**
 * identity(...)?.toString() is the outer optional, and prop?.value is the inner
 * one.
 * Note that prop?.
 */
function useFoo({
  prop1,
  prop2,
  prop3,
  prop4,
  prop5,
  prop6,
}: {
  prop1: null | {value: number};
  prop2: null | {inner: {value: number}};
  prop3: null | {fn: (val: any) => NonNullable<object>};
  prop4: null | {inner: {value: number}};
  prop5: null | {fn: (val: any) => NonNullable<object>};
  prop6: null | {inner: {value: number}};
}) {
  // prop1?.value should be hoisted as the dependency of x
  const x = identity(prop1?.value)?.toString();

  // prop2?.inner.value should be hoisted as the dependency of y
  const y = identity(prop2?.inner.value)?.toString();

  // prop3 and prop4?.inner should be hoisted as the dependency of z
  const z = prop3?.fn(prop4?.inner.value).toString();

  // prop5 and prop6?.inner should be hoisted as the dependency of zz
  const zz = prop5?.fn(prop6?.inner.value)?.toString();
  return [x, y, z, zz];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [
    {
      prop1: null,
      prop2: null,
      prop3: null,
      prop4: null,
      prop5: null,
      prop6: null,
    },
  ],
  sequentialRenders: [
    {
      prop1: null,
      prop2: null,
      prop3: null,
      prop4: null,
      prop5: null,
      prop6: null,
    },
    {
      prop1: {value: 2},
      prop2: {inner: {value: 3}},
      prop3: {fn: identity},
      prop4: {inner: {value: 4}},
      prop5: {fn: identity},
      prop6: {inner: {value: 4}},
    },
    {
      prop1: {value: 2},
      prop2: {inner: {value: 3}},
      prop3: {fn: identity},
      prop4: {inner: {value: 4}},
      prop5: {fn: identity},
      prop6: {inner: {value: undefined}},
    },
    {
      prop1: {value: 2},
      prop2: {inner: {value: undefined}},
      prop3: {fn: identity},
      prop4: {inner: {value: undefined}},
      prop5: {fn: identity},
      prop6: {inner: {value: undefined}},
    },
    {
      prop1: {value: 2},
      prop2: {},
      prop3: {fn: identity},
      prop4: {},
      prop5: {fn: identity},
      prop6: {inner: {value: undefined}},
    },
  ],
};
```

----------------------------------------

TITLE: Enhanced React Component with React Compiler Runtime
DESCRIPTION: This snippet showcases an optimized version of the Component function with enhanced reactivity management using the react/compiler-runtime module. It introduces a caching mechanism through a memoized sentinel for improved performance. The state manipulation logic remains similar to the initial implementation, with reliance on the props for initial state settings. The caching mechanism checks for a sentinel value, allowing encapsulated reactivity in returning state outputs. Dependencies include import of react/compiler-runtime. It inputs props, outputs an array of values, and requires usage within a compatible React environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-in.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);

  const a = [];
  const b = [];
  b.push(props.cond);
  a.push({ a: false });

  const c = [a];

  let x;
  for (const i in c[0][0]) {
    x = 1;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};
```

----------------------------------------

TITLE: Initializing React Component with Memoized Helper
DESCRIPTION: Example of using useMemo hook with an incorrect implementation that triggers a React validation error. The snippet demonstrates an improper memoization pattern where the first argument is not an inline function expression.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.validate-useMemo-named-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = useMemo(someHelper, []);
  return x;
}
```

----------------------------------------

TITLE: Invalid Dynamic Component Creation in React
DESCRIPTION: This code shows an anti-pattern where a component is constructed during render using 'new ComponentFactory()'. This approach causes state to reset on each render and is flagged as invalid by React's compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-new.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger @validateStaticComponents
function Example(props) {
  const Component = new ComponentFactory();
  return <Component />;
}
```

----------------------------------------

TITLE: React Component with useMemo Implementation
DESCRIPTION: Original React component implementation using useMemo hooks to memoize values and arrays. Shows pattern for memoizing individual items and collections with dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {typedArrayPush, ValidateMemoization} from 'shared-runtime';

export function Component({a, b}) {
  const item1 = useMemo(() => ({a}), [a]);
  const item2 = useMemo(() => ({b}), [b]);
  const items = useMemo(() => {
    const items = [];
    typedArrayPush(items, item1);
    typedArrayPush(items, item2);
    return items;
  }, [item1, item2]);

  return (
    <>
      <ValidateMemoization inputs={[a]} output={items[0]} />
      <ValidateMemoization inputs={[b]} output={items[1]} />
      <ValidateMemoization inputs={[a, b]} output={items} />
    </>
  );
}
```

----------------------------------------

TITLE: Defining a React Component with Invalid Side Effect Handling
DESCRIPTION: This code defines a functional React component 'Component' which contains a local function 'foo' that attempts to modify a global variable 'someGlobal'. This approach is incorrect according to React's strict rules regarding side effects, as components should remain pure. The error output specifies the issue with the variable reassignment that occurs within the component's scope.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-jsx-children.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const foo = () => {
    someGlobal = true;
  };
  // Children are generally access/called during render, so
  // modifying a global in a children function is almost
  // certainly a mistake.
  return <Foo>{foo}</Foo>;
}

```

----------------------------------------

TITLE: React Component with Potential Prop Mutation
DESCRIPTION: This React component defines a function that attempts to mutate a variable `x` derived from either `someGlobal` or `props.foo`. The `useEffect` hook is used to indirectly trigger this mutation, violating React's principle of immutability, especially when `x` is derived from props. Mutating props directly or values derived from props is generally discouraged in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutation-of-possible-props-phi-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = cond ? someGlobal : props.foo;
  const mutatePhiThatCouldBeProps = () => {
    x.y = true;
  };
  const indirectMutateProps = () => {
    mutatePhiThatCouldBeProps();
  };
  useEffect(() => indirectMutateProps(), []);
}

```

----------------------------------------

TITLE: React useState Hook Usage in Component
DESCRIPTION: This code snippet demonstrates the correct usage of the `useState` hook within a React component.  It highlights how the hook can be used in a component that contains loops and conditional statements, as long as the hook itself is not placed inside the loop or condition. It showcases a valid scenario where the `useState` hook is called only once and outside of the control flow structures.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-69521d94fa03.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// Valid because the neither the condition nor the loop affect the hook call.
function App(props) {
  const someObject = { propA: true };
  for (const propName in someObject) {
    if (propName === true) {
    }
  }

  useState(null);
}

```

----------------------------------------

TITLE: Implementing useFoo Function with React Memoization
DESCRIPTION: This snippet defines a useFoo function that uses React's useMemo hook for memoization. It calculates derived values based on a condition and a source dependency, demonstrating basic memoization patterns.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-constant-prop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {identity} from 'shared-runtime';

function useFoo(cond) {
  const sourceDep = 0;
  const derived1 = useMemo(() => {
    return identity(sourceDep);
  }, [sourceDep]);
  const derived2 = (cond ?? Math.min(sourceDep, 1)) ? 1 : 2;
  const derived3 = useMemo(() => {
    return identity(sourceDep);
  }, [sourceDep]);
  const derived4 = (Math.min(sourceDep, -1) ?? cond) ? 1 : 2;
  return [derived1, derived2, derived3, derived4];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: Initializing React Component with useMemo Hook
DESCRIPTION: This snippet defines a React component that uses useMemo to memoize a computed value based on the 'value' prop. It includes error handling and null checks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-unreachable-code-early-return-in-useMemo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
import {useMemo, useState} from 'react';
import {ValidateMemoization, identity} from 'shared-runtime';

function Component({value}) {
  const result = useMemo(() => {
    if (value == null) {
      return null;
    }
    try {
      return {value};
    } catch (e) {
      return null;
    }
  }, [value]);
  return <ValidateMemoization inputs={[value]} output={result} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: null}],
  sequentialRenders: [
    {value: null},
    {value: null},
    {value: 42},
    {value: 42},
    {value: null},
    {value: 42},
    {value: null},
    {value: 42},
  ],
};
```

----------------------------------------

TITLE: React Class Component with Invalid useState Hook Usage
DESCRIPTION: This code demonstrates an attempt to use the `useState` hook within a class component's `render` method. React hooks can only be used inside functional components or custom hooks, not within class components. This code is expected to fail in a proper React environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-8303403b8e4c.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

class ClassComponentWithHook extends React.Component {
  render() {
    React.useState();
  }
}

```

----------------------------------------

TITLE: React useCallback with Dependency Array Mismatch
DESCRIPTION: This code defines a React component, `Component`, that uses `useCallback` to memoize a function. The function returns an object with properties derived from the component's props (`propA` and `propB`).  The dependency array provided to `useCallback` is `[propA, propB.x.y]`.  The React Compiler detected that the manually specified dependencies do not match the inferred dependencies, preventing optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-conditional-access-noAlloc.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';

function Component({propA, propB}) {
  return useCallback(() => {
    return {
      value: propB?.x.y,
      other: propA,
    };
  }, [propA, propB.x.y]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{propA: 2, propB: {x: {y: []}}}],
};

```

----------------------------------------

TITLE: Defining a Simple React Component in JavaScript
DESCRIPTION: This snippet defines a basic React component that returns a <div> element with the text 'Hello world'. It is structured to serve as a fixture entry point for testing or documentation APIs. The component does not take any parameters and does not depend on external libraries other than React itself.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/target-flag.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @target="18"

function Component() {
  return <div>Hello world</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};

```

----------------------------------------

TITLE: Using useEffect with Mutable Dependencies in React
DESCRIPTION: This snippet defines a functional React component that attempts to use `useEffect` to log a list of items derived from props. However, the items array is not memoized, leading to potential issues with infinite loops during component updates. It illustrates how to manage dependencies within side effects when mutable values are involved.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useEffect-dep-not-memoized-bc-range-overlaps-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateMemoizedEffectDependencies
function Component(props) {
  // Items cannot be memoized bc its mutation spans a hook call
  const items = [props.value];
  const [state, _setState] = useState(null);
  mutate(items);

  // Items is no longer mutable here, but it hasn't been memoized
  useEffect(() => {
    console.log(items);
  }, [items]);

  return [items, state];
}


```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Input source code showing a React component with a custom hook useFoo that manages tab state and renders conditional text.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagate-global-phis.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_STRING0, CONST_STRING1, Text} from 'shared-runtime';

function useFoo() {
  'use no forget';
  return {tab: CONST_STRING1};
}

function Test() {
  const {tab} = useFoo();
  const currentTab = tab === CONST_STRING0 ? CONST_STRING0 : CONST_STRING1;

  return <Text value={currentTab} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: React Component with Hook Misuse (JavaScript)
DESCRIPTION: This snippet showcases an incorrect implementation of a React component where the `useFoo` hook is passed as an argument to the `foo` function instead of being called. This leads to the "InvalidReact" error, because React hooks must always be called directly, not referenced as values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-hook-as-call-arg.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return foo(useFoo);
}

```

----------------------------------------

TITLE: Memoizing React Component with Optional Data Access
DESCRIPTION: A React functional component that uses useMemo to memoize data extraction with safe optional chaining, handling potential undefined nested properties
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-optional-member-expression-as-memo-dep-non-optional-in-body.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
function Component(props) {
  const data = useMemo(() => {
    // actual code is non-optional
    return props.items.edges.nodes ?? [];
    // deps are optional
  }, [props.items?.edges?.nodes]);
  return <Foo data={data} />;
}
```

----------------------------------------

TITLE: Implementing React Component with Memoization and Validation
DESCRIPTION: This snippet defines a React component that uses useMemo for memoization and SharedRuntime for validation. It creates memoized objects based on props and validates the memoization using SharedRuntime.ValidateMemoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture-namespace-import.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import * as SharedRuntime from 'shared-runtime';

export function Component({a, b}) {
  const item1 = useMemo(() => ({a}), [a]);
  const item2 = useMemo(() => ({b}), [b]);
  const items = useMemo(() => {
    const items = [];
    SharedRuntime.typedArrayPush(items, item1);
    SharedRuntime.typedArrayPush(items, item2);
    return items;
  }, [item1, item2]);

  return (
    <>
      <SharedRuntime.ValidateMemoization inputs={[a]} output={items[0]} />
      <SharedRuntime.ValidateMemoization inputs={[b]} output={items[1]} />
      <SharedRuntime.ValidateMemoization inputs={[a, b]} output={items} />
    </>
  );
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows the optimized version of the component using React's compiler runtime. It implements memoization to avoid unnecessary re-computations and conditionally executes the loop based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-conditional-break.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props) {
    x = [0, 1, 2, 3];
    do {
      if (x === 0) {
        break;
      }

      mutate(x);
    } while (props.cond);
    $[0] = props;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: React Component with useState Hook (Code)
DESCRIPTION: This React component uses the useState hook to initialize a state variable 'x' with the initial value of 1. The component is designed to return this initial value of 'x'.  The `setX` function from the useState hook is intentionally unused in this version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-with-React-namespace.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component() {
  const [x] = React.useState(1);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: Defining React Component with Props
DESCRIPTION: This JavaScript code defines a React component called `Component` that accepts props. It uses the spread operator to combine arrays from `props.foo` and `props.bar` with other values into a new array `x`. The `FIXTURE_ENTRYPOINT` object specifies the component and its initial parameters for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-expression-spread.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [0, ...props.foo, null, ...props.bar, 'z'];
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{foo: [1, 2, 3], bar: [4, 5, 6]}],
  isComponent: false,
};

```

----------------------------------------

TITLE: Basic Component Initialization in React
DESCRIPTION: This snippet shows a simple React component that uses the useState hook to manage internal state. The component takes props, specifically a property 'x', transforms it with the function 'f', and displays it inside a div element. This serves as a typical pattern in functional React components where state initialization is tied to props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-pruned-dependency-change-detect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableChangeDetectionForDebugging
import {useState} from 'react';

function Component(props) {
  const [x, _] = useState(f(props.x));
  return <div>{x}</div>;
}

```

----------------------------------------

TITLE: Backend Initialization and Activation
DESCRIPTION: This JavaScript snippet demonstrates how to initialize and activate the React DevTools backend within an iframe.  It's crucial to initialize before React is loaded and activate only after the frontend is ready to avoid missing initialization events.  The code retrieves the iframe's contentWindow and passes it to the `initialize` and `activate` functions.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { activate, initialize } from 'react-devtools-inline/backend';

// This should be the iframe the React application is running in.
const iframe = document.getElementById(frameID);
const contentWindow = iframe.contentWindow;

// Call this before importing React (or any other packages that might import React).
initialize(contentWindow);

// Initialize the frontend...

// Call this only once the frontend has been initialized.
activate(contentWindow);
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component that filters out null values from an items array passed through props. Includes test fixture with sample input data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/noAlias-filter-on-array-prop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const filtered = props.items.filter(item => item != null);
  return filtered;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      items: [{a: true}, null, true, false, null, 'string', 3.14, null, [null]],
    },
  ],
};
```

----------------------------------------

TITLE: Original React Component with Context Access
DESCRIPTION: Simple React component that accesses multiple values from the same context using separate useContext calls.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-acess-multiple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @lowerContextAccess
function App() {
  const {foo} = useContext(MyContext);
  const {bar} = useContext(MyContext);
  return <Bar foo={foo} bar={bar} />;
}
```

----------------------------------------

TITLE: Defining useInvalidMutation Hook - JavaScript
DESCRIPTION: This snippet defines a custom hook 'useInvalidMutation' that contains a nested function 'test'. The 'test' function tries to mutate the 'options.foo' property directly, which violates React's rule against mutating props or hook arguments. This example demonstrates a common pitfall in React development where developers might mistakenly modify these immutable values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutation-in-closure.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useInvalidMutation(options) {
  function test() {
    foo(options.foo); // error should not point on this line
    options.foo = 'bar';
  }
  return test;
}

```

----------------------------------------

TITLE: Error Message for Invalid Component Naming in JavaScript
DESCRIPTION: This error message describes the constraints and intended usage of component names in React. It specifies that capitalized function names are reserved for components and must be rendered with JSX. The message guides users on how to rename their functions or allowlist them in the compiler config if they are not components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-method-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | // @validateNoCapitalizedCalls
  2 | function Component() {
> 3 |   const x = someGlobal.SomeFunc();
    |             ^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Capitalized functions are reserved for components, which must be invoked with JSX. If this is a component, render it with JSX. Otherwise, ensure that it has no hook calls and rename it to begin with a lowercase letter. Alternatively, if you know for a fact that this function is not a component, you can allowlist it via the compiler config. SomeFunc may be a component. (3:3)
  4 |
  5 |   return x;
  6 | }

```

----------------------------------------

TITLE: React Component Definition with Destructuring
DESCRIPTION: This code defines a React component named 'Foo' that receives props. It destructures the 'a' property of props to extract 'x'. The component then returns the value of 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  const { x } = props.a;
  return x;
}
```

----------------------------------------

TITLE: Using useEffect with inferred dependency [arr[0].value] in React JavaScript
DESCRIPTION: This React component uses `useEffect` with an explicit dependency array `[arr[0].value]`. This indicates a potential transformation or analysis result where the dependency on the accessed property `arr[0].value` is made explicit, likely inferred from the effect's closure usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/mutate-after-useeffect-granular-access.expect.md#_snippet_1

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import { useEffect } from "react";
import { print } from "shared-runtime";

function Component(t0) {
  const { foo } = t0;
  const arr = [];

  useEffect(() => print(arr[0].value), [arr[0].value]);
  arr.push({ value: foo });
  return arr;
}
```

----------------------------------------

TITLE: Defining useBar Hook with Memoization
DESCRIPTION: This snippet defines a React custom hook called useBar, which manages dependencies and memoization using useCallback. It captures the current value of variables to prevent unnecessary re-renders and optimizes rendering based on context changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-extended-contextvar-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees:true

import {useCallback} from 'react';
import {Stringify, useIdentity} from 'shared-runtime';

/**
 * Here, the *inferred* dependencies of cb are `a` and `t1 = LoadContext capture x_@1`.
 * - t1 does not have a scope as it captures `x` after x's mutable range
 * - `x` is a context variable, which means its mutable range extends to all
 *    references / aliases.
 * - `a`, `b`, and `x` get the same mutable range due to potential aliasing.
 *
 * We currently bail out because `a` has a scope and is not transitively memoized
 * (as its scope is pruned due to a hook call)
 */
function useBar({a, b}, cond) {
  let x = useIdentity({val: 3});
  if (cond) {
    x = b;
  }

  const cb = useCallback(() => {
    return [a, x];
  }, [a, x]);

  return <Stringify cb={cb} shouldInvoke={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useBar,
  params: [{a: 1, b: 2}, true],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees:true

import { useCallback } from "react";
import { Stringify, useIdentity } from "shared-runtime";

/**
 * Here, the *inferred* dependencies of cb are `a` and `t1 = LoadContext capture x_@1`.
 * - t1 does not have a scope as it captures `x` after x's mutable range
 * - `x` is a context variable, which means its mutable range extends to all
 *    references / aliases.
 * - `a`, `b`, and `x` get the same mutable range due to potential aliasing.
 *
 * We currently bail out because `a` has a scope and is not transitively memoized
 * (as its scope is pruned due to a hook call)
 */
function useBar(t0, cond) {
  const $ = _c(6);
  const { a, b } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = { val: 3 };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let x;
  x = useIdentity(t1);
  if (cond) {
    x = b;
  }
  let t2;
  if ($[1] !== a || $[2] !== x) {
    t2 = () => [a, x];
    $[1] = a;
    $[2] = x;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  x;
  const cb = t2;
  let t3;
  if ($[4] !== cb) {
    t3 = <Stringify cb={cb} shouldInvoke={true} />;
    $[4] = cb;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useBar,
  params: [{ a: 1, b: 2 }, true],
};
```

----------------------------------------

TITLE: Implementing useFoo React Hook in JavaScript
DESCRIPTION: This snippet defines the useFoo hook that takes an object with optional string properties and a boolean flag. It conditionally destructures the input and returns a new object with selected properties. The hook demonstrates handling of optional parameters and conditional logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-in-branch-ssa.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo(props: {
  x?: string;
  y?: string;
  z?: string;
  doDestructure: boolean;
}) {
  let x = null;
  let y = null;
  let z = null;
  const myList = [];
  if (props.doDestructure) {
    ({x, y, z} = props);

    myList.push(z);
  }
  return {
    x,
    y,
    myList,
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{x: 'hello', y: 'world', doDestructure: true}],
};
```

----------------------------------------

TITLE: Defining a Functional Component in React
DESCRIPTION: This snippet defines a functional component named 'foo' that takes 'props' as an argument. It initializes variables, processes input props, and returns a structured JSX output containing a header and content. The component maintains internal state using local variables and handles changes in props efficiently using array manipulations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/same-variable-as-dep-and-redeclare.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// note: comments are for the ideal scopes, not what is currently
// emitted
function foo(props) {
  // scope 0: deps=[props.a] decl=[x] reassign=none
  let x = [];
  x.push(props.a);

  // scope 1: deps=[x] decl=[header] reassign=none
  const header = <div>{x}</div>;

  // scope 2:
  // deps=[x, props.b, props.c]
  // decl=none
  // reassign=[x]
  const y = [x]; // y depends on the earlier x
  x = []; // x reassigned
  y.push(props.b); // interleaved mutation of x/y
  x.push(props.c); // interleaved mutation

  // scope 3 ...
  const content = (
    <div>
      {x}
      {y}
    </div>
  );

  // scope 4 ...
  return (
    <>
      {header}
      {content}
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component with useMemo Hook
DESCRIPTION: This React component utilizes the `useMemo` hook to memoize the value of `x` based on the input `a`. It returns a `<Foo>` component with the memoized `x` prop. The hook prevents unnecessary re-renders of the `<Foo>` component if `a` remains unchanged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let x = useMemo(() => [a], [a]);
  return <Foo x={x}></Foo>;
}
```

----------------------------------------

TITLE: Implementing React Functional Component with Conditional Rendering
DESCRIPTION: This snippet implements a React functional component that conditionally renders its children based on the 'entity' prop. It uses the 'useCallback' hook for memoization of the 'showMessage' function, which checks the presence of the entity. The component is designed to preserve memoization guarantees outlined in React's best practices.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-nonescaping.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
import {useCallback} from 'react';

function Component({entity, children}) {
  // showMessage doesn't escape so we don't memoize it.
  // However, validatePreserveExistingMemoizationGuarantees only sees that the scope
  // doesn't exist, and thinks the memoization was missed instead of being intentionally dropped.
  const showMessage = useCallback(() => entity != null, [entity]);

  if (!showMessage()) {
    return children;
  }

  return <div>{children}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      entity: {name: 'Sathya'},
      children: [<div key="gsathya">Hi Sathya!</div>],
    },
  ],
};

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
import { useCallback } from "react";

function Component(t0) {
  const $ = _c(2);
  const { entity, children } = t0;

  const showMessage = () => entity != null;
  if (!showMessage()) {
    return children;
  }
  let t1;
  if ($[0] !== children) {
    t1 = <div>{children}</div>;
    $[0] = children;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      entity: { name: "Sathya" },
      children: [<div key="gsathya">Hi Sathya!</div>],
    },
  ],
};

```

----------------------------------------

TITLE: React Component with Type Annotations
DESCRIPTION: A React component example using TypeScript annotations and identity function processing. Shows prop type definitions and type assertions with a numeric ID parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-number.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableUseTypeAnnotations
import {identity} from 'shared-runtime';

function Component(props: {id: number}) {
  const x = identity(props.id);
  const y = x as number;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 42}],
};
```

----------------------------------------

TITLE: React Error Message for Invalid useRef Usage
DESCRIPTION: The error message from React showing that accessing ref.current in the dependency array is invalid. It points to line 5 where the error occurs and provides a link to the React documentation about useRef.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-ref-value.expect.md#2025-04-22_snippet_1

LANGUAGE: text
CODE:
```
  3 | function Component(props) {
  4 |   const ref = useRef();
> 5 |   useEffect(() => {}, [ref.current]);
    |                        ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)

InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)
  6 | }
  7 |
  8 | export const FIXTURE_ENTRYPOINT = {
```

----------------------------------------

TITLE: Invalid Hook Usage in Nested Function Component
DESCRIPTION: This code example demonstrates a common error pattern where a React Hook (useFoo) is incorrectly called within a nested function expression. React Hooks must be called at the top level of a function component or custom Hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-in-nested-object-method.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function Component() {
  'use memo';
  const x = {
    outer() {
      const y = {
        inner() {
          return useFoo();
        },
      };
      return y;
    },
  };
  return x;
}
```

LANGUAGE: text
CODE:
```
   6 |       const y = {
   7 |         inner() {
>  8 |           return useFoo();
     |                  ^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (8:8)
   9 |         },
  10 |       };
  11 |       return y;
```

----------------------------------------

TITLE: Invalid Conditional React Hook Usage
DESCRIPTION: Example of incorrect React Hook implementation where useHook() is called inside a conditional statement. This violates React's Rules of Hooks which require hooks to be called in the same order on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-if-consequent.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = null;
  if (props.cond) {
    x = useHook();
  }
  return x;
}
```

LANGUAGE: text
CODE:
```
  2 |   let x = null;
  3 |   if (props.cond) {
> 4 |     x = useHook();
    |         ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (4:4)
  5 |   }
  6 |   return x;
  7 | }
```

----------------------------------------

TITLE: Port Forwarding for React Native Debugging
DESCRIPTION: ADB command to forward the TCP port used by React DevTools when debugging on a physical device. This enables communication between the DevTools application and React Native running on a device.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_4

LANGUAGE: shell
CODE:
```
adb reverse tcp:8097 tcp:8097
```

----------------------------------------

TITLE: Original React Component with Context Access
DESCRIPTION: A React component that uses the useContext hook to access values from MyContext and passes them as props to a child component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-destructure-multiple.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
// @lowerContextAccess
function App() {
  const context = useContext(MyContext);
  const {foo} = context;
  const {bar} = context;
  return <Bar foo={foo} bar={bar} />;
}
```

----------------------------------------

TITLE: Implementing Basic React Component with State (JavaScript)
DESCRIPTION: This snippet shows a basic React component using the useState hook to manage a counter state. It renders a span displaying the count and a button to increment it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-scopes-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableInstructionReordering
import {useState} from 'react';

function Component() {
  const [state, setState] = useState(0);
  const onClick = () => {
    setState(s => s + 1);
  };
  return (
    <>
      <span>Count: {state}</span>
      <button onClick={onClick}>Increment</button>
    </>
  );
}
```

----------------------------------------

TITLE: Using DOM Event Testing Library with Jest for React Components
DESCRIPTION: This example demonstrates how to use dom-event-testing-library to test a React hook that handles tap events. It shows setting up tests with different pointer types, creating event targets, and dispatching pointer events in a way that realistically simulates browser behavior.
SOURCE: https://github.com/facebook/react/blob/main/packages/dom-event-testing-library/README.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  describeWithPointerEvent,
  testWithPointerType,
  createEventTarget,
  setPointerEvent,
  resetActivePointers
} from 'dom-event-testing-library';

describeWithPointerEvent('useTap', hasPointerEvent => {
  beforeEach(() => {
    // basic PointerEvent mock
    setPointerEvent(hasPointerEvent);
  });

  afterEach(() => {
    // clear active pointers between test runs
    resetActivePointers();
  });

  // test all the pointer types supported by the environment
  testWithPointerType('pointer down', pointerType => {
    const ref = createRef(null);
    const onTapStart = jest.fn();
    render(() => {
      useTap(ref, { onTapStart });
      return <div ref={ref} />
    });

    // create an event target
    const target = createEventTarget(ref.current);
    // dispatch high-level pointer event
    target.pointerdown({ pointerType });

    expect(onTapStart).toBeCalled();
  });
});
```

----------------------------------------

TITLE: Original React Component with Destructuring
DESCRIPTION: A React component that demonstrates nested object destructuring with default values from props. The component extracts a nested 'y' value with a default fallback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const {x: {y} = {y: 'default'}} = props.y;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Creating a Custom React Hook in JavaScript
DESCRIPTION: This code snippet demonstrates the creation of a custom React hook. The `createHook` function returns a `useHook` function which in turn calls other hooks (`useHook1` and `useHook2`). This illustrates a valid pattern in React where hooks can invoke other hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-2bec02ac982b.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
// Valid because hooks can call hooks.
function createHook() {
  return function useHook() {
    useHook1();
    useHook2();
  };
}

```

----------------------------------------

TITLE: Implementing React Component with useState Hook
DESCRIPTION: This snippet defines a React component that uses the useState hook to manage the state of an input field. It includes a handler function to update the state when the input value changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/controlled-input.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';
function component() {
  let [x, setX] = useState(0);
  const handler = event => setX(event.target.value);
  return <input onChange={handler} value={x} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: React Component Definition with Conditional Rendering
DESCRIPTION: This snippet defines a React component that conditionally renders different outputs based on the `props.cond`, `props.a`, and `props.b` values. It uses `x.push` to construct arrays and returns them based on nested `if` conditions. Notably, there's a potential for missed memoization opportunities in this initial, unoptimized version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/early-return-nested-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function Component(props) {
  let x = [];
  if (props.cond) {
    x.push(props.a);
    if (props.b) {
      const y = [props.b];
      x.push(y);
      // oops no memo!
      return x;
    }
    // oops no memo!
    return x;
  } else {
    return foo();
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, a: 42, b: 3.14}],
};

```

----------------------------------------

TITLE: Defining a Functional Component - JavaScript
DESCRIPTION: This snippet defines a basic functional React component that utilizes props, initializes an empty array, and maps over it. It serves as a simple example of a React component structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-frozen-array-noAlias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [];
  <dif>{x}</dif>;
  const y = x.map(item => item);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Invalid React Hooks Usage in Loops
DESCRIPTION: Demonstrates improper usage of React Hooks inside while loops and conditional statements. This code is intentionally invalid to test React's hook validation rules that require hooks to be called in a consistent order and not within loops or conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-1b9527f967f3.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHookInLoops() {
  while (a) {
    useHook1();
    if (b) return;
    useHook2();
  }
  while (c) {
    useHook3();
    if (d) return;
    useHook4();
  }
}
```

----------------------------------------

TITLE: Invalid React Hook Usage in Labeled Block
DESCRIPTION: Demonstrates an invalid pattern where a React Hook is called within a labeled block statement that can be broken out of conditionally. This violates React's Rules of Hooks requiring hooks to be called in a consistent order and unconditionally.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-49d341e5d68f.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useLabeledBlock() {
  label: {
    if (a) break label;
    useHook();
  }
}
```

LANGUAGE: text
CODE:
```
   6 |   label: {
   7 |     if (a) break label;
>  8 |     useHook();
     |     ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (8:8)
   9 |   }
  10 | }
  11 |
```

----------------------------------------

TITLE: React Component with Array Destructuring Default Value
DESCRIPTION: Demonstrates array destructuring in a React component with a default value of 42. Takes props.value array and assigns the first element to x with a default value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-explicit-null.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // destructure slot index has an explicit null in the input, should return null (not the default)
  const [x = 42] = props.value;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: [null]}],
};
```

----------------------------------------

TITLE: Implementing React Component with Destructuring and Default Value
DESCRIPTION: This snippet defines a React component that uses array destructuring with a default value. It extracts the first element of props.value, defaulting to 42 if undefined. The component returns this value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-explicit-undefined.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // destructure slot index has an explicit undefined in the input, should return default
  const [x = 42] = props.value;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: [undefined]}],
};
```

----------------------------------------

TITLE: Identifying React Component Error - JavaScript
DESCRIPTION: This snippet displays an error message generated by the React linter indicating that the component 'Foo' is attempting to reassign 'someGlobal', which is considered a side effect. The error highlights the need to maintain purity in React components and suggests using hooks like useState instead of direct variable manipulation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.assign-global-in-component-tag-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Component() {
  2 |   const Foo = () => {
> 3 |     someGlobal = true;
    |     ^^^^^^^^^^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)
  4 |   };
  5 |   return <Foo />;
  6 | }

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Initial implementation of a React component that creates a callback closure over a mutable variable and renders a Stringify component with the callback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-outside-of-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component(props) {
  let x = null;
  const callback = () => {
    console.log(x);
  };
  x = {};
  return <Stringify callback={callback} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component with Object Spread
DESCRIPTION: Simple React component that spreads props.foo object and returns it. Includes fixture configuration for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-spread-element.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {...props.foo};
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Compiler Error Logs
DESCRIPTION: The logs produced by React's validation system that identify the errors in the component. It shows specific compiler errors about components being created during render, which will cause state reset issues.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-function.expect.md#2025-04-21_snippet_2

LANGUAGE: json
CODE:
```
{"kind":"CompileError","detail":{"options":{"reason":"Components created during render will reset their state each time they are created. Declare components outside of render. ","description":null,"severity":"InvalidReact","suggestions":null,"loc":{"start":{"line":6,"column":10,"index":122},"end":{"line":6,"column":19,"index":131},"filename":"invalid-dynamically-constructed-component-function.ts"}}}},"fnLoc":null}
{"kind":"CompileError","detail":{"options":{"reason":"The component may be created during render","description":null,"severity":"InvalidReact","suggestions":null,"loc":{"start":{"line":3,"column":2,"index":65},"end":{"line":5,"column":3,"index":111},"filename":"invalid-dynamically-constructed-component-function.ts"}}}},"fnLoc":null}
{"kind":"CompileSuccess","fnLoc":{"start":{"line":2,"column":0,"index":37},"end":{"line":7,"column":1,"index":137},"filename":"invalid-dynamically-constructed-component-function.ts"},"fnName":"Example","memoSlots":1,"memoBlocks":1,"memoValues":1,"prunedMemoBlocks":0,"prunedMemoValues":0}
```

----------------------------------------

TITLE: Using useMemo for Memoization in React
DESCRIPTION: This snippet illustrates how to use the useMemo hook in a React functional component to memoize the derived value from props. The component takes 'propA' as a parameter and uses useMemo to compute a value that depends on 'propA.x'. This ensures that the computed value is recalculated only when 'propA.x' changes, thereby optimizing performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-property-call-chained-object.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';

function Component({propA}) {
  return useMemo(() => {
    return {
      value: propA.x().y,
    };
  }, [propA.x]);
}

```

----------------------------------------

TITLE: Mutating React Component Props in JavaScript
DESCRIPTION: This JavaScript snippet demonstrates an attempt to directly mutate React component props within a function called during the component's lifecycle. The `mutateProps` function tries to assign a boolean value to a property of the `props` object. React considers this an anti-pattern and throws an error because props should be treated as immutable within a component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-props-mutation-in-effect-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const mutateProps = () => {
    props.value = true;
  };
  const indirectMutateProps = () => {
    mutateProps();
  };
  useEffect(() => indirectMutateProps(), []);
}
```

----------------------------------------

TITLE: Using useMemo for Identity Function in React
DESCRIPTION: This snippet demonstrates the use of the useMemo hook from React to optimize a function (identity). It ensures memoization of the result based on the input parameter x. The function is also included in an exportable fixture object for further testing or usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';
import {identity} from 'shared-runtime';

/**
 * This is technically a false positive, although it makes sense
 * to bailout as source code might be doing something sketchy.
 */
function useFoo(x) {
  useMemo(() => identity(x), [x]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [2],
};

```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: Compiler-optimized version of the component that implements caching and memoization using React's compiler runtime. Uses array-based caching to store and compare previous values of props and computed results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-object-declaration-to-context-var.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props) {
    const { x: t0 } = props;
    x = t0;
    const foo = () => {
      x = identity(props.x);
    };

    foo();
    $[0] = props;
    $[1] = x;
  } else {
    x = $[1];
  }
  let t0;
  if ($[2] !== x) {
    t0 = { x };
    $[2] = x;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ x: 42 }],
};
```

----------------------------------------

TITLE: React Component with Compiler Runtime Optimization
DESCRIPTION: This code defines a React component that utilizes the `react/compiler-runtime` to optimize rendering. The component calculates 'z' similarly to the first snippet, but then it uses the compiler runtime's `_c` function to memoize the returned array `[z]`. This optimization prevents unnecessary re-renders when 'z' hasn't changed, improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-do-while-indirect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x = 0;
  let y = 0;
  let z;
  do {
    x = x + 1;
    y = y + 1;
    z = y;
  } while (x < props.limit);
  let t0;
  if ($[0] !== z) {
    t0 = [z];
    $[0] = z;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { limit: 10 },
    { limit: 10 },
    { limit: 1 },
    { limit: 1 },
    { limit: 10 },
    { limit: 1 },
    { limit: 10 },
    { limit: 1 },
  ],
};
```

----------------------------------------

TITLE: Defining React Components with Different Prop Dependencies
DESCRIPTION: This snippet defines four React components (ComponentA, ComponentB, ComponentC, and ComponentD) that demonstrate different patterns of how props influence component behavior. It also exports a fixture entrypoint for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-early-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
/**
 * props.b does *not* influence `a`
 */
function ComponentA(props) {
  const a_DEBUG = [];
  a_DEBUG.push(props.a);
  if (props.b) {
    return null;
  }
  a_DEBUG.push(props.d);
  return a_DEBUG;
}

/**
 * props.b *does* influence `a`
 */
function ComponentB(props) {
  const a = [];
  a.push(props.a);
  if (props.b) {
    a.push(props.c);
  }
  a.push(props.d);
  return a;
}

/**
 * props.b *does* influence `a`, but only in a way that is never observable
 */
function ComponentC(props) {
  const a = [];
  a.push(props.a);
  if (props.b) {
    a.push(props.c);
    return null;
  }
  a.push(props.d);
  return a;
}

/**
 * props.b *does* influence `a`
 */
function ComponentD(props) {
  const a = [];
  a.push(props.a);
  if (props.b) {
    a.push(props.c);
    return a;
  }
  a.push(props.d);
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: ComponentA,
  params: [{a: 1, b: false, d: 3}],
};
```

----------------------------------------

TITLE: Compiled React Component with Caching
DESCRIPTION: Compiler-optimized version of the component with added caching logic. Uses an array ($) to store previous values and implements dependency checking to avoid unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-property-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(11);
  let a;
  let t0;
  if ($[0] !== props.a || $[1] !== props.b) {
    a = [props.a, props.b, "hello"];
    t0 = a.push(42);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = a;
    $[3] = t0;
  } else {
    a = $[2];
    t0 = $[3];
  }
  const x = t0;
  let t1;
  if ($[4] !== a || $[5] !== props.c) {
    t1 = a.at(props.c);
    $[4] = a;
    $[5] = props.c;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  const y = t1;
  let t2;
  if ($[7] !== a || $[8] !== x || $[9] !== y) {
    t2 = { a, x, y };
    $[7] = a;
    $[8] = x;
    $[9] = y;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1, b: 2, c: 0 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component with Conditional Hook Call
DESCRIPTION: This code snippet defines a React component named `Component` that receives `props`. Inside the component, `makeObject_Primitives()` is called, and its returned object's `useFoo()` method is called conditionally based on `props.cond`. This conditional hook call violates React's rules, leading to an error because hook calls must be consistent across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-conditionally-methodcall-hooklike-property-of-local.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives} from 'shared-runtime';

function Component(props) {
  const local = makeObject_Primitives();
  if (props.cond) {
    local.useFoo();
  }
}

```

----------------------------------------

TITLE: Modifying Props in a React Component
DESCRIPTION: This JavaScript function iterates over the items passed in as props and attempts to modify each item directly by setting its 'modified' property to true. This operation is against React's practice of keeping props immutable, which can lead to unexpected behavior and errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-props-via-for-of-iterator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const items = [];
  for (const x of props.items) {
    x.modified = true;
    items.push(x);
  }
  return items;
}
```

----------------------------------------

TITLE: Initializing React Component with useMemo
DESCRIPTION: This snippet demonstrates initializing a React component using the useMemo hook to memoize the computation of objects based on props. It reduces unnecessary recomputation by caching the results for given dependencies. Dependencies include React hooks and the makeObject function to transform props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-independently-memoizeable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [a, b] = useMemo(() => {
    const items = [];
    const a = makeObject(props.a);
    const b = makeObject(props.b);
    return [a, b];
  });
  return [a, b];
}
```

----------------------------------------

TITLE: Mutating Component Props with useEffect - React - JavaScript
DESCRIPTION: This React functional component attempts to directly mutate its props, specifically altering the 'foo' property of the 'y' variable, which is derived from props. The component demonstrates the misuse of state by mutating props, which violates React's principles and leads to a runtime error. The useEffect hook is utilized to trigger the mutation, but this approach is discouraged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-props-in-effect-fixpoint.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect} from 'react';

function Component(props) {
  let x = null;
  while (x == null) {
    x = props.value;
  }
  let y = x;
  let mutateProps = () => {
    y.foo = true;
  };
  let mutatePropsIndirect = () => {
    mutateProps();
  };
  useEffect(() => mutatePropsIndirect(), [mutatePropsIndirect]);
}

```

----------------------------------------

TITLE: Initializing React Component with Context Access
DESCRIPTION: Defines a React component 'App' that uses the useContext hook to access 'foo' and 'bar' from MyContext. The @lowerContextAccess directive is used to indicate optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-selector-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @lowerContextAccess
function App() {
  const {foo, bar} = useContext(MyContext);
  return <Bar foo={foo} bar={bar} />;
}
```

----------------------------------------

TITLE: Creating Browser History with History Library - JavaScript
DESCRIPTION: This snippet initializes browser history using the 'history' library version 2.1.2, encapsulated in a React environment. It defines a browser history object using the 'useBasename' function to set a base URL for navigation. The calling of the top-level Hook-like construct is warned against due to potential runtime errors in environments that support inline requires.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-28a7111f56a7.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

// Technically this is a false positive.
// We *could* make it valid (and it used to be).
//
// However, top-level Hook-like calls can be very dangerous
// in environments with inline requires because they can mask
// the runtime error by accident.
// So we prefer to disallow it despite the false positive.

const {createHistory, useBasename} = require('history-2.1.2');
const browserHistory = useBasename(createHistory)({
  basename: '/',
});

```

----------------------------------------

TITLE: Original React Component with Ref Usage in Effects
DESCRIPTION: Demonstrates a React component that uses refs within useEffect hooks without explicit dependency arrays. The code showcases the usage of refs and nested refs that will need proper dependency tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-ref-helper.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect} from 'react';
import {print} from 'shared-runtime';

/**
 * We never include a .current access in a dep array because it may be a ref access.
 * This might over-capture objects that are not refs and happen to have fields named
 * current, but that should be a rare case and the result would still be correct
 * (assuming the effect is idempotent). In the worst case, you can always write a manual
 * dep array.
 */
function RefsInEffects() {
  const ref = useRefHelper();
  const wrapped = useDeeperRefHelper();
  useEffect(() => {
    print(ref.current);
    print(wrapped.foo.current);
  });
}

function useRefHelper() {
  return useRef(0);
}

function useDeeperRefHelper() {
  return {foo: useRefHelper()};
}
```

----------------------------------------

TITLE: Input Component with Optional Chaining in useEffect
DESCRIPTION: A React component example before compilation that uses optional chaining in a useEffect hook. The component creates an object with a conditional nested property and uses optional chaining to access that property in the effect.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-optional-chain.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect} from 'react';
import {print} from 'shared-runtime';

// TODO: take optional chains as dependencies
function ReactiveMemberExpr({cond, propVal}) {
  const obj = {a: cond ? {b: propVal} : null};
  useEffect(() => print(obj.a?.b));
}
```

----------------------------------------

TITLE: Invalid React Hook Usage in Class Component
DESCRIPTION: Demonstrates an incorrect attempt to use React useState hook within a class component method, which violates React hooks rules
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-e69ffce323c3.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip\n// Passed but should have failed\n\n(class {\n  useHook = () => {\n    useState();\n  };\n});
```

----------------------------------------

TITLE: Implementing React.forwardRef() in JavaScript
DESCRIPTION: Demonstration of using the new React.forwardRef() API to allow components to forward their refs to a child component.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_17

LANGUAGE: JavaScript
CODE:
```
const ForwardedComponent = React.forwardRef((props, ref) => {
  return <ChildComponent ref={ref} {...props} />;
});
```

----------------------------------------

TITLE: Implementing React Component with useMemo Hook (JavaScript)
DESCRIPTION: This snippet defines a React component 'Foo' that uses the useMemo hook. It demonstrates the use of makeArray function and how useMemo is applied to memoize an array based on a dependency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-dep-array-literal-access.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';
import {makeArray} from 'shared-runtime';

// We currently only recognize "hoistable" values (e.g. variable reads
// and property loads from named variables) in the source depslist.
// This makes validation logic simpler and follows the same constraints
// from the eslint react-hooks-deps plugin.
function Foo(props) {
  const x = makeArray(props);
  // react-hooks-deps lint would already fail here
  return useMemo(() => [x[0]], [x[0]]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{val: 1}],
};
```

----------------------------------------

TITLE: Implementing React Counter Component
DESCRIPTION: This snippet defines a React component with a counter using useState hook. It renders a counter value, a button to increment it, and uses a custom Stringify component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';
import {Stringify} from 'shared-runtime';

function Component() {
  let [state, setState] = useState(0);
  return (
    <div>
      <Stringify text="Counter" />
      <span>{state}</span>
      <button data-testid="button" onClick={() => setState(state + 1)}>
        increment
      </button>
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Invalidating React Hook Invocation
DESCRIPTION: Demonstrates an incorrect method of calling React hooks inside a try-catch block, which breaks the fundamental rules of hook usage
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.rules-of-hooks-e29c874aa913.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useHook() {
  try {
    f();
    useState();
  } catch {}
}
```

----------------------------------------

TITLE: Defining Functional Component with JSX - JavaScript
DESCRIPTION: This snippet defines a simple functional React component named 'Component' that receives props and returns JSX. The component renders a nested component 'Sathya.Codes.Forget' which wraps around 'Foo.Bar.Baz'. No external dependencies are mentioned. The expected output is a valid React element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-member-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return (
    <Sathya.Codes.Forget>
      <Foo.Bar.Baz />
    </Sathya.Codes.Forget>
  );
}

```

----------------------------------------

TITLE: Creating Simple React Component
DESCRIPTION: This snippet defines a basic React functional component that takes props and renders a div element displaying the count property from props. It utilizes JSX syntax to create elements and manage their display. The expected input is a props object containing a count property, and it outputs a rendered React element with the count value shown in two places within the JSX structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-overlapping-scopes-with-intermediate-reassignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component(props) {
  let x;
  const array = [props.count];
  x = array;
  const element = <div>{array}</div>;
  return (
    <div>
      {element}
      {x}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{count: 42}],
};
```

----------------------------------------

TITLE: Original React Component with Effect Hooks
DESCRIPTION: A React component that demonstrates various patterns of dependencies in useEffect hooks. It includes references to props, module constants, local variables, and refs, which the compiler will analyze to automatically infer the required dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/infer-effect-dependencies.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect, useRef} from 'react';
import useEffectWrapper from 'useEffectWrapper';

const moduleNonReactive = 0;

function Component({foo, bar}) {
  const localNonreactive = 0;
  const ref = useRef(0);
  const localNonPrimitiveReactive = {
    foo,
  };
  const localNonPrimitiveNonreactive = {};
  useEffect(() => {
    console.log(foo);
    console.log(bar);
    console.log(moduleNonReactive);
    console.log(localNonreactive);
    console.log(globalValue);
    console.log(ref.current);
    console.log(localNonPrimitiveReactive);
    console.log(localNonPrimitiveNonreactive);
  });

  // Optional chains and property accesses
  // TODO: we may be able to save bytes by omitting property accesses if the
  // object of the member expression is already included in the inferred deps
  useEffect(() => {
    console.log(bar?.baz);
    console.log(bar.qux);
  });

  useEffectWrapper(() => {
    console.log(foo);
  });
}
```

----------------------------------------

TITLE: Implementing useFoo with React's useMemo Hook
DESCRIPTION: This snippet defines a useFoo function that uses React's useMemo hook to memoize a computation based on data.a. It also exports a FIXTURE_ENTRYPOINT for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-inner-decl.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {identity} from 'shared-runtime';

function useFoo(data) {
  return useMemo(() => {
    const temp = identity(data.a);
    return {temp};
  }, [data.a]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: 2}],
};
```

----------------------------------------

TITLE: Original React Component with useMemo
DESCRIPTION: A React functional component that uses useMemo to conditionally create and memoize an object based on a prop condition
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-if-else-multiple-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = useMemo(() => {
    if (props.cond) {
      return makeObject(props.a);
    }
    return makeObject(props.b);
  });
  return x;
}
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This code defines a React component named `Component` that renders static text elements. It imports a `StaticText1` component from 'shared-runtime' and uses it within the component's JSX structure. The component returns a div containing several `StaticText1` elements and plain text.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-preserve-whitespace.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {StaticText1} from 'shared-runtime';

function Component() {
  return (
    <div>
      Before text
      <StaticText1 />
      Middle text
      <StaticText1>
        Inner before text
        <StaticText1 />
        Inner middle text
        <StaticText1 />
        Inner after text
      </StaticText1>
      After text
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: React Component with Conditional Hook Usage
DESCRIPTION: The `InvalidComponent` conditionally calls the `useHook` function based on the `props.cond` value. This can violate the rules of hooks if the condition changes between renders, leading to unpredictable behavior. It imports `useHook` from `shared-runtime`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multiple-components-first-is-invalid.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @panicThreshold(none)
import {useHook} from 'shared-runtime';

function InvalidComponent(props) {
  if (props.cond) {
    useHook();
  }
  return <div>Hello World!</div>;
}

```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This snippet defines a React component that conditionally renders a `<Bar>` element based on the `isMenuShown` variable. It uses a ternary operator to choose between `props.b` and `props.c` based on the value of `props.a`. The component returns the rendered element or null.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-at-start-of-value-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(props) {
  // NOTE: the temporary for the leading space was previously dropped
  const x = isMenuShown ? <Bar> {props.a ? props.b : props.c}</Bar> : null;
  return x;
}

```

----------------------------------------

TITLE: Using Optional Chaining in React Component with JavaScript
DESCRIPTION: This JavaScript function, 'useFoo', demonstrates safe property access in a React context using optional chaining. The function checks and collects nested properties into an array using optional chaining to avoid errors caused by null or undefined values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @enablePropagateDepsInHIR

function useFoo({a}) {
  let x = [];
  x.push(a?.b.c?.d.e);
  x.push(a.b?.c.d?.e);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: null}],
  sequentialRenders: [
    {a: null},
    {a: null},
    {a: {}},
    {a: {b: {c: {d: {e: 42}}}}},
    {a: {b: {c: {d: {e: 43}}}}},
    {a: {b: {c: {d: {e: undefined}}}}},
    {a: {b: undefined}},
  ],
};
```

----------------------------------------

TITLE: Defining the Custom Hook Function - JavaScript
DESCRIPTION: This snippet defines a custom React hook called 'useHook' that accepts props and creates two objects 'x' and 'y'. It uses the 'setProperty' function to return an object combining the two. The purpose of the hook is to enable component interaction with passed props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-maybe-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper, setProperty} from 'shared-runtime';
function useHook(props) {
  const x = {
    getX() {
      return props;
    },
  };
  const y = {
    getY() {
      return 'y';
    },
  };
  return setProperty(x, y);
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{value: 0}],
};

```

----------------------------------------

TITLE: Running Backend and Standalone DevTools for Local Development
DESCRIPTION: Commands for running the backend and standalone components of React DevTools when developing the tool itself. These commands are used after completing prerequisite build steps.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_6

LANGUAGE: shell
CODE:
```
yarn start:backend
yarn start:standalone
```

----------------------------------------

TITLE: Defining useKeyedState Hook in React (JavaScript)
DESCRIPTION: This snippet defines the 'useKeyedState' custom hook that receives a key and an initial state value to manage state in a functional component using React's hooks. It leverages 'useState' to hold the current state and 'useMemo' to update the state when the key or initial value changes. Note that the use of 'setState' within 'useMemo' may lead to an infinite loop, as indicated by the accompanying error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-setState-in-useMemo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useKeyedState({key, init}) {
  const [prevKey, setPrevKey] = useState(key);
  const [state, setState] = useState(init);

  useMemo(() => {
    setPrevKey(key);
    setState(init);
  }, [key, init]);

  return state;
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component implementation using context and event handling. Demonstrates usage of useContext hook with a memoized onClick handler that mutates context data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-maybe-mutate-context-in-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as React from 'react';
import {useContext} from 'react';
import {mutate} from 'shared-runtime';

const FooContext = React.createContext({current: null});

function Component(props) {
  const Foo = useContext(FooContext);
  // This callback can be memoized because we aren't 100% positive that
  // `mutate()` actually mutates, so we optimistically assume it doesn't
  // Its range doesn't get entagled w the useContext call so we're able
  // to create a reactive scope and memoize it.
  const onClick = () => {
    mutate(Foo.current);
  };
  return <div onClick={onClick}>{props.children}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{children: <div>Hello</div>}],
};
```

----------------------------------------

TITLE: Implementing Conditional Memoization in React Component
DESCRIPTION: This snippet defines a React component that uses useMemo to conditionally render based on propA and propB. It demonstrates how to optimize rendering performance by memoizing computed values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-own-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';

function Component({propA, propB}) {
  return useMemo(() => {
    if (propA) {
      return {
        value: propB.x.y,
      };
    }
  }, [propA, propB.x.y]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{propA: 1, propB: {x: {y: []}}}],
};
```

----------------------------------------

TITLE: Error Handling in React Hook Usage
DESCRIPTION: The snippet includes an error message indicating that the React reference's current property cannot be accessed during the render phase of the useFoo hook. This is a critical limitation that developers need to address when working with useRef and useMemo to ensure proper component functionality without violating React's rules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-mutable-ref-not-preserved.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```
   6 | function useFoo() {
   7 |   const r = useRef();
>  8 |   return useMemo(() => makeArray(r), []);
     |                                  ^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (8:8)
   9 | }
  10 |
  11 | export const FIXTURE_ENTRYPOINT = {
```

```

----------------------------------------

TITLE: Using Memoization to Optimize React Component Rendering
DESCRIPTION: This code snippet defines a React functional component that leverages the 'useMemo' hook to memoize calculations based on the component's props. It also utilizes the 'ValidateMemoization' component to validate the inputs and outputs of the memoized data, ensuring that changes to the props do not negatively affect the memoization guarantees. Required dependencies include React and 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-member-expression-with-conditional-optional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
  const data = useMemo(() => {
    const x = [];
    x.push(props?.items);
    if (props.cond) {
      x.push(props?.items);
    }
    return x;
  }, [props?.items, props.cond]);
  return (
    <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />
  );
}

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that manages state using useState hook and handles input changes. The component demonstrates variable shadowing in the onChange handler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-function-shadowed-identifiers.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [x, setX] = useState(null);

  const onChange = e => {
    let x = null; // intentionally shadow the original x
    setX(currentX => currentX + x); // intentionally refer to shadowed x
  };

  return <input value={x} onChange={onChange} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Using useMemo for Conditional Calculation in React
DESCRIPTION: This snippet defines a custom hook 'useFoo' that utilizes 'useMemo' from React to memoize values based on a condition. It imports necessary functions from 'react' and 'shared-runtime'. The hook takes a boolean parameter, where it computes and returns 10 if true or 5 if false. The memoized value is recalculated only when the condition changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo-mult-returns.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';
import {identity} from 'shared-runtime';

function useFoo(cond) {
  useMemo(() => {
    if (cond) {
      return identity(10);
    } else {
      return identity(5);
    }
  }, [cond]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: Validating Memoization in React Component with useMemo
DESCRIPTION: Defines a React component using the useMemo hook to memoize array data derived from component props, optimizing re-renders. The component imports ValidateMemoization from 'shared-runtime' and checks memoized inputs and outputs. This ensures that the memoization guarantees are preserved while allowing optional dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-single-with-unconditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
  const data = useMemo(() => {
    const x = [];
    x.push(props?.items);
    x.push(props.items);
    return x;
  }, [props.items]);
  return <ValidateMemoization inputs={[props.items]} output={data} />;
}

```

----------------------------------------

TITLE: Custom configuration with flat config format
DESCRIPTION: Advanced setup using flat config (eslint.config.js) with manual configuration of individual rules for finer control.
SOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_5

LANGUAGE: javascript
CODE:
```
import * as reactHooks from 'eslint-plugin-react-hooks';

export default [
  {
    files: ['**/*.{js,jsx}'],
    plugins: { 'react-hooks': reactHooks },
    // ...
    rules: {
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',
    }
  },
];
```

----------------------------------------

TITLE: Defining ComponentB Using Custom Hook in JavaScript
DESCRIPTION: The function 'componentB' utilizes a custom hook 'useFoo' to generate a greeting message. It takes 'props' as an argument, specifically using the property 'a'. The function returns the result from 'useFoo'. The code assumes 'useFoo' is defined elsewhere and properly imported or globally available.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/template-literal.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function componentB(props) {
  let x = useFoo(`hello ${props.a}`);
  return x;
}

```

LANGUAGE: javascript
CODE:
```
function componentB(props) {
  const x = useFoo(`hello ${props.a}`);
  return x;
}

```

----------------------------------------

TITLE: Implementing React Component with useCallback and useRef
DESCRIPTION: This snippet defines a React component using useCallback and useRef hooks. It creates an input element with an onChange handler that updates a ref value. However, there's an issue with accessing the ref value during render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useCallback-set-ref-nested-property-dont-preserve-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees:false
import {useCallback, useRef} from 'react';

function Component(props) {
  const ref = useRef({inner: null});

  const onChange = useCallback(event => {
    // The ref should still be mutable here even though function deps are frozen in
    // @enablePreserveExistingMemoizationGuarantees mode
    ref.current.inner = event.target.value;
  });

  ref.current.inner = null;

  return <input onChange={onChange} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component Using Custom Hook - JavaScript
DESCRIPTION: This snippet features a React functional component that utilizes the custom useState hook. The component initiates the state with 'hello' and updates the state to 'goodbye' when the div is clicked. The key functionalities include rendering the current state and handling user interaction through an onClick event.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-dont-resolve-local-useState.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component() {
  const [state, setState] = useState('hello');

  return <div onClick={() => setState('goodbye')}>{state}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with useState
DESCRIPTION: This code defines a React component that utilizes the useState hook to manage state. It also includes examples of using Boolean, Number, and String constructor functions. A constant function is also defined and used within the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capitalized-function-allowlist.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoCapitalizedCalls @hookPattern:".*\b(use[^$]+)$"
import * as React from 'react';
const React$useState = React.useState;
const THIS_IS_A_CONSTANT = () => {};
function Component() {
  const b = Boolean(true); // OK
  const n = Number(3); // OK
  const s = String('foo'); // OK
  const [state, setState] = React$useState(0); // OK
  const [state2, setState2] = React.useState(1); // OK
  const constant = THIS_IS_A_CONSTANT(); // OK
  return 3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};

```

----------------------------------------

TITLE: Initializing React Component with Memoized Data
DESCRIPTION: Creates a React functional component that uses useMemo to generate an array based on conditional props, with validation of memoization behavior
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-member-expression-with-conditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
  const data = useMemo(() => {
    const x = [];
    x.push(props?.items);
    if (props.cond) {
      x.push(props.items);
    }
    return x;
  }, [props?.items, props.cond]);
  return (
    <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />
  );
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Original React component implementation using useCallback hook for event handling optimization. The component creates an object, uses a custom hook, and sets up a click handler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-call-second-function-which-captures-maybe-mutable-value-dont-preserve-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees:false @enableTransitivelyFreezeFunctionExpressions:false
import {useCallback} from 'react';
import {
  identity,
  logValue,
  makeObject_Primitives,
  useHook,
} from 'shared-runtime';

function Component(props) {
  const object = makeObject_Primitives();

  useHook();

  const log = () => {
    logValue(object);
  };

  const onClick = useCallback(() => {
    log();
  }, [log]);

  identity(object);

  return <div onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Error Message for Invalid Ref Access during Render
DESCRIPTION: This error message is triggered by the React component when it tries to access ref.current during render. It specifically points to the reset() function call which violates React's rule about not accessing ref values during render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useCallback-accesses-ref-mutated-later-via-function-preserve-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  15 |     ref.current.inner = null;
  16 |   };
> 17 |   reset();
     |   ^^^^^ InvalidReact: This function accesses a ref value (the `current` property), which may not be accessed during render. (https://react.dev/reference/react/useRef) (17:17)

InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (17:17)
  18 |
  19 |   return <input onChange={onChange} />;
  20 | }
```

----------------------------------------

TITLE: Implementing React Component with Invalid Ref Access during Render
DESCRIPTION: This code demonstrates a React component that incorrectly accesses a ref's current property during render. The component uses useCallback and useRef hooks, but violates React's rules by calling reset() during render, which accesses ref.current.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useCallback-accesses-ref-mutated-later-via-function-preserve-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees @validateRefAccessDuringRender
import {useCallback, useRef} from 'react';

function Component(props) {
  const ref = useRef({inner: null});

  const onChange = useCallback(event => {
    // The ref should still be mutable here even though function deps are frozen in
    // @enablePreserveExistingMemoizationGuarantees mode
    ref.current.inner = event.target.value;
  });

  // The ref is modified later, extending its range and preventing memoization of onChange
  const reset = () => {
    ref.current.inner = null;
  };
  reset();

  return <input onChange={onChange} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with useMemo
DESCRIPTION: This snippet defines a React component `Component` that uses `useMemo` to memoize an object based on the values of `propA` and `propB.x.y`. It imports `useMemo` from 'react' and `identity` from 'shared-runtime'. The component returns a memoized object with `value` (derived from `propB?.x.y`) and `other` (equal to `propA`).
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-alloc.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {identity} from 'shared-runtime';

function Component({propA, propB}) {
  return useMemo(() => {
    return {
      value: identity(propB?.x.y),
      other: propA,
    };
  }, [propA, propB.x.y]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{propA: 2, propB: {x: {y: []}}}],
};

```

----------------------------------------

TITLE: Initializing React Component with useRef in JavaScript
DESCRIPTION: This snippet demonstrates a React component using the useRef hook. It initially sets and checks a ref's current value. Dependencies include React's 'useRef'. The function C initializes and uses the ref 'r' with default value 'null'. During render, it checks if the current value is null and sets it to 1, leading to an error due to accessing the ref during render. React dependency is necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-post-access.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow\nimport {useRef} from 'react';\n\ncomponent C() {\n  const r = useRef(null);\n  if (r.current == null) {\n    r.current = 1;\n  }\n  r.current = 1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}],\n};
```

----------------------------------------

TITLE: Implementing React Component with Dynamic Theming in JavaScript
DESCRIPTION: This snippet defines a React component that uses a custom theming system. It utilizes a 'useTheme' hook and a 'cx' utility for dynamic class name generation based on the current theme.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-namespace-assigned-to-temporary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer) @enableAssumeHooksFollowRulesOfReact:false @customMacros(cx)
import {identity} from 'shared-runtime';

const DARK = 'dark';

function Component() {
  const theme = useTheme();
  return (
    <div
      className={cx.foo({
        'styles/light': true,
        'styles/dark': identity([theme.getTheme()]),
      })}
    />
  );
}

const cx = {
  foo(obj) {
    const classes = [];
    for (const [key, value] of Object.entries(obj)) {
      if (value) {
        classes.push(key);
      }
    }
    return classes.join(' ');
  },
};

function useTheme() {
  return {
    getTheme() {
      return DARK;
    },
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Creating a React Hook with Hook Usage (JavaScript)
DESCRIPTION: This code defines a function `createHook` that returns another function, `useHookWithHook`. The returned function represents a custom React hook that internally calls the `useHook` function. This demonstrates that React hooks can indeed call other hooks within their implementation, which is a valid and common pattern for creating more complex and reusable hook logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-33a6e23edac1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
// Valid because hooks can use hooks.
function createHook() {
  return function useHookWithHook() {
    useHook();
  };
}
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This code defines a simple React component called `Component` that uses the `useCustomHook` with the string "hello".  It returns a `div` element containing the text "Hello". This component demonstrates how to use the custom hook within a functional component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component() {
  useCustomHook('hello');
  return <div>Hello</div>;
}
```

----------------------------------------

TITLE: Defining React Component with Rest Parameters
DESCRIPTION: This snippet defines a simple React component that takes a 'foo' parameter and rest parameters. It returns an array containing 'foo' and the rest parameters. An export constant FIXTURE_ENTRYPOINT is also defined for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-identifier.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(foo, ...bar) {
  return [foo, bar];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['foo', 'bar', 'baz'],
};
```

----------------------------------------

TITLE: React Component Definition with JSX Outlining
DESCRIPTION: This code defines a React component `Component` that takes an array `arr` as a prop and renders a list of `Bar` components, each containing a `Baz` component. It uses `Array.map` to iterate over the array and generate JSX elements. The `useX` hook is used to provide a value `x` to the `Bar` component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-jsx-stored-in-id.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableJsxOutlining
function Component({arr}) {
  const x = useX();
  return (
    <>
      {arr.map((i, id) => {
        let jsx = (
          <Bar key={id} x={x}>
            <Baz i={i}></Baz>
          </Bar>
        );
        return jsx;
      })}
    </>
  );
}

function Bar({x, children}) {
  return (
    <>
      {x}
      {children}
    </>
  );
}

function Baz({i}) {
  return i;
}

function useX() {
  return 'x';
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arr: ['foo', 'bar']}],
};

```

----------------------------------------

TITLE: Implementing Memoization with Validation in React
DESCRIPTION: This code snippet defines a React functional component that utilizes the `useMemo` hook to memoize derived data based on the `arg.items` prop. It uses a `ValidateMemoization` component to ensure the memoization guarantees are preserved. The snippet is intended for scenarios where performance optimizations via memoization and validation are crucial.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-single.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
import {useMemo} from 'react';
function Component({arg}) {
  const data = useMemo(() => {
    const x = [];
    x.push(arg?.items);
    return x;
  }, [arg?.items]);
  return <ValidateMemoization inputs={[arg?.items]} output={data} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arg: {items: 2}}],
  sequentialRenders: [
    {arg: {items: 2}},
    {arg: {items: 2}},
    {arg: null},
    {arg: null},
  ],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import { ValidateMemoization } from "shared-runtime";
import { useMemo } from "react";
function Component(t0) {
  const $ = _c(7);
  const { arg } = t0;

  arg?.items;
  let t1;
  let x;
  if ($[0] !== arg?.items) {
    x = [];
    x.push(arg?.items);
    $[0] = arg?.items;
    $[1] = x;
  } else {
    x = $[1];
  }
  t1 = x;
  const data = t1;
  const t2 = arg?.items;
  let t3;
  if ($[2] !== t2) {
    t3 = [t2];
    $[2] = t2;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== data || $[5] !== t3) {
    t4 = <ValidateMemoization inputs={t3} output={data} />;
    $[4] = data;
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arg: { items: 2 } }],
  sequentialRenders: [
    { arg: { items: 2 } },
    { arg: { items: 2 } },
    { arg: null },
    { arg: null },
  ],
};
```

----------------------------------------

TITLE: Defining a Simple React Functional Component in JavaScript
DESCRIPTION: This snippet declares a function `foo` that returns an array based on the input parameters. It conditionally adds elements to the array based on whether parameter `a` is truthy. If so, it adds a React `div` containing parameter `b`; otherwise, it adds parameter `c`. The `FIXTURE_ENTRYPOINT` object exports the function `foo`, alongside additional metadata.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes-if.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function foo(a, b, c) {
  const x = [];
  if (a) {
    const y = [];
    y.push(b);
    x.push(<div>{y}</div>);
  } else {
    x.push(c);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Validating Ref Access in React Component
DESCRIPTION: Demonstrates incorrect usage of ref.current during component rendering, which violates React's rendering rules and can cause unexpected behavior
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ref-in-callback-invoked-during-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function Component(props) {
  const ref = useRef(null);
  const renderItem = item => {
    const current = ref.current;
    return <Foo item={item} current={current} />;
  };
  return <Items>{props.items.map(item => renderItem(item))}</Items>;
}
```

----------------------------------------

TITLE: Demonstrating difference between value property and attribute in JavaScript
DESCRIPTION: Illustrates how the value property manipulates the working value for an input, while the attribute remains unchanged. This shows the separation between the visible/functional value and the attribute value.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/dom/src/components/fixtures/text-inputs/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
var input = document.createElement('input')
input.defaultValue = 'hello'
input.value = 'goodbye'

console.log(input.getAttribute('value')) // => "hello"
console.log(input.value) // => "goodbye"
```

----------------------------------------

TITLE: Defining Custom Hook and Component in React - JavaScript
DESCRIPTION: This snippet defines a custom hook using the useRef hook from React to create a reference with a click method, and a functional component Foo that utilizes this custom hook. The component defines an onClick handler using useCallback to invoke the click method of the ref when a button is clicked. No external dependencies other than React are needed, and it assumes the component is rendered using React in a browser environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-useCallback-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableTreatRefLikeIdentifiersAsRefs @validatePreserveExistingMemoizationGuarantees\nimport {useRef, useCallback} from 'react';\n\nfunction useCustomRef() {\n  return useRef({click: () => {}});\n}\n\nfunction Foo() {\n  const ref = useCustomRef();\n\n  const onClick = useCallback(() => {\n    ref.current?.click();\n  }, []);\n\n  return <button onClick={onClick} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: true,\n};
```

----------------------------------------

TITLE: React Component with Conditional Rendering (Input)
DESCRIPTION: This snippet defines a React component that initializes an array conditionally based on the `props.cond` value. If `props.cond` is truthy, an empty array is initialized; otherwise, it's set to `null`.  The component then attempts to push `props.a` into the `items` array (if it's not null) and returns the `items` value.  The `FIXTURE_ENTRYPOINT` exports the component and sample parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/iife-return-modified-later-phi.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const items = (() => {
    if (props.cond) {
      return [];
    } else {
      return null;
    }
  })();
  items?.push(props.a);
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: {}}],
};

```

----------------------------------------

TITLE: React Memo Input Component Definition
DESCRIPTION: Defines React components using memo with different rendered content, showcasing basic component memoization setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/reassigned-fnexpr-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import * as React from 'react';

/**
 * Test that the correct `Foo` is printed
 */
let Foo = () => <div>hello world 1!</div>;
const MemoOne = React.memo(Foo);
Foo = () => <div>hello world 2!</div>;
const MemoTwo = React.memo(Foo);

export const FIXTURE_ENTRYPOINT = {
  fn: () => {
    'use no memo';
    return (
      <>
        <MemoOne />
        <MemoTwo />
      </>
    );
  },
  params: [],
};
```

----------------------------------------

TITLE: Installing Dependencies for React DevTools
DESCRIPTION: Command to install all necessary dependencies for React DevTools development from the root of the repository.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
yarn install
```

----------------------------------------

TITLE: React Component Source Implementation
DESCRIPTION: Source implementation of a React component demonstrating memoization patterns with module-level state variables. Uses useState and useMemo hooks with a module-level counter to test memoization behavior during fast refresh.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-refresh-on-const-changes-dev.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer) @enableResetCacheOnSourceFileChanges
import {useEffect, useMemo, useState} from 'react';
import {ValidateMemoization} from 'shared-runtime';

let pretendConst = 0;

function unsafeResetConst() {
  pretendConst = 0;
}

function unsafeUpdateConst() {
  pretendConst += 1;
}

function Component() {
  useState(() => {
    // unsafe: reset the constant when first rendering the instance
    unsafeResetConst();
  });
  // UNSAFE! changing a module variable that is read by a component is normally
  // unsafe, but in this case we're simulating a fast refresh between each render
  unsafeUpdateConst();

  // TODO: In fast refresh mode (@enableResetCacheOnSourceFileChanges) Forget should
  // reset on changes to globals that impact the component/hook, effectively memoizing
  // as if value was reactive. However, we don't want to actually treat globals as
  // reactive (though that would be trivial) since it could change compilation too much
  // btw dev and prod. Instead, we should reset the cache via a secondary mechanism.
  const value = useMemo(() => [{pretendConst}], [pretendConst]);

  return <ValidateMemoization inputs={[pretendConst]} output={value} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Implementing useFoo Custom Hook in React
DESCRIPTION: This snippet defines a custom hook useFoo that creates and manipulates Set objects based on input props. It also includes a test fixture for sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-copy-constructor-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray, mutate} from 'shared-runtime';

function useFoo({propArr}: {propArr: Array<number>}) {
  const s1 = new Set<number | Array<number>>([1, 2, 3]);
  s1.add(makeArray(propArr[0]));

  const s2 = new Set(s1);
  // this may also may mutate s1
  mutate(s2);

  return [s1, s2];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{propArr: [7, 8, 9]}],
  sequentialRenders: [
    {propArr: [7, 8, 9]},
    {propArr: [7, 8, 9]},
    {propArr: [7, 8, 10]},
  ],
};
```

----------------------------------------

TITLE: React Hook inside Loop (Valid)
DESCRIPTION: This JavaScript snippet shows a valid example of using `React.useLayoutEffect` inside a `for` loop. The loop's condition ensures that the number of hook calls remains consistent across renders, avoiding issues with hook ordering. The additionalCond variable allows for conditional loop execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-93dc5d5e538a.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because the loop doesn't change the order of hooks calls.
function RegressionTest() {
  const res = [];
  const additionalCond = true;
  for (let i = 0; i !== 10 && additionalCond; ++i) {
    res.push(i);
  }
  React.useLayoutEffect(() => {});
}

```

----------------------------------------

TITLE: Defining Component with useMemo in React - JavaScript
DESCRIPTION: This snippet defines a functional React component 'Component' that uses the 'useMemo' hook to memoize a value based on the 'props.cond' condition. It checks the condition and returns the memoized value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-nested-ifs.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = useMemo(() => {
    if (props.cond) {
      if (props.cond) {
      }
    }
  }, [props.cond]);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Using useRef Hook in React
DESCRIPTION: This snippet demonstrates the implementation of a custom hook that attempts to set a ref value during the render phase in React. It highlights the error produced when accessing the `current` property of a ref. The main dependency for this code is React itself, specifically the useRef hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-write-but-dont-read-ref-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function useHook({value}) {
  const ref = useRef(null);
  // Writing to a ref in render is against the rules:
  ref.current = value;
  // returning a ref is allowed, so this alone doesn't trigger an error:
  return ref;
}
```

----------------------------------------

TITLE: React Component Calling a Function (JavaScript)
DESCRIPTION: This code defines a React component, `ComponentWithNormalFunction`, which calls a normal JavaScript function `doSomething()`. This demonstrates a standard way to integrate regular JavaScript functions within a React component's logic. It highlights that React components can directly call functions defined in the same scope or imported from other modules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-7e52f5eec669.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because components can call functions.
function ComponentWithNormalFunction() {
  doSomething();
}

```

----------------------------------------

TITLE: React Component with useCallback and useRef
DESCRIPTION: This code defines a React component `Foo` that utilizes `useCallback` and `useRef` hooks to create a memoized `onClick` handler that interacts with a ref.  The `useCustomRef` hook is used to create a ref object.  The error indicates that React Compiler couldn't preserve the memoization guarantees due to dependency mismatch.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-like-name-not-Ref.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';

function useCustomRef() {
  return useRef({click: () => {}});
}

function Foo() {
  const Ref = useCustomRef();

  const onClick = useCallback(() => {
    Ref.current?.click();
  }, []);

  return <button onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
  isComponent: true,
};

```

----------------------------------------

TITLE: Demonstrating value detachment behavior in JavaScript
DESCRIPTION: Shows how defaultValue updates also affect the value property until value is directly manipulated. After value is set directly, changes to defaultValue no longer affect the value property.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/dom/src/components/fixtures/text-inputs/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
var input = document.createElement('input')
// This will turn into 3
input.defaultValue = 3
// This will turn into 5
input.defaultValue = 5
// This will turn into 7
input.value = 7
// This will do nothing
input.defaultValue = 1
```

----------------------------------------

TITLE: Initializing React Component with useEffect Hook in JavaScript
DESCRIPTION: The snippet demonstrates a React component that uses the useEffect hook to invoke a function after rendering. The component also relies on a custom hook, referenced by useDynamicHook, to possibly alter its behavior. It imports necessary functions from 'react'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/repro-dont-add-hook-guards-on-retry.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableEmitHookGuards @panicThreshold(none) @enableFire\nimport {useEffect, fire} from 'react';\n\nfunction Component(props, useDynamicHook) {\n  'use memo';\n  useDynamicHook();\n  const foo = props => {\n    console.log(props);\n  };\n  useEffect(() => {\n    fire(foo(props));\n  });\n\n  return <div>hello world</div>;\n}\n
```

----------------------------------------

TITLE: Implementing React Component with Memoized Data Processing
DESCRIPTION: This snippet defines a React component that processes input data using useMemo for optimization. It maps over nested array data and uses a ValidateMemoization component to verify inputs and outputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR
import {identity, ValidateMemoization} from 'shared-runtime';
import {useMemo} from 'react';

function Component({arg}) {
  const data = useMemo(() => {
    return arg?.items.edges?.nodes.map(identity);
  }, [arg?.items.edges?.nodes]);
  return (
    <ValidateMemoization inputs={[arg?.items.edges?.nodes]} output={data} />
  );
}
```

----------------------------------------

TITLE: Implementing Conditional Rendering in React Component
DESCRIPTION: This snippet defines a React component that conditionally renders based on props. It uses the useState hook and handles an array of items. The component showcases different rendering scenarios based on the 'cond' prop and the 'items' array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-mutable-range-extending-into-ternary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { useState } from "react";

function Component(props) {
  const items = props.items ? props.items.slice() : [];
  const [state] = useState("");
  return props.cond ? <div>{state}</div> : <div>{items.map(_temp)}</div>;
}
function _temp(item) {
  return <div key={item.id}>{item.name}</div>;
}
```

----------------------------------------

TITLE: Initializing React Component with Problematic Variable Reassignment
DESCRIPTION: Demonstrates a React component with potential state management issues by directly reassigning variables instead of using React state hooks. The code triggers a lint warning about inconsistent behavior during renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutable-range-shared-inner-outer-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
let cond = true;
function Component(props) {
  let a;
  let b;
  const f = () => {
    if (cond) {
      a = {};
      b = [];
    } else {
      a = {};
      b = [];
    }
    a.property = true;
    b.push(false);
  };
  return <div onClick={f()} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Input Memoization Function with useMemo
DESCRIPTION: Initial implementation of useFoo function using React's useMemo hook to create a memoized array based on a callback function
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-invoke-prop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';

function useFoo({callback}) {
  return useMemo(() => new Array(callback()), [callback]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [
    {
      callback: () => {
        'use no forget';
        return [1, 2, 3];
      },
    },
  ],
};
```

----------------------------------------

TITLE: Original React Component with useMemo
DESCRIPTION: Source code showing a React component using useMemo hook without explicit dependency array. The component takes a propA parameter and returns it in an array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-with-no-depslist.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';

// Compiler can produce any memoization it finds valid if the
// source listed no memo deps
function Component({propA}) {
  // @ts-ignore
  return useMemo(() => {
    return [propA];
  });
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{propA: 2}],
};
```

----------------------------------------

TITLE: Implementing React Components with Different Memoization Strategies
DESCRIPTION: This snippet defines four React components (ComponentA, ComponentB, ComponentC, and ComponentD) that demonstrate different approaches to handling props and memoization. Each component has a unique behavior regarding how props.b influences the component's output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-early-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * props.b does *not* influence `a`
 */
function ComponentA(props) {
  const a_DEBUG = [];
  a_DEBUG.push(props.a);
  if (props.b) {
    return null;
  }
  a_DEBUG.push(props.d);
  return a_DEBUG;
}

/**
 * props.b *does* influence `a`
 */
function ComponentB(props) {
  const a = [];
  a.push(props.a);
  if (props.b) {
    a.push(props.c);
  }
  a.push(props.d);
  return a;
}

/**
 * props.b *does* influence `a`, but only in a way that is never observable
 */
function ComponentC(props) {
  const a = [];
  a.push(props.a);
  if (props.b) {
    a.push(props.c);
    return null;
  }
  a.push(props.d);
  return a;
}

/**
 * props.b *does* influence `a`
 */
function ComponentD(props) {
  const a = [];
  a.push(props.a);
  if (props.b) {
    a.push(props.c);
    return a;
  }
  a.push(props.d);
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: ComponentA,
  params: [{a: 1, b: false, d: 3}],
};
```

----------------------------------------

TITLE: Defining React Component with Custom Function in useEffect
DESCRIPTION: This snippet extends the previous example by moving the logic inside the useEffect to a separate function. The function _temp is invoked within useEffect to assign a value to a property of the object x. This organization allows for better separation of logic and could facilitate easier testing or modification of the effect's behavior. As before, it requires React to be present.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-method-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
let x = {};
function Component() {
  React.useEffect(_temp);
}
function _temp() {
  x.foo = 1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Implementing Optional Chaining in React Component - JavaScript
DESCRIPTION: The snippet demonstrates a React component function using optional chaining to safely access deeply nested properties of an object. 'a' is assumed to be an object accessible in the scope, and the component returns the first element of the nested array if it exists. This code requires JavaScript ES11 (ECMAScript 2020) support for optional chaining.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-computed-load-static.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = a?.b.c[0];
  return x;
}
```

----------------------------------------

TITLE: Defining React Component with State Manipulation in JavaScript
DESCRIPTION: This snippet defines a React component that creates an object, manipulates it, and returns it within a JSX structure. It demonstrates the importance of avoiding mutations on variables used in JSX and includes an error scenario where this rule is violated. Key parameters include 'props' passed to the component, with expected outputs being the object and potential error messages indicating invalid operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-delete-property-of-frozen-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeObject();
  // freeze
  <div>{x}</div>;
  delete x.y;
  return x;
}


```

----------------------------------------

TITLE: Original React Component with useRef in useEffect
DESCRIPTION: A React component that demonstrates how useRef values are used within useEffect hooks. The special comment @inferEffectDependencies indicates that the React compiler should automatically infer the dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-ref.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect, useRef} from 'react';
import {print} from 'shared-runtime';

/**
 * Special case of `infer-effect-deps/nonreactive-dep`.
 *
 * We know that local `useRef` return values are stable, regardless of
 * inferred memoization.
 */
function NonReactiveRefInEffect() {
  const ref = useRef('initial value');
  useEffect(() => print(ref.current));
}
```

----------------------------------------

TITLE: Implementing React Context and Memoization Test Components
DESCRIPTION: Defines React components that demonstrate context usage and memoization validation. Creates a context provider component and an inner component that uses the context value with memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-call-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {ValidateMemoization} from 'shared-runtime';
import {use, useMemo} from 'react';

const FooContext = React.createContext(null);
function Component(props) {
  return (
    <FooContext.Provider value={props.value}>
      <Inner />
    </FooContext.Provider>
  );
}

function Inner(props) {
  const input = use(FooContext);
  const output = useMemo(() => [input], [input]);
  return <ValidateMemoization inputs={[input]} output={output} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
  sequentialRenders: [
    {value: null},
    {value: 42},
    {value: 42},
    {value: null},
    {value: null},
    {value: 42},
    {value: null},
    {value: 42},
    {value: null},
  ],
};
```

----------------------------------------

TITLE: React Component with Mutation after JSX
DESCRIPTION: This React component attempts to modify an object `x` after it has been used within JSX. This violates React's principle of immutability for objects used in rendering, leading to an error. The `delete x[y]` statement attempts to remove a property from the object after `<div>{x}</div>` has already used it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-delete-computed-property-of-frozen-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeObject();
  // freeze
  <div>{x}</div>;
  delete x[y];
  return x;
}
```

----------------------------------------

TITLE: Defining React Hook useFoo (Input) - Javascript
DESCRIPTION: Defines the initial version of a React custom hook useFoo that calculates a derived value based on a prop and a ref's current value. It uses useSpecialEffect with derived as a dependency. This snippet illustrates the source code structure before potential transformation or analysis by a tool like the "@inferEffectDependencies" system.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/infer-deps-on-retry.expect.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import {useRef} from 'react';
import {useSpecialEffect} from 'shared-runtime';

/**
 * The retry pipeline disables memoization features, which means we need to
 * provide an alternate implementation of effect dependencies which does not
 * rely on memoization.
 */
function useFoo({cond}) {
  const ref = useRef();
  const derived = cond ? ref.current : makeObject();
  useSpecialEffect(() => {
    log(derived);
  }, [derived]);
  return ref;
}
```

----------------------------------------

TITLE: Implementing React Component with Pagination Fragment
DESCRIPTION: This code snippet defines a React component that uses a pagination fragment to manage data loading and rendering. It includes a function to load more data and an effect hook to trigger loading based on certain conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-freeze-function-expressions.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableTransitivelyFreezeFunctionExpressions
function Component(props) {
  const {data, loadNext, isLoadingNext} =
    usePaginationFragment(props.key).items ?? [];

  const loadMoreWithTiming = () => {
    if (data.length === 0) {
      return;
    }
    loadNext();
  };

  useEffect(() => {
    if (isLoadingNext) {
      return;
    }
    loadMoreWithTiming();
  }, [isLoadingNext, loadMoreWithTiming]);

  const items = data.map(x => x);

  return items;
}
```

----------------------------------------

TITLE: Initializing React Component with useCallback
DESCRIPTION: A React functional component demonstrating the use of useCallback hook with a potential optimization issue due to eslint rule disabling
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.sketchy-code-exhaustive-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const item = [];
  const foo = useCallback(
    () => {
      item.push(1);
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );

  return <Button foo={foo} />;
}
```

----------------------------------------

TITLE: Initial VideoTab React Component Implementation
DESCRIPTION: A basic React functional component that creates a ref and defines a function to modify the ref's current value, then renders a VideoList component
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-write-not-added-to-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function VideoTab() {
  const ref = useRef();
  let x = () => {
    ref.current = 1;
  };

  return <VideoList videos={x} />;
}
```

----------------------------------------

TITLE: Implementing Component Logging Functionality in React - JavaScript
DESCRIPTION: This snippet defines a React component that logs values of input properties 'a' and 'b' only once, using the 'useRef' hook to track whether logging has already occurred. It utilizes the shared-runtime's 'Stringify' component to handle rendering. The dependencies include React and shared-runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditional-call-chain.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef} from 'react';
import {Stringify} from 'shared-runtime';

function Component({a, b}) {
  const logA = () => {
    console.log(a.value);
  };
  const logB = () => {
    console.log(b.value);
  };
  const hasLogged = useRef(false);
  const log = () => {
    if (!hasLogged.current) {
      logA();
      logB();
      hasLogged.current = true;
    }
  };
  return <Stringify log={log} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: {value: 1}, b: {value: 2}}],
  sequentialRenders: [
    {a: {value: 1}, b: {value: 2}},
    {a: {value: 3}, b: {value: 4}},
  ],
};
```

----------------------------------------

TITLE: Using React Context API with JavaScript
DESCRIPTION: This snippet demonstrates a basic React component utilizing the Context API. The App function accesses context values using the useContext hook, and displays them by rendering the Bar component. There are no external dependencies other than React, and the snippet requires a predefined MyContext. The component expects the context to provide an array from which it destructures values for use. It returns a JSX element representing the rendered component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-array-destructuring.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @lowerContextAccess
function App() {
  const [foo, bar] = useContext(MyContext);
  return <Bar foo={foo} bar={bar} />;
}

```

----------------------------------------

TITLE: Defining React Component with State Updates
DESCRIPTION: This snippet shows the original implementation of a React component that updates state based on props. It uses array destructuring and a closure to modify the state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-array-assignment-to-context-var.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(props) {
  let x;
  [x] = props.value;
  const foo = () => {
    x = identity(props.value[0]);
  };
  foo();
  return {x};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: [42]}],
};
```

----------------------------------------

TITLE: Initializing Memoization Cache with React Compiler Runtime in JavaScript
DESCRIPTION: This code snippet demonstrates initializing and utilizing a memoization cache using React's compiler runtime. It checks if the cache is a specific sentinel value and proceeds to execute the same function while caching its result. This is useful in performance optimization when using React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/store-via-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = {};
    const y = foo(x);
    y.mutate();
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that takes a value prop, stores it in an array, and renders it within a span element inside a clickable div. Uses useEffect hook and includes click handling functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-memoize-array-with-immutable-map-after-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';

function Component(props) {
  const x = [props.value];
  useEffect(() => {}, []);
  const onClick = () => {
    console.log(x.length);
  };
  return (
    <div onClick={onClick}>
      {x.map(item => {
        return <span key={item}>{item}</span>;
      })}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
  isComponent: true,
};
```

----------------------------------------

TITLE: Demonstrating Invalid useRef Usage in React Component
DESCRIPTION: This JavaScript snippet demonstrates an incorrect pattern where the 'useRef' hook is used to update a ref during the render phase of a React component. This practice is discouraged as it can lead to unexpected behavior since ref updates should occur after render or in a callback. The example shows a function component attempting to update a ref value, which leads to an error due to accessing the ref's 'current' property during render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-disallow-mutating-refs-in-render-transitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function Component() {
  const ref = useRef(null);

  const setRef = () => {
    ref.current = false;
  };
  const changeRef = setRef;
  changeRef();

  return <button ref={ref} />;
}
```

----------------------------------------

TITLE: Using Memoization in Functional Component - JavaScript
DESCRIPTION: This snippet demonstrates the use of the 'useMemo' hook in a functional React component to cache computed data based on specific props, ensuring that the output is only recalculated when certain inputs change. It relies on the 'ValidateMemoization' component to manage inputs and outputs for validation purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-inverted-optionals-parallel-paths.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
  const data = useMemo(() => {
    const x = [];
    x.push(props?.a.b?.c.d?.e);
    x.push(props.a?.b.c?.d.e);
    return x;
  }, [props.a.b.c.d.e]);
  return <ValidateMemoization inputs={[props.a.b.c.d.e]} output={x} />;
}
```

----------------------------------------

TITLE: Demonstrating defaultValue and value attribute relationship in JavaScript
DESCRIPTION: Shows how defaultValue directly maps to the value attribute of an input element. When defaultValue is set, the attribute value reflects this change.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/dom/src/components/fixtures/text-inputs/README.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
var input = document.createElement('input')
input.defaultValue = 'hello'

console.log(input.getAttribute('value')) // => "hello"
```

----------------------------------------

TITLE: Advanced Transition Management in React JavaScript
DESCRIPTION: This JavaScript snippet uses React's compiler-runtime for memoization and uses the hooks useCallback and useTransition to manage state transitions. The function useFoo returns a memoized function, ensuring transitions are correctly handled by using internal caches to optimize repeated renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/preserve-use-memo-transition.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useCallback, useTransition } from "react";

function useFoo() {
  const $ = _c(1);
  const [, start] = useTransition();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      start();
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Implementing React Component with Fragment and Memoization (JavaScript)
DESCRIPTION: This snippet defines a React component that uses useFragment and useMemo hooks. It performs various array operations on the data retrieved from the fragment, including flatMap, filter, and map. The component also demonstrates the use of Flow type annotations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-memoization-lack-of-phi-types-explicit-types.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @validatePreserveExistingMemoizationGuarantees @enableUseTypeAnnotations
import {useMemo} from 'react';
import {useFragment} from 'shared-runtime';

// This is a version of error.todo-repro-missing-memoization-lack-of-phi-types
// with explicit type annotations and using enableUseTypeAnnotations to demonstrate
// that type information is sufficient to preserve memoization in this example
function Component() {
  const data = useFragment();
  const nodes: Array<any> = data.nodes ?? [];
  const flatMap: Array<any> = nodes.flatMap(node => node.items);
  const filtered: Array<any> = flatMap.filter(item => item != null);
  const map: Array<any> = useMemo(() => filtered.map(), [filtered]);
  const index: Array<any> = filtered.findIndex(x => x === null);

  return (
    <div>
      {map}
      {index}
    </div>
  );
}
```

----------------------------------------

TITLE: React useLayoutEffect with Unmemoized Dependency in JavaScript
DESCRIPTION: This code defines a React component `Component` that uses the `useLayoutEffect` hook. The effect's dependency array includes a new object `{}` assigned to `data` within the component. This causes the effect to re-run on every render, as the object identity changes, which the React compiler flags as an unoptimized effect.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useLayoutEffect-dep-not-memoized.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateMemoizedEffectDependencies
import {useLayoutEffect} from 'react';

function Component(props) {
  const data = {};
  useLayoutEffect(() => {
    console.log(props.value);
  }, [data]);
  mutate(data);
  return data;
}

```

----------------------------------------

TITLE: Creating a useRef-based Custom Hook in React
DESCRIPTION: This snippet defines a custom React hook named `useArrayOfRef` that utilizes the `useRef` hook to create a mutable reference. A callback function is defined to update the `current` property of the ref, which is then returned as part of an array. The purpose of this hook is to provide a way to access and modify a value without causing re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-type-cast-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef} from 'react';

function useArrayOfRef() {
  const ref = useRef(null);
  const callback = value => {
    ref.current = value;
  };
  return [callback] as const;
}

export const FIXTURE_ENTRYPOINT = {
  fn: () => {
    useArrayOfRef();
    return 'ok';
  },
  params: [{}] 
};

```

----------------------------------------

TITLE: Displaying Console Warning with Component Stack in React
DESCRIPTION: This code snippet demonstrates how React DevTools can automatically append component stack information to console warnings, providing more context for debugging.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
console.warn('Example console warning with component stack added')
```

----------------------------------------

TITLE: Original React Function with Boolean Logic and Conditional Rendering
DESCRIPTION: A React function that creates a component with various boolean expressions to be rendered through the Stringify component. The function includes conditionals and boolean operations on different data types.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-unary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function foo() {
  let _b;
  const b = true;
  if (!b) {
    _b = 'bar';
  } else {
    _b = 'baz';
  }

  return (
    <Stringify
      value={{
        _b,
        b0: !true,
        n0: !0,
        n1: !1,
        n2: !2,
        n3: !-1,
        s0: !'',
        s1: !'a',
        s2: !'ab',
        u: !undefined,
        n: !null,
      }}
    />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Defines a React component that conditionally renders div elements with dynamic class names based on props and constants. Uses identity function for class name composition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-separate-scopes-for-divs.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

const DISPLAY = true;
function Component({cond = false, id}) {
  return (
    <>
      <div className={identity(styles.a, id !== null ? styles.b : {})}></div>

      {cond === false && (
        <div className={identity(styles.c, DISPLAY ? styles.d : {})} />
      )}
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: false, id: 42}],
  sequentialRenders: [
    {cond: false, id: 4},
    {cond: true, id: 4},
    {cond: true, id: 42},
  ],
};

const styles = {
  a: 'a',
  b: 'b',
  c: 'c',
  d: 'd',
};
```

----------------------------------------

TITLE: Original React Component with useMemo Hook
DESCRIPTION: This snippet shows a React component that imports Stringify from shared-runtime and wraps it in a useMemo hook. The component renders Stringify with the passed props. An export FIXTURE_ENTRYPOINT is defined for testing with a sample parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-as-jsx-element-tag.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {Stringify} from 'shared-runtime';

function Component(props) {
  let Component = Stringify;

  Component = useMemo(() => {
    return Component;
  });

  return <Component {...props} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Sathya'}],
};
```

----------------------------------------

TITLE: React Component Definition with Conditional Logic
DESCRIPTION: This code defines a functional React component that receives `props` as input. It declares a variable `x`, then uses a ternary operator to assign a value to `x` based on the value of `props.cond`. If `props.cond` is truthy, `x` is assigned 1, otherwise it's assigned 2. The component returns the value of `x`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-logical.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  props.cond ? (x = 1) : (x = 2);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: React Component Rendering
DESCRIPTION: This React component takes `props` as input, specifically expecting an `items` property that is potentially nullable. It maps over the `items` array using a `render` function, filters out falsy values, and returns the resulting array. If `props` or `items` are null/undefined, it returns an empty array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-with-optional-property-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return props?.items?.map?.(render)?.filter(Boolean) ?? [];
}
```

----------------------------------------

TITLE: Defining Basic React Component in JavaScript
DESCRIPTION: Defines a simple React component called Component that returns an empty div element. The snippet highlights the basic use of JSX to create a component structure. No dependencies are required other than React itself. Inputs include the component properties through props, and the output is a rendered JSX element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function Component(props) {
  return <div />;
}

```

----------------------------------------

TITLE: React useCallback Hook with Incorrect Dependencies
DESCRIPTION: This React component uses the useCallback hook to memoize a function that depends on a property of the propA object. The dependency array includes propA.x, but the React Compiler detects a mismatch between the inferred and specified dependencies, causing an error. This typically occurs when propA.x is not a stable reference or changes unexpectedly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-property-call-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';

function Component({propA}) {
  return useCallback(() => {
    return propA.x();
  }, [propA.x]);
}

```

----------------------------------------

TITLE: Creating a Custom Ref Hook with React
DESCRIPTION: This snippet defines a custom hook 'useCustomRef' that creates and returns a ref using the useRef hook in React. The hook is useful for encapsulating ref usage within functional components, providing simpler access to DOM elements or components without needing to deal with React's ref forwarding.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/helper-nonreactive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect, useRef} from 'react';
function useCustomRef() {
  const ref = useRef();
  return ref;
}
function NonReactiveWrapper() {
  const ref = useCustomRef();
  useEffect(() => {
    print(ref);
  });
}
```

----------------------------------------

TITLE: Implementing Flight Prerendering Function
DESCRIPTION: Implementation of a prerender function for Flight in React Server Components. Unlike regular rendering, prerendering handles errors differently and returns a Promise that resolves to an object containing a prelude stream once all content is ready.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_6

LANGUAGE: javascript
CODE:
```
function prerender(
  model: ReactClientValue,
  clientManifest: ClientManifest,
  options?: Options,
): Promise<StaticResult> {
  return new Promise((resolve, reject) => {
    const onFatalError = reject;
    function onAllReady() {
      const stream = new ReadableStream(
        {
          type: 'bytes',
          start: (controller): ?Promise<void> => {
            startWork(request);
          },
          pull: (controller): ?Promise<void> => {
            startFlowing(request, controller);
          },
          cancel: (reason): ?Promise<void> => {
            stopFlowing(request);
            abort(request, reason);
          },
        },
        // $FlowFixMe[prop-missing] size() methods are not allowed on byte streams.
        {highWaterMark: 0},
      );
      resolve({prelude: stream});
    }
    const request = createPrerenderRequest(
      model,
      clientManifest,
      onAllReady,
      onFatalError,
      options ? options.onError : undefined,
      options ? options.identifierPrefix : undefined,
      options ? options.onPostpone : undefined,
      options ? options.temporaryReferences : undefined,
      __DEV__ && options ? options.environmentName : undefined,
      __DEV__ && options ? options.filterStackFrame : undefined,
    );
    startWork(request);
  });
}
```

----------------------------------------

TITLE: Using useEffect without explicit dependencies in React JavaScript
DESCRIPTION: This React component uses `useEffect` to call a `print` function, accessing `arr[0].value`. The effect dependency array is omitted, leading to potential issues as the `arr` array is modified later in the render. It illustrates a scenario where dependency inference is ambiguous or requires careful consideration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/mutate-after-useeffect-granular-access.expect.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import {useEffect} from 'react';
import {print} from 'shared-runtime';

function Component({foo}) {
  const arr = [];
  // Taking either arr[0].value or arr as a dependency is reasonable
  // as long as developers know what to expect.
  useEffect(() => print(arr[0].value));
  arr.push({value: foo});
  return arr;
}
```

----------------------------------------

TITLE: Initializing React Hook with Invalid Variable Reassignment
DESCRIPTION: Demonstrates an incorrect hook implementation that attempts to destructure and reassign props, which violates React's component purity rules. The code triggers an error recommending the use of useState for managing component state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-destructure-assignment-to-global.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo(props) {
  [x] = props;
  return {x};
}
```

----------------------------------------

TITLE: Conditional Component Logic using useMemo in React JavaScript
DESCRIPTION: This snippet demonstrates a React component function where `useMemo` is used to conditionally return one of the props based on a provided condition. The component favors `props.a` unless `props.cond` is true, in which case it will return `props.b`. Dependencies include React and `useMemo` hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-inverted-if.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Component(props) {
  const x = useMemo(() => {
    label: {
      if (props.cond) {
        break label;
      }
      return props.a;
    }
    return props.b;
  });
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Implementing Custom React Hook with Nested Function
DESCRIPTION: Demonstrates implementation of a custom React hook 'useFoo' that modifies props, contains a nested function 'bar', and uses 'useNoAlias'. Includes test fixture setup for entry point testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-retain-source-when-bailout.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @panicThreshold(none)
import {useNoAlias} from 'shared-runtime';

const cond = true;
function useFoo(props) {
  props.x = 10;
  if (cond) bar();
  return useNoAlias({});

  function bar() {
    console.log('bar called');
    return 5;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}],
};
```

LANGUAGE: javascript
CODE:
```
// @panicThreshold(none)
import { useNoAlias } from "shared-runtime";

const cond = true;
function useFoo(props) {
  props.x = 10;
  if (cond) bar();
  return useNoAlias({});

  function bar() {
    console.log("bar called");
    return 5;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Hook Implementation
DESCRIPTION: Implements a custom React hook that creates a Set from two array elements using makeArray utility. Takes two parameters el1 and el2, converts them to arrays, and returns the size of the resulting Set.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-constructor.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

function useHook({el1, el2}) {
  const s = new Set();
  s.add(makeArray(el1));
  s.add(makeArray(el2));
  return s.size;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{el1: 1, el2: 'foo'}],
  sequentialRenders: [
    {el1: 1, el2: 'foo'},
    {el1: 2, el2: 'foo'},
  ],
};
```

----------------------------------------

TITLE: Using Created Objects in a React Component - JavaScript
DESCRIPTION: Defines the 'MyApp' function component that uses 'makeObj' to get an object with a specific structure. It retrieves the property 'b' from the created object and manipulates the array. This demonstrates usage of functions within React components and handles potential memoization logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue933-disjoint-set-infinite-loop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// This caused an infinite loop in the compiler
function MyApp(props) {
  const y = makeObj();
  const tmp = y.a;
  const tmp2 = tmp.b;
  y.push(tmp2);
  return y;
}
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function makeObj() {
  "use no forget";
  const result = [];
  result.a = { b: 2 };

  return result;
}

// This caused an infinite loop in the compiler
function MyApp(props) {
  const $ = _c(1);
  let y;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    y = makeObj();
    const tmp = y.a;
    const tmp2 = tmp.b;
    y.push(tmp2);
    $[0] = y;
  } else {
    y = $[0];
  }
  return y;
}
```

----------------------------------------

TITLE: Invalid Hook Assignment in React Component
DESCRIPTION: Example of incorrect hook usage where a hook (useFoo) is assigned to a variable instead of being called directly. This violates React's rules of hooks which require hooks to be called at the top level of components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-reassigned-in-conditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let y;
  props.cond ? (y = useFoo) : null;
  return y();
}
```

LANGUAGE: plaintext
CODE:
```
  1 | function Component(props) {
  2 |   let y;
> 3 |   props.cond ? (y = useFoo) : null;
    |                     ^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)

InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)

InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (4:4)
  4 |   return y();
  5 | }
  6 |

```

----------------------------------------

TITLE: React Component with Dynamic State and Logging
DESCRIPTION: A React functional component that manages state, logs events, and renders different components based on current step. Uses useState and custom logging hook to control component behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/validate-no-set-state-in-render-uncalled-function-with-mutable-range-is-valid.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const logEvent = useLogging(props.appId);
  const [currentStep, setCurrentStep] = useState(0);

  const onSubmit = errorEvent => {
    logEvent(errorEvent);
    setCurrentStep(1);
  };

  switch (currentStep) {
    case 0:
      return <OtherComponent data={{foo: 'bar'}} />;
    case 1:
      return <OtherComponent data={{foo: 'joe'}} onSubmit={onSubmit} />;
    default:
      logEvent('Invalid step');
      return <OtherComponent data={null} />;
  }
}
```

----------------------------------------

TITLE: Defining a Memoized Component in React
DESCRIPTION: This snippet illustrates the creation of a memoized functional component in React that uses the useMemo hook to efficiently manage object states based on props. It imports required functions from 'shared-runtime' to handle object creation and mutations. The object returned from the component is memoized based on the input value, optimizing rendering performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-mabye-modified-free-variable-dont-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees:false
import {useMemo} from 'react';
import {identity, makeObject_Primitives, mutate, useHook} from 'shared-runtime';

function Component(props) {
  // With the feature disabled these variables are inferred as being mutated inside the useMemo block
  const free = makeObject_Primitives();
  const free2 = makeObject_Primitives();
  const part = free2.part;

  // This causes their range to extend to include this hook call, and in turn for the memoization to be pruned
  useHook();
  const object = useMemo(() => {
    const x = makeObject_Primitives();
    x.value = props.value;
    mutate(x, free, part);
    return x;
  }, [props.value]);

  identity(free);
  identity(part);
  return object;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees:false
import { useMemo } from "react";
import {
  identity,
  makeObject_Primitives,
  mutate,
  useHook,
} from "shared-runtime";

function Component(props) {
  const free = makeObject_Primitives();
  const free2 = makeObject_Primitives();
  const part = free2.part;

  useHook();
  let t0;

  const x = makeObject_Primitives();
  x.value = props.value;
  mutate(x, free, part);
  t0 = x;
  const object = t0;

  identity(free);
  identity(part);
  return object;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Input React Component with useCallback
DESCRIPTION: Original React component implementation using useCallback and useRef hooks to handle input changes. The component demonstrates memoization behavior with the @enablePreserveExistingMemoizationGuarantees flag.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-value-dont-preserve-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';

function Component(props) {
  const ref = useRef(null);

  const onChange = useCallback(event => {
    // The ref should still be mutable here even though function deps are frozen in
    // @enablePreserveExistingMemoizationGuarantees mode
    ref.current = event.target.value;
  });

  return <input onChange={onChange} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component with Array Destructuring
DESCRIPTION: A React component implementing array destructuring with default values from props. Shows pattern matching syntax with nested array destructuring.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-array-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [[x] = ['default']] = props.y;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Managing Component Props - JavaScript
DESCRIPTION: This code snippet is a JavaScript function named 'Component' that processes properties ('props') to generate and return an array of values based on conditional checks. The snippet shows how to use fallback values and conditionally alter state based on the presence of specific props. It is structured for intelligible state transitions, ideal for components in a React-like framework.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-cascading-eliminated-phis.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Component(props) {
  let x = 0;
  const values = [];
  const y = props.a || props.b;
  values.push(y);
  if (props.c) {
    x = 1;
  }
  values.push(x);
  if (props.d) {
    x = 2;
  }
  values.push(x);
  return values;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 0, b: 1, c: true, d: true}],
  sequentialRenders: [
    {a: 0, b: 1, c: true, d: true},
    {a: 4, b: 1, c: true, d: true},
    {a: 4, b: 1, c: false, d: true},
    {a: 4, b: 1, c: false, d: false},
  ],
};
```

----------------------------------------

TITLE: Using Custom Hooks to Fire Functions in a React Component
DESCRIPTION: This code snippet demonstrates another implementation of a React component using custom hooks (useFire) to abstract firing functions. It also employs useEffect for handling side effects and useRef for maintaining a reference to a button element. Essential dependencies include React and the custom useFire hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-eslint-suppressions.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useFire } from "react/compiler-runtime"; // @enableFire @panicThreshold(none)
import { useRef } from "react";

function Component(t0) {
  const { props, bar } = t0;
  const foo = () => {
    console.log(props);
  };
  const t1 = useFire(foo);
  const t2 = useFire(bar);

  useEffect(() => {
    t1(props);
    t1();
    t2();
  });

  const ref = useRef(null);

  ref.current = "bad";
  return <button ref={ref} />;
}

```

----------------------------------------

TITLE: Implementing a React Hook with Conditionals
DESCRIPTION: The snippet imports constants and a component from a shared runtime. It defines a React hook that uses these constants to dynamically compute a value. If the 'cond' parameter is true, a constant is added to an initial value, which is then limited to a maximum of 100. It returns a JSX element of type 'Stringify' with a function and a boolean flag as props. Dependencies include 'shared-runtime', and the function expects an object with a 'cond' property. It returns a JSX component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-reassigned-twice-let-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_NUMBER0, CONST_NUMBER1, Stringify} from 'shared-runtime';

function useHook({cond}) {
  'use memo';
  const getX = () => x;

  let x = CONST_NUMBER0;
  if (cond) {
    x += CONST_NUMBER1;
    x = Math.min(x, 100);
  }
  return <Stringify getX={getX} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{cond: true}],
  sequentialRenders: [{cond: true}, {cond: true}, {cond: false}],
};

```

----------------------------------------

TITLE: Incorrect useMemo Hook Usage in React Component
DESCRIPTION: A React component function that tries to use the useMemo hook with a logical OR fallback pattern. This pattern is not supported by React's compiler, as hooks must be called unconditionally at the top level.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-useMemo-with-optional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return (
    useMemo(() => {
      return [props.value];
    }) || []
  );
}

```

----------------------------------------

TITLE: Using FBT for Internationalized React Component
DESCRIPTION: This snippet shows how to create a React component that uses FBT to display an internationalized message with a parameter. The component renders a greeting message that includes the user's name after capitalizing it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-params-complex-param-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component(props) {
  return (
    <fbt desc={'Dialog to show to user'}>
      Hello <fbt:param name="user name">{capitalize(props.name)}</fbt:param>
    </fbt>
  );
}
```

----------------------------------------

TITLE: Demonstrating Optional Chaining with React Hooks in JavaScript
DESCRIPTION: This function, 'useFoo', processes an input object with a 'screen' property. It returns a specific string based on whether 'screen.title_text' is non-null, utilizing optional chaining. Key dependencies include the 'identity' function from 'shared-runtime'. Inputs include a 'screen' object that may be null or contain a 'title_text' property. The expected behavior is to return '(not null)' for non-null 'title_text', otherwise it returns an identity function result. The function may throw if 'screen' is null.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/merge-uncond-optional-chain-and-cond.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

/**
 * Very contrived text fixture showing that it's technically incorrect to merge
 * a conditional dependency (e.g. dep.path in `cond ? dep.path : ...`) and an
 * unconditionally evaluated optional chain (`dep?.path`).
 *
 *
 * when screen is non-null, useFoo returns { title: null } or "(not null)"
 * when screen is null, useFoo throws
 */
function useFoo({screen}: {screen: null | undefined | {title_text: null}}) {
  return screen?.title_text != null
    ? '(not null)'
    : identity({title: screen.title_text});
}
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{screen: null}],
  sequentialRenders: [{screen: {title_bar: undefined}}, {screen: null}],
};
```

----------------------------------------

TITLE: Implementing Custom Hook to Manage State Immutability in React
DESCRIPTION: This snippet defines a React functional component named `Foo` which utilizes a custom hook called `useIdentity`. The purpose of this snippet is to manage the internal state of the component while adhering to React's immutability principles. A `count` parameter is accepted, and the snippet highlights the risk of mutating an object that React treats as immutable, evidenced by an error message on line 13, which indicates the mutation of `x.value` is not permitted.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-call-freezes-captured-memberexpr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableTransitivelyFreezeFunctionExpressions
import {mutate, Stringify, useIdentity} from 'shared-runtime';

function Foo({count}) {
  const x = {value: 0};
  /**
   * After this custom hook call, it's no longer valid to mutate x.
   */
  const cb = useIdentity(() => {
    x.value++;
  });

  x.value += count;
  return <Stringify x={x} cb={cb} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{count: 1}],
};
```

----------------------------------------

TITLE: React Rendering Error Message
DESCRIPTION: This snippet captures the rendering error that arises when attempting to access the `current` property of a ref inappropriately. The error message indicates the exact location in the code where the violation occurs, referencing the React documentation for further clarification.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-ref-to-function.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  2 | function Component(props) {
  3 |   const ref = useRef(null);
> 4 |   const x = foo(ref);
    |                 ^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (4:4)
  5 |   return x.current;
  6 | }
  7 |
```

----------------------------------------

TITLE: Original React Function with Conditional Rendering
DESCRIPTION: A JavaScript function that conditionally creates an array and renders a div based on input parameters. Demonstrates basic React component logic with conditional rendering and array manipulation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function f(a, b) {
  let x = []; // <- x starts being mutable here.
  if (a.length === 1) {
    if (b) {
      x.push(b); // <- x stops being mutable here.
    }
  }

  return <div>{x}</div>;
}
```

----------------------------------------

TITLE: Implementing a Custom React Hook with Array Manipulation
DESCRIPTION: A React custom hook that creates and manipulates an array based on input props. The hook takes props with 'bar', 'cond', and 'foo' properties, using conditional logic to push values into the array and return it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-destruction.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond ? (({x} = {x: {}}), ([x] = [[]]), x.push(props.foo)) : null;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};
```

----------------------------------------

TITLE: Using useRef Hook in React Component
DESCRIPTION: This code snippet defines a React functional component, `C`, which uses the `useRef` hook to create a mutable ref object. The component checks if the ref's current value is null and calls function `f` if it is. This snippet exemplifies component reference management in React and is intended to be used within a React application. It is crucial to note that accessing `r.current` during rendering can lead to an error, as indicated in the error section following the code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow
import {useRef} from 'react';

component C() {
  const r = useRef(null);
  if (r.current == null) {
    f(r.current);
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{}],
};

```

----------------------------------------

TITLE: Using React's useEffect Hook in JavaScript
DESCRIPTION: This snippet demonstrates a React function component utilizing the useEffect hook with a dependency on an object created by the makeObject_Primitives function. It showcases the necessity of managing dependencies manually when the React compiler cannot infer them. Dependencies include React itself and functions like makeObject_Primitives and print. Limitations include the requirement to manually define dependencies to prevent build errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.todo-import-default-property-useEffect.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import React from 'react';

function NonReactiveDepInEffect() {
  const obj = makeObject_Primitives();
  React.useEffect(() => print(obj));
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Original React component that processes video items and generates thumbnails using useMemo hook. The component takes props with an item, processes base videos, and renders them in a FlatList component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const item = props.item;
  const thumbnails = [];
  const baseVideos = getBaseVideos(item);
  useMemo(() => {
    baseVideos.forEach(video => {
      const baseVideo = video.hasBaseVideo;
      if (Boolean(baseVideo)) {
        thumbnails.push({extraVideo: true});
      }
    });
  });
  return <FlatList baseVideos={baseVideos} items={thumbnails} />;
}
```

----------------------------------------

TITLE: Original React Component with Memo
DESCRIPTION: Source React component implementing memoization with 'use memo' directive, taking props and rendering a div element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-memo-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  'use memo';
  let x = [props.foo];
  return <div x={x}>"foo"</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{foo: 1}],
  isComponent: true,
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Original React component showing a simple implementation that processes a listItem and thread, using hooks and conditional rendering based on thread type.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-value-for-temporary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
function Component(listItem, thread) {
  const isFoo = isFooThread(thread.threadType);
  const body = useBar(listItem, [getBadgeText(listItem, isFoo)]);

  return body;
}
```

----------------------------------------

TITLE: Defining a Functional Component with useRef in React
DESCRIPTION: This snippet defines a React functional component `Foo` that uses the `useRef` hook to create a mutable ref object. It captures the `current` value of the ref and constructs an object that includes both the prop `a` and the ref's current value. The component then passes this object to the `VideoList` component as a prop named `videos`. This implementation helps ensure that the component re-renders correctly based on the ref's value, thereby optimizing rendering logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-aliased-not-added-to-dep-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender:false
function Foo({a}) {
  const ref = useRef();
  const val = ref.current;
  const x = {a, val};

  return <VideoList videos={x} />;
}

```

----------------------------------------

TITLE: Ternary Operator in React Component
DESCRIPTION: This JavaScript code defines a React component named `ternary` that takes `props` as input. Inside the component, a ternary operator is used to conditionally assign values to the variable `x` based on the value of `props.a`. The component then returns the sum of `x` and `y`. The `FIXTURE_ENTRYPOINT` object exports the component and its configuration for testing or usage elsewhere.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ternary-assignment-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function ternary(props) {
  let x;
  const y = props.a ? (x = 1) : (x = 2);
  return x + y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: ternary,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Using useMemo for Memoization in React
DESCRIPTION: This snippet defines a React functional component that uses the useMemo hook to compute a value based on the provided props. The component checks the prop's key and returns the corresponding value or a default value. It is intended to enhance performance by memoizing the result to avoid unnecessary calculations on re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-switch-no-fallthrough.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = useMemo(() => {
    switch (props.key) {
      case 'key': {
        return props.value;
      }
      default: {
        return props.defaultValue;
      }
    }
  });
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Managing Component State Interleaving in React - JavaScript
DESCRIPTION: This JavaScript snippet defines a React component where two independent states, 'a' and 'b', are interleaved, making 'a' reactive. The component ultimately returns a single value 'x', which becomes reactive as it depends on 'c', a control value derived from 'a'. This snippet does not require any additional dependencies outside of the React component system, and inputs/outputs are managed through the 'props' object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-if.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Component(props) {
  // a and b are independent but their mutations are interleaved, so
  // they get grouped in a reactive scope. this means that a becomes
  // reactive since it will effectively re-evaluate based on a reactive
  // input
  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(null);

  // Downstream consumer of a, which initially seems non-reactive except
  // that a becomes reactive, per above
  const c = [a];

  let x;
  if (c[0][0]) {
    x = 1;
  } else {
    x = 2;
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `c[0]` which becomes reactive via
  // being interleaved with `b`.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};
```

----------------------------------------

TITLE: Defining React Component with Destructuring in JavaScript
DESCRIPTION: This snippet defines a React component that uses array destructuring to extract values from props. It demonstrates a simple component structure with export for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-pattern-within-rest.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [y, ...{z}] = props.value;
  return [y, z];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: ['y', {z: 'z!'}]}],
};
```

----------------------------------------

TITLE: Validating React Component Memoization with useCallback in JavaScript
DESCRIPTION: This snippet defines a React component called Foo that uses the useCallback hook to handle context variable dependencies. It includes logic to manage context variables and ensure memoization. Dependencies include react and shared-runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-captures-reassigned-context-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useCallback} from 'react';
import {Stringify} from 'shared-runtime';

/**
 * TODO: we're currently bailing out because `contextVar` is a context variable
 * and not recorded into the PropagateScopeDeps LoadLocal / PropertyLoad
 * sidemap. Previously, we were able to avoid this as `BuildHIR` hoisted
 * `LoadContext` and `PropertyLoad` instructions into the outer function, which
 * we took as eligible dependencies.
 *
 * One solution is to simply record `LoadContext` identifiers into the
 * temporaries sidemap when the instruction occurs *after* the context
 * variable's mutable range.
 */
function Foo(props) {
  let contextVar;
  if (props.cond) {
    contextVar = {val: 2};
  } else {
    contextVar = {};
  }

  const cb = useCallback(() => [contextVar.val], [contextVar.val]);

  return <Stringify cb={cb} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{cond: true}],
};

```

----------------------------------------

TITLE: Defining Component with Optional Chaining in React JavaScript
DESCRIPTION: This snippet defines a React component in JavaScript that leverages optional chaining to safely access deeply nested properties in props. No external dependencies are required, and it returns an object with properties x and y that may be undefined if the optional chains do not resolve.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-chain.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Note that `a?.b.c` is semantically different from `(a?.b).c`
// We should codegen the correct member expressions
function Component(props) {
  let x = props?.b.c;
  let y = props?.b.c.d?.e.f.g?.h;
  return {x, y};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Memoizing object creation with useMemo in React
DESCRIPTION: This code snippet demonstrates how to use `useMemo` to memoize the creation of an object in a React component. The `makeObject_Primitives` function is called only once, and the result is stored in the `object` variable. The `identity` function is called with the object as an argument. The `FIXTURE_ENTRYPOINT` is an exported object that defines the component and its parameters for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-maybe-modified-later-dont-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees:false
import {useMemo} from 'react';
import {identity, makeObject_Primitives, mutate} from 'shared-runtime';

function Component(props) {
  const object = useMemo(() => makeObject_Primitives(), []);
  identity(object);
  return object;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: Creating a React Component with Props and Switch Statement
DESCRIPTION: Defines a React functional component that accepts props and uses a switch statement to conditionally set variables. The component returns a value that may be modified based on the switch condition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-switch-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const a = [props.a];
  let x = props.b;
  switch (a) {
    case true: {
      x = props.c;
    }
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React useState Hook Used Conditionally
DESCRIPTION: This React component attempts to use the `useState` hook conditionally based on the `props.cond` value. This is an anti-pattern in React, as hooks must be called in the same order on every render. The expected input is a React component with a `cond` prop, and the output is a potential render with an error due to the conditional hook usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-aliased-react-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState as state} from 'react';

function Component(props) {
  let s;
  if (props.cond) {
    [s] = state();
  }
  return s;
}

```

----------------------------------------

TITLE: React Component with RegExp Pattern Matching (Original)
DESCRIPTION: This snippet shows a React component that uses a regular expression to test a value and conditionally render content. It demonstrates the use of RegExp objects and conditional rendering in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/regexp-literal.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const pattern = /foo/g;
  const value = makeValue();
  // We treat RegExp instances as mutable objects (bc they are)
  // so by default we assume this could be mutating `value`:
  if (pattern.test(value)) {
    return <div>{value}</div>;
  }
  return <div>Default</div>;
}
```

----------------------------------------

TITLE: React Component with FBT Translation - Input Version
DESCRIPTION: Original source code showing a React component that uses FBT for text translation. The component accepts a name prop and renders a greeting message using FBT's parameter interpolation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-quotes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component(props) {
  const element = (
    <fbt desc={'Dialog to show to user'}>
      Hello <fbt:param name='"user" name'>{props.name}</fbt:param>
    </fbt>
  );
  return element.toString();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Jason'}],
};
```

----------------------------------------

TITLE: Unoptimized React Component Implementation
DESCRIPTION: A React component that creates an object with dynamic property assignment and function calls based on props. This represents the code before React's compiler optimizations are applied.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-computed.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const index = 'foo';
  const x = {};
  x[index] = x[index] + x['bar'];
  x[index](props.foo);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Implementing Set Operations with React Hook
DESCRIPTION: Original implementation of a React hook that creates and manipulates multiple Sets. Takes an array of numbers as props and performs various Set operations with memoization opportunities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-constructor-arg.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const MODULE_LOCAL = new Set([4, 5, 6]);
function useFoo({propArr}: {propArr: Array<number>}) {
  /* Array can be memoized separately of the Set */
  const s1 = new Set([1, 2, 3]);
  s1.add(propArr[0]);

  /* but `.values` cannot be memoized separately */
  const s2 = new Set(MODULE_LOCAL.values());
  s2.add(propArr[1]);

  const s3 = new Set(s2.values());
  s3.add(propArr[2]);

  /**
   * s4 should be memoized separately from s3
   */
  const s4 = new Set(s3);
  s4.add(propArr[3]);
  return [s1, s2, s3, s4];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{propArr: [7, 8, 9]}],
  sequentialRenders: [{propArr: [7, 8, 9]}, {propArr: [7, 8, 10]}],
};
```

----------------------------------------

TITLE: Original React Component with Map Function
DESCRIPTION: A React functional component that takes props containing an items array and maps each item to a Stringify component. The component destructures the id and name from each item and uses them as props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlined-destructured-params.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component(props) {
  // test outlined functions with destructured parameters - the
  // temporary for the destructured param must be promoted
  return (
    <>
      {props.items.map(({id, name}) => (
        <Stringify key={id} name={name} />
      ))}
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{items: [{id: 1, name: 'one'}]}],
};
```

----------------------------------------

TITLE: Demonstrating Non-Reactive Dependencies in React useEffect
DESCRIPTION: Original source code showing a React component with a useEffect that has a non-reactive object in its dependencies. The commented documentation explains the current limitation in effect dependency inference and outlines potential future improvements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect} from 'react';
import {makeObject_Primitives, print} from 'shared-runtime';

/**
 * Note that `obj` is currently added to the effect dependency array, even
 * though it's non-reactive due to memoization.
 *
 * This is a TODO in effect dependency inference. Note that we cannot simply
 * filter out non-reactive effect dependencies, as some non-reactive (by data
 * flow) values become reactive due to scope pruning. See the
 * `infer-effect-deps/pruned-nonreactive-obj` fixture for why this matters.
 *
 * Realizing that this `useEffect` should have an empty dependency array
 * requires effect dependency inference to be structured similarly to memo
 * dependency inference.
 * Pass 1: add all potential dependencies regardless of dataflow reactivity
 * Pass 2: (todo) prune non-reactive dependencies
 *
 * Note that instruction reordering should significantly reduce scope pruning
 */
function NonReactiveDepInEffect() {
  const obj = makeObject_Primitives();
  useEffect(() => print(obj));
}
```

----------------------------------------

TITLE: Calling Class Methods in React - JavaScript
DESCRIPTION: This snippet illustrates a JavaScript class with methods that call other functions. Specifically, it shows how methods `this.useHook()` and `super.useHook()` are called, which are not considered hooks in the React framework. There are no special prerequisites, but it assumes a basic understanding of JavaScript classes and React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-dfde14171fcd.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because classes can call functions.\n// We don\'t consider these to be hooks.\nclass C {\n  m() {\n    this.useHook();\n    super.useHook();\n  }\n}\n
```

----------------------------------------

TITLE: Original React Component with Array Push Operations
DESCRIPTION: Simple React component that creates an array and pushes objects into it, including values derived from props. Shows basic array mutation pattern.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-push-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// arrayInstance.push should have the following effects:\n//  - read on all args (rest parameter)\n//  - mutate on receiver\nfunction Component(props) {\n  const x = foo(props.x);\n  const y = {y: props.y};\n  const arr = [];\n  arr.push({});\n  arr.push(x, y);\n  return arr;\n}
```

----------------------------------------

TITLE: React Component with Undefined Return
DESCRIPTION: A React functional component that conditionally returns undefined or props.value based on props.cond. Includes fixture configuration for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-undefined.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  if (props.cond) {
    return undefined;
  }
  return props.value;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining Component with useHook in React
DESCRIPTION: This snippet defines a React functional component that utilizes a custom hook from 'shared-runtime'. It initializes an object, uses the hook to prevent memoization, and returns a structured output based on the component's props. It also exports a fixture entry point for easier testing with predefined parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-object.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useHook} from 'shared-runtime';

function Component(props) {
  const x = {};
  useHook(); // intersperse a hook call to prevent memoization of x
  x.value = props.value;

  const y = {x};

  return {y};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'sathya'}],
};
```

LANGUAGE: javascript
CODE:
```
import { useHook } from "shared-runtime";

function Component(props) {
  const x = {};
  useHook();
  x.value = props.value;

  const y = { x };
  return { y };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "sathya" }],
};
```

----------------------------------------

TITLE: React Component with useRef Hook and Test Fixture
DESCRIPTION: This snippet defines a React component 'C' that uses the useRef hook to create a mutable reference. It initializes the reference to 1 if it's null. The code also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-initialization.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useRef } from "react";

function C() {
  const r = useRef(null);
  if (r.current == null) {
    r.current = 1;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Component Rendering with Compiler Runtime in JavaScript
DESCRIPTION: This code represents a compiler-generated optimized version of the previous React component definitions, aiming at reducing unnecessary re-renders using caching/indexing techniques. It relies on the \'react/compiler-runtime\' module, enhancing performance for dynamic React component rendering. Each functional React component includes indexed change detection, minimizing update processing and memory allocation. Inputs mirror the initial component interface, focused on enhanced rendering efficiency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-with-non-jsx-children.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableJsxOutlining
function Component(t0) {
  const $ = _c(7);
  const { arr } = t0;
  const x = useX();
  let t1;
  if ($[0] !== arr || $[1] !== x) {
    let t2;
    if ($[3] !== x) {
      t2 = (i, id) => {
        const t3 = "Test";
        const T0 = _temp;
        return <T0 i={i} t={t3} k={i} key={id} x={x} />;
      };
      $[3] = x;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    t1 = arr.map(t2);
    $[0] = arr;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = <>{t1}</>;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
function _temp(t0) {
  const $ = _c(9);
  const { i: i, t: t, k: k, x: x } = t0;
  let t1;
  if ($[0] !== i || $[1] !== t) {
    t1 = <Baz i={i}>{t}</Baz>;
    $[0] = i;
    $[1] = t;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== k) {
    t2 = <Foo k={k} />;
    $[3] = k;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== t1 || $[6] !== t2 || $[7] !== x) {
    t3 = (
      <Bar x={x}>
        {t1}
        {t2}
      </Bar>
    );
    $[5] = t1;
    $[6] = t2;
    $[7] = x;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  return t3;
}

function Bar(t0) {
  const $ = _c(3);
  const { x, children } = t0;
  let t1;
  if ($[0] !== children || $[1] !== x) {
    t1 = (
      <>
        {x}
        {children}
      </>
    );
    $[0] = children;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Baz(t0) {
  const $ = _c(3);
  const { i, children } = t0;
  let t1;
  if ($[0] !== children || $[1] !== i) {
    t1 = (
      <>
        {i}
        {children}
      </>
    );
    $[0] = children;
    $[1] = i;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Foo(t0) {
  const { k } = t0;
  return k;
}

function useX() {
  return "x";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arr: ["foo", "bar"] }],
};

```

----------------------------------------

TITLE: Implementing useMemo with Array Dependencies in React
DESCRIPTION: A React hook implementation that demonstrates an issue with useMemo and mutable array dependencies. The function creates an array, pushes props to it, and then tries to memoize it, which causes a React Compiler error because the memoization cannot be preserved.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-dropped-infer-always-invalidating.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';
import {useHook} from 'shared-runtime';

// useMemo values may not be memoized in Forget output if we
// infer that their deps always invalidate.
// This is technically a false positive as the useMemo in source
// was effectively a no-op
function useFoo(props) {
  const x = [];
  useHook();
  x.push(props);

  return useMemo(() => [x], [x]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining React Component with Array Manipulation
DESCRIPTION: This snippet defines a React component that takes props, creates an array, pushes a value from props, and returns the array along with its length. It demonstrates basic array manipulation and destructuring in a functional component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-property-inference.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [];
  x.push(props.value);
  const {length: y} = x;
  foo(y);
  return [x, y];
}
```

----------------------------------------

TITLE: Initializing Memoized React Component with Invalid Hook Condition
DESCRIPTION: A memo component that demonstrates an incorrect implementation of hooks by conditionally calling a custom hook, which violates React's core hook usage rules
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.invalid-rules-of-hooks-8566f9a360e2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const MemoizedButton = memo(function (props) {
  if (props.fancy) {
    useCustomHook();
  }
  return <button>{props.children}</button>;
});
```

----------------------------------------

TITLE: Creating Invalid Hook Usage in React JavaScript
DESCRIPTION: The provided snippet demonstrates an incorrect pattern of using hooks inside function expressions in React. The createHook function defines a nested useHookWithConditionalHook function that conditionally calls another hook, which is against React rules as hooks must be at the top level of a function component or custom hook. This snippet requires understanding of React's hooks and the Rules of Hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-0a1dbff27ba0.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// Invalid because it\'s dangerous and might not warn otherwise.\n// This *must* be invalid.\nfunction createHook() {\n  return function useHookWithConditionalHook() {\n    if (cond) {\n      useConditionalHook();\n    }\n  };\n}\n
```

----------------------------------------

TITLE: Configuring eslint-plugin-react-hooks with legacy config (ESLint < 5.2.0)
DESCRIPTION: Setup for ESLint versions earlier than 5.2.0 using the legacy .eslintrc format with the recommended configuration.
SOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_4

LANGUAGE: javascript
CODE:
```
{
  "extends": [
    // ...
    "plugin:react-hooks/recommended"
  ]
}
```

----------------------------------------

TITLE: Input React Hook Component Definition
DESCRIPTION: Original React hook component implementation with imports and simple JSX rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-nonreferenced-identifier-collision.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import {identity, useHook as useRenamed} from 'shared-runtime';
const _ = {
  useHook: () => {},
};
identity(_.useHook);

function useHook() {
  useRenamed();
  return <div>hello world!</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{}],
};
```

----------------------------------------

TITLE: Creating a React Component in JavaScript
DESCRIPTION: This snippet demonstrates how to create a simple React component that receives props and renders JSX elements. The component leverages a function, `makeFunction`, to process these props, and produces an output element that includes a `<span>` displaying `props.text`. The component expects props to be passed in as parameters and outputs a JSX structure. Dependencies include React and potential external function dependencies for `makeFunction`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-with-independently-memoizable-arg.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeFunction(props);
  const y = x(
    <div>
      <span>{props.text}</span>
    </div>
  );
  return y;
}

```

----------------------------------------

TITLE: Supporting Named Hooks
DESCRIPTION: This JavaScript snippet illustrates how to support named hooks in React DevTools by providing a `hookNamesModuleLoaderFunction` prop to the DevTools component. This function dynamically imports the necessary module for extracting hook names. The module is lazy-loaded only when the feature is enabled, improving performance.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
// Follow code examples above to configure the backend and frontend.
// When rendering DevTools, the important part is to pass a 'hookNamesModuleLoaderFunction' prop.
const hookNamesModuleLoaderFunction = () => import('react-devtools-inline/hookNames');

// Render:
<DevTools
  hookNamesModuleLoaderFunction={hookNamesModuleLoaderFunction}
  {...otherProps}
/>;
```

----------------------------------------

TITLE: Incrementing Render Count without React Hooks - JavaScript
DESCRIPTION: A React component is defined using a simple function that increments a global render count variable each time it renders. No hooks are used in the component. 'renderCount' is a global variable that tracks the render count for this component. It takes no inputs and returns a simple HTML 'div' element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-global-increment-op-invalid-react.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
let renderCount = 0;

function NoHooks() {
  renderCount++;
  return <div />;
}

```

----------------------------------------

TITLE: Optimizing React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows an optimized version of the component using React's compiler runtime for memoization. It caches the result of the computation to avoid unnecessary recalculations on re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-continue.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let ret;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [0, 1, 2, 3];
    ret = [];
    for (const item of x) {
      if (item === 0) {
        continue;
      }

      ret.push(item / 2);
    }
    $[0] = ret;
  } else {
    ret = $[0];
  }
  return ret;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimizing a React Component using Compiler Runtime in JavaScript
DESCRIPTION: This snippet showcases an optimized version of the React component that utilizes the compiler runtime for performance enhancements. It checks prop changes to conditionally render the component, thereby minimizing unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-empty-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
export function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.a) {
    t0 = <div>{props.a}</div>;
    $[0] = props.a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: "hello" }],
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows an optimized version of the Component using React's compiler runtime. It implements memoization to cache results and improve performance for repeated renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-continue.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let ret;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [0, 1, 2, 3];
    ret = [];
    do {
      const item = x.pop();
      if (item === 0) {
        continue;
      }

      ret.push(item / 2);
    } while (x.length);
    $[0] = ret;
  } else {
    ret = $[0];
  }
  return ret;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized Implementation of Custom React Hook
DESCRIPTION: This snippet shows an optimized version of the 'useFoo' hook. It uses destructuring for parameters and simplifies the function structure. The functionality remains the same as the original implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-for-of-iterate-values.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { makeArray, useHook } from "shared-runtime";

function useFoo(t0) {
  const { propArr } = t0;
  const s1 = new Set([1, 2, 3]);
  s1.add(makeArray(propArr[0]));

  useHook();
  const s2 = new Set();
  for (const el of s1.values()) {
    s2.add(el);
  }
  return [s1, s2];
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows an optimized version of the 'Component' function using React's compiler runtime. It implements memoization to cache the rendered output and avoid unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constructor.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {}

function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = [];
    const b = {};
    new Foo(a, b);
    new Foo(b);
    t0 = <div a={a} b={b} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimizing Component Definition with react/compiler-runtime in JavaScript
DESCRIPTION: This snippet enhances a component definition by utilizing react/compiler-runtime for memoization or caching. It checks for updates to the input parameter and decides whether to reuse a cached function or define a new one. The export is structured the same as in the simpler implementation, enabling fixture testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(3);
  let t;
  if ($[0] !== a) {
    t = { a };
    let t0;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = function x(p) {
        p.foo();
      };
      $[2] = t0;
    } else {
      t0 = $[2];
    }
    const x = t0;

    x(t);
    $[0] = a;
    $[1] = t;
  } else {
    t = $[1];
  }
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining React Component with Hooks and Global State
DESCRIPTION: This snippet defines a React component using useState, useCallback, and useEffect hooks. It interacts with a global state and renders the state value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-in-effect-indirect-usecallback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useEffect, useState} from 'react';

let someGlobal = {};

function Component() {
  const [state, setState] = useState(someGlobal);

  const setGlobal = useCallback(() => {
    someGlobal.value = true;
  }, []);
  useEffect(() => {
    setGlobal();
  }, []);

  useEffect(() => {
    setState(someGlobal.value);
  }, [someGlobal]);

  return <div>{String(state)}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Hook Implementation
DESCRIPTION: A simple React hook 'useFoo' that takes props and calls a function 'foo' with props.x. The compiler directives indicate freezing and instrumentation capabilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-emit-imports-same-source.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableEmitFreeze @enableEmitInstrumentForget

function useFoo(props) {
  return foo(props.x);
}
```

----------------------------------------

TITLE: React Impure Function Call Error
DESCRIPTION: This error message highlights the violation of React's purity rule by the `Component` function. It specifically identifies `Date.now`, `performance.now` and `Math.random` as impure functions, indicating they can produce unstable results and violate the idempotent nature required by React for its components and hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-impure-functions-in-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 |
  3 | function Component() {
> 4 |   const date = Date.now();
    |                ^^^^^^^^ InvalidReact: Calling an impure function can produce unstable results. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent). `Date.now` is an impure function whose results may change on every call (4:4)

InvalidReact: Calling an impure function can produce unstable results. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent). `performance.now` is an impure function whose results may change on every call (5:5)

InvalidReact: Calling an impure function can produce unstable results. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent). `Math.random` is an impure function whose results may change on every call (6:6)
  5 |   const now = performance.now();
  6 |   const rand = Math.random();
  7 |   return <Foo date={date} now={now} rand={rand} />;

```

----------------------------------------

TITLE: Foo Component for Value Rendering
DESCRIPTION: Simple wrapper component that renders its value prop inside a div element
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-fragment-value.flow.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
function Foo({value}) {
  return <div>{value}</div>;
}
```

----------------------------------------

TITLE: Importing and Initializing Component with Static Text Elements in JavaScript
DESCRIPTION: This snippet defines a functional React component named `Component` that takes props with a value property, and it involves conditional rendering of static text elements (`StaticText1` and `StaticText2`). The snippet highlights the simple embedding of prop values within JSX elements and exports an object with the component's configuration. Dependencies are `shared-runtime` for the static text components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-tag-evaluation-order.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {StaticText1, StaticText2} from 'shared-runtime';

function Component(props: {value: string}) {
  let Tag = StaticText1;

  // Currently, Forget preserves jsx whitespace in the source text.
  // prettier-ignore
  return (
    <Tag>{((Tag = StaticText2), props.value)}<Tag /></Tag>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'string value 1'}],
  isComponent: true,
};

```

----------------------------------------

TITLE: Defining a Component with Conditional Logic - JavaScript
DESCRIPTION: This snippet defines a React functional component that utilizes props to determine how to construct its state. It uses a switch-case statement to manage different scenarios based on props. The component recursively renders itself based on derived state values from props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/switch-non-final-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function Component(props) {
  let x = [];
  let y;
  switch (props.p0) {
    case 1: {
      break;
    }
    case true: {
      x.push(props.p2);
      y = [];
    }
    default: {
      break;
    }
    case false: {
      y = x;
      break;
    }
  }
  const child = <Component data={x} />;
  y.push(props.p4);
  return <Component data={y}>{child}</Component>;
}

```

----------------------------------------

TITLE: Accessing Ref Current in Render Error Message - Javascript
DESCRIPTION: This snippet captures the error generated when trying to access the `current` property of a ref during rendering in React. The error message explicitly explains the violation of React's rules regarding refs, making it a useful reference for understanding this common issue.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-access-ref-during-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 | function Component(props) {
  3 |   const ref = useRef(null);
> 4 |   const value = ref.current;
    |                 ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (4:4)
  5 |   return value;
  6 | }
  7 |
```

----------------------------------------

TITLE: Defining a Simple React Component - JavaScript
DESCRIPTION: This snippet defines a simple React component that creates and returns an object based on a function `foo`, passing in a property from `props`. It demonstrates basic component structure and usage of optional chaining.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-call-as-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeObject();
  return x?.[foo(props.value)];
}
```

----------------------------------------

TITLE: Using useMemo for Memoization in React JavaScript
DESCRIPTION: This snippet demonstrates the use of the useMemo hook to optimize component re-renders by memoizing the computed values based on specific dependencies. It defines a function 'useHook' that takes an input and returns an array composed of the input and a nested property, while ensuring dependencies are managed properly. The snippet is designed for use in React and has specific considerations regarding memoization guarantees.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-aliased-var.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

// This is technically a false positive, but source is already breaking
// `exhaustive-deps` lint rule (and can be considered invalid).
function useHook(x) {
  const aliasedX = x;
  const aliasedProp = x.y.z;

  return useMemo(() => [x, x.y.z], [aliasedX, aliasedProp]);
}

```

----------------------------------------

TITLE: Using useMemo in React Component with JavaScript
DESCRIPTION: This React component uses the useMemo hook to memoize a value based on the props passed to the component. It ensures the array \\"a\\" is only recalculated when the \\"name\\" prop changes, improving performance by reducing unnecessary computations. The component also uses a \\"ValidateMemoization\\" component to validate the memoized inputs and outputs. Dependencies include \\"React\\" and \\"shared-runtime\\" packages.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-prototype-call-mutating.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {ValidateMemoization} from 'shared-runtime';

function Component(props) {
  const a = useMemo(() => {
    const a = [];
    const f = function () {
      a.push(props.name);
    };
    f.call();
    return a;
  }, [props.name]);
  return <ValidateMemoization inputs={[props.name]} output={a} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Jason'}],
  sequentialRenders: [{name: 'Lauren'}, {name: 'Lauren'}, {name: 'Jason'}],
};
```

----------------------------------------

TITLE: React Error for Invalid Ref Access
DESCRIPTION: The error message shown when React detects a ref.current access during component render. The error points to line 6 where the ref value is read and explains that ref values may not be accessed during render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-nonif.expect.md#2025-04-22_snippet_1

LANGUAGE: plaintext
CODE:
```
  4 | component C() {
  5 |   const r = useRef(null);
> 6 |   const guard = r.current == null;
    |                 ^^^^^^^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (6:6)

InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef). Cannot access ref value `guard` (7:7)
  7 |   if (guard) {
  8 |     r.current = 1;
  9 |   }
```

----------------------------------------

TITLE: Error Handling for Mutating Props
DESCRIPTION: The provided error message indicates that mutating the props that are passed into a React component is disallowed. It suggests using a local variable for modifications to avoid direct mutation of props, which aligns with React's state management and rendering principles.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-props-via-for-of-iterator.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 |   const items = [];
  3 |   for (const x of props.items) {
> 4 |     x.modified = true;
    |     ^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead (4:4)
  5 |     items.push(x);
  6 |   }
  7 |   return items;
```

----------------------------------------

TITLE: Error Analysis for Incremented Render Count - JavaScript
DESCRIPTION: This error message indicates an unsupported update expression for a global variable 'renderCount' within a React function component. The error highlights the code location and suggests that global variable updates must be managed safely, potentially with state management solutions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-global-increment-op-invalid-react.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  2 |
  3 | function NoHooks() {
> 4 |   renderCount++;
    |   ^^^^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Support UpdateExpression where argument is a global (4:4)
  5 |   return <div />;
  6 | }
  7 |

```

----------------------------------------

TITLE: Implementing React Hooks
DESCRIPTION: This snippet showcases multiple methods to define hooks using JavaScript functions and arrow functions in the context of a React application. Dependencies include the React library and its useState hook. Each function calls useState to demonstrate valid hook initialization patterns. The inputs and outputs are not explicitly detailed as the focus is on valid function definitions. Constraints include the necessity for the useState function to exist within the React context.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-e0a5db3ae21e.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```

// @skip
// Unsupported input

// Valid because hooks can call hooks.
function useHook() {
  useState();
}
const whatever = function useHook() {
  useState();
};
const useHook1 = () => {
  useState();
};
let useHook2 = () => useState();
useHook2 = () => {
  useState();
};
({
  useHook: () => {
    useState();
  },
});
({
  useHook() {
    useState();
  },
});
const {
  useHook3 = () => {
    useState();
  },
} = {};
({
  useHook = () => {
    useState();
  },
} = {});
Namespace.useHook = () => {
  useState();
};

```

----------------------------------------

TITLE: Creating a Memoized Component with React.memo
DESCRIPTION: Input source code showing a simple React.memo wrapper around a functional component that returns a div element. This is the code before compilation optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-React-memo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
React.memo(props => {
  return <div />;
});
```

----------------------------------------

TITLE: Defining React Component with Conditional Rendering
DESCRIPTION: This snippet defines a React component that conditionally renders a 'Stringify' component based on the 'props' value. It includes a function that accesses nested properties of 'props'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/functionexpr-conditional-access-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableTreatFunctionDepsAsConditional
import {Stringify} from 'shared-runtime';

function Component({props}) {
  const f = () => props.a.b;

  return <Stringify f={props == null ? () => {} : f} />;
}
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{props: null}],
};
```

----------------------------------------

TITLE: Implementing a React Component - JavaScript
DESCRIPTION: This snippet demonstrates the creation of a React component that improperly uses a hook as a regular value. The use of `useFoo` as a prop without invocation leads to an error. No dependencies are explicitly mentioned, but React is assumed. The key parameter is `props`, and the output is a JSX element. The snippet highlights the importance of using hooks correctly in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-hook-as-prop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return <Child foo={useFoo} />;
}

```

----------------------------------------

TITLE: Defining Click Event Handlers with Stringify Component - JavaScript
DESCRIPTION: This snippet defines two click event handler functions ('onClick' and 'onClick2') within a 'hoisting' function, which returns a 'Stringify' component with the handlers passed as props. It demonstrates the use of local variables and object property access. Dependencies include 'shared-runtime' for the Stringify component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-computed-member-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function hoisting() {
  function onClick() {
    return bar['baz'];
  }
  function onClick2() {
    return bar[baz];
  }
  const baz = 'baz';
  const bar = {baz: 1};

  return (
    <Stringify onClick={onClick} onClick2={onClick2} shouldInvokeFns={true} />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
};
```

----------------------------------------

TITLE: Initializing React Component with useState and useMemo - JavaScript
DESCRIPTION: This snippet demonstrates the creation of a React component using hooks to manage local state and compute a memoized value based on that state. It uses useMemo to optimize the rendering process for potentially expensive calculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-kitchensink-import.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as React from 'react';
import {useState, useMemo} from 'react';

function Component(props) {
  const [x] = useState(0);
  const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);

  return <div>{expensiveNumber}</div>;
}

function Component2(props) {
  const [x] = useState(0);
  const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);

  return <div>{expensiveNumber}</div>;
}
```

----------------------------------------

TITLE: Installing and Starting React Application
DESCRIPTION: Illustrates how to install dependencies and start the development server for the React application. Uses npm scripts to manage the build and run processes. It's essential to have Node.js and npm installed.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_0

LANGUAGE: Shell
CODE:
```
npm install
npm start
```

----------------------------------------

TITLE: React useRef Hook Usage with Error Demonstration
DESCRIPTION: This code snippet demonstrates the usage of the `useRef` hook in React. It initializes a ref and attempts to modify its `current` property directly within the component's render function. This is an anti-pattern in React and causes an error, as ref values should not be modified during the render phase.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-linear.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow
import {useRef} from 'react';

component C() {
  const r = useRef(null);
  if (r.current == null) {
    r.current = 42;
    r.current = 42;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{}]],
};
```

----------------------------------------

TITLE: Implementing React Component with Custom Hook in JavaScript
DESCRIPTION: This snippet defines a React component that uses a custom hook 'useMakeArray' from an imported 'ObjectWithHooks'. The component creates an array, adds an element from the hook's result, and returns that element. It also exports a fixture entrypoint for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/flatten-scopes-with-methodcall-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const { ObjectWithHooks } = require("shared-runtime");

function Component(props) {
  const x = [];
  const [y] = ObjectWithHooks.useMakeArray();
  x.push(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React functional component that filters and renders items using hooks (useItems, useMemo). Includes conditional rendering based on filtered items length and mapping over filtered items to render Stringify components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-declarations-in-reactive-scope-with-early-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
function Component() {
  const items = useItems();
  const filteredItems = useMemo(
    () =>
      items.filter(([item]) => {
        return item.name != null;
      }),
    [item]
  );

  if (filteredItems.length === 0) {
    // note: this must return nested JSX to create the right scope
    // shape that causes no declarations to be emitted
    return (
      <div>
        <span />
      </div>
    );
  }

  return (
    <>
      {filteredItems.map(([item]) => (
        <Stringify item={item} />
      ))}
    </>
  );
}
```

----------------------------------------

TITLE: Defining React Component with FBT Internationalization
DESCRIPTION: This snippet defines a React component that uses FBT for internationalization. It handles plural forms and conditional rendering based on props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-unmerged-fbt-call-merge-overlapping-reactive-scopes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';
import {Stringify} from 'shared-runtime';

function Component(props) {
  const label = fbt(
    fbt.plural('bar', props.value.length, {
      many: 'bars',
      showCount: 'yes',
    }),
    'The label text'
  );
  return props.cond ? (
    <Stringify
      description={<fbt desc="Some text">Text here</fbt>}
      label={label.toString()}
    />
  ) : null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, value: [0, 1, 2]}],
};
```

----------------------------------------

TITLE: React Component with useMemo - Source Code
DESCRIPTION: Original React component implementation using useMemo hook with optional chaining for nested object access. Includes validation of memoization using ValidateMemoization component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-inverted-optionals-parallel-paths.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
  const data = useMemo(() => {
    const x = [];
    x.push(props?.a.b?.c.d?.e);
    x.push(props.a?.b.c?.d.e);
    return x;
  }, [props.a.b.c.d.e]);
  return <ValidateMemoization inputs={[props.a.b.c.d.e]} output={x} />;
}
```

----------------------------------------

TITLE: React Component with useMemo
DESCRIPTION: This React component utilizes `useMemo` to memoize a value derived from `propA.x()`. The intention is to optimize performance by preventing unnecessary recalculations. The dependencies array `[propA.x]` specifies when the memoized value should be updated.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-property-call-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';

function Component({propA}) {
  return useMemo(() => {
    return propA.x();
  }, [propA.x]);
}

```

----------------------------------------

TITLE: Implementing React Component with Memoized Effect - Input Version
DESCRIPTION: This snippet shows the original implementation of a React component using useEffect with a dependency array. It demonstrates how to use nested arrays as dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merged-scopes-are-valid-effect-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateMemoizedEffectDependencies

import {useEffect} from 'react';

function Component(props) {
  const y = [[props.value]]; // merged w scope for inner array

  useEffect(() => {
    console.log(y);
  }, [y]); // should still be a valid dependency here

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Initial React Component Definition
DESCRIPTION: This code defines a React component named `Component` that conditionally returns an array. If `props.cond` is true, it pushes `props.a` into an array and returns it. Otherwise, it returns an array created using `makeArray(props.b)`. The `FIXTURE_ENTRYPOINT` object provides configuration for testing and rendering the component sequentially with different props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

function Component(props) {
  let x = [];
  if (props.cond) {
    x.push(props.a);
    // oops no memo!
    return x;
  } else {
    return makeArray(props.b);
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    // pattern 1
    {cond: true, a: 42},
    {cond: true, a: 42},
    // pattern 2
    {cond: false, b: 3.14},
    {cond: false, b: 3.14},
    // pattern 1
    {cond: true, a: 42},
    // pattern 2
    {cond: false, b: 3.14},
    // pattern 1
    {cond: true, a: 42},
    // pattern 2
    {cond: false, b: 3.14},
  ],
};

```

----------------------------------------

TITLE: Implementing useMemo with Mismatched Dependencies in React
DESCRIPTION: A hook implementation that uses useMemo with manually specified dependencies that don't match what the React Compiler infers from the code. The hook creates a closure that accesses maybeRef.current but includes shouldRead before maybeRef in the dependency array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-invalid-useMemo-read-maybeRef.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';

function useHook(maybeRef, shouldRead) {
  return useMemo(() => {
    return () => [maybeRef.current];
  }, [shouldRead, maybeRef]);
}

```

----------------------------------------

TITLE: Customizing Pointer Event Properties in DOM Event Testing
DESCRIPTION: This snippet shows how to customize properties of pointer events when testing. It demonstrates setting properties like button state, coordinates, and pointer type to simulate specific interaction scenarios.
SOURCE: https://github.com/facebook/react/blob/main/packages/dom-event-testing-library/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
target.pointerdown({
  button: 0,
  buttons: 1,
  pageX: 10,
  pageY: 10,
  pointerType,
  // NOTE: use x,y instead of clientX,clientY
  x: 10,
  y: 10
});
```

----------------------------------------

TITLE: React Component with Hoisting Error
DESCRIPTION: This code demonstrates a React functional component with a hoisting error. The function defines an inner function named 'hasErrors' that also declares a local variable with the same name, which causes a scoping issue when the function is called in the return statement.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-named-function-with-shadowed-local-same-name.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  function hasErrors() {
    let hasErrors = false;
    if (props.items == null) {
      hasErrors = true;
    }
    return hasErrors;
  }
  return hasErrors();
}
```

----------------------------------------

TITLE: Validating Component Calls in React
DESCRIPTION: This JavaScript snippet defines a function `Component` which erroneously calls a capitalized function `SomeFunc()` without using JSX. The function demonstrates a common pattern in React where capitalized functions suggest components, leading to a validation error if not properly used. Dependencies include React's validation mechanisms. Inputs and outputs involve calling functions with appropriate notation, either as JSX components or standard functions. The highlighted limitation is that capitalized functions should only be used as components with JSX, else they trigger validation errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-function-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoCapitalizedCalls
function Component() {
  const x = SomeFunc();

  return x;
}
```

----------------------------------------

TITLE: Defining a Reactive Component - React JavaScript
DESCRIPTION: This snippet defines a functional component that uses a global constant to determine the value of a local variable based on props. It illustrates how the variable's value depends on reactive props, making it essential to treat it as reactive. The component returns an array containing the computed value based on the switch statement. Dependencies include React for creating components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-switch-condition.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const GLOBAL = 42;

function Component({value}) {
  let x;
  switch (GLOBAL) {
    case value: {
      x = 1;
      break;
    }
    default: {
      x = 2;
    }
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `props.value` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {value: GLOBAL},
    {value: GLOBAL},
    {value: null},
    {value: null},
    {value: GLOBAL},
    {value: null},
    {value: GLOBAL},
    {value: null},
  ],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const GLOBAL = 42;

function Component(t0) {
  const $ = _c(2);
  const { value } = t0;
  let x;
  bb0: switch (GLOBAL) {
    case value: {
      x = 1;
      break bb0;
    }
    default: {
      x = 2;
    }
  }
  let t1;
  if ($[0] !== x) {
    t1 = [x];
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { value: GLOBAL },
    { value: GLOBAL },
    { value: null },
    { value: null },
    { value: GLOBAL },
    { value: null },
    { value: GLOBAL },
    { value: null },
  ],
};
```

----------------------------------------

TITLE: Defining Click Handler in React Component
DESCRIPTION: This snippet defines a functional React component with a click event handler. The callback function is intended to be used as an event handler for an onClick event but attempts to reassign itself, resulting in an error that suggests managing state instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.function-expression-references-variable-its-assigned-to.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let callback = () => {
    callback = null;
  };
  return <div onClick={callback} />;
}

```

----------------------------------------

TITLE: Initial VideoTab Component Implementation
DESCRIPTION: A basic React functional component that creates a reference and defines a function to access video list data
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-optional-field-no-added-to-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function VideoTab() {
  const ref = useRef();
  let x = () => {
    ref.current?.x;
  };

  return <VideoList videos={x} />;
}
```

----------------------------------------

TITLE: Original useFoo Custom Hook Implementation in React
DESCRIPTION: The original implementation of a custom hook that processes arrays. It creates a callback function that adds a value from arr2 to each element of arr1, then maps through arr1 applying this callback to build a new array which is returned.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/bug-invalid-array-map-manual.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({arr1, arr2}) {
  const cb = e => arr2[0].value + e.value;
  const y = [];
  for (let i = 0; i < arr1.length; i++) {
    y.push(cb(arr1[i]));
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{arr1: [], arr2: []}],
  sequentialRenders: [
    {arr1: [], arr2: []},
    {arr1: [], arr2: null},
    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},
  ],
};
```

----------------------------------------

TITLE: Original React Component with Context Usage
DESCRIPTION: Defines a React component that uses Context API to access a boolean state and renders conditional output using a Stringify component. Includes context creation and component export configuration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-read-context-in-callback-if-condition.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createContext, useContext} from 'react';
import {Stringify} from 'shared-runtime';

const FooContext = createContext({current: true});

function Component(props) {
  const foo = useContext(FooContext);

  const getValue = () => {
    if (foo.current) {
      return {};
    } else {
      return null;
    }
  };
  const value = getValue();

  return <Stringify value={value} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Compiler Error Message for Memoization Issues
DESCRIPTION: This error message shows how React Compiler detects and reports a situation where it cannot preserve memoization guarantees. The error occurs when a dependency array contains a reference that might be mutated later, potentially causing unexpected value changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-infer-mutate-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  12 |   return useMemo(() => {
  13 |     return identity(val);
> 14 |   }, [val]);
     |       ^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly (14:14)
  15 | }
  16 |
  17 | export const FIXTURE_ENTRYPOINT = {
```

----------------------------------------

TITLE: Invalid Hook Method Invocation in JavaScript Class
DESCRIPTION: Demonstrates a class method with potentially incorrect references to 'This' and 'Super' hook methods, which may violate React hook usage rules
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-acb56658fe7e.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
class C {
  m() {
    This.useHook();
    Super.useHook();
  }
}
```

----------------------------------------

TITLE: React Component with Memoization Error
DESCRIPTION: A React component that demonstrates a memoization error detected by React Compiler. The component uses useMemo to memoize a value returned by getIsEnabled, but this creates issues because the returned value might be mutable, which is later captured by getLoggingData and passed to other functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-missed-memoization-from-capture-in-invoked-function-inferred-as-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {logValue, useFragment, useHook, typedLog} from 'shared-runtime';

component Component() {
  const data = useFragment();

  const getIsEnabled = () => {
    if (data != null) {
      return true;
    } else {
      return {};
    }
  };

  // We infer that getIsEnabled returns a mutable value, such that
  // isEnabled is mutable
  const isEnabled = useMemo(() => getIsEnabled(), [getIsEnabled]);

  // We then infer getLoggingData as capturing that mutable value,
  // so any calls to this function are then inferred as extending
  // the mutable range of isEnabled
  const getLoggingData = () => {
    return {
      isEnabled,
    };
  };

  // The call here is then inferred as an indirect mutation of isEnabled
  useHook(getLoggingData());

  return <div onClick={() => typedLog(getLoggingData())} />;
}
```

----------------------------------------

TITLE: React Component with Conditional Props
DESCRIPTION: This React component takes props and conditionally assigns a value to the `bar` prop based on the `cond` prop. The `bar` prop is either `props.foo` or `props.bar` depending on the value of `props.cond`. This component illustrates a common pattern in React where props are dynamically derived based on other props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-spread.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return (
    <Component {...props} {...{bar: props.cond ? props.foo : props.bar}} />
  );
}

```

----------------------------------------

TITLE: Subscribing to DOM event dispatchers with use-subscription in React
DESCRIPTION: Example demonstrating how to use the useSubscription hook to subscribe to event dispatchers like DOM elements. The component will automatically re-render when the input value changes.
SOURCE: https://github.com/facebook/react/blob/main/packages/use-subscription/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import React, { useMemo } from "react";
import { useSubscription } from "use-subscription";

// In this example, "input" is an event dispatcher (e.g. an HTMLInputElement)
// but it could be anything that emits an event and has a readable current value.
function Example({ input }) {

  // Memoize to avoid removing and re-adding subscriptions each time this hook is called.
  const subscription = useMemo(
    () => ({
      getCurrentValue: () => input.value,
      subscribe: callback => {
        input.addEventListener("change", callback);
        return () => input.removeEventListener("change", callback);
      }
    }),

    // Re-subscribe any time our input changes
    // (e.g. we get a new HTMLInputElement prop to subscribe to)
    [input]
  );

  // The value returned by this hook reflects the input's current value.
  // Our component will automatically be re-rendered when that value changes.
  const value = useSubscription(subscription);

  // Your rendered output goes here ...
}
```

----------------------------------------

TITLE: Using React Hooks to Create a Custom Hook in JavaScript
DESCRIPTION: This snippet defines a custom React hook using useCallback and useTransition from React. It exposes a function called useFoo, which internally starts a transition using start from useTransition. The hook bypasses all parameters and aims to preserve existing memoization guarantees.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/preserve-use-memo-transition.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useTransition} from 'react';

function useFoo() {
  const [t, start] = useTransition();

  return useCallback(() => {
    start();
  }, []);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Invalid React Hook Call in Callback (JavaScript)
DESCRIPTION: This code demonstrates an invalid use of a React hook (`useHookInsideCallback`) within a `useEffect` callback function inside a component. This violates the Rules of Hooks, which stipulate that hooks must be called at the top level of a component or custom hook, not within callbacks or other function expressions. The expected outcome is a runtime error indicating the invalid hook call.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-d952b82c2597.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
function ComponentWithHookInsideCallback() {
  useEffect(() => {
    useHookInsideCallback();
  });
}

```

----------------------------------------

TITLE: React Hook: Using a Hook Within Another Hook (JavaScript) - Repeated Code
DESCRIPTION: This code snippet, identical to the previous one, demonstrates a valid React custom hook, `useHookWithHook`, which internally calls another hook, `useHook`.  This pattern is permitted and allows for the composition of hook logic. The assumption is that `useHook` is a previously defined hook in the same scope or imported from elsewhere.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-844a496db20b.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// Valid because hooks can use hooks.
function useHookWithHook() {
  useHook();
}

```

----------------------------------------

TITLE: Error Handling for Invalid useMemo Usage
DESCRIPTION: This snippet captures an error message that indicates the misuse of the useMemo hook with an async callback. The error message informs the developer that useMemo callbacks must not be asynchronous or generator functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useMemo-async-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function component(a, b) {
> 2 |   let x = useMemo(async () => {
    |                   ^^^^^^^^^^^^^
> 3 |     await a;
    | ^^^^^^^^^^^^
> 4 |   }, []);
    | ^^^^ InvalidReact: useMemo callbacks may not be async or generator functions (2:4)
  5 |   return x;
  6 | }
  7 |

```

----------------------------------------

TITLE: React ForwardRef with Hook in Anonymous Function
DESCRIPTION: This snippet demonstrates the usage of React's `forwardRef` with a hook inside an anonymous function. The `FancyButton` component is created using `React.forwardRef` and takes `props` and `ref` as arguments. The `useHook()` function is called within the component to utilize a custom hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-9a47e97b5d13.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because hooks can be used in anonymous function arguments to
// forwardRef.
const FancyButton = React.forwardRef(function (props, ref) {
  useHook();
  return <button {...props} ref={ref} />;
});

```

----------------------------------------

TITLE: Original React Hook Implementation
DESCRIPTION: Simple React hook function that conditionally sets a variable based on props and returns it. Shows nested conditional logic without memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-in-nested-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useBar(props) {
  let z;

  if (props.a) {
    if (props.b) {
      z = baz();
    }
  }

  return z;
}
```

----------------------------------------

TITLE: React Component with useRef
DESCRIPTION: This React component, VideoTab, uses the useRef hook to create a reference. A function `x` is defined that logs the current value of the reference. This function is then passed as the `videos` prop to the `VideoList` component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-aliased-no-added-to-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender false
function VideoTab() {
  const ref = useRef();
  const t = ref.current;
  let x = () => {
    console.log(t);
  };

  return <VideoList videos={x} />;
}

```

----------------------------------------

TITLE: Creating Component with Props Handling - React - JavaScript
DESCRIPTION: Defines a React functional component that processes props to potentially call an optional method. It uses two helper functions to make an optional object and create an object from props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-receiver-optional-method.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeOptionalObject(props);
  const y = makeObject(props);
  const z = x?.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));
  return z;
}

```

----------------------------------------

TITLE: Input React Component with Memoization
DESCRIPTION: Original React component code showing useState, context usage, and scope creation patterns. Demonstrates primitive object creation and loop handling that will be optimized in compilation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/log-pruned-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger
import {createContext, use, useState} from 'react';
import {
  Stringify,
  identity,
  makeObject_Primitives,
  useHook,
} from 'shared-runtime';

function Component() {
  const w = use(Context);

  // The scopes for x and x2 are interleaved, so this is one scope with two values
  const x = makeObject_Primitives();
  const x2 = makeObject_Primitives();
  useState(null);
  identity(x);
  identity(x2);

  // We create a scope for all call expressions, but prune those with hook calls
  // in this case it's _just_ a hook call, so we don't count this as pruned
  const y = useHook();

  const z = [];
  for (let i = 0; i < 10; i++) {
    // The scope for obj is pruned bc it's in a loop
    const obj = makeObject_Primitives();
    z.push(obj);
  }

  // Overall we expect two pruned scopes (for x+x2, and obj), with 3 pruned scope values.
  return <Stringify items={[w, x, x2, y, z]} />;
}

const Context = createContext();

function Wrapper() {
  return (
    <Context value={42}>
      <Component />
    </Context>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Wrapper,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing Custom Ref and Callback in React
DESCRIPTION: This snippet defines a custom ref hook and a React component using that hook with a callback. It demonstrates the use of useRef and useCallback hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-useCallback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableTreatRefLikeIdentifiersAsRefs @validatePreserveExistingMemoizationGuarantees
import {useRef, useCallback} from 'react';

function useCustomRef() {
  return useRef({click: () => {}});
}

function Foo() {
  const customRef = useCustomRef();

  const onClick = useCallback(() => {
    customRef.current?.click();
  }, []);

  return <button onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Memoizing Functional Components in React with Hooks
DESCRIPTION: This JavaScript code snippet shows a functional component that uses React.memo to prevent unnecessary re-renders. The memo function is used to wrap an anonymous function component, while the useHook function is called within it. It returns a button element, spreading the received props. This requires React and appropriate hook implementation to function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-eacfcaa6ef89.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// Valid because hooks can be used in anonymous function arguments to
// memo.
const MemoizedFunction = memo(function (props) {
  useHook();
  return <button {...props} />;
});
```

----------------------------------------

TITLE: Defining a React Hook
DESCRIPTION: This code snippet defines a custom React hook named `useHook`. This hook demonstrates that hooks can call other hooks, such as `useHook1` and `useHook2`, which promotes code reusability and composability within React functional components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-cfdfe5572fc7.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// Valid because hooks can call hooks.
function useHook() {
  useHook1();
  useHook2();
}

```

----------------------------------------

TITLE: Defining a Functional Component in React - JavaScript
DESCRIPTION: This snippet illustrates the definition of a functional React component named 'Component' which takes an 'arr' property and uses the custom hook 'useX'. It renders child components 'Bar', 'Baz', and 'Foo' based on the mapped values from the array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-duplicate-prop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableJsxOutlining
function Component({arr}) {
  const x = useX();
  return (
    <>
      {arr.map((i, id) => {
        return (
          <Bar key={id} x={x}>
            <Baz i={i}></Baz>
            <Foo i={i}></Foo>
          </Bar>
        );
      })}
    </>
  );
}
function Bar({x, children}) {
  return (
    <>
      {x}
      {children}
    </>
  );
}

function Baz({i}) {
  return i;
}

function Foo({i}) {
  return i;
}

function useX() {
  return 'x';
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arr: ['foo', 'bar']}],
};
```

----------------------------------------

TITLE: Defining a React Component with Hooks in JavaScript
DESCRIPTION: This snippet demonstrates the creation of a React component using hooks, which are used for managing state and lifecycle methods in function components. The given structure allows for inferred compilation mode, indicative of build time optimizations. No external dependencies are explicitly required other than a valid React and hooks environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-8f1c2c3f71c9.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
// Valid because components can use hooks.
function createComponentWithHook() {
  return function ComponentWithHook() {
    useHook();
  };
}

```

----------------------------------------

TITLE: Creating a Custom Ref Hook in React
DESCRIPTION: This snippet defines a custom hook 'useCustomRef' that initializes a ref with a default click function. The 'Foo' component illustrates how to use this ref in a button click handler, utilizing React's useCallback for memoization to optimize rendering. Key parameters include the click handler and the ref object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-like-name-not-a-ref.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';

function useCustomRef() {
  return useRef({click: () => {}});
}

function Foo() {
  const notaref = useCustomRef();

  const onClick = useCallback(() => {
    notaref.current?.click();
  }, []);

  return <button onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Streaming Server Rendering in Modern Edge Runtimes
DESCRIPTION: New API for streaming server-side rendering in modern edge runtime environments like Deno and Cloudflare workers.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_11

LANGUAGE: javascript
CODE:
```
renderToReadableStream
```

----------------------------------------

TITLE: Flow-Typed React Component Input
DESCRIPTION: Original React component implementation with Flow type annotations. Defines a User type and creates an object based on props.name.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow
function Component(props) {
  type User = {name: string};
  const user: User = {name: props.name};
  return user;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Mofei'}],
};
```

----------------------------------------

TITLE: React Component Definition with Conditional Rendering
DESCRIPTION: Defines a React functional component `MyApp` that conditionally returns `undefined` (implicitly) based on the value of the `cond` prop. If `props.cond` is truthy, the component returns nothing, otherwise, it would continue execution. This version demonstrates an issue where a variable would be assigned only conditionally.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function MyApp(props) {
  let res;
  if (props.cond) {
    return;
  } else {
    res = 1;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Starting Request Render in React
DESCRIPTION: Method to initiate rendering of a request, continuing until completion.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_7

LANGUAGE: typescript
CODE:
```
startWork(request: Request): void
```

----------------------------------------

TITLE: Optimizing React Component with Memoization
DESCRIPTION: This snippet shows how to implement a functional component with memoization using the '@compilationMode(infer)' directive and a separate memoization cache. It ensures that the component only re-renders if the memoized value changes, enhancing performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-expression-component.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)

const Component = function ComponentName(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Foo />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
};

```

----------------------------------------

TITLE: Managing Reactive Ref in React Component - JavaScript
DESCRIPTION: This snippet demonstrates the use of the useRef hook along with forwardRef in React to manage reactive values. It includes a Parent component that conditionally uses reactive references and a Child component implemented using forwardRef. The system uses the shared-runtime's Stringify component for some of its functional requirements. The fixture entry point defined establishes different renders based on conditional values. Key dependencies are react and shared-runtime packages.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-ref-param.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef, forwardRef} from 'react';
import {Stringify} from 'shared-runtime';

/**
 * Fixture showing that Ref types may be reactive.
 * We should always take a dependency on ref values (the outer box) as
 * they may be reactive. Pruning should be done in
 * `pruneNonReactiveDependencies`
 */

function Parent({cond}) {
  const ref1 = useRef(1);
  const ref2 = useRef(2);
  const ref = cond ? ref1 : ref2;
  return <Child ref={ref} />;
}

function ChildImpl(_props, ref) {
  const cb = () => ref.current;
  return <Stringify cb={cb} shouldInvokeFns={true} />;
}

const Child = forwardRef(ChildImpl);

export const FIXTURE_ENTRYPOINT = {
  fn: Parent,
  params: [{cond: true}],
  sequentialRenders: [{cond: true}, {cond: false}],
};
```

----------------------------------------

TITLE: Initialization of a React Component with Hooks in JavaScript
DESCRIPTION: This snippet illustrates an incorrect usage of a React hook, where it is conditionally called. Hooks must be called unconditionally within the component body. Here, `React.useNonexistentHook` is incorrectly used, causing a runtime error. Dependencies include React library that provides hook functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.conditional-hook-unknown-hook-react-namespace.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Component(props) {
  let x = null;
  if (props.cond) {
    x = React.useNonexistentHook();
  }
  return x;
}

```

----------------------------------------

TITLE: Implementing Custom React Hook with useMemo
DESCRIPTION: Defines a custom React hook that uses useMemo to memoize an array containing a nested object property value. Demonstrates the relationship between object reference changes and nested property changes in memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-more-specific.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';

// More specific memoization always results in fewer memo block
// executions.
// Precisely:
//  x_new != x_prev does NOT imply x.y.z_new != x.y.z_prev
//  x.y.z_new != x.y.z_prev does imply x_new != x_prev
function useHook(x) {
  return useMemo(() => [x.y.z], [x]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{y: {z: 2}}],
};
```

----------------------------------------

TITLE: Defining Input React Component in JavaScript
DESCRIPTION: This snippet shows the original React component with a mutable variable 'a' and an array operation. It demonstrates the basic structure before optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-capture-in-method-receiver.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  // a's mutable range should be limited
  // the following line
  let a = someObj();

  let x = [];
  x.push(a);

  return [x, a];
}
```

----------------------------------------

TITLE: Defining React Component Function in JavaScript
DESCRIPTION: This snippet implements a basic React component function that handles input data and uses props to conditionally render child components. The function utilizes a switch statement to determine behavior based on props, encapsulates input data, and passes it down to rendered child components, demonstrating fundamental component design patterns in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/switch.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @enablePropagateDepsInHIR
function Component(props) {
  let x = [];
  let y;
  switch (props.p0) {
    case true: {
      x.push(props.p2);
      x.push(props.p3);
      y = [];
    }
    case false: {
      y = x;
      break;
    }
  }
  const child = <Component data={x} />;
  y.push(props.p4);
  return <Component data={y}>{child}</Component>;
}

```

----------------------------------------

TITLE: React Component Definition with Array Destructuring
DESCRIPTION: Defines a React functional component `t` that takes props as input and destructures it to extract a value using array destructuring. It then returns the extracted value. This component is intended for use in a testing or fixture environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-pattern-dce-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function t(props) {
  let [foo, bar, ,] = props;
  return foo;
}

export const FIXTURE_ENTRYPOINT = {
  fn: t,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Defining React Component with useEffect
DESCRIPTION: This snippet defines a React component 'Foo' using the useEffect hook to update a ref. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-parameter-mutate-in-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect} from 'react';

function Foo(props, ref) {
  useEffect(() => {
    ref.current = 2;
  }, []);
  return <div>{props.bar}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{bar: 'foo'}, {ref: {current: 1}}],
  isComponent: true,
};
```

----------------------------------------

TITLE: Incorrectly Mutating React Context Value
DESCRIPTION: This code snippet shows an invalid approach to modifying context by directly assigning a value, which violates React's immutability principles and triggers a runtime error
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-context.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const context = useContext(FooContext);
  context.value = props.value;
  return context.value;
}
```

----------------------------------------

TITLE: React Component with State Update and Export
DESCRIPTION: This snippet defines a React component named 't' that uses the useState hook to trigger a state update with `setstate(1)`. It then returns the value of the `foo` prop. The `FIXTURE_ENTRYPOINT` object exports metadata about the component, including a reference to the component function, the expected parameter names ('TodoAdd'), and the component's name ('TodoAdd').
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function t(props) {
  const [, setstate] = useState();
  setstate(1);
  return props.foo;
}

export const FIXTURE_ENTRYPOINT = {
  fn: t,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Simple Baz Component for Item Rendering
DESCRIPTION: A minimal component that simply returns its input item, used for rendering individual elements
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
function Baz({i}) {
  return i;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This is the compiled version of the React component, utilizing `react/compiler-runtime` for memoization. It uses a cache (`$[0]`, `$[1]`, etc.) to store the previous values of `props.cond` and `stateObject.setState` to avoid unnecessary re-renders.  It imports necessary modules and demonstrates compiler optimizations for efficient rendering based on prop and state changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-phi-setState-type.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import invariant from "invariant";
import { useState } from "react";

function Component(props) {
  const $ = _c(5);
  const [, setX] = useState(false);
  const [, setY] = useState(false);
  let setState;
  if (props.cond) {
    setState = setX;
  } else {
    setState = setY;
  }

  const setState2 = setState;
  let t0;
  if ($[0] !== setState2) {
    t0 = { setState: setState2 };
    $[0] = setState2;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const stateObject = t0;
  let t1;
  if ($[2] !== props.cond || $[3] !== stateObject.setState) {
    t1 = (
      <Foo
        cond={props.cond}
        setX={setX}
        setY={setY}
        setState={stateObject.setState}
      />
    );
    $[2] = props.cond;
    $[3] = stateObject.setState;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}

function Foo(t0) {
  const { cond, setX, setY, setState } = t0;
  if (cond) {
    invariant(setState === setX, "Expected the correct setState function");
  } else {
    invariant(setState === setY, "Expected the correct setState function");
  }
  return "ok";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { cond: true },
    { cond: true },
    { cond: false },
    { cond: false },
    { cond: true },
    { cond: false },
    { cond: true },
    { cond: false },
  ],
};

```

----------------------------------------

TITLE: Creating and Managing Refs in a React Component
DESCRIPTION: This snippet defines a React functional component that utilizes local references and memoization. The useMemo hook is employed to determine the merged reference based on the disableLocalRef flag. The identity function ensures the correct reference is maintained unless disabled. This example emphasizes correct ref handling during component rendering, focusing on avoiding invalid access to ref properties within the React render phase.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-with-refs.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @validatePreserveExistingMemoizationGuarantees
import {identity} from 'shared-runtime';

component Component(disableLocalRef, ref) {
  const localRef = useFooRef();
  const mergedRef = useMemo(() => {
    return disableLocalRef ? ref : identity(ref, localRef);
  }, [disableLocalRef, ref, localRef]);
  return <div ref={mergedRef} />;
}
```

----------------------------------------

TITLE: Implementing React Component with useRef and onClick Handler
DESCRIPTION: This snippet defines a React component that uses useRef to manage an input element and includes an onClick handler for a button. The handler checks and modifies the ref's current value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-in-callback-passed-to-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
import {useRef} from 'react';

function Component() {
  const ref = useRef(null);

  const onClick = () => {
    if (ref.current !== null) {
      ref.current = '';
    }
  };

  return (
    <>
      <input ref={ref} />
      <button onClick={onClick} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Initializing Forwarded Reference React Component with Hooks
DESCRIPTION: Creates a React component using forwardRef and an anonymous arrow function, demonstrating hook integration and prop forwarding
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-e9f9bac89f8f.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const FancyButton = React.forwardRef((props, ref) => {
  useHook();
  return <button {...props} ref={ref} />;
});
```

----------------------------------------

TITLE: Defining Basic React Component with forwardRef
DESCRIPTION: This snippet defines a basic React component using forwardRef. The component is not named like a typical component and simply returns an empty div element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/infer-function-expression-React-memo-gating.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating @compilationMode(infer)
import React from 'react';
export default React.forwardRef(function notNamedLikeAComponent(props) {
  return <div />;
});
```

----------------------------------------

TITLE: Initializing Memoization with React
DESCRIPTION: This snippet utilizes React's useMemo hook to create a memoized object. It ensures that the object is not recreated on each render. Dependencies like 'identity' and 'makeObject_Primitives' from 'shared-runtime' are required for this functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-maybe-modified-later-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {identity, makeObject_Primitives, mutate} from 'shared-runtime';

function Component(props) {
  const object = useMemo(() => makeObject_Primitives(), []);
  identity(object);
  return object;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Implementing Conditional Dependencies in React Custom Hook (Input)
DESCRIPTION: A React custom hook that demonstrates how props accessed within multiple conditional blocks should be tracked as unconditional dependencies. The function creates an object with different properties depending on condition evaluation, but accesses props.a.b in all possible execution paths.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-nested-ifelse.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths

import {getNull, identity} from 'shared-runtime';

function useCondDepInNestedIfElse(props, cond) {
  const x = {};
  if (identity(cond)) {
    if (getNull()) {
      x.a = props.a.b;
    } else {
      x.b = props.a.b;
    }
  } else if (identity(cond)) {
    x.c = props.a.b;
  } else {
    x.d = props.a.b;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInNestedIfElse,
  params: [{a: {b: 2}}, true],
};
```

----------------------------------------

TITLE: Implementing Complex Destructuring in JavaScript for React Component
DESCRIPTION: This function demonstrates advanced destructuring patterns in JavaScript, likely used in a React component. It extracts nested values from input objects and returns a new object with selected properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let d, g, n, o;
  [
    d,
    [
      {
        e: {f: g},
      },
    ],
  ] = a;
  ({
    l: {
      m: [[n]],
    },
    o,
  } = b);
  return {d, g, n, o};
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining and Using a Hook in JavaScript
DESCRIPTION: This snippet imports a constant, defines a function `useHook` that logs messages based on a boolean condition, and exports a constant object representing the fixture entry point. It relies on the `shared-runtime` for the `CONST_STRING0` constant. The function returns an array of log messages depending on the condition provided as input.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/labeled-break-within-label-switch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_STRING0} from 'shared-runtime';

function useHook(cond) {
  const log = [];
  switch (CONST_STRING0) {
    case CONST_STRING0:
      log.push(`@A`);
      bb0: {
        if (cond) {
          break bb0;
        }
        log.push(`@B`);
      }
      log.push(`@C`);
  }
  return log;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [true],
};

```

----------------------------------------

TITLE: Defining React Component with Memoization (JavaScript)
DESCRIPTION: This snippet defines a React component 'useFoo' that uses memoization to optimize rendering. It utilizes a custom compiler runtime for dependency tracking and caching. The component renders a 'Stringify' element with memoized props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-object-method-uncond-access.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR

import { identity, Stringify } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(4);
  const { a } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = {
      fn() {
        return identity(a.b.c);
      },
    };
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  let t2;
  if ($[2] !== x) {
    t2 = <Stringify x={x} shouldInvokeFns={true} />;
    $[2] = x;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: null }],
  sequentialRenders: [{ a: null }, { a: { b: { c: 4 } } }],
};
```

----------------------------------------

TITLE: Defining TypeScript Function with Type Alias in React
DESCRIPTION: This snippet defines a TypeScript function using a type alias. It demonstrates the use of type annotations and a higher-order function pattern. The function is exported as part of a FIXTURE_ENTRYPOINT object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-variable-annotation.expect.md#2025-04-21_snippet_0

LANGUAGE: typescript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
type Bar = string;
function TypeAliasUsedAsVariableAnnotation() {
  type Foo = Bar;
  const fun = f => {
    let g: Foo = f;
    console.log(g);
  };
  fun('hello, world');
}

export const FIXTURE_ENTRYPOINT = {
  fn: TypeAliasUsedAsVariableAnnotation,
  params: [],
};
```

----------------------------------------

TITLE: React Hooks Dependency Linting Error
DESCRIPTION: The error message generated by a React hooks linting tool when it detects a conditional dependency list in useMemo. It specifically highlights line 10 where a ternary operator is used instead of a literal array expression for dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useMemo-non-literal-depslist.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   8 |       return text.toUpperCase();
   9 |     },
> 10 |     hasDeps ? null : [text], // should be DCE'd
     |     ^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Expected the dependency list for useMemo to be an array literal (10:10)
  11 |   );
  12 |   return resolvedText;
  13 | }
```

----------------------------------------

TITLE: Defining useFoo Function in React
DESCRIPTION: This snippet defines the function useFoo which takes a screen object and returns "(not null)" if the title_text is non-null or uses identity when title_text is null. It demonstrates handling conditional dependencies and optional chains which can lead to errors if screen is null. Dependencies include importing identity from shared-runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/edge-case-merge-uncond-optional-chain-and-cond.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

/**
 * Evaluator failure:
 * Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok) {}
 *   [[ (exception in render) TypeError: Cannot read properties of null (reading 'title_text') ]]
 *   Forget:
 *   (kind: ok) {}
 *   {}
 */
/**
 * Very contrived text fixture showing that it's technically incorrect to merge
 * a conditional dependency (e.g. dep.path in `cond ? dep.path : ...`) and an
 * unconditionally evaluated optional chain (`dep?.path`).
 *
 *
 * when screen is non-null, useFoo returns { title: null } or "(not null)"
 * when screen is null, useFoo throws
 */
function useFoo({screen}: {screen: null | undefined | {title_text: null}}) {
  return screen?.title_text != null
    ? '(not null)'
    : identity({title: screen.title_text});
}
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{screen: null}],
  sequentialRenders: [{screen: {title_bar: undefined}}, {screen: null}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet represents the compiled version of the React component, demonstrating the compiler's optimization of `useMemo`. It replaces `useMemo` with inline checks and state updates to avoid unnecessary recalculations.  The compiler generates optimized code using the `_c` function from `react/compiler-runtime` to manage memoized values and conditional rendering based on dependency changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-single.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR
import { ValidateMemoization } from "shared-runtime";
import { useMemo } from "react";
function Component(t0) {
  const $ = _c(7);
  const { arg } = t0;

  arg?.items;
  let t1;
  let x;
  if ($[0] !== arg?.items) {
    x = [];
    x.push(arg?.items);
    $[0] = arg?.items;
    $[1] = x;
  } else {
    x = $[1];
  }
  t1 = x;
  const data = t1;
  const t2 = arg?.items;
  let t3;
  if ($[2] !== t2) {
    t3 = [t2];
    $[2] = t2;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== data || $[5] !== t3) {
    t4 = <ValidateMemoization inputs={t3} output={data} />;
    $[4] = data;
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arg: { items: 2 } }],
  sequentialRenders: [
    { arg: { items: 2 } },
    { arg: { items: 2 } },
    { arg: null },
    { arg: null },
  ],
};

```

----------------------------------------

TITLE: React Component Definition with Ternary Logic (Code)
DESCRIPTION: Defines a React functional component named 'ternary' that accepts 'props' as input. It uses nested ternary operators to conditionally assign values to variables 'a' and 'b' based on the values of props. The component returns 'b' if 'a' is truthy, otherwise it returns null. This snippet is nearly identical to the "Input" snippet but uses double quotes around the string 'TodoAdd' in the params array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ternary-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function ternary(props) {
  const a = props.a && props.b ? props.c || props.d : (props.e ?? props.f);
  const b = props.a ? (props.b && props.c ? props.d : props.e) : props.f;
  return a ? b : null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: ternary,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Using useMemo for Constant Value Caching in React
DESCRIPTION: This snippet demonstrates the use of the `useMemo` hook to memoize a constant value in a custom React hook. The hook, `useFoo`, returns a memoized array containing `constVal`, which is useful for preventing unnecessary re-renders. It requires the React library and takes no parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/todo-ensure-constant-prop-decls-get-removed.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';

// Todo: we currently only generate a `constVal` declaration when
// validatePreserveExistingMemoizationGuarantees is enabled, as the
// StartMemoize instruction uses `constVal`.
// Fix is to rewrite StartMemoize instructions to remove constant
// propagated values
function useFoo() {
  const constVal = 0;

  return useMemo(() => [constVal], [constVal]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component with Computed Properties
DESCRIPTION: An example React component that computes values from props and conditionally calls functions. This represents the source code before compilation optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/interdependent-across-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function compute() {}
function foo() {}
function Foo() {}

/**
 * Should produce 1 scope:
 *
 * return: inputs=props.a & props.b & props.c; outputs=return
 *   const a = compute(props.a);
 *   const b = compute(props.b);
 *   if (props.c)
 *     foo(a, b);
 *   return = <Foo a={a} b={b} />
 */
function Component(props) {
  const a = compute(props.a);
  const b = compute(props.b);
  if (props.c) {
    foo(a, b);
  }
  return <Foo a={a} b={b} />;
}
```

----------------------------------------

TITLE: Configuring a Same-Origin `iframe`
DESCRIPTION: This JavaScript snippet demonstrates configuring React DevTools with a same-origin iframe. It initializes both the backend and frontend, ensuring the backend is initialized before React loads in the iframe. The frontend returns a React component that can be rendered in the parent window, and the backend is activated after the frontend is initialized.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
import {
  activate as activateBackend,
  initialize as initializeBackend
} from 'react-devtools-inline/backend';
import { initialize as initializeFrontend } from 'react-devtools-inline/frontend';

// The React app you want to inspect with DevTools is running within this iframe:
const iframe = document.getElementById('target');
const { contentWindow } = iframe;

// Installs the global hook into the iframe.
// This must be called before React is loaded into that frame.
initializeBackend(contentWindow);

// Initialize DevTools UI to listen to the hook we just installed.
// This returns a React component we can render anywhere in the parent window.
// This also must be called before React is loaded into the iframe
const DevTools = initializeFrontend(contentWindow);

// React application can be injected into <iframe> at any time now...
// Note that this would need to be done via <script> tag injection,
// as setting the src of the <iframe> would load a new page (without the injected backend).

// <DevTools /> interface can be rendered in the parent window at any time now...
// Be sure to use ReactDOMClient.createRoot() to render this component.

// Let the backend know the frontend is ready and listening.
activateBackend(contentWindow);
```

----------------------------------------

TITLE: React Mutation Error
DESCRIPTION: This error message indicates an attempt to mutate a variable defined outside a component or hook. Specifically, it highlights a mutation of `x` within the `mutatePhiThatCouldBeProps` function. The error suggests using an effect to manage state changes instead of directly mutating variables derived from props or global variables.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutation-of-possible-props-phi-indirect.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  2 |   let x = cond ? someGlobal : props.foo;
  3 |   const mutatePhiThatCouldBeProps = () => {
> 4 |     x.y = true;
    |     ^ InvalidReact: Writing to a variable defined outside a component or hook is not allowed. Consider using an effect. Found mutation of `x` (4:4)
  5 |   };
  6 |   const indirectMutateProps = () => {
  7 |     mutatePhiThatCouldBeProps();

```

----------------------------------------

TITLE: Handling Ref Access in React JavaScript Components
DESCRIPTION: This JavaScript function demonstrates an issue when attempting to access the 'current' property of a ref during the rendering phase in a React component. It highlights an invalid access pattern, which can lead to runtime errors. The React 'useRef' hook is used here, and the function is expected to return a component with a ref applied to a 'Foo' element. No explicit inputs are required, apart from standard component props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ref-value-as-props.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function Component(props) {
  const ref = useRef(null);
  return <Foo ref={ref.current} />;
}
```

----------------------------------------

TITLE: Rendering React Component with Props
DESCRIPTION: Demonstrates a basic rendering of a React component where nested components are passed props, showcasing how properties are used to pass data. The component utilizes props.p0 to populate and iterate a list and updates a data attribute with this list.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {};
  const y = [];
  x.y = y;
  const child = <Component data={y} />;
  x.y.push(props.p0);
  return <Component data={x}>{child}</Component>;
}

```

----------------------------------------

TITLE: Initializing React Component with Props - JavaScript
DESCRIPTION: This function defines a simple React component that initializes an array and pushes a prop value into it. It demonstrates basic prop handling in function components. The expected input is a 'props' object containing a key 'a', and it outputs an array containing the value of 'a'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/iife-return-modified-later.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const items = (() => {
    return [];
  })();
  items.push(props.a);
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: {}}],
};
```

----------------------------------------

TITLE: Initializing React Component with Incorrect useEffect
DESCRIPTION: A React functional component using useEffect with an invalid dependency handling approach, which causes a compilation error
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.use-no-memo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import {useEffect} from 'react';

function Component({propVal}) {
  'use no memo';
  useEffect(() => [propVal]);
}
```

----------------------------------------

TITLE: React Error Message for setState During Render
DESCRIPTION: The error message shown when setState is called unconditionally during component render. It points to the function call that initiates the chain leading to setState and includes a link to React documentation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-nested-function-expressions.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  14 |     bar();
  15 |   };
> 16 |   baz();
     |   ^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (16:16)
  17 |
  18 |   return [x];
  19 | }
```

----------------------------------------

TITLE: Error Message for Invalid Hook Usage in React
DESCRIPTION: This error message is generated when attempting to use a hook inside a callback function within a React component. It points out the specific line where the invalid hook call occurs and provides a link to the Rules of Hooks documentation for further information.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.bail.rules-of-hooks-3d692676194b.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
   6 | const ComponentWithHookInsideCallback = React.forwardRef((props, ref) => {
   7 |   useEffect(() => {
>  8 |     useHookInsideCallback();
     |     ^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (8:8)
   9 |   });
  10 |   return <button {...props} ref={ref} />;
  11 | });
```

----------------------------------------

TITLE: Defining a Hook with Invalid Prop Mutation in JavaScript
DESCRIPTION: This function attempts to mutate the properties of the arguments passed, which violates React's practice of not mutating props directly. It highlights the importance of using local variables to manage component state instead of modifying incoming props. The snippet illustrates how React enforces immutability by providing an error message when attempting such mutations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-hook-argument.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useHook(a, b) {
  b.test = 1;
  a.test = 2;
}

```

----------------------------------------

TITLE: Input Component with Error Handling in JavaScript
DESCRIPTION: A React component that demonstrates error catching, array manipulation, and input parameter processing. Uses throwInput for testing and handles exceptions by pushing additional data into the caught error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-try-value-modified-in-catch-escaping.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
const {throwInput} = require('shared-runtime');

function Component(props) {
  let x;
  try {
    const y = [];
    y.push(props.y);
    throwInput(y);
  } catch (e) {
    e.push(props.e);
    x = e;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{y: 'foo', e: 'bar'}],
};
```

----------------------------------------

TITLE: Implementing React Component with Custom Hook and Memo Caching
DESCRIPTION: This code snippet defines a React component 'Test' that uses a custom hook 'useFoo' and implements memo caching for performance optimization. It also includes an export for a fixture entrypoint.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagate-global-phis-constant.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_STRING0, Text } from "shared-runtime";
function useFoo() {
  "use no forget";
  return { tab: CONST_STRING0 };
}

function Test() {
  const $ = _c(1);
  const { tab } = useFoo();
  tab === CONST_STRING0 ? CONST_STRING0 : CONST_STRING0;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Text value={CONST_STRING0} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Defining Functional Component Foo with Identity Functions - JavaScript
DESCRIPTION: This snippet defines a functional React component named 'Foo' that takes props 'a' and 'cond', evaluates conditions, and uses the identity function to manipulate data before rendering. It also prepares its output for further evaluation using a Stringify component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-hoists-other-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR

import {identity, makeArray, Stringify, useIdentity} from 'shared-runtime';

function Foo({a, cond}) {
  // Assume fn will be uncond evaluated, so we can safely evaluate {a.<any>,
  // a.b.<any}
  const fn = () => [a, a.b.c];
  useIdentity(null);
  const x = makeArray();
  if (cond) {
    x.push(identity(a.b.c));
  }
  return <Stringify fn={fn} x={x} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{a: null, cond: true}],
  sequentialRenders: [
    {a: null, cond: true},
    {a: {b: {c: 4}}, cond: true},
    {a: {b: {c: 4}}, cond: true},
  ],
};


```

----------------------------------------

TITLE: React Component Definition with Reactivity Issue
DESCRIPTION: This code defines a React component that illustrates a reactivity issue when dealing with nested arrays. Initially, the `z` array is non-reactive. The code then attempts to update `y` to make it reactive, which should ideally propagate back to `z`. However, the reactivity propagation requires a fixpoint, which the component attempts to handle by storing the potentially reactive array into another variable `a`. Finally the value `b` is conditionally updated based on the value within the array `a`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-readonly-alias-of-mutable-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [];
  const y = x;

  // y isn't reactive yet when we first visit this, so z is initially non-reactive
  const z = [y];

  // then we realize y is reactive. we need a fixpoint to propagate this back to z
  y.push(props.input);

  // PruneNonReactiveDependencies partially propagates reactivity (for now) which
  // we bypass with an indirection of storing into another variable
  const a = [z];

  // b's value is conditional on `a`, which is reactive per above
  let b = 0;
  if (a[0][0][0] === 42) {
    b = 1;
  }

  return [b];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {input: 42},
    {input: 42},
    {input: 'sathya'},
    {input: 'sathya'},
    {input: 42},
    {input: 'sathya'},
    {input: 42},
    {input: 'sathya'},
  ],
};
```

----------------------------------------

TITLE: Using Compiler Runtime for React Optimizations
DESCRIPTION: This snippet uses the React compiler runtime to optimize component rendering. It implements a comparison-based rendering approach to prevent unnecessary re-renders by checking previous prop values and state before updating the local variables and the JSX output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/same-variable-as-dep-and-redeclare.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // note: comments are for the ideal scopes, not what is currently
// emitted
function foo(props) {
  const $ = _c(14);
  let t0;
  let x;
  if ($[0] !== props.a) {
    x = [];
    x.push(props.a);

    t0 = <div>{x}</div>;
    $[0] = props.a;
    $[1] = t0;
    $[2] = x;
  } else {
    t0 = $[1];
    x = $[2];
  }
  const header = t0;
  let y;
  if ($[3] !== props.b || $[4] !== props.c || $[5] !== x) {
    y = [x];
    x = [];
    y.push(props.b);
    x.push(props.c);
    $[3] = props.b;
    $[4] = props.c;
    $[5] = x;
    $[6] = y;
    $[7] = x;
  } else {
    y = $[6];
    x = $[7];
  }
  let t1;
  if ($[8] !== x || $[9] !== y) {
    t1 = (
      <div>
        {x}
        {y}
      </div>
    );
    $[8] = x;
    $[9] = y;
    $[10] = t1;
  } else {
    t1 = $[10];
  }
  const content = t1;
  let t2;
  if ($[11] !== content || $[12] !== header) {
    t2 = (
      <>
        {header}
        {content}
      </>
    );
    $[11] = content;
    $[12] = header;
    $[13] = t2;
  } else {
    t2 = $[13];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized Implementation of useFoo with React Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the useFoo function, using React's compiler runtime for improved performance. It implements the same functionality as the original but with more efficient memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-inner-decl.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useMemo } from "react";
import { identity } from "shared-runtime";

function useFoo(data) {
  const $ = _c(4);
  let t0;
  let t1;
  if ($[0] !== data.a) {
    t1 = identity(data.a);
    $[0] = data.a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const temp = t1;
  let t2;
  if ($[2] !== temp) {
    t2 = { temp };
    $[2] = temp;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  t0 = t2;
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: 2 }],
};
```

----------------------------------------

TITLE: Defining a React Functional Component with Hooks
DESCRIPTION: This snippet defines a React functional component that uses the useEffect hook. The component incorrectly attempts to nest useEffect calls, which leads to a hook call violation error. The props are logged to the console inside a nested function that is executed within the useEffect phase.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-nested-use-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enable
import {fire} from 'react';

function Component(props) {
  const foo = props => {
    console.log(props);
  };
  useEffect(() => {
    useEffect(() => {
      function nested() {
        fire(foo(props));
      }

      nested();
    });
  });

  return null;
}

```

----------------------------------------

TITLE: ESLint Immutability Violation in React Component
DESCRIPTION: This ESLint error indicates an attempt to mutate a variable that React considers immutable. Specifically, it flags the line where `renderIcon.displayName` is being assigned. This is a common issue when trying to set properties on function components in a way that React's reconciliation process might not expect.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-function-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | export function ViewModeSelector(props) {
  2 |   const renderIcon = () => <AcceptIcon />;
> 3 |   renderIcon.displayName = 'AcceptIcon';
    |   ^^^^^^^^^^ InvalidReact: This mutates a variable that React considers immutable (3:3)
  4 |
  5 |   return <Dropdown checkableIndicator={{children: renderIcon}} />;
  6 | }
```

----------------------------------------

TITLE: Defining Component with GraphQL Fragment - JavaScript
DESCRIPTION: This snippet defines a React functional component that uses the GraphQL useFragment hook to fetch user data based on a defined fragment. It expects 'props' containing a 'user' object and returns the user's name. The snippet demonstrates the integration of GraphQL fragments in React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-inside-logical-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const user =
    useFragment(
      graphql`
        fragment F on T {
          id
        }
      `,
      props.user
    ) ?? {};
  return user.name;
}

```

----------------------------------------

TITLE: Defining useMakeCallback Hook
DESCRIPTION: This code defines a React hook `useMakeCallback` that conditionally returns a callback function based on the `shouldMakeCb` prop. The callback updates the state using the `setState` function with the `obj.value`.  The hook takes an object with `obj`, `shouldMakeCb`, and `setState` properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditionally-return-fn.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper} from 'shared-runtime';

/**
 * Assume that conditionally returned functions can be invoked and that their
 * property loads are hoistable to the function declaration site.
 */
function useMakeCallback({
  obj,
  shouldMakeCb,
  setState,
}: {
  obj: {value: number};
  shouldMakeCb: boolean;
  setState: (newState: number) => void;
}) {
  const cb = () => setState(obj.value);
  if (shouldMakeCb) return cb;
  else return null;
}

const setState = (arg: number) => {
  'use no memo';
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useMakeCallback),
  params: [{obj: {value: 1}, shouldMakeCb: true, setState}],
  sequentialRenders: [
    {obj: {value: 1}, shouldMakeCb: true, setState},
    {obj: {value: 2}, shouldMakeCb: true, setState},
  ],
};

```

----------------------------------------

TITLE: Using React useState Hook for State Management in JavaScript
DESCRIPTION: This snippet illustrates the use of the useState hook from React to manage local component state. The initial state is set to an object containing a nested structure. However, it demonstrates an incorrect approach by directly mutating the state, which leads to a warning about proper usage. It is important to utilize the setter function to make updates to the state instead of mutating it directly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.modify-state-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';

function Foo() {
  const [state, setState] = useState({foo: {bar: 3}});
  const foo = state.foo;
  foo.bar = 1;
  return state;
}

```

LANGUAGE: javascript
CODE:
```
  4 |   const [state, setState] = useState({foo: {bar: 3}});
  5 |   const foo = state.foo;
> 6 |   foo.bar = 1;
    |   ^^^ InvalidReact: Mutating a value returned from 'useState()', which should not be mutated. Use the setter function to update instead (6:6)
  7 |   return state;
  8 | }
  9 |
```

----------------------------------------

TITLE: Original React Function Component with Conditional Rendering
DESCRIPTION: Defines a React function component useFoo that conditionally renders based on input properties. The function handles various conditions including potential null paths, and returns either null or an array of processed values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/reduce-if-nonexhaustive-poisoned-deps1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function useFoo({input, cond, hasAB}) {
  const x = [];
  if (cond) {
    if (!hasAB) {
      return null;
    } else {
      x.push(identity(input.a.b));
    }
    x.push(identity(input.a.b));
  } else {
    x.push(identity(input.a.b));
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {b: 1}, cond: true, hasAB: false}],
  sequentialRenders: [
    {input: {a: {b: 1}}, cond: true, hasAB: true},
    {input: null, cond: true, hasAB: false},
    // preserve nullthrows
    {input: {a: {b: undefined}}, cond: true, hasAB: true},
    {input: {a: null}, cond: true, hasAB: true},
    {input: {a: {b: undefined}}, cond: true, hasAB: true},
  ],
};
```

----------------------------------------

TITLE: Defining a React Functional Component Using useState - JavaScript
DESCRIPTION: This code defines a functional component 'Component' that attempts to use the useState Hook incorrectly. It initializes a state variable but assigns the Hook reference itself instead of calling it. The expected output is the first element of the state array, but this will trigger an error due to improper Hook usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-assign-hook-to-local.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = useState;
  const state = x(null);
  return state[0];
}
```

----------------------------------------

TITLE: React Immutability Violation Error Handling
DESCRIPTION: This snippet includes an inline error comment that occurs when trying to mutate a React component state. The comment points out that `x.value` cannot be mutated after the use of the `useIdentity` hook, serving as a caution for developers about React's immutable state management principles.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-call-freezes-captured-memberexpr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```
  11 |   });
  12 |
> 13 |   x.value += count;
     |   ^ InvalidReact: This mutates a variable that React considers immutable (13:13)
  14 |   return <Stringify x={x} cb={cb} />;
  15 | }
  16 |
```
```

----------------------------------------

TITLE: Defining a Function with Object Manipulation in JavaScript
DESCRIPTION: This JavaScript snippet defines a function named 'foo' that takes three arguments (a, b, c). It destructures a property from 'a', uses spread syntax to create a new object 'y' based on nested properties of 'b', modifies 'y', and recursively calls itself with a nested property of 'a'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-properties.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const x = a.x;
  const y = {...b.c.d};
  y.z = c.d.e;
  foo(a.b.c);
  [a.b.c];
}
```

----------------------------------------

TITLE: React Component Source Code with useCallback and useRef
DESCRIPTION: Original React component implementation showing usage of useRef for mutable state and useCallback for event handlers. Demonstrates pattern for maintaining mutable references while using callback memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-multiple-callbacks-modifying-same-ref-preserve-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';

function Component(props) {
  const ref = useRef({inner: null});

  const onChange = useCallback(event => {
    // The ref should still be mutable here even though function deps are frozen in
    // @enablePreserveExistingMemoizationGuarantees mode
    ref.current.inner = event.target.value;
  });

  const onReset = useCallback(() => {
    ref.current.inner = null;
  });

  return <input onChange={onChange} onReset={onReset} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component that creates a function to render a div with a name prop. The component uses a function call pattern to return the rendered content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-prototype-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const f = function () {
    return <div>{props.name}</div>;
  };
  return f.call();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Jason'}],
};
```

----------------------------------------

TITLE: React Component with Conditional Props
DESCRIPTION: A React function component that takes props and performs conditional assignment based on props.a. The component returns either props.b or props.c depending on the evaluation of props.a in an array context.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-if-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [props.a];
  let y;
  if (x) {
    y = props.b;
  } else {
    y = props.c;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Implementing useFoo React Hook (Original Input)
DESCRIPTION: Original implementation of a useFoo React hook that manipulates an array based on conditional props. The hook pushes either props.foo or props.bar into the array depending on props.cond value. This is the code before React compiler optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-ternary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond
    ? ((x = {}), (x = []), x.push(props.foo))
    : ((x = []), (x = []), x.push(props.bar));
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};
```

----------------------------------------

TITLE: Optimized React Component with Forget Feature Flag
DESCRIPTION: This snippet shows an optimized version of the component using the Forget feature flag. It includes conditional rendering based on the feature flag, and implements memoization for the rendered content when the feature is enabled.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/infer-function-expression-React-memo-gating.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating @compilationMode(infer)
import React from "react";
export default React.forwardRef(
  isForgetEnabled_Fixtures()
    ? function notNamedLikeAComponent(props) {
        const $ = _c(1);
        let t0;
        if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
          t0 = <div />;
          $[0] = t0;
        } else {
          t0 = $[0];
        }
        return t0;
      }
    : function notNamedLikeAComponent(props) {
        return <div />;
      },
);
```

----------------------------------------

TITLE: Using useMemo for Conditional Computation in React (JavaScript)
DESCRIPTION: This snippet defines a React functional component that uses the useMemo hook to optimize rendering by caching calculated values based on the component's props. The function evaluates conditions and returns an array based on the boolean props 'cond' and 'cond2'. The expected input is an object containing numeric properties 'a' and 'b', and boolean flags 'cond' and 'cond2'. The output is an array consisting of the selected values or an empty array, based on the conditions. This aims to avoid unnecessary recalculations on rerenders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/useMemo-multiple-if-else.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {useMemo} from 'react';

function Component(props) {
  const x = useMemo(() => {
    let y = [];
    if (props.cond) {
      y.push(props.a);
    }
    if (props.cond2) {
      return y;
    }
    y.push(props.b);
    return y;
  });
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1, b: 2, cond2: false}],
};

```

----------------------------------------

TITLE: Optimized React Component with useImperativeHandle and useRef
DESCRIPTION: This code represents an optimized version of the React component using the React compiler runtime.  It uses `_c` to memoize values. The `useImperativeHandle` hook's callback computes a value based on the component's props and ref values. The component also exports a `FIXTURE_ENTRYPOINT` constant, which configures the component's initial props for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useImperativeHandle-ref-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";

import { useImperativeHandle, useRef } from "react";

function Component(t0) {
  const $ = _c(3);
  const { prop } = t0;
  const ref1 = useRef(null);
  const ref2 = useRef(1);
  let t1;
  let t2;
  if ($[0] !== prop) {
    t1 = () => {
      const precomputed = prop + ref2.current;
      return { foo: () => prop + ref2.current + precomputed };
    };

    t2 = [prop];
    $[0] = prop;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useImperativeHandle(ref1, t1, t2);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ prop: 1 }],
};

```

----------------------------------------

TITLE: Invalid Hook Usage
DESCRIPTION: This snippet demonstrates the invalid usage of a hook within a named function in React. Such usage violates the rules of hooks, which state that hooks can only be called at the top level of a functional component or custom hook. The snippet includes an example that is expected to fail validation but passes mistakenly due to the testing setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-a63fd4f9dcc0.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

// This is invalid because "use"-prefixed functions used in named
// functions are assumed to be hooks.
React.unknownFunction(function notAComponent(foo, bar) {
  useProbablyAHook(bar);
});
```

----------------------------------------

TITLE: Custom Hook for Value Retrieval
DESCRIPTION: A simple custom hook that returns a static string value, used for demonstration purposes
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_4

LANGUAGE: javascript
CODE:
```
function useX() {
  return 'x';
}
```

----------------------------------------

TITLE: Defining Foo Component and Rendering JSX - React - JavaScript
DESCRIPTION: This snippet demonstrates the definition of a functional component 'Foo' in React. It uses destructuring to extract values from an array and an object, rendering these values in a div. The component does not take any parameters and relies on React's implicit state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoist-destruct.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow
component Foo() {
  function foo() {
    return (
      <div>
        {a} {z} {y}
      </div>
    );
  }
  const [a, {x: z, y = 10}] = [1, {x: 2}];
  return foo();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};

```

----------------------------------------

TITLE: Initializing React Component in JavaScript
DESCRIPTION: The function 'Component' is a simple React component that receives props and returns a JSX element. It formats the numeric property 'x' using 'toFixed' and renders it within a 'div'. The export 'FIXTURE_ENTRYPOINT' contains the component function and a sample parameter object for testing. There are no external dependencies besides basic React JSX functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ignore-use-no-forget.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @ignoreUseNoForget
function Component(prop) {
  'use no forget';
  const result = prop.x.toFixed();
  return <div>{result}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: 1}],
};
```

----------------------------------------

TITLE: Configuring eslint-plugin-react-hooks with legacy config (ESLint 5.2.0+)
DESCRIPTION: Setup for ESLint below 9.0.0 using the legacy .eslintrc format with the recommended-legacy configuration.
SOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
{
  "extends": [
    // ...
    "plugin:react-hooks/recommended-legacy"
  ]
}
```

----------------------------------------

TITLE: Defining Hook Usage Rules in JavaScript
DESCRIPTION: This code snippet defines a function that improperly uses a hook inside a normal function, violating React's rules about hooks. It is used to illustrate cases that should be flagged as invalid to maintain the integrity of hook usage across the application.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-c59788ef5676.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

// Currently invalid because it violates the convention and removes the "taint"
// from a hook. We *could* make it valid to avoid some false positives but let's
// ensure that we don't break the "renderItem" and "normalFunctionWithConditionalHook"
// cases which must remain invalid.
function normalFunctionWithHook() {
  useHookInsideNormalFunction();
}

```

----------------------------------------

TITLE: Validating Ref Access During Render - React - Javascript
DESCRIPTION: This snippet defines a React functional component that utilizes the useRef hook to create a reference. It attempts to access the current value of the reference during the render lifecycle, which results in an error, indicating that ref values cannot be accessed in this manner. This teaches the user about proper ref usage in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-access-ref-during-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function Component(props) {
  const ref = useRef(null);
  const value = ref.current;
  return value;
}
```

----------------------------------------

TITLE: Defining a Basic Functional Component in React - JavaScript
DESCRIPTION: This snippet defines a simple functional component named Foo using React. It accepts 'props' and renders a greeting message along with static content. The snippet does not include any external dependencies and focuses purely on React's JSX syntax.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-fragment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  return (
    <>
      Hello {props.greeting}{' '}
      <div>
        <>Text</>
      </div>
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: React useState with useMemo Issue
DESCRIPTION: This code demonstrates a potential issue with using `useState` and `useMemo` together in React.  The `useKeyedState` hook attempts to initialize state based on a `key` and `init` value.  `useMemo` is used to call a function that updates the state when `key` or `init` changes, but calling `setState` inside the `useMemo` callback will cause infinite re-renders and result in an infinite loop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-setState-in-useMemo-indirect-useCallback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useCallback} from 'react';

function useKeyedState({key, init}) {
  const [prevKey, setPrevKey] = useState(key);
  const [state, setState] = useState(init);

  const fn = useCallback(() => {
    setPrevKey(key);
    setState(init);
  });

  useMemo(() => {
    fn();
  }, [key, init]);

  return state;
}
```

----------------------------------------

TITLE: Input React Component with useCallback
DESCRIPTION: Original React component code showing usage of useCallback and useRef hooks. Defines a Foo component that uses ref access in a callback, and a simple A component that renders a div.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-ref-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @validateRefAccessDuringRender @validatePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';

component Foo() {
  const ref = useRef();

  const s = useCallback(() => {
    return ref.current;
  });

  return <A r={s} />;
}

component A(r: mixed) {
  return <div />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Error Handling for Memoization in React - JavaScript
DESCRIPTION: This error snippet outlines a compiler warning that indicates a failure to preserve existing memoization guarantees. It suggests that the inferred dependencies do not align with the specified dependencies, which could lead to unexpected behavior in the optimization of the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-invalid-useCallback-read-maybeRef.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  3 |
  4 | function useHook(maybeRef) {
> 5 |   return useCallback(() => {
    |                      ^^^^^^^
> 6 |     return [maybeRef.current];
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 7 |   }, [maybeRef]);
    | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:7)
  8 | }
  9 |

```

----------------------------------------

TITLE: Defining a Simple Custom React Hook with Input Properties
DESCRIPTION: Implements a custom React hook called useMakeCallback that returns a callback function. The hook takes an object and setState function as parameters and returns a callback that updates state with the object's value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/return-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper} from 'shared-runtime';

/**
 * Assume that directly returned functions are invoked and that their property
 * loads are hoistable.
 */
function useMakeCallback({
  obj,
  setState,
}: {
  obj: {value: number};
  setState: (newState: number) => void;
}) {
  return () => setState(obj.value);
}

const setState = (arg: number) => {
  'use no memo';
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useMakeCallback),
  params: [{obj: {value: 1}, setState}],
  sequentialRenders: [
    {obj: {value: 1}, setState},
    {obj: {value: 2}, setState},
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component with React compiler optimizations applied. It adds memoization logic to prevent unnecessary array recreation when the state hasn't changed, improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-hook-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
function Component(props) {
  const $ = _c(2);
  const [state] = useState(null);
  let t0;
  if ($[0] !== state) {
    t0 = [state];
    $[0] = state;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Utility Bar Component for Rendering
DESCRIPTION: A simple Bar component that renders its children alongside an x prop, demonstrating basic React component composition
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
function Bar({x, children}) {
  return (
    <>
      {x}
      {children}
    </>
  );
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component using various hooks (useState, useEffect, useContext) with a custom context implementation. The component manages state, performs side effects, and uses context values through hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/flag-enable-emit-hook-guards.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableEmitHookGuards
import {createContext, useContext, useEffect, useState} from 'react';
import {
  CONST_STRING0,
  ObjectWithHooks,
  getNumber,
  identity,
  print,
} from 'shared-runtime';

const MyContext = createContext('my context value');
function Component({value}) {
  print(identity(CONST_STRING0));
  const [state, setState] = useState(getNumber());
  print(value, state);
  useEffect(() => {
    if (state === 4) {
      setState(5);
    }
  }, [state]);
  print(identity(value + state));
  return ObjectWithHooks.useIdentity(useContext(MyContext));
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  args: [{value: 0}],
};
```

----------------------------------------

TITLE: Implementing React Components with Conditional Rendering
DESCRIPTION: This snippet defines two React components, ComponentA and ComponentB, which conditionally render child elements based on props. It also includes utility functions Foo and mayMutate.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-on-mutable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function ComponentA(props) {
  const a = [];
  const b = [];
  if (b) {
    a.push(props.p0);
  }
  if (props.p1) {
    b.push(props.p2);
  }
  return <Foo a={a} b={b} />;
}

function ComponentB(props) {
  const a = [];
  const b = [];
  if (mayMutate(b)) {
    a.push(props.p0);
  }
  if (props.p1) {
    b.push(props.p2);
  }
  return <Foo a={a} b={b} />;
}

function Foo() {}
function mayMutate() {}
```

----------------------------------------

TITLE: Defining React Component with Conditional Returns
DESCRIPTION: This snippet defines a React component 'Foo' that uses the useRef hook and returns different structures based on input conditions. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-ref-callback-structure.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @validateRefAccessDuringRender @validatePreserveExistingMemoizationGuarantees

import {useRef} from 'react';

component Foo(cond: boolean, cond2: boolean) {
  const ref = useRef();

  const s = () => {
    return ref.current;
  };

  if (cond) return [s];
  else if (cond2) return {s};
  else return {s: [s]};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{cond: false, cond2: false}],
};
```

----------------------------------------

TITLE: Invalid Hook Usage in React Component
DESCRIPTION: Example of incorrect hook implementation where useHook is called within a for loop. This violates React's Rules of Hooks which require hooks to be called in a consistent order and not within loops, conditions, or nested functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-for.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let i = 0;
  for (let x = 0; useHook(x) < 10; useHook(i), x++) {
    i += useHook(x);
  }
  return i;
}
```

LANGUAGE: plaintext
CODE:
```
  2 |   let i = 0;
  3 |   for (let x = 0; useHook(x) < 10; useHook(i), x++) {
> 4 |     i += useHook(x);
    |          ^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (4:4)

InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (3:3)
  5 |   }
  6 |   return i;
  7 | }
```

----------------------------------------

TITLE: React Component Input Definition
DESCRIPTION: Original component definition with an arrow function as default parameter that returns an array of mixed values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-with-reorderable-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(x = () => [-1, true, 42.0, 'hello']) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Implementing React Component with Default Parameter
DESCRIPTION: This snippet defines a React component function that uses array destructuring and default parameters. It takes an array as input and returns the first element or a default value of 2 if the array is empty.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-array-param-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component([a = 2]) {
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Original Invalid React Component Definition
DESCRIPTION: A React function component that incorrectly defines another component function inside its render body, which violates React's best practices as components created during render will reset their state on each render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger @validateStaticComponents
function Example(props) {
  function Component() {
    return <div />;
  }
  return <Component />;
}
```

----------------------------------------

TITLE: React Hook Error Message
DESCRIPTION: Detailed error message explaining why the current implementation is invalid. The error highlights that variable reassignment is a side effect that breaks the pure function principles of React components and hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-destructure-assignment-to-global.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
1 | function useFoo(props) {
> 2 |   [x] = props;
    |    ^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (2:2)
3 |   return {x};
4 | }
```

----------------------------------------

TITLE: React Compiler Error for Unmemoized Effect Dependencies
DESCRIPTION: Error output from the React Compiler showing that it has skipped optimizing the component because the effect dependencies could not be memoized. The error warns that unmemoized effect dependencies can trigger infinite loops or unexpected behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-memoized-effect-deps-invalidated-dep-value.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   9 |   const y = [x];
  10 |
> 11 |   useEffect(() => {
     |   ^^^^^^^^^^^^^^^^^
> 12 |     console.log(y);
     | ^^^^^^^^^^^^^^^^^^^
> 13 |   }, [y]);
     | ^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the effect dependencies could not be memoized. Unmemoized effect dependencies can trigger an infinite loop or other unexpected behavior (11:13)
  14 | }
  15 |
  16 | export const FIXTURE_ENTRYPOINT = {
```

----------------------------------------

TITLE: Defining a Basic React Component in JavaScript
DESCRIPTION: This snippet defines a React component named Foo, which returns a div element accepting a ref prop. It demonstrates the basic export of this component using a constant named FIXTURE_ENTRYPOINT. There are no external dependencies or prerequisites, and the code handles component referencing for div elements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-ref-arg.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)

function Foo({}, ref) {
  return <div ref={ref} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};

```

----------------------------------------

TITLE: Defining Custom useState Hook - JavaScript
DESCRIPTION: This snippet defines a custom useState hook that mimics React's useState, utilizing a memoization technique to optimize state management. It captures state changes and optimally returns the state and setState function. The expected input is an initial value for the state, and the output is the current state along with a function to update it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-dont-resolve-local-useState.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState as _useState, useCallback, useEffect} from 'react';
import {ValidateMemoization} from 'shared-runtime';

function useState(value) {
  const [state, setState] = _useState(value);
  return [state, setState];
}
```

----------------------------------------

TITLE: Rendering Button List in React (Input Version)
DESCRIPTION: This React component takes a list of buttons as props, separates the primary button, and renders the secondary buttons with alternating left/right styles. It uses the StaticText1 and Stringify components from 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-undefined-expression-of-jsxexpressioncontainer.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {StaticText1, Stringify, Text} from 'shared-runtime';

function Component(props) {
  const {buttons} = props;
  const [primaryButton, ...nonPrimaryButtons] = buttons;

  const renderedNonPrimaryButtons = nonPrimaryButtons.map((buttonProps, i) => (
    <Stringify
      {...buttonProps}
      key={`button-${i}`}
      style={
        i % 2 === 0 ? styles.leftSecondaryButton : styles.rightSecondaryButton
      }
    />
  ));

  return <StaticText1>{renderedNonPrimaryButtons}</StaticText1>;
}

const styles = {
  leftSecondaryButton: {left: true},
  rightSecondaryButton: {right: true},
};

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      buttons: [
        {},
        {type: 'submit', children: ['Submit!']},
        {type: 'button', children: ['Reset']},
      ],
    },
  ],
};
```

----------------------------------------

TITLE: Using Non-Reactive Dependencies in React Effect Hooks - JavaScript
DESCRIPTION: This snippet defines the function NonReactiveDepInEffect, which utilizes the useEffect hook from React to manage non-reactive dependencies. It prints an object created by makeObject_Primitives using both React's useEffect and a custom SharedRuntime hook. It is required to have 'react' and 'shared-runtime' libraries available.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/import-namespace-useEffect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import * as React from 'react';
import * as SharedRuntime from 'shared-runtime';

function NonReactiveDepInEffect() {
  const obj = makeObject_Primitives();
  React.useEffect(() => print(obj));
  SharedRuntime.useSpecialEffect(() => print(obj), [obj]);
}

```

----------------------------------------

TITLE: Using React Portal Creation
DESCRIPTION: Example of using ReactDOM.createPortal() for rendering subtrees into different DOM nodes.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_21

LANGUAGE: javascript
CODE:
```
ReactDOM.createPortal()
```

----------------------------------------

TITLE: Managing State with Hooks in React - JavaScript
DESCRIPTION: This snippet defines a React component using hooks to manage state. It imports a hook from a shared runtime, processes a list of items from props, and dynamically renders them with attached click handlers that update the state. It requires React to be installed and expects 'props.data' to be an array of objects with 'id' properties. The output is a rendered list of items encapsulated in a 'div'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-of-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import {useHook} from 'shared-runtime';

function Component(props) {
  const data = useHook();
  const items = [];
  // NOTE: `item` is a context variable because it's reassigned and also referenced
  // within a closure, the `onClick` handler of each item
  for (let item of props.data) {
    item = item ?? {}; // reassignment to force a context variable
    items.push(
      <div key={item.id} onClick={() => data.set(item)}>
        {item.id}
      </div>
    );
  }
  return <div>{items}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{data: [{id: '1'}, {id: '2'}]}],
};
```

----------------------------------------

TITLE: Configuring a Sandboxed `iframe` (Frontend)
DESCRIPTION: This JavaScript snippet configures the React DevTools frontend to communicate with a sandboxed iframe's backend.  It initializes the frontend and then posts a message to the iframe to activate the backend once the iframe is loaded. This indirect activation is required due to the sandboxed environment's restrictions.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_5

LANGUAGE: javascript
CODE:
```
import { initialize } from "react-devtools-inline/frontend";

const iframe = document.getElementById("target");
const { contentWindow } = iframe;

// Initialize DevTools UI to listen to the iframe.
// This returns a React component we can render anywhere in the main window.
// Be sure to use ReactDOMClient.createRoot() to render this component.
const DevTools = initialize(contentWindow);

// Let the backend know to initialize itself.
// We can't do this directly because the iframe is sandboxed.
// Only initialize the backend once the DevTools frontend has been initialized.
iframe.onload = () => {
  contentWindow.postMessage(
    {
      type: "activate-backend"
    },
    "*"
  );
};
```

----------------------------------------

TITLE: Validating Capitalized Function Calls - JavaScript
DESCRIPTION: This snippet defines a function 'Foo' that incorrectly invokes a capitalized function 'Bar'. This triggers a validation error, indicating that capitalized functions are reserved for React components. The error message provides guidance on how to correct the issue or allowlist the function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-function-call-aliased.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoCapitalizedCalls
function Foo() {
  let x = Bar;
  x(); // ERROR
}

```

----------------------------------------

TITLE: Defining Component Logic in React: Javascript
DESCRIPTION: This snippet defines a basic React component function, which performs operations using input properties to compute a result. It relies on helper functions like 'foo' and 'bar', and utilizes array operations to derive its return value. Key operations include duplicating an array and accessing array elements by index.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-closure.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = foo(props.x);
  const fn = function () {
    const arr = [...bar(props)];
    return arr.at(x);
  };
  const fnResult = fn();
  return fnResult;
}

```

----------------------------------------

TITLE: Implementing React Component with Dynamic Theming in JavaScript
DESCRIPTION: This snippet defines a React component that applies CSS classes dynamically based on a theme. It uses a custom 'cx' function for class name generation and a mock 'useTheme' hook. The code includes React compiler optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-assigned-to-temporary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer) @enableAssumeHooksFollowRulesOfReact:false @customMacros(cx)
import { identity } from "shared-runtime";

const DARK = "dark";

function Component() {
  const $ = _c(2);
  const theme = useTheme();

  const t0 = cx({
    "styles/light": true,
    "styles/dark": theme.getTheme() === DARK,
  });
  let t1;
  if ($[0] !== t0) {
    t1 = <div className={t0} />;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function cx(obj) {
  const classes = [];
  for (const [key, value] of Object.entries(obj)) {
    if (value) {
      classes.push(key);
    }
  }
  return classes.join(" ");
}

function useTheme() {
  return {
    getTheme() {
      return DARK;
    },
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Creating a Basic Custom Hook in React
DESCRIPTION: Defines a simple React hook 'useFoo' that returns the current state of a boolean value. It uses React's 'useState' to manage the state and returns an object with a function to access that state. No external dependencies beyond React are required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-hook-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper} from 'shared-runtime';
import {useState} from 'react';
function useFoo() {
  const [state, _setState] = useState(false);
  return {
    func() {
      return state;
    },
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useFoo),
  params: [{}],
};
```

----------------------------------------

TITLE: React Lint Error for Variable Reassignment
DESCRIPTION: An error message highlighting the React best practice of avoiding direct variable reassignment after render, recommending the use of state management instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-in-hook-return-value.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  2 |   let x = 0;
  3 |   return value => {
> 4 |     x = value;
    |     ^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `x` cannot be reassigned after render (4:4)
  5 |   };
  6 | }
```

----------------------------------------

TITLE: Optimizing React Component with Caching (JavaScript)
DESCRIPTION: This snippet shows an optimized version of the MyComponentName component. It uses caching to store previous prop values and their computed results, avoiding unnecessary recalculations when props haven't changed. It also includes development-specific read-only behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-emit-make-read-only.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { makeReadOnly } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @enableEmitFreeze true

function MyComponentName(props) {
  const $ = _c(3);
  let y;
  if ($[0] !== props.a || $[1] !== props.b) {
    const x = {};
    foo(x, props.a);
    foo(x, props.b);

    y = [];
    y.push(x);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = __DEV__ ? makeReadOnly(y, "MyComponentName") : y;
  } else {
    y = $[2];
  }
  return y;
}
```

----------------------------------------

TITLE: Testing React Fragments with react-is
DESCRIPTION: Shows how to identify React Fragment components using isFragment and typeOf functions.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_4

LANGUAGE: javascript
CODE:
```
import React from "react";
import * as ReactIs from 'react-is';

ReactIs.isFragment(<></>); // true
ReactIs.typeOf(<></>) === ReactIs.Fragment; // true
```

----------------------------------------

TITLE: Optimizing Functional Component Foo for React Compiler - JavaScript
DESCRIPTION: The second snippet reflects a more optimized version of the 'Foo' component, leveraging React's compiler runtime. It employs memoization techniques to avoid unnecessary re-evaluations of variables, making the component more efficient by checking dependencies before rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-hoists-other-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR

import { identity, makeArray, Stringify, useIdentity } from "shared-runtime";

function Foo(t0) {
  const $ = _c(8);
  const { a, cond } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = () => [a, a.b.c];
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const fn = t1;
  useIdentity(null);
  let x;
  if ($[2] !== a.b.c || $[3] !== cond) {
    x = makeArray();
    if (cond) {
      x.push(identity(a.b.c));
    }
    $[2] = a.b.c;
    $[3] = cond;
    $[4] = x;
  } else {
    x = $[4];
  }
  let t2;
  if ($[5] !== fn || $[6] !== x) {
    t2 = <Stringify fn={fn} x={x} shouldInvokeFns={true} />;
    $[5] = fn;
    $[6] = x;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ a: null, cond: true }],
  sequentialRenders: [
    { a: null, cond: true },
    { a: { b: { c: 4 } }, cond: true },
    { a: { b: { c: 4 } }, cond: true },
  ],
};
```

----------------------------------------

TITLE: Implementing React Component with Nested Functions and Logging
DESCRIPTION: This snippet defines a React component 'useFoo' that takes a prop 'value' and returns a number. It uses nested functions and includes logging statements. The component is exported as part of a FIXTURE_ENTRYPOINT object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables-nested-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableChangeVariableCodegen
import {identity} from 'shared-runtime';

const $ = 'module_$';
const t0 = 'module_t0';
const c_0 = 'module_c_0';
function useFoo(props: {value: number}): number {
  const a = () => {
    const b = () => {
      const c = () => {
        console.log($);
        console.log(t0);
        console.log(c_0);
        return identity(props.value);
      };
      return c;
    };
    return b;
  };
  return a()()();
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Compiled and Optimized Array Filtering in React
DESCRIPTION: This snippet shows the compiled and optimized version of the useArray function. It implements memoization for the filtered result and separates the filter callback into a standalone function. The compiler runtime is imported for optimization purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/todo_type-annotations-props.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableUseTypeAnnotations
function useArray(items) {
  const $ = _c(2);
  let t0;
  if ($[0] !== items) {
    t0 = items.filter(_temp);
    $[0] = items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function _temp(x) {
  return x !== 0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useArray,
  params: [[1, 0, 2, 0, 3, 0, 42]],
};
```

----------------------------------------

TITLE: Defining React Component with useMemo
DESCRIPTION: This snippet defines a React functional component that uses the useMemo hook. It attempts to create a memoized value based on an asynchronous operation, which is not valid as useMemo is meant for synchronous return values. The callback provided to useMemo cannot be an async function, leading to a runtime error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useMemo-async-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  let x = useMemo(async () => {
    await a;
  }, []);
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet shows the compiled version of the React component. It utilizes the '_c' function from 'react/compiler-runtime' for memoization. It checks if the prop 'a' has changed, and if so, re-executes the logic, updating a cache. Otherwise, it retrieves the previously computed value from the cache, optimizing for performance and avoiding unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";
function Component(t0) {
  const $ = _c(2);
  const { a } = t0;
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};
    const f0 = function () {
      y.x = x;
    };

    f0();
    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 2 }],
  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],
};

```

----------------------------------------

TITLE: Using GraphQL Fragment in React Component
DESCRIPTION: This snippet defines a React functional component that utilizes the 'useFragment' hook to fetch a GraphQL fragment for an item. It maps over the fetched items and renders each item using the 'renderItem' function. The component expects props containing an 'item' with GraphQL data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-logical.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useFragment} from 'shared-runtime';

function Component(props) {
  const item = useFragment(
    graphql`
      fragment F on T {
        id
      }
    `,
    props.item
  );
  return item.items?.map(item => renderItem(item)) ?? [];
}

```

----------------------------------------

TITLE: Incorrect React Component with Variable Reassignment
DESCRIPTION: This snippet demonstrates a React component that incorrectly reassigns variables within the component function. It attempts to destructure values from props.value and assign them to variables 'a' and 'b'. This approach violates React's rules for pure components and hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-destructure-to-local-global-variables.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let a;
  [a, b] = props.value;

  return [a, b];
}
```

----------------------------------------

TITLE: Optimized React Components with Compiler Runtime
DESCRIPTION: This snippet shows optimized versions of the four React components using React's compiler runtime. It includes memoization and early return optimizations to improve performance based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-early-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
/**
 * props.b does *not* influence `a`
 */
function ComponentA(props) {
  const $ = _c(5);
  let a_DEBUG;
  let t0;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.d) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      a_DEBUG = [];
      a_DEBUG.push(props.a);
      if (props.b) {
        t0 = null;
        break bb0;
      }

      a_DEBUG.push(props.d);
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.d;
    $[3] = a_DEBUG;
    $[4] = t0;
  } else {
    a_DEBUG = $[3];
    t0 = $[4];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return a_DEBUG;
}

/**
 * props.b *does* influence `a`
 */
function ComponentB(props) {
  const $ = _c(5);
  let a;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d
  ) {
    a = [];
    a.push(props.a);
    if (props.b) {
      a.push(props.c);
    }

    a.push(props.d);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = a;
  } else {
    a = $[4];
  }
  return a;
}

/**
 * props.b *does* influence `a`, but only in a way that is never observable
 */
function ComponentC(props) {
  const $ = _c(6);
  let a;
  let t0;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d
  ) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      a = [];
      a.push(props.a);
      if (props.b) {
        a.push(props.c);
        t0 = null;
        break bb0;
      }

      a.push(props.d);
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = a;
    $[5] = t0;
  } else {
    a = $[4];
    t0 = $[5];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return a;
}

/**
 * props.b *does* influence `a`
 */
function ComponentD(props) {
  const $ = _c(6);
  let a;
  let t0;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d
  ) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      a = [];
      a.push(props.a);
      if (props.b) {
        a.push(props.c);
        t0 = a;
        break bb0;
      }

      a.push(props.d);
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = a;
    $[5] = t0;
  } else {
    a = $[4];
    t0 = $[5];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: ComponentA,
  params: [{ a: 1, b: false, d: 3 }],
};
```

----------------------------------------

TITLE: React Component Definition with Conditional Logic (Input)
DESCRIPTION: This code snippet defines a functional React component named `Component` that takes `props` as input. It initializes a local variable `x` and assigns it a value based on the conditional `props.cond`. If `props.cond` is truthy, `x` is set to 1; otherwise, it's set to 2. The component then returns the value of `x`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-logical.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  props.cond ? (x = 1) : (x = 2);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Optimized useFoo Hook with Memoization in JavaScript
DESCRIPTION: This snippet shows an optimized version of the 'useFoo' hook using memoization techniques. It imports a compiler runtime function '_c' for caching and implements conditional logic to avoid unnecessary recalculations. The optimization aims to improve performance in React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables-nested-object-method.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableChangeVariableCodegen
import { identity } from "shared-runtime";

const $ = "module_$";
const t0 = "module_t0";
const c_0 = "module_c_0";
function useFoo(props) {
  const $0 = _c(2);
  const c_00 = $0[0] !== props;
  let t1;
  if (c_00) {
    const a = {
      foo() {
        const b = {
          bar() {
            console.log($);
            console.log(t0);
            console.log(c_0);
            return identity(props.value);
          },
        };
        return b;
      },
    };

    t1 = a.foo().bar();
    $0[0] = props;
    $0[1] = t1;
  } else {
    t1 = $0[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Importing and Memoization of React Component - JavaScript
DESCRIPTION: This snippet shows a React component utilizing memoization to cache rendered elements for performance improvement. The component checks a cache sentinel symbol and updates or returns a cached JSX element. It relies on a custom import from 'react/compiler-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-within-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0) {
  const $ = _c(1);
  const outer = _temp;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <div>{outer()}</div>;
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  return t1;
}
function _temp() {
  const inner = () => x;
  const x = 3;
  return inner();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimizing a React Div Component with Memoization - Javascript
DESCRIPTION: This snippet defines an optimized version of the 'useDiv' component that uses memoization for performance enhancements. It leverages React's compiler runtime to store and re-use rendered elements to avoid unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-hook-with-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
function useDiv(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

```

----------------------------------------

TITLE: Demonstrating Hoisting with shared-runtime in JavaScript
DESCRIPTION: This snippet imports a `print` function from the `shared-runtime` module to demonstrate JavaScript variable hoisting. The `hoisting` function takes a boolean parameter `cond` and prints different values for `x` based on this condition. Initial dependencies include the `shared-runtime` library for logging purposes. The function prints `1` if `cond` is true and `2` otherwise. It highlights the concept of variable hoisting in JavaScript where a later declared variable can overshadow the previous one within its scope.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-block-statements.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {print} from 'shared-runtime';

function hoisting(cond) {
  if (cond) {
    const x = 1;
    print(x);
  }

  const x = 2;
  print(x);
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [false],
};
```

----------------------------------------

TITLE: Defining React Component with Dynamic State Update
DESCRIPTION: This snippet defines a React component that uses destructuring, a closure, and state update. It demonstrates a simple component that renders a value from props after potential modification.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-array-declaration-to-context-var.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(props) {
  let [x] = props.value;
  const foo = () => {
    x = identity(props.value[0]);
  };
  foo();
  return <div>{x}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: [42]}],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiled version of the React component showing optimized memoization implementation using compiler runtime utilities. Implements the same functionality with manual cache checking and updating using an array-based caching system.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-nonmutating-loop-local-collection.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { ValidateMemoization } from "shared-runtime";

function Component(t0) {
  const $ = _c(19);
  const { a, b } = t0;
  let t1;
  let t2;
  if ($[0] !== a) {
    t2 = [a];
    $[0] = a;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const x = t1;
  let t3;
  let items;
  if ($[2] !== b || $[3] !== x) {
    items = [b];
    for (const i of x) {
      items.push(i);
    }
    $[2] = b;
    $[3] = x;
    $[4] = items;
  } else {
    items = $[4];
  }

  t3 = items;
  const y = t3;
  let t4;
  if ($[5] !== a) {
    t4 = [a];
    $[5] = a;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== t4 || $[8] !== x) {
    t5 = <ValidateMemoization inputs={t4} output={x} />;
    $[7] = t4;
    $[8] = x;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== b || $[11] !== x) {
    t6 = [x, b];
    $[10] = b;
    $[11] = x;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  let t7;
  if ($[13] !== t6 || $[14] !== y) {
    t7 = <ValidateMemoization inputs={t6} output={y} />;
    $[13] = t6;
    $[14] = y;
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  let t8;
  if ($[16] !== t5 || $[17] !== t7) {
    t8 = (
      <>
        {t5}
        {t7}
      </>
    );
    $[16] = t5;
    $[17] = t7;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  return t8;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 0, b: 0 }],
  sequentialRenders: [
    { a: 1, b: 0 },
    { a: 1, b: 1 },
    { a: 0, b: 1 },
  ],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that creates a context object with a memoized value using the identity function. The component takes props with a value parameter and returns a context object with a key-value pair.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-constant-string.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(props) {
  const key = 'KeyName';
  const context = {
    [key]: identity([props.value]),
  };
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Lazy Loading Legacy React Components
DESCRIPTION: Demonstrates how to lazily load legacy React components using a custom helper function similar to 'React.lazy'. This technique helps load the legacy bundle only when required, enhancing application performance.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_2

LANGUAGE: JavaScript
CODE:
```
import lazyLegacyRoot from './lazyLegacyRoot';

// Lazy-load a component from the bundle using legacy React.
const Greeting = lazyLegacyRoot(() => import('../legacy/Greeting'));

function AboutPage() {
  return (
    <>
      <h3>This component is rendered by React ({React.version}).</h3>
      <Greeting />
    </>
  );
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React functional component that conditionally renders nested components based on an optional chained property. Takes props v1 and v2, and renders different component structures based on v5's value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-propagate-type-of-ternary-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function V0({v1, v2}: V3<{v1: any, v2: V4}>): V12.V11 {
  const v5 = v1.v6?.v7;
  return (
    <Component8 c9={va} cb="apqjx">
      {v5 != null ? (
        <ComponentC cd={v5}>
          <ComponentE cf={v1} c10={v2} />
        </ComponentC>
      ) : (
        <ComponentE cf={v1} c10={v2} />
      )}
    </Component8>
  );
}
```

----------------------------------------

TITLE: React Component Definition with Conditional Logic
DESCRIPTION: Defines a React component named `Foo` that accepts `a` and `cond` props. It utilizes optional chaining (`a.b?.c.d`, `a.b?.c.e`) to safely access nested properties of the `a` prop. The component conditionally pushes values into an array based on the `cond` prop and then renders a `Stringify` component with the derived data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-optional-hoists-other-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR

import {identity, makeArray, Stringify, useIdentity} from 'shared-runtime';

function Foo({a, cond}) {
  // Assume fn can be uncond evaluated, so we can safely evaluate a.b?.c.<any>
  const fn = () => [a, a.b?.c.d];
  useIdentity(null);
  const arr = makeArray();
  if (cond) {
    arr.push(identity(a.b?.c.e));
  }
  return <Stringify fn={fn} arr={arr} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{a: null, cond: true}],
  sequentialRenders: [
    {a: null, cond: true},
    {a: {b: {c: {d: 5}}}, cond: true},
    {a: {b: null}, cond: false},
  ],
};

```

----------------------------------------

TITLE: Accessing React Context
DESCRIPTION: This code snippet demonstrates how to access context values using the `useContext` hook in a functional React component. It retrieves `foo` and `bar` properties from the `MyContext` and passes them as props to the `Bar` component. The `@lowerContextAccess` comment likely indicates compiler optimizations related to context access.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-property-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @lowerContextAccess
function App() {
  const context = useContext(MyContext);
  const foo = context.foo;
  const bar = context.bar;
  return <Bar foo={foo} bar={bar} />;
}

```

----------------------------------------

TITLE: Defining React Component Using useEffect
DESCRIPTION: This snippet defines a simple React component that utilizes the useEffect hook to set a property on an object. The component does not take any parameters, and its main purpose is to showcase how useEffect can be used to manipulate external objects upon rendering. Since React is a fundamental library for building UI components, it is essential to have it as a dependency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-method-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
let x = {};
function Component() {
  React.useEffect(() => {
    x.foo = 1;
  });
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: React Component with Nested Factorial Function
DESCRIPTION: This code defines a React component `Foo` that calculates the factorial of a fixed value (3) using nested functions `outer` and `fact`. The `outer` function takes a value and calls the `fact` function to compute its factorial.  The component returns the result of the factorial calculation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-recursive-call-within-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo({}) {
  const outer = val => {
    const fact = x => {
      if (x <= 0) {
        return 1;
      }
      return x * fact(x - 1);
    };
    return fact(val);
  };
  return outer(3);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}]
};

```

----------------------------------------

TITLE: Implementing Memoized React Component in JavaScript/JSX
DESCRIPTION: This code defines a React component named TestComponent that uses a custom memoization technique. It checks if the 'x' prop has changed and only updates the rendered Button component when necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/function-scope-beats-module-scope-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function TestComponent(t0) {
  "use memo";
  const $ = _c(2);
  const { x } = t0;
  let t1;
  if ($[0] !== x) {
    t1 = <Button>{x}</Button>;
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: Defines a React component named `Component` that receives `props` as input.  It initializes a variable `x` and defines an `onChange` handler that may mutate `x`. The component conditionally renders `x` and returns a `Foo` component with `x` as the `value` prop. The `onChange` function is called.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-function-expression-captures-value-later-frozen.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = {};
  // onChange should be inferred as immutable, because the value
  // it captures (`x`) is frozen by the time the function is referenced
  const onChange = e => {
    maybeMutate(x, e.target.value);
  };
  if (props.cond) {
    <div>{x}</div>;
  }
  // ideally this call would be outside the memoization block for `x`
  onChange();
  return <Foo value={x} />;
}

```

----------------------------------------

TITLE: Implementing React Component Functionality in JavaScript
DESCRIPTION: This snippet demonstrates the creation of a React component function called 'Foo' that utilizes the 'useRef' hook to access a mutable reference. It takes an object argument, extracts property 'a', and combines it with the current ref value to pass to the 'VideoList' component. It highlights the use of hooks for component state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-not-added-to-dep-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender:false
function Foo({a}) {
  const ref = useRef();
  const x = {a, val: ref.current};

  return <VideoList videos={x} />;
}

```

----------------------------------------

TITLE: React Component with Local Reassignment
DESCRIPTION: This React component defines a local variable `local` and a function `reassignLocal` that attempts to reassign its value. The `onClick` handler calls `reassignLocal` and then checks if the reassignment was successful. The purpose is to demonstrate an issue with React's rendering behavior when reassigning local variables in functions that escape.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-jsx-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let local;

  const reassignLocal = newValue => {
    local = newValue;
  };

  const onClick = newValue => {
    reassignLocal('hello');

    if (local === newValue) {
      // Without React Compiler, `reassignLocal` is freshly created
      // on each render, capturing a binding to the latest `local`,
      // such that invoking reassignLocal will reassign the same
      // binding that we are observing in the if condition, and
      // we reach this branch
      console.log('`local` was updated!');
    } else {
      // With React Compiler enabled, `reassignLocal` is only created
      // once, capturing a binding to `local` in that render pass.
      // Therefore, calling `reassignLocal` will reassign the wrong
      // version of `local`, and not update the binding we are checking
      // in the if condition.
      //
      // To protect against this, we disallow reassigning locals from
      // functions that escape
      throw new Error('`local` not updated!');
    }
  };

  return <button onClick={onClick}>Submit</button>;
}
```

----------------------------------------

TITLE: Compiler-Optimized React Component Implementation
DESCRIPTION: An optimized version of the React component using React compiler runtime with memoization and cached computations
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-nested-lambdas.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableTransitivelyFreezeFunctionExpressions:false

function Component(props) {
  const $ = _c(7);
  const item = useMutable(props.itemId);
  const dispatch = useDispatch();
  useFreeze(dispatch);
  let t0;
  if ($[0] !== dispatch) {
    t0 = () => {
      dispatch(createExitAction());
    };
    $[0] = dispatch;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const exit = t0;
  let t1;
  let t2;
  if ($[2] !== exit || $[3] !== item) {
    t1 = () => {
      const cleanup = GlobalEventEmitter.addListener("onInput", () => {
        if (item.value) {
          exit();
        }
      });
      return () => cleanup.remove();
    };
    t2 = [exit, item];
    $[2] = exit;
    $[3] = item;
    $[4] = t1;
    $[5] = t2;
  } else {
    t1 = $[4];
    t2 = $[5];
  }
  useEffect(t1, t2);

  maybeMutate(item);
  let t3;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = <div />;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}
```

----------------------------------------

TITLE: Memoized Component with React Compiler Optimizations (Compiled Version)
DESCRIPTION: The compiled version of the Component with React compiler optimizations applied. It uses memoization to avoid recreating the object on every render by tracking dependencies on props.cond and props.value. The code utilizes a React compiler runtime helper (_c) to manage the cached state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/object-mutated-in-consequent-alternate-both-return.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { makeObject_Primitives } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.cond || $[1] !== props.value) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const object = makeObject_Primitives();
      if (props.cond) {
        object.value = 1;
        t0 = object;
        break bb0;
      } else {
        object.value = props.value;
        t0 = object;
        break bb0;
      }
    }
    $[0] = props.cond;
    $[1] = props.value;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: false, value: [0, 1, 2] }],
};
```

----------------------------------------

TITLE: React forwardRef with Hooks
DESCRIPTION: This code snippet demonstrates the usage of React's `forwardRef` with hooks. It shows that hooks can be used within the anonymous function provided as an argument to `forwardRef`. The `FancyButton` component forwards its ref to the underlying button element and uses a hook named `useHook`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-e66a744cffbe.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because hooks can be used in anonymous function arguments to
// forwardRef.
const FancyButton = forwardRef(function (props, ref) {
  useHook();
  return <button {...props} ref={ref} />;
});

```

----------------------------------------

TITLE: React Component with Multiple FBT Enums
DESCRIPTION: A React component that attempts to use multiple fbt:enum tags within a single FBT component for internationalization. The component takes two props 'a' and 'b' and tries to display them as enumerated values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-fbt-unknown-enum-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component({a, b}) {
  return (
    <fbt desc="Description">
      <fbt:enum enum-range={['avalue1', 'avalue1']} value={a} />{' '}
      <fbt:enum enum-range={['bvalue1', 'bvalue2']} value={b} />
    </fbt>
  );
}
```

----------------------------------------

TITLE: Defining React Component with fbt Internationalization
DESCRIPTION: This snippet defines a React component that uses fbt for internationalization. It handles pluralization of 'vote' based on count and inserts a parameter for the voting option.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-leading-whitespace.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';
import {identity} from 'shared-runtime';

function Component(props) {
  return (
    <span>
      <fbt desc="Title">
        <fbt:plural count={identity(props.count)} name="count" showCount="yes">
          vote
        </fbt:plural>{' '}
        for <fbt:param name="option"> {props.option}</fbt:param>
      </fbt>
      !
    </span>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{count: 42, option: 'thing'}],
  sequentialRenders: [
    {count: 42, option: 'thing'},
    {count: 42, option: 'thing'},
    {count: 1, option: 'other'},
    {count: 1, option: 'other'},
    {count: 42, option: 'thing'},
    {count: 1, option: 'other'},
    {count: 42, option: 'thing'},
    {count: 1, option: 'other'},
  ],
};
```

----------------------------------------

TITLE: Defining React Component with Flow and Default Array Destructuring
DESCRIPTION: This snippet defines a React component using Flow type annotations. It demonstrates default array destructuring in the component's props. The component extracts an array from props.y with a default empty array of numbers.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-with-typecast-as-default-value.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow
function Component(props) {
  const [x = ([]: Array<number>)] = props.y;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{y: []}],
};
```

----------------------------------------

TITLE: Invalid React useContext Mutation Error
DESCRIPTION: This error message indicates that a value returned from `useContext()` is being mutated, which is not allowed in React.  Specifically, it points to the line where `FooContext.current` is being set to `true`. React context should be updated using a state management solution (e.g., useState, useReducer) or a dedicated context provider that handles updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-context-in-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  10 |   // independently
  11 |   const onClick = () => {
> 12 |     FooContext.current = true;
     |     ^^^^^^^^^^ InvalidReact: Mutating a value returned from 'useContext()', which should not be mutated. Found mutation of `FooContext` (12:12)
  13 |   };
  14 |   return <div onClick={onClick} />;
  15 | }

```

----------------------------------------

TITLE: Defining React component with conflicting global variable
DESCRIPTION: This code defines a React component named `useFoo` that takes `props` as input. Inside the component, it declares a local variable `__DEV__` and initializes it with a string value. The component then logs the value of the local `__DEV__` and returns the result of calling the `foo` function with `props.x` as its argument. The snippet highlights a common issue when a local variable name accidentally shadows a global variable, potentially leading to unexpected behavior or compilation errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.emit-freeze-conflicting-global.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableEmitFreeze @instrumentForget
function useFoo(props) {
  const __DEV__ = 'conflicting global';
  console.log(__DEV__);
  return foo(props.x);
}

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that uses useCallback and custom primitives for memoization. It creates objects using makeObject_Primitives and handles mutations with a callback function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-maybe-modify-free-variable-preserve-memoization-guarantee.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';
import {identity, makeObject_Primitives, mutate, useHook} from 'shared-runtime';

function Component(props) {
  const free = makeObject_Primitives();
  const free2 = makeObject_Primitives();
  const part = free2.part;
  useHook();
  const callback = useCallback(() => {
    const x = makeObject_Primitives();
    x.value = props.value;
    mutate(x, free, part);
  }, [props.value]);
  mutate(free, part);
  return callback;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Error Handling in React Component Memoization
DESCRIPTION: This portion of the file highlights an error related to memoization preservation within a React component. It suggests that the dependencies inferred for the 'useMemo' hook do not align with those specified manually, which can lead to unexpected behavior in rendering. The error indicates that existing manual memoization has been bypassed, necessitating a review of the dependency array passed to 'useMemo'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-member-expression-with-conditional-optional.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
   2 | import {ValidateMemoization} from 'shared-runtime';
   3 | function Component(props) {
>  4 |   const data = useMemo(() => {
     |                        ^^^^^^^
>  5 |     const x = [];
     | ^^^^^^^^^^^^^^^^^
>  6 |     x.push(props?.items);
     | ^^^^^^^^^^^^^^^^^
>  7 |     if (props.cond) {
     | ^^^^^^^^^^^^^^^^^
>  8 |       x.push(props?.items);
     | ^^^^^^^^^^^^^^^^^
>  9 |     }
     | ^^^^^^^^^^^^^^^^^
> 10 |     return x;
     | ^^^^^^^^^^^^^^^^^
> 11 |   }, [props?.items, props.cond]);
     | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (4:11)
  12 |   return (
  13 |     <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />
  14 |   );
}
```

----------------------------------------

TITLE: Managing Reactivity in React Component
DESCRIPTION: Defines a React component function that manages two independent states 'a' and 'b,' which become interdependently reactive due to interleaved operations. It demonstrates the control flow logic to manage dependencies reactively, returning a reactive array based on the provided prop. Importantly, 'x' is treated reactively as it indirectly depends on the reactive 'c'. There are no external dependencies beyond standard JavaScript and React environment. Inputs and outputs revolve around a props object and a returned array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-init.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a and b are independent but their mutations are interleaved, so
  // they get grouped in a reactive scope. this means that a becomes
  // reactive since it will effectively re-evaluate based on a reactive
  // input
  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(0);

  // Downstream consumer of a, which initially seems non-reactive except
  // that a becomes reactive, per above
  const c = [a];

  let x;
  for (let i = c[0][0]; i < 10; i++) {
    x = 1;
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `c[0]` which becomes reactive via
  // being interleaved with `b`.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};

```

----------------------------------------

TITLE: Defining React Component with Conditional Rendering in JavaScript
DESCRIPTION: This snippet defines a React component 'Foo' that uses conditional rendering based on a 'cond' prop. It also includes a fixture for testing sequential renders with different conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-scopes-begin-same-instr-valueblock.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate} from 'shared-runtime';

function Foo({cond}) {
  const x = identity(identity(cond)) ? {a: 2} : {b: 2};

  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{cond: false}],
  sequentialRenders: [{cond: false}, {cond: false}, {cond: true}, {cond: true}],
};
```

----------------------------------------

TITLE: Implementing HomeDiscoStoreItemTileRating Component in React
DESCRIPTION: This snippet shows the original implementation of a React component that calculates and displays a rating count based on aggregated data. It uses the useFragment hook and iterates over an array to compute the total count.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-scope-missing-mutable-range.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function HomeDiscoStoreItemTileRating(props) {
  const item = useFragment();
  let count = 0;
  const aggregates = item?.aggregates || [];
  aggregates.forEach(aggregate => {
    count += aggregate.count || 0;
  });

  return <Text>{count}</Text>;
}
```

----------------------------------------

TITLE: Using getNumber in useFoo with Error Handling - JavaScript
DESCRIPTION: This snippet defines a React hook 'useFoo' that attempts to retrieve a number using the 'getNumber' function from the shared runtime. It handles potential errors silently, ensuring that the application can continue running even if the retrieval fails. The exported 'FIXTURE_ENTRYPOINT' prepares this hook for use in other parts of the application, with no parameters required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/empty-catch-statement.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {getNumber} from 'shared-runtime';

function useFoo() {
  try {
    return getNumber();
  } catch {} 
}
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: React InvalidReact Error Message
DESCRIPTION: This error message highlights an attempt to access the `current` property of a ref during the render phase of a React component. According to React best practices, refs should be accessed within event handlers or effects to avoid side effects during rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-arbitrary.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   6 | component C() {
   7 |   const r = useRef(DEFAULT_VALUE);
>  8 |   if (r.current == DEFAULT_VALUE) {
     |       ^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (8:8)

InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (9:9)
   9 |     r.current = 1;
  10 |   }
  11 | }
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the component using React's compiler runtime. It implements memoization to avoid unnecessary re-computations and array creations. The optimization includes conditional checks to update values only when necessary, potentially improving performance in re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-property-inference.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(5);
  let x;
  if ($[0] !== props.value) {
    x = [];
    x.push(props.value);
    $[0] = props.value;
    $[1] = x;
  } else {
    x = $[1];
  }
  const { length: y } = x;
  foo(y);
  let t0;
  if ($[2] !== x || $[3] !== y) {
    t0 = [x, y];
    $[2] = x;
    $[3] = y;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimizing Property Mutations in React with JavaScript
DESCRIPTION: Implements an optimized version of the useFoo function where it avoids unnecessary mutations by tracking previous property values. The code leverages react/compiler-runtime for improved dependency checks and efficient state management. It addresses property changes efficiently by reducing redundant operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { mutate } from "shared-runtime";

function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    x = [];
    x.push(props.bar);
    if (props.cond) {
      x = [];
      x.push(props.foo);
    } else {
      x = [];
      x.push(props.bar);
    }

    mutate(x);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ bar: "bar", foo: "foo", cond: true }],
  sequentialRenders: [
    { bar: "bar", foo: "foo", cond: true },
    { bar: "bar", foo: "foo", cond: true },
    { bar: "bar", foo: "foo", cond: false },
  ],
};

```

----------------------------------------

TITLE: Optimized React Component Function Using Compiler Runtime
DESCRIPTION: This snippet shows the optimized version of the 'foo' function using React's compiler runtime. It implements memoization for object creation and method calls, improving performance by avoiding unnecessary recalculations when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call-computed.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(8);
  let t0;
  if ($[0] !== a) {
    t0 = makeObject(a);
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  let t1;
  if ($[2] !== a) {
    t1 = makeObject(a);
    $[2] = a;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const y = t1;
  let t2;
  if ($[4] !== b || $[5] !== x || $[6] !== y.method) {
    t2 = x[y.method](b);
    $[4] = b;
    $[5] = x;
    $[6] = y.method;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  const z = t2;
  return z;
}
```

----------------------------------------

TITLE: Measuring Rendering Time - React - JavaScript
DESCRIPTION: This snippet defines a simple React component that measures the time taken for rendering by capturing the start time and calculating the difference when rendering is complete. It returns a div that displays the rendering time along with the current timestamp.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/timers.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const start = performance.now();
  const now = Date.now();
  const time = performance.now() - start;
  return (
    <div>
      rendering took {time} at {now}
    </div>
  );
}
```

----------------------------------------

TITLE: Defining React Component with Complex Logic
DESCRIPTION: This code defines a React functional component named `MyComponent` that includes a significant number of conditional statements (`if/else`) and React hooks (`useHook`). The purpose is to simulate a component with high complexity, making it harder to compute efficiently. The function `useHook` is assumed to be a predefined or imported hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-c1e8c7f4c191.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Is valid but hard to compute by brute-forcing
function MyComponent() {
  // 40 conditions
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }
  if (c) {
  } else {
  }

  // 10 hooks
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
}

```

----------------------------------------

TITLE: Original React Component Function
DESCRIPTION: A simple React component that creates objects from props, calls a method conditionally, and returns the result. The component performs several potentially expensive operations without any manual memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-receiver-method-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeOptionalObject(props);
  const y = makeObject(props);
  const z = x?.method(y.a, props.a, foo(y.b), bar(props.b));
  return z;
}
```

----------------------------------------

TITLE: Input React Component with Array Destructuring
DESCRIPTION: Original React component using array destructuring with a conditional expression as default value. Props receive an array 'y' which is destructured with a default ternary expression.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-with-conditional-as-default-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [x = true ? 1 : 0] = props.y;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{y: []}],
};
```

----------------------------------------

TITLE: Creating a React Component with State Mutation - JavaScript
DESCRIPTION: This snippet defines a React functional component named 'Component' which attempts to manage its internal state using an array. It pushes a value from props into this array and renders it within a div. However, it demonstrates an error since modifying the value after it has been declared in JSX is not allowed. The component aims to show the misuse of state management in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-array-push-frozen.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Component(props) {
  const x = [];
  <div>{x}</div>;
  x.push(props.value);
  return x;
}
```

----------------------------------------

TITLE: Invalid Component with JSX in Try/Catch Blocks
DESCRIPTION: The original component function attempts to render a JSX element inside a catch block, which is invalid in React. This pattern is flagged by the React compiler as it violates React's error boundary pattern.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-catch-in-outer-try-with-catch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger @validateNoJSXInTryStatements
import {identity} from 'shared-runtime';

function Component(props) {
  let el;
  try {
    let value;
    try {
      value = identity(props.foo);
    } catch {
      el = <div value={value} />;
    }
  } catch {
    return null;
  }
  return el;
}
```

----------------------------------------

TITLE: Creating and Using ReactTestRenderer with JSX
DESCRIPTION: This snippet demonstrates how to use the react-test-renderer package to render a Link component to a JavaScript object and display its JSON representation. The renderer creates a pure JavaScript object representation of the component tree without requiring a browser or jsdom.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-test-renderer/README.md#2025-04-21_snippet_0

LANGUAGE: jsx
CODE:
```
const ReactTestRenderer = require('react-test-renderer');

const renderer = ReactTestRenderer.create(
  <Link page="https://www.facebook.com/">Facebook</Link>
);

console.log(renderer.toJSON());
// { type: 'a',
//   props: { href: 'https://www.facebook.com/' },
//   children: [ 'Facebook' ] }
```

----------------------------------------

TITLE: Refactored React Component with Destructuring in JavaScript
DESCRIPTION: This snippet is a refactored version of the previous function 'foo'. It separates variable declarations and uses a slightly different formatting for object destructuring. The FIXTURE_ENTRYPOINT export remains the same.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-direct-reassignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let x;
  let y;
  ({ x, y } = { x: props.a, y: props.b });
  console.log(x);
  x = props.c;
  return x + y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Invalid Hook Usage in React Component
DESCRIPTION: Demonstrates incorrect usage of a React Hook by assigning it to a variable in a conditional expression. This violates the Rules of Hooks by treating a hook as a normal value rather than calling it directly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-call-phi-possibly-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // This is a violation of using a hook as a normal value rule:
  const getUser = props.cond ? useGetUser : emptyFunction;

  // Ideally we would report a "conditional hook call" error here.
  // It's an unconditional call, but the value may or may not be a hook.
  // TODO: report a conditional hook call error here
  return getUser();
}
```

LANGUAGE: text
CODE:
```
  1 | function Component(props) {
  2 |   // This is a violation of using a hook as a normal value rule:
> 3 |   const getUser = props.cond ? useGetUser : emptyFunction;
    |                                ^^^^^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)

InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)

InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (8:8)
  4 |
  5 |   // Ideally we would report a "conditional hook call" error here.
  6 |   // It's an unconditional call, but the value may or may not be a hook.
```

----------------------------------------

TITLE: Defining Functions with useState Hook in JavaScript
DESCRIPTION: This snippet showcases different function definitions (function declarations, expressions, and arrow functions) that all attempt to call the useState hook. It highlights invalid patterns that do not conform to the PascalCase or useFoo naming convention for hooks. The required context indicates that currently only certain naming formats are accepted for hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-fadd52c1e460.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Unsupported input

// Currently invalid.
// These are variations capturing the current heuristic--
// we only allow hooks in PascalCase or useFoo functions.
// We *could* make some of these valid. But before doing it,
// consider specific cases documented above that contain reasoning.
function a() {
  useState();
}
const whatever = function b() {
  useState();
};
const c = () => {
  useState();
};
let d = () => useState();
e = () => {
  useState();
};
({
  f: () => {
    useState();
  },
});
({
  g() {
    useState();
  },
});
const {
  j = () => {
    useState();
  },
} = {};
({
  k = () => {
    useState();
  },
} = {});

```

----------------------------------------

TITLE: Illustrating JavaScript Hoisting without Local Variable Shadowing
DESCRIPTION: This code snippet simplifies the example by removing the local `x` declaration in the `if` block, using the `print` function from `shared-runtime` module to illustrate hoisting. The `hoisting` function prints `1` if `cond` is true, otherwise prints `2`. The snippet is dependent on the shared-runtime for the print functionality. It highlights the absence of variable re-declaration's impact, showcasing hoisting effect clearly with each scenario.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-block-statements.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { print } from "shared-runtime";

function hoisting(cond) {
  if (cond) {
    print(1);
  }

  print(2);
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [false],
};
```

----------------------------------------

TITLE: Original React Component with Switch Statement
DESCRIPTION: Original React component function that processes props through a switch statement, manipulates arrays, and renders nested components. The component demonstrates conditional branching and child component rendering based on props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-non-final-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [];
  let y;
  switch (props.p0) {
    case 1: {
      break;
    }
    case true: {
      x.push(props.p2);
      y = [];
    }
    default: {
      break;
    }
    case false: {
      y = x;
      break;
    }
  }
  const child = <Component data={x} />;
  y.push(props.p4);
  return <Component data={y}>{child}</Component>;
}
```

----------------------------------------

TITLE: Input: React Component with Passive Effect State Update
DESCRIPTION: Initial React component demonstrating a state update within a useEffect and setTimeout mechanism, with a validation annotation for passive effects
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/valid-setState-in-useEffect-listener-transitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoSetStateInPassiveEffects
import {useEffect, useState} from 'react';

function Component() {
  const [state, setState] = useState(0);
  useEffect(() => {
    const f = () => {
      setState();
    };
    setTimeout(() => f(), 10);
  });
  return state;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Conditional Logic in React Component - JavaScript
DESCRIPTION: This snippet defines a React component that takes props to determine the value of 'x' based on several conditions. It processes the props and sets 'x' according to the values provided. Additionally, it constructs a FIXTURE_ENTRYPOINT containing the component function and metadata for possible integration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reverse-postorder.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  if (props.cond) {
    switch (props.test) {
      case 0: {
        x = props.v0;
        break;
      }
      case 1: {
        x = props.v1;
        break;
      }
      case 2: {
      }
      default: {
        x = props.v2;
      }
    }
  } else {
    if (props.cond2) {
      x = props.b;
    } else {
      x = props.c;
    }
  }
  x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining Component Logic in JavaScript
DESCRIPTION: This snippet defines a React functional component that creates two objects using a hypothetical 'makeObject' function and evaluates a conditional expression to determine which property to use based on the objects and props. It demonstrates how to manage dependencies on prop values using logical operators.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-logical-assigned-to-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // unused!
  const obj = makeObject();
  const obj2 = makeObject();
  const _ = (obj.a ?? obj2.b) || props.c;
  return null;
}

```

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const obj = makeObject();
  const obj2 = makeObject();
  (obj.a ?? obj2.b) || props.c;
  return null;
}

```

----------------------------------------

TITLE: Defining and Exporting React Component with Parameters - JavaScript
DESCRIPTION: This snippet defines a simple component function that takes an array as an argument, processes it into separate objects, and returns an array of these objects. It exports a constant that sets the component function with its parameters, specifying that it's not a component. It requires the use of JavaScript and is intended for use in a React environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-pattern-params.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component([a, b]) {
  let y = {a};
  let z = {b};
  return [y, z];
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [['val1', 'val2']],
  isComponent: false,
};

```

----------------------------------------

TITLE: Implementing useMakeCallback Hook with Nested Callback Functions in React
DESCRIPTION: A custom React hook that demonstrates callback handling with conditional execution. This hook creates a callback that accesses object properties, showcasing how React compiler can optimize property loads in nested functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/function-with-conditional-callsite-in-another-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper} from 'shared-runtime';

/**
 * (Given that the returned lambda is assumed to be invoked, see
 * return-function)
 *
 * If lambda A conditionally calls lambda B, optimistically assume that property
 * loads from lambda B has the same hoistability of ones from lambda A. This
 * helps optimize components / hooks that create and chain many helper
 * functions.
 *
 * Type systems and code readability encourage developers to colocate length and
 * null checks values in the same function as where values are used. i.e.
 * developers are unlikely to write the following code.
 * ```js
 * function useFoo(obj, objNotNullAndHasElements) {
 *   // ...
 *   const get0th = () => obj.arr[0].value;
 *   return () => objNotNullAndHasElements ? get0th : undefined;
 * }
 * ```
 *
 * In Meta code, this assumption helps reduce the number of memo dependency
 * deopts.
 */
function useMakeCallback({
  obj,
  cond,
  setState,
}: {
  obj: {value: number};
  cond: boolean;
  setState: (newState: number) => void;
}) {
  const cb = () => setState(obj.value);
  // cb's property loads are assumed to be hoistable to the start of this lambda
  return () => (cond ? cb() : undefined);
}

const setState = (arg: number) => {
  'use no memo';
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useMakeCallback),
  params: [{obj: {value: 1}, cond: true, setState}],
  sequentialRenders: [
    {obj: {value: 1}, cond: true, setState},
    {obj: {value: 2}, cond: true, setState},
  ],
};
```

----------------------------------------

TITLE: React Error Handling for Ref Access
DESCRIPTION: This snippet outlines the error message resulting from invalid access of the `current` property of a ref during the render phase in React. It indicates the specific line of code causing the issue and provides a link for further reference on React's rules regarding ref access.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-write-but-dont-read-ref-in-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  3 |   const ref = useRef(null);
  4 |   // Writing to a ref in render is against the rules:
> 5 |   ref.current = value;
    |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)
  6 |   // returning a ref is allowed, so this alone doesn't trigger an error:
  7 |   return ref;
  8 | }
```

----------------------------------------

TITLE: Defining Unoptimized React Component in JavaScript
DESCRIPTION: This snippet defines a simple React component that creates an array from the 'items' prop. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-multiple-variable-declarations-in-initializer.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const items = [];

  for (let i = 0, length = props.items.length; i < length; i++) {
    items.push(props.items[i]);
  }

  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{items: ['a', 'b', 42]}],
};
```

----------------------------------------

TITLE: Input React Component with Memoization Preservation
DESCRIPTION: Demonstrates a React component using useMemo to create and memoize objects with controlled mutability and runtime optimizations
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-mabye-modified-free-variable-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {identity, makeObject_Primitives, mutate, useHook} from 'shared-runtime';

function Component(props) {
  const free = makeObject_Primitives();
  const free2 = makeObject_Primitives();
  const part = free2.part;

  useHook();

  const object = useMemo(() => {
    const x = makeObject_Primitives();
    x.value = props.value;
    mutate(x, free, part);
    return x;
  }, [props.value, free, part]);

  identity(free);
  identity(part);

  return object;
}
```

----------------------------------------

TITLE: React Component with Invalid useState Hook
DESCRIPTION: This code snippet defines a `List` component that takes `items` as props and attempts to render each item using the `renderItem` function. The `renderItem` function attempts to use the `useState` hook, which is invalid in this context because hooks must be called at the top level of a function component or custom hook. The intention is to demonstrate an incorrect usage of `useState` and its expected failure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-e675f0a672d8.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function renderItem() {
  useState();
}

function List(props) {
  return props.items.map(renderItem);
}

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Defines a React component that initializes an array from a nullable value and adds a prop to it. Uses nullish coalescing operator for default empty array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-iife-return-modified-later-logical.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {getNull} from 'shared-runtime';

function Component(props) {
  const items = (() => {
    return getNull() ?? [];
  })();
  items.push(props.a);
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: {}}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet shows the compiled JavaScript version of the React component. It includes memoization logic using the '_c' function from 'react/compiler-runtime' to optimize performance by caching computed values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-satisfies-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableUseTypeAnnotations
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.id) {
    t0 = makeArray(props.id);
    $[0] = props.id;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0 satisfies number[];
  let t1;
  if ($[2] !== x) {
    t1 = x.at(0);
    $[2] = x;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const y = t1;
  return y;
}

function makeArray(x) {
  const $ = _c(2);
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 42 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with explicit memoization checks and render optimizations. Includes compiler-generated code for tracking prop changes and memoizing render output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-conditional.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { ValidateMemoization } from "shared-runtime";
import { use, useMemo } from "react";

const FooContext = React.createContext(null);
function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.cond) {
    t0 = <Inner cond={props.cond} />;
    $[0] = props.cond;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== props.value || $[3] !== t0) {
    t1 = <FooContext.Provider value={props.value}>{t0}</FooContext.Provider>;
    $[2] = props.value;
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}

function Inner(props) {
  const $ = _c(7);
  let input;
  input = null;
  if (props.cond) {
    input = use(FooContext);
  }

  input;
  let t0;
  let t1;
  if ($[0] !== input) {
    t1 = [input];
    $[0] = input;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const output = t0;
  let t2;
  if ($[2] !== input) {
    t2 = [input];
    $[2] = input;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== output || $[5] !== t2) {
    t3 = <ValidateMemoization inputs={t2} output={output} />;
    $[4] = output;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, value: 42 }],
  sequentialRenders: [
    // change cond true->false
    { cond: true, value: 42 },
    { cond: false, value: 42 },

    // change value
    { cond: false, value: null },
    { cond: false, value: 42 },

    // change cond false->true
    { cond: true, value: 42 },

    // change cond true->false, change unobserved value, change cond false->true
    { cond: false, value: 42 },
    { cond: false, value: null },
    { cond: true, value: 42 },
  ],
};
```

----------------------------------------

TITLE: React Component with Object Property Iteration
DESCRIPTION: A React component that spreads props.value into a new object, iterates through its properties, and attempts to mutate the last property name. Includes a test fixture with sample input values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-type-inference.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {identity, mutate} = require('shared-runtime');

function Component(props) {
  let x;
  const object = {...props.value};
  for (const y in object) {
    x = y;
  }
  mutate(x); // can't modify, x is known primitive!
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: {a: 'a', b: 'B', c: 'C!'}}],
};
```

LANGUAGE: javascript
CODE:
```
const { identity, mutate } = require("shared-runtime");

function Component(props) {
  let x;
  const object = { ...props.value };
  for (const y in object) {
    x = y;
  }

  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: { a: "a", b: "B", c: "C!" } }],
};
```

----------------------------------------

TITLE: Compiled JavaScript Function
DESCRIPTION: This is the compiled version of the `foo` function, optimized using React's compiler. It uses `_c` from `react/compiler-runtime` to memoize the function's result based on the input `a`. It checks if the input `a` has changed, and if so, executes the original logic. Otherwise, it reuses the previously computed value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-alias-mutate-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";\nfunction foo(a) {\n  const $ = _c(2);\n  let x;\n  if ($[0] !== a) {\n    const b = {};\n    x = b;\n    if (a) {\n      const y = {};\n      x.y = y;\n    } else {\n      const z = {};\n      x.z = z;\n    }\n\n    mutate(b);\n    $[0] = a;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n
```

----------------------------------------

TITLE: Initializing a Foo Object with Props in JavaScript React
DESCRIPTION: This snippet defines a simple React functional component that initializes a Foo object using its props. It takes 'foo' and 'bar' from props to create a new instance of Foo, ensuring it receives the correct arguments.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/new-spread.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = new Foo(...props.foo, null, ...[props.bar]);
  return x;
}
```

----------------------------------------

TITLE: Defining a React Component with Fragment and Conditional Rendering
DESCRIPTION: Defines a React functional component 'Foo' that conditionally renders a Fragment with a div and a Stringify component based on props. It demonstrates scope alignment and mutable value handling in the React compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-within-nested-valueblock-in-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify, identity, makeArray, mutate} from 'shared-runtime';

/**
 * Here, identity('foo') is an immutable allocating instruction.
 * `arr` is a mutable value whose mutable range ends at `arr.map`.
 *
 * The previous (reactive function) version of alignScopesToBlocks set the range of
 * both scopes to end at value blocks within the <></> expression.
 * However, both scope ranges should be aligned to the outer value block
 * (e.g. `cond1 ? <>: null`). The HIR version of alignScopesToBlocks
 * handles this correctly.
 */
function Foo({cond1, cond2}) {
  const arr = makeArray<any>({a: 2}, 2, []);

  return cond1 ? (
    <>
      <div>{identity('foo')}</div>
      <Stringify value={cond2 ? arr.map(mutate) : null} />
    </>
  ) : null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{cond1: true, cond2: true}],
};
```

----------------------------------------

TITLE: Error Handling for useInvalidMutation - JavaScript
DESCRIPTION: This section showcases the error output generated when attempting to mutate the 'options' object inside the 'test' function defined in the 'useInvalidMutation' hook. The error message highlights that modifying the props or hook arguments is not allowed and suggests using local variables instead. This serves as a warning for developers to adhere to immutability in their React applications.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutation-in-closure.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 |   function test() {
  3 |     foo(options.foo); // error should not point on this line
> 4 |     options.foo = 'bar';
    |     ^^^^^^^ InvalidReact: Mutating component props or hook arguments is not allowed. Consider using a local variable instead. Found mutation of `options` (4:4)
  5 |   }
  6 |   return test;
  7 | }

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component that includes memoization logic using React's compiler runtime. It caches the computed value and only recalculates when the input parameter changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-calls-global-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  let t1;
  if ($[0] !== t0) {
    t1 = t0 === undefined ? identity([_temp, true, 42, "hello"]) : t0;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  return x;
}
function _temp() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows the compiled and optimized version of the React component using React's compiler runtime. It includes memoization checks and optimized array operations, improving performance by reducing unnecessary re-computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-memoization-lack-of-phi-types.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { useFragment } from "shared-runtime";

function Component() {
  const $ = _c(11);
  const data = useFragment();
  let t0;
  if ($[0] !== data.nodes) {
    t0 = data.nodes ?? [];
    $[0] = data.nodes;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const nodes = t0;
  let t1;
  if ($[2] !== nodes) {
    t1 = nodes.flatMap(_temp);
    $[2] = nodes;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const flatMap = t1;
  let t2;
  if ($[4] !== flatMap) {
    t2 = flatMap.filter(_temp2);
    $[4] = flatMap;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const filtered = t2;
  let t3;
  let t4;
  if ($[6] !== filtered) {
    t4 = filtered.map();
    $[6] = filtered;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  t3 = t4;
  const map = t3;
  const index = filtered.findIndex(_temp3);
  let t5;
  if ($[8] !== index || $[9] !== map) {
    t5 = (
      <div>
        {map}
        {index}
      </div>
    );
    $[8] = index;
    $[9] = map;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  return t5;
}
function _temp3(x) {
  return x === null;
}
function _temp2(item) {
  return item != null;
}
function _temp(node) {
  return node.items;
}
```

----------------------------------------

TITLE: Initial Component Definition with JSX in Try-Catch
DESCRIPTION: Original React component attempting to render JSX within a try-catch block, which triggers a compilation warning about potential rendering errors
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-try-with-catch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger @validateNoJSXInTryStatements
function Component(props) {
  let el;
  try {
    el = <div />;
  } catch {
    return null;
  }
  return el;
}
```

----------------------------------------

TITLE: Defining Functions and Exporting in JavaScript
DESCRIPTION: This snippet defines two functions, 'useFoo' and 'Foo'. The 'Foo' function calls 'useFoo' to obtain its name and logs it, returning the name value. An exportable object, 'FIXTURE_ENTRYPOINT', is created to provide access to the 'Foo' function and its parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-property-load-local.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo() {}
```

LANGUAGE: javascript
CODE:
```
function Foo() {
  let name = useFoo.name;
  console.log(name);
  return name;
}
```

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Input React Component with Array Transformation
DESCRIPTION: Original input component showing array manipulation, identity usage, and rendering with Stringify component
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-maybemutates-arg0.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutateAndReturn, Stringify, useIdentity} from 'shared-runtime';

function Component({value}) {
  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];
  useIdentity();
  const derived = Array.from(arr).map(mutateAndReturn);
  return (
    <Stringify>
      {derived.at(0)}
      {derived.at(-1)}
    </Stringify>
  );
}
```

----------------------------------------

TITLE: Implementing useSupportsTouchEvent Hook in React
DESCRIPTION: This snippet defines a custom React hook that checks if the browser supports touch events. It uses useMemo for performance optimization and tries to create a TouchEvent to determine support.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-preds-undefined-try-catch-return-primitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions

import {useMemo} from 'react';

const checkforTouchEvents = true;
function useSupportsTouchEvent() {
  return useMemo(() => {
    if (checkforTouchEvents) {
      try {
        document.createEvent('TouchEvent');
        return true;
      } catch {
        return false;
      }
    }
  }, []);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useSupportsTouchEvent,
  params: [],
};
```

----------------------------------------

TITLE: Managing Key Commands in React - JavaScript
DESCRIPTION: This snippet defines a React hook that manages key command interactions, primarily focusing on left and right movements. It uses the useRef hook to track the current position and an external addOne function to update this position. The snippet exports a fixture entry point with the function and its parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-ref-for-later-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef} from 'react';
import {addOne} from 'shared-runtime';

function useKeyCommand() {
  const currentPosition = useRef(0);
  const handleKey = direction => () => {
    const position = currentPosition.current;
    const nextPosition = direction === 'left' ? addOne(position) : position;
    currentPosition.current = nextPosition;
  };
  const moveLeft = {
    handler: handleKey('left'),
  };
  const moveRight = {
    handler: handleKey('right'),
  };
  return [moveLeft, moveRight];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useKeyCommand,
  params: [],
};

```

----------------------------------------

TITLE: React Component with Conditional Refs in JavaScript
DESCRIPTION: This snippet demonstrates using React's useRef hook in a React component to conditionally assign ref objects and return a component that responds to changes in these refs. Dependencies are imported from external React libraries. It features a 'Component' function which returns a 'Stringify' component based on ref conditions. The expected input is a boolean 'cond', with outputs being 'Stringify' components for each state of 'cond'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-ref.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef} from 'react';
import {Stringify} from 'shared-runtime';

/**
 * Fixture showing that Ref types may be reactive.
 * We should always take a dependency on ref values (the outer box) as
 * they may be reactive. Pruning should be done in
 * `pruneNonReactiveDependencies`
 */
function Component({cond}) {
  const ref1 = useRef(1);
  const ref2 = useRef(2);
  const ref = cond ? ref1 : ref2;
  const cb = () => ref.current;
  return <Stringify cb={cb} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
  sequentialRenders: [{cond: true}, {cond: false}],
};
```

----------------------------------------

TITLE: Compiled React Component with useFire Hook
DESCRIPTION: This snippet represents the compiled output of the previous React component, utilizing React's compiler runtime and a 'useFire' hook. It demonstrates how the 'fire' function is transformed into a memoized and conditionally executed side effect, optimizing performance by avoiding unnecessary executions. The code uses temporary variables and conditional checks to manage the side effect execution based on prop and hook changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/basic.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c, useFire } from "react/compiler-runtime"; // @enableFire
import { fire } from "react";

function Component(props) {
  const $ = _c(3);
  const foo = _temp;
  const t0 = useFire(foo);
  let t1;
  if ($[0] !== props || $[1] !== t0) {
    t1 = () => {
      t0(props);
    };
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  useEffect(t1);
  return null;
}
function _temp(props_0) {
  console.log(props_0);
}

```

----------------------------------------

TITLE: FBT Component Input Example in React
DESCRIPTION: Demonstrates the usage of FBT internationalization component in React JSX. Shows how to use fbt:param for dynamic text insertion and handling whitespace rules within FBT components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace-subtree.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

/**
 * Note that fbt whitespace rules apply to the entire fbt subtree,
 * not just direct children of fbt elements.
 * (e.g. here, the JSXText children of the span element also use
 * fbt whitespace rules)
 */

function Foo(props) {
  return (
    <fbt desc={'Dialog to show to user'}>
      <span key={props.name}>
        <fbt:param name="user name really long description for prettier">
          {props.name}
        </fbt:param>
        !
      </span>
    </fbt>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{name: 'Jason'}],
};
```

----------------------------------------

TITLE: Error Handling for Invalid Ref Access - JavaScript
DESCRIPTION: This snippet shows the error output generated when executing the Component function that violates React's ref access rules. The error indicates that ref values should not be accessed during render, and provides a link to the documentation for further clarification.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-read-ref-prop-in-render-property-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | // @validateRefAccessDuringRender @compilationMode(infer)
  2 | function Component(props) {
> 3 |   const value = props.ref.current;
    |                 ^^^^^^^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (3:3)
  4 |   return <div>{value}</div>;
  5 | }
  6 |
```

----------------------------------------

TITLE: Defining a Reactive Component in JavaScript
DESCRIPTION: This code snippet defines a function `Component` that conditionally updates an array and uses switch-case statements to set a boolean variable based on the array's content. It is designed to exemplify basic reactive programming techniques within a JavaScript context, particularly in a React application. No external dependencies beside React are required, and inputs are expected to be object literals defining conditional flags.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-via-mutation-switch.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Component(props) {
  // x is mutated conditionally based on a reactive value,
  // so it needs to be considered reactive
  let x = [];
  if (props.cond) {
    x.push(1);
  }
  // Since x is reactive, y is now reactively controlled too:
  let y = false;
  switch (x[0]) {
    case 1: {
      y = true;
      break;
    }
  }
  // Thus this value should be reactive on `y`:
  return [y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {cond: true},
    {cond: true},
    {cond: false},
    {cond: false},
    {cond: true},
    {cond: false},
    {cond: true},
    {cond: false},
  ],
};

```

----------------------------------------

TITLE: Defining React Component with useMemo Hook in JavaScript
DESCRIPTION: This snippet defines a React component using the `useMemo` hook to cache computed data based on the `props.value`. It exports a constant `FIXTURE_ENTRYPOINT` to facilitate testing or integration, which includes the component function and relevant parameters. React library is a required dependency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/drop-methodcall-usememo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as React from 'react';

function Component(props) {
  const x = React.useMemo(() => {
    const x = [];
    x.push(props.value);
    return x;
  }, [props.value]);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};

```

----------------------------------------

TITLE: Defining a React Component with State Management in JavaScript
DESCRIPTION: This snippet defines a component function utilizing the React compiler runtime, which helps manage state more effectively. It checks if the input 'a' has changed and either creates a new object or returns an existing one based on changes, thus optimizing performance. The returned object maintains the internal state with nested structures. It exports a fixture entry point similar to the simpler version, facilitating integration into React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-nested.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    y = { b: { a } };
    const x = function () {
      y.b.a = 2;
    };

    x();
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization (JavaScript)
DESCRIPTION: This is the compiled version of the React component, incorporating memoization techniques. It uses React's compiler runtime and implements a cache sentinel for optimization. The component's logic remains similar to the input version but with added memoization handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-alias-try-values.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { throwInput } = require("shared-runtime");

function Component(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    let y;
    x = [];
    try {
      throwInput(x);
    } catch (t0) {
      const e = t0;

      y = e;
    }

    y.push(null);
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining a Component with Reactivity in JavaScript
DESCRIPTION: The snippet defines a JavaScript function `Component` that uses a `for` loop to assign different values to `x` based on `props.test`, a reactive property. The purpose is to demonstrate how reactivity can affect variable assignment based on control flow. The component returns an array with the value of `x`. The component relies on standard JavaScript and React-like behavior, with care needed around the 'reactive' context.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  for (let i = 0; i < props.test; i++) {
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" variable `i`, whose value is capped by
  // `props.test` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {test: 12},
    {test: 12},
    {test: 1},
    {test: 1},
    {test: 12},
    {test: 1},
    {test: 12},
    {test: 1},
  ],
};
```

----------------------------------------

TITLE: Defining React Component with Array Operations and Memoization
DESCRIPTION: This snippet shows a React component that uses the useFragment hook to fetch data, performs various array operations like flatMap and filter, and uses useMemo for optimization. It also includes Flow type checking annotations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-memoization-lack-of-phi-types.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {useFragment} from 'shared-runtime';

function Component() {
  const data = useFragment();
  const nodes = data.nodes ?? [];
  const flatMap = nodes.flatMap(node => node.items);
  const filtered = flatMap.filter(item => item != null);
  const map = useMemo(() => filtered.map(), [filtered]);
  const index = filtered.findIndex(x => x === null);

  return (
    <div>
      {map}
      {index}
    </div>
  );
}
```

----------------------------------------

TITLE: Defining Component Functionality in JavaScript
DESCRIPTION: This snippet defines a React component named 'Component' that processes props to generate output. It checks if a property 'p0' is true, modifies an array based on the value of 'p1', and returns a JSX structure wrapped in the Stringify component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-leave-case.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component(props) {
  let x = [];
  let y;
  if (props.p0) {
    x.push(props.p1);
    y = x;
  }
  return (
    <Stringify>
      {x}
      {y}
    </Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{p0: false, p1: 2}],
  sequentialRenders: [
    {p0: false, p1: 2},
    {p0: false, p1: 2},
    {p0: true, p1: 2},
    {p0: true, p1: 3},
  ],
};
```

----------------------------------------

TITLE: Creating a Functional Component with Optional Function Calls - JavaScript
DESCRIPTION: This snippet defines a functional component named 'Component' that uses an optional function call to render a JSX element. It utilizes the 'makeOptionalFunction' to handle the props optionally and returns the rendered element. The snippet illustrates how optional chaining is applied in functional components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-with-independently-memoizable-arg.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeOptionalFunction(props);
  // for a regular call, the JSX element could be independently memoized
  // since it is an immutable value. however, because the call is optional,
  // we can't extract out independent memoization for the element w/o
  // forcing that argument to evaluate unconditionally
  const y = x?.(
    <div>
      <span>{props.text}</span>
    </div>
  );
  return y;
}

```

----------------------------------------

TITLE: Function Initialization with Conditional Logic in JavaScript
DESCRIPTION: This JavaScript snippet demonstrates basic object initialization inside a function, with different objects configured based on the input condition. The function returns an object containing the initialized sub-object. No external dependencies are required, and the function accepts one parameter that determines which sub-object to initialize.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a) {
  const x = {};
  if (a) {
    let y = {};
    x.y = y;
  } else {
    let z = {};
    x.z = z;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component implementation showing useCallback pattern for event handling and object memoization. Uses custom hooks and utilities for demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-call-second-function-which-captures-maybe-mutable-value-preserve-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';
import {
  identity,
  logValue,
  makeObject_Primitives,
  useHook,
} from 'shared-runtime';

function Component(props) {
  const object = makeObject_Primitives();

  useHook();

  const log = () => {
    logValue(object);
  };

  const onClick = useCallback(() => {
    log();
  }, [log]);

  identity(object);

  return <div onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Effect Handling
DESCRIPTION: The compiled version of the component with added effect handling logic. Includes caching mechanism for rendered elements and proper tracking of dependencies through the _c compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mixedreadonly-mutating-map.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import {
  arrayPush,
  identity,
  makeArray,
  Stringify,
  useFragment,
} from "shared-runtime";

function Component(t0) {
  const $ = _c(6);
  const { extraJsx } = t0;
  const x = makeArray();
  const items = useFragment();

  const jsx = items.a.map((item, i) => {
    arrayPush(x, 2);
    return <Stringify item={item} key={i} />;
  });
  const offset = jsx.length;
  for (let i_0 = 0; i_0 < extraJsx; i_0++) {
    jsx.push(<Stringify item={0} key={i_0 + offset} />);
  }

  const count = jsx.length;
  identity(count);
  let t1;
  if ($[0] !== count || $[1] !== x) {
    t1 = <Stringify x={x} count={count} />;
    $[0] = count;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== jsx[0] || $[4] !== t1) {
    t2 = (
      <>
        {t1}
        {jsx[0]}
      </>
    );
    $[3] = jsx[0];
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ extraJsx: 0 }],
  sequentialRenders: [{ extraJsx: 0 }, { extraJsx: 1 }],
};
```

----------------------------------------

TITLE: Compiled Output of Array Length Manipulation Test in JavaScript for React
DESCRIPTION: This snippet shows the compiled version of the 'useFoo' function, optimized by React's compiler. It includes caching mechanisms and conditional checks to improve performance while maintaining the original functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/evaluation-order-mutate-store-after-dependency-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * Test that we preserve order of evaluation on the following case scope@0
 * ```js
 * // simplified HIR
 * scope@0
 *    ...
 *    $0 = arr.length
 *    $1 = arr.length = 0
 *
 * scope@1 <-- here we should depend on $0 (the value of the property load before the
 *             property store)
 *   [$0, $1]
 * ```
 */
function useFoo(source) {
  const $ = _c(6);
  let t0;
  let t1;
  if ($[0] !== source) {
    const arr = [1, 2, 3, ...source];
    t0 = arr.length;
    t1 = arr.length = 0;
    $[0] = source;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t0 || $[4] !== t1) {
    t2 = [t0, t1];
    $[3] = t0;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [[5, 6]],
};
```

----------------------------------------

TITLE: Input React Component Definition
DESCRIPTION: Original React component implementation with Flow types and memo wrapper. Defines a simple component that renders a div with a string value prop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-with-hoisted-type-reference.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @gating
import {memo} from 'react';

type Props = React.ElementConfig<typeof Component>;

component Component(value: string) {
  return <div>{value}</div>;
}

export default memo<Props>(Component);

export const FIXTURE_ENTRYPOINT = {
  fn: eval('Component'),
  params: [{value: 'foo'}],
};
```

----------------------------------------

TITLE: Demonstrating Incorrect Hook Usage in React Component - JavaScript
DESCRIPTION: This JavaScript snippet illustrates an incorrect pattern of using the `useState` hook within a callback function inside a React component. Hooks in React must be called at the top level of a function component or a custom hook and not inside nested functions to ensure consistent behavior. The example showcases a common misunderstanding that could lead to runtime errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-76a74b4666e9.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Invalid because it's a common misunderstanding.\n// We *could* make it valid but the runtime error could be confusing.\nfunction ComponentWithHookInsideCallback() {\n  function handleClick() {\n    useState();\n  }\n}
```

----------------------------------------

TITLE: Improper useRef Access in React Component
DESCRIPTION: A React component that incorrectly tries to access the current property of a ref during render, which violates React's rules about ref access timing. This will trigger an error because refs should not be accessed during render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-optional.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef} from 'react';

function Component(props) {
  const ref = useRef();
  return ref?.current;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Defining React Functional Component - JavaScript
DESCRIPTION: This code snippet defines a React functional component named 'Component'. It attempts to mutate an array 'x' after it has already been rendered in the JSX, which triggers a React error due to improper state management practices. The snippet serves as an example of a common mistake where state updates are attempted after JSX rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-after-freeze.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [];

  let _ = <Component x={x} />;

  // x is Frozen at this point
  x.push(props.p2);

  return <div>{_}</div>;
}

```

----------------------------------------

TITLE: React Context Usage with @lowerContextAccess
DESCRIPTION: This React component, `App`, consumes context values `foo` from `joe` and `bar` from `MyContext` using the `useContext` hook. It then passes these values as props to a `Bar` component. The `@lowerContextAccess` annotation likely indicates special handling of context access during compilation or transformation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-nested-destructuring.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @lowerContextAccess
function App() {
  const {
    joe: {foo},
    bar,
  } = useContext(MyContext);
  return <Bar foo={foo} bar={bar} />;
}

```

----------------------------------------

TITLE: Implementing a Basic React Hook with Conditional Object Creation
DESCRIPTION: A custom React hook named useFoo that creates and returns an object with three properties (x, y, z) based on a boolean input parameter. When setOne is true, all properties are set to 1; otherwise, they're set to different values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-phi-nodes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo(setOne: boolean) {
  let x;
  let y;
  let z;
  if (setOne) {
    x = y = z = 1;
  } else {
    x = 2;
    y = 3;
    z = 5;
  }
  return {x, y, z};
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: React Component with useImperativeHandle and useRef
DESCRIPTION: This code defines a React component named `Component` that uses `useRef` to create mutable ref objects and `useImperativeHandle` to customize the instance value that is exposed to parent components when using `ref`. The `useImperativeHandle` hook's callback computes a value based on the component's props and ref values. The component also exports a `FIXTURE_ENTRYPOINT` constant, which configures the component's initial props for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useImperativeHandle-ref-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow

import {useImperativeHandle, useRef} from 'react';

component Component(prop: number) {
  const ref1 = useRef(null);
  const ref2 = useRef(1);
  useImperativeHandle(ref1, () => {
    const precomputed = prop + ref2.current;
    return {
      foo: () => prop + ref2.current + precomputed,
    };
  }, [prop]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{prop: 1}],
};

```

----------------------------------------

TITLE: Defining Component with useMemo - JavaScript
DESCRIPTION: This snippet defines a simple React functional component that uses the useMemo hook to memoize the output based on the dependency array [a, b]. It checks if 'a' is truthy, and if so, returns an object containing 'b'. The component is then exported as part of the FIXTURE_ENTRYPOINT object, which can be used in various contexts to reference the component with parameters for rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-inlining-block-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  let x = useMemo(() => {
    if (a) {
      return {b};
    }
  }, [a, b]);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Compiled React Function with Memoization
DESCRIPTION: This JavaScript code represents a compiled version of the `get2` function, potentially generated by a React compiler. It uses `react/compiler-runtime` to memoize the result. The code checks if a memoized value exists; if not, it executes the original logic, stores the result, and then returns the result. Subsequent calls will retrieve the memoized value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-repro-variable-used-in-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function get2() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const callbk = () => {
      const copy = x;
      return copy;
    };

    const x = 2;
    t0 = callbk();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: get2,
  params: [],
};

```

----------------------------------------

TITLE: Defining useFoo function with array.map
DESCRIPTION: This code snippet defines a React component `useFoo` that takes two arrays, `arr1` and `arr2`, as input. It then uses the `map` method on `arr1` twice, with two different named lambda functions `cb1` and `cb2`, to create two new arrays, `x` and `y`. Finally, it returns an array containing `x` and `y`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * Forked from array-map-simple.js
 * 
 * Whether lambdas are named or passed inline shouldn't affect whether we expect
 * it to be called.
 */
function useFoo({arr1, arr2}) {
  const cb1 = e => arr1[0].value + e.value;
  const x = arr1.map(cb1);
  const cb2 = e => arr2[0].value + e.value;
  const y = arr1.map(cb2);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{arr1: [], arr2: []}],
  sequentialRenders: [
    {arr1: [], arr2: []},
    {arr1: [], arr2: null},
    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},
  ],
};

```

----------------------------------------

TITLE: Original React Component with Default Parameter
DESCRIPTION: Defines a simple React component using parameter destructuring with a default value of 2 for parameter 'a'. Includes an export of a fixture entry point for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-param-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({a = 2}) {
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Memoization Error Handling
DESCRIPTION: This snippet contains a comment indicating a potential issue with memoization in React components. The error arises when the inferred dependencies for useMemo do not match the manually specified dependencies, which could lead to unexpected behavior regarding value updates. This highlights the importance of accurate dependency management in memoization for maintaining performance consistency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-property-call-chained-object.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```
   3 |
   4 | function Component({propA}) {
>  5 |   return useMemo(() => {
     |                  ^^^^^^^
>  6 |     return {
     | ^^^^^^^^^^^^
>  7 |       value: propA.x().y,
     | ^^^^^^^^^^^^
>  8 |     };
     | ^^^^^^^^^^^^
>  9 |   }, [propA.x]);
     | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:9)
  10 | }
  11 |
```
```

----------------------------------------

TITLE: React Component with Memoization - Source Code
DESCRIPTION: Original React component implementation using useMemo hook to memoize values based on props 'a' and 'b'. Includes validation components to verify memoization behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-log-default-import.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {ValidateMemoization} from 'shared-runtime';
import typedLog from 'shared-runtime';

export function Component({a, b}) {
  const item1 = useMemo(() => ({a}), [a]);
  const item2 = useMemo(() => ({b}), [b]);
  typedLog(item1, item2);

  return (
    <>
      <ValidateMemoization inputs={[a]} output={item1} />
      <ValidateMemoization inputs={[b]} output={item2} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 0, b: 0}],
  sequentialRenders: [
    {a: 0, b: 0},
    {a: 1, b: 0},
    {a: 1, b: 1},
    {a: 1, b: 2},
    {a: 2, b: 2},
    {a: 3, b: 2},
    {a: 0, b: 0},
  ],
};
```

----------------------------------------

TITLE: Original React Component with GraphQL Fragment
DESCRIPTION: A React component that defines and renders a GraphQL fragment within a div element. Includes test fixtures for component rendering with various prop combinations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-tagged-template-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {graphql} from 'shared-runtime';

export function Component({a, b}) {
  const fragment = graphql`
    fragment Foo on User {
      name
    }
  `;
  return <div>{fragment}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 0, b: 0}],
  sequentialRenders: [
    {a: 0, b: 0},
    {a: 1, b: 0},
    {a: 1, b: 1},
    {a: 1, b: 2},
    {a: 2, b: 2},
    {a: 3, b: 2},
    {a: 0, b: 0},
  ],
};
```

----------------------------------------

TITLE: React ForwardRef with Compiler Runtime and Hook
DESCRIPTION: This snippet showcases `React.forwardRef` combined with a compiler runtime (`_c`) and a hook. It illustrates how the compiler runtime can be used for memoization and optimization within a forwarded ref component that also utilizes a custom hook (`useHook`).
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-9a47e97b5d13.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Valid because hooks can be used in anonymous function arguments to
// forwardRef.
const FancyButton = React.forwardRef(function (props, ref) {
  const $ = _c(3);
  useHook();
  let t0;
  if ($[0] !== props || $[1] !== ref) {
    t0 = <button {...props} ref={ref} />;
    $[0] = props;
    $[1] = ref;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
});

```

----------------------------------------

TITLE: React Hook Definition with Conditional Array Modification
DESCRIPTION: This code defines a React hook `useFoo` that takes `props` as input.  It initializes an array `x`, pushes `props.bar` into it, and conditionally modifies the array based on `props.cond`. If `props.cond` is true, it re-initializes the array and pushes `props.foo` into it. Finally, it calls `mutate(x)` and returns the array. The `FIXTURE_ENTRYPOINT` provides test data for sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {mutate} from 'shared-runtime';

function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;
  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};

```

----------------------------------------

TITLE: Enhanced Custom useState Hook with Memoization - JavaScript
DESCRIPTION: This snippet enhances the custom useState hook by integrating a memoization strategy to prevent unnecessary re-renders. It utilizes a runtime function to track state changes and optimize updates, improving performance in functional components. The hook behaves similarly to React's useState but with additional optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-dont-resolve-local-useState.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState as _useState, useCallback, useEffect } from "react";
import { ValidateMemoization } from "shared-runtime";

function useState(value) {
  const $ = _c(2);
  const [state, setState] = _useState(value);
  let t0;
  if ($[0] !== state) {
    t0 = [state, setState];
    $[0] = state;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: React Component with Optional Properties
DESCRIPTION: This snippet defines a React component named `Component` that accesses nested properties (a, b, c, d) of the `props` object.  It uses the optional chaining operator `?.` to handle cases where `props.a` might be null or undefined, avoiding errors when trying to access properties on potentially null values. The value obtained from this nested property access is then passed to the `foo` function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-optional-member-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// We should codegen nested optional properties correctly
// (i.e. placing `?` in the correct PropertyLoad)
function Component(props) {
  let x = foo(props.a?.b.c.d);
  return x;
}

```

----------------------------------------

TITLE: Defining a Simple Div Component in React - Javascript
DESCRIPTION: This snippet defines a simple functional component 'useDiv' that returns a basic div element. It is intended to demonstrate a minimal React component structure without additional functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-hook-with-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function useDiv(props) {
  return <div />;
}

```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet illustrates a more complex version of the component using memoization to optimize rendering in React. It uses a custom cache sentinel to decide if it should create a new ref object or reuse an existing one. The input change handling and rendering are similarly structured, but the logic incorporates additional checks for memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-field-write-not-added-to-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useRef } from "react";

function Component() {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { text: { value: null } };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const ref = useRef(t0);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    const inputChanged = (e) => {
      ref.current.text.value = e.target.value;
    };

    t1 = <input onChange={inputChanged} />;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Implementing React Component with Optional Chaining in JavaScript
DESCRIPTION: This snippet defines a React component that uses optional chaining to access a nested property. It demonstrates the difference between `a?.b.c` and `(a?.b).c`, where the latter performs an unconditional load on `.b`. The component expects 'props' as an input and returns the value of `props.a.b`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonoptional-load-from-optional-memberexpr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Note that `a?.b.c` is semantically different from `(a?.b).c`
// Here, 'props?.a` is an optional chain, and `.b` is an unconditional load
// (nullthrows if a is nullish)

function Component(props) {
  const x = (props?.a).b;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component with useRef Implementation
DESCRIPTION: A React component that demonstrates useRef hook usage, including a potential hooks rule violation by mutating ref.current directly. The code includes helper functions and a fixture export for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-forget-multiple-with-eslint-suppression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useRef} from 'react';

const useControllableState = options => {};
function NoopComponent() {}

function Component() {
  'use no forget';
  const ref = useRef(null);
  // eslint-disable-next-line react-hooks/rules-of-hooks
  ref.current = 'bad';
  return <button ref={ref} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

LANGUAGE: javascript
CODE:
```
import { useRef } from "react";

const useControllableState = (options) => {};
function NoopComponent() {}

function Component() {
  "use no forget";
  const ref = useRef(null);
  // eslint-disable-next-line react-hooks/rules-of-hooks
  ref.current = "bad";
  return <button ref={ref} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Original Component with FBT Internationalization
DESCRIPTION: A React component that uses FBT for internationalization to render a greeting message. It accepts a name prop and displays it within a localized greeting string.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call-complex-param-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';
import {identity} from 'shared-runtime';

function Component(props) {
  const text = fbt(
    `Hello, ${fbt.param('(key) name', identity(props.name))}!`,
    '(description) Greeting'
  );
  return <div>{text}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Sathya'}],
};
```

----------------------------------------

TITLE: Implementing useFoo React Hook with Conditional Logic
DESCRIPTION: A React hook that conditionally processes input data based on provided conditions. It checks for the existence of nested properties and returns either null or an array containing the processed input.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/reduce-if-nonexhaustive-poisoned-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function useFoo({input, cond, hasAB}) {
  const x = [];
  if (cond) {
    if (!hasAB) {
      return null;
    }
    x.push(identity(input.a.b));
  } else {
    x.push(identity(input.a.b));
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {b: 1}, cond: true, hasAB: false}],
  sequentialRenders: [
    {input: {a: {b: 1}}, cond: true, hasAB: true},
    {input: null, cond: true, hasAB: false},
    // preserve nullthrows
    {input: {a: {b: undefined}}, cond: true, hasAB: true},
    {input: {a: undefined}, cond: true, hasAB: true},
    {input: {a: {b: undefined}}, cond: true, hasAB: true},
    {input: undefined, cond: true, hasAB: true},
  ],
};
```

----------------------------------------

TITLE: Input React Components with Flow Types
DESCRIPTION: Original React components with Flow type annotations, showing a Foo component that renders a Bar component with a number prop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component-declaration-basic.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @compilationMode(infer)
export default component Foo(bar: number) {
  return <Bar bar={bar} />;
}

component Bar(bar: number) {
  return <div>{bar}</div>;
}

function shouldNotCompile() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{bar: 42}],
};
```

----------------------------------------

TITLE: React component using useMemo with invalid argument
DESCRIPTION: This code defines a React component that uses the useMemo hook. The callback function passed to useMemo incorrectly accepts an argument 'c', which causes an ESLint error because the dependency array is empty. This indicates that the memoized value should only be calculated once, and the callback shouldn't rely on any changing values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useMemo-callback-args.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  let x = useMemo(c => a, []);
  return x;
}
```

----------------------------------------

TITLE: Defining a Function in React Component - JavaScript
DESCRIPTION: This snippet defines a React functional component named `Component`, which initializes a variable `x` and includes a nested function `foo` that modifies `x`. The component's return statement includes a child component `Child`, passing `y` as a prop, where `y` gets assigned the result of calling `bar` with `foo`. The snippet also highlights an error regarding the reassigning of variable `x`, suggesting the use of state instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.declare-reassign-variable-in-function-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let x = null;
  function foo() {
    x = 9;
  }
  const y = bar(foo);
  return <Child y={y} />;
}

```

----------------------------------------

TITLE: Defining a React Component and State Update
DESCRIPTION: This function defines a React component that attempts to modify an external variable 'x'. However, this approach is invalid in React because state should be managed using hooks or component props. The snippet highlights an invalid operation error that occur when trying to write to a variable defined outside the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.not-useEffect-external-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
"let x = {a: 42};\n\nfunction Component(props) {\n  foo(() => {\n    x.a = 10;\n    x.a = 20;\n  });\n}\n"
```

----------------------------------------

TITLE: Defining a Basic React Component - JavaScript
DESCRIPTION: This snippet defines a simple React component that returns an array of objects based on the condition provided through props. It initializes two objects and modifies one based on the provided props. The functionality relies on the condition being evaluated to either create a default object or extend an object with properties. It does not have external dependencies other than React itself. Expected output is an array containing two objects, under various conditional scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-property-store.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @debug @enablePropagateDepsInHIR
function Component(props) {
  const x = {};
  let y;
  if (props.cond) {
    y = {};
  } else {
    y = {a: props.a};
  }
  // This should be inferred as `<store> y` s.t. `x` can still
  // be independently memoized. *But* this also must properly
  // extend the mutable range of the object literals in the
  // if/else branches
y.x = x;

  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: false, a: 'a!'}],
};

```

----------------------------------------

TITLE: Invalid React Hook Usage in Unnamed Function
DESCRIPTION: This code snippet showcases an invalid usage of a function named `useNotAHook` (which is likely intended to be a hook) inside an unnamed function argument passed to `React.unknownFunction`. The linter flags this because the call to `useNotAHook` is conditional (within an `if` statement), violating the Rules of Hooks, which require hooks to be called in the same order on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.rules-of-hooks-d0935abedc42.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Unsupported input

// This is valid because "use"-prefixed functions called in
// unnamed function arguments are not assumed to be hooks.
React.unknownFunction((foo, bar) => {
  if (foo) {
    useNotAHook(bar);
  }
});

```

----------------------------------------

TITLE: Defining React Components with 'use forget' Directive
DESCRIPTION: This snippet defines React components Bar, NoForget, and Foo. The Bar and Foo components use the 'use forget' directive for optimization. It also exports a FIXTURE_ENTRYPOINT for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-default-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating @compilationMode(annotation)
export default function Bar(props) {
  'use forget';
  return <div>{props.bar}</div>;
}

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}

function Foo(props) {
  'use forget';
  return <Foo>{props.bar}</Foo>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval('Bar'),
  params: [{bar: 2}],
};
```

----------------------------------------

TITLE: React Component with useMemo (Input)
DESCRIPTION: This snippet defines a React component named `Component` that uses `useMemo` to memoize the value of `[a]`. The memoized value is then rendered within a `div`. The `FIXTURE_ENTRYPOINT` object configures the component for testing or demonstration purposes, specifying the component function, initial parameters, and indicating that it's a component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple-preserved-nomemo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @disableMemoizationForDebugging
import {useMemo} from 'react';

function Component({a}) {
  let x = useMemo(() => [a], []);
  return <div>{x}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 42}],
  isComponent: true,
};

```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This snippet defines a React component that uses props to conditionally push values into arrays `a` and `b`. The values assigned to x depend on `c[0]`, which becomes reactive as `b` is interleaved with `a`, making `x` reactive as well.  The component returns an array containing `x`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-of.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a and b are independent but their mutations are interleaved, so
  // they get grouped in a reactive scope. this means that a becomes
  // reactive since it will effectively re-evaluate based on a reactive
  // input
  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(null);

  // Downstream consumer of a, which initially seems non-reactive except
  // that a becomes reactive, per above
  const c = [a];

  let x;
  for (const i of c[0]) {
    x = 1;
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `c[0]` which becomes reactive via
  // being interleaved with `b`.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};

```

----------------------------------------

TITLE: Defining useFoo Component and Fixture (Input)
DESCRIPTION: This code defines a React component called `useFoo` which conditionally mutates an array based on the provided props (`bar`, `foo`, `cond`). The `FIXTURE_ENTRYPOINT` object configures the component for testing with specific initial parameters and sequential renders. The `mutate` function is used which is likely part of a shared runtime for state management or triggering updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-via-destructuring-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {mutate} from 'shared-runtime';

function useFoo(props) {
  let {x} = {x: []};
  x.push(props.bar);
  if (props.cond) {
    ({x} = {x: {}});
    ({x} = {x: []});
    x.push(props.foo);
  }
  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{bar: 'bar', foo: 'foo', cond: true}],
  sequentialRenders: [
    {bar: 'bar', foo: 'foo', cond: true},
    {bar: 'bar', foo: 'foo', cond: true},
    {bar: 'bar', foo: 'foo', cond: false},
  ],
};

```

----------------------------------------

TITLE: Installing use-subscription package using Yarn or NPM
DESCRIPTION: Commands to install the use-subscription package using either Yarn or NPM package managers.
SOURCE: https://github.com/facebook/react/blob/main/packages/use-subscription/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
# Yarn
yarn add use-subscription

# NPM
npm install use-subscription
```

----------------------------------------

TITLE: Component Initialization with Optional Chaining in JavaScript
DESCRIPTION: A simple React component that utilizes JavaScript's optional chaining to safely access nested object properties based on dynamic key access through props. The function takes 'props' as input and initializes an object 'x' using the 'makeObject' function, returning a deeply nested property if it exists.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-with-optional-member-expr-as-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeObject();
  return x.y?.[props.a?.[props.b?.[props.c]]];
}

```

----------------------------------------

TITLE: Implementing React Component with Array Destructuring in JavaScript
DESCRIPTION: This snippet defines a React component that uses array destructuring with a default value. It also exports a fixture for testing purposes with a sparse array input.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-array-hole.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // destructure slot index has a hole in the input, should return default
  const [x = 42] = props.value;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: [, /* hole! */ 3.14]}],
};
```

----------------------------------------

TITLE: Using React useMemo with Conditional Dependency List in JavaScript
DESCRIPTION: This React component demonstrates an improper pattern with useMemo where the dependency array is conditionally defined. The code uses a ternary operator to either pass null or an array containing 'text' as the dependency list, which violates React hooks rules and triggers a linting error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useMemo-non-literal-depslist.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';

// react-hooks-deps would error on this code (complex expression in depslist),
// so Forget could bailout here
function App({text, hasDeps}) {
  const resolvedText = useMemo(
    () => {
      return text.toUpperCase();
    },
    hasDeps ? null : [text], // should be DCE'd
  );
  return resolvedText;
}

export const FIXTURE_ENTRYPOINT = {
  fn: App,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Input React Component with Type Annotations
DESCRIPTION: Original React component implementation with TypeScript-like type annotations. Defines a Component that takes props with a numeric id, creates an array, and returns its first element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-var-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableUseTypeAnnotations
function Component(props: {id: number}) {
  const x: number[] = makeArray(props.id);
  const y = x.at(0);
  return y;
}

function makeArray<T>(x: T): Array<T> {
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 42}],
};
```

----------------------------------------

TITLE: React Component with useCallback Hook
DESCRIPTION: This snippet defines a React component named 'Component' that accepts props. It uses the 'useCallback' hook to memoize the 'onClick' handler.  The 'onClick' handler logs the 'value' prop to the console when the div is clicked, and the handler is only recreated if 'props.value' changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/drop-methodcall-usecallback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as React from 'react';

function Component(props) {
  const onClick = React.useCallback(() => {
    console.log(props.value);
  }, [props.value]);
  return <div onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};

```

----------------------------------------

TITLE: Creating a Functional Component - JavaScript
DESCRIPTION: This snippet demonstrates the creation of a React functional component that accepts props and returns the uppercase version of the name prop. It includes a non-null assertion for type safety.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/non-null-assertion.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props: ComponentProps) {
  return props.name!.toUpperCase();
}

```

----------------------------------------

TITLE: Implementing React Component with Global State
DESCRIPTION: This snippet defines a React component that uses useState and useEffect hooks to manage and synchronize with a global variable. It demonstrates how to update local state based on global changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-reassignment-in-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';

let someGlobal = false;

function Component() {
  const [state, setState] = useState(someGlobal);

  useEffect(() => {
    someGlobal = true;
  }, []);

  useEffect(() => {
    setState(someGlobal);
  }, [someGlobal]);

  return <div>{String(state)}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining Component with Dynamic Key Extraction in JavaScript
DESCRIPTION: This component function takes props as an argument and extracts a value from the 'val' property using a dynamic key defined in 'key'. It directly returns the extracted value. The intended use is for situations where you need to dynamically access properties based on input keys in a React application.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error._todo.computed-lval-in-destructure.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const computedKey = props.key;
  const {[computedKey]: x} = props.val;

  return x;
}
```

----------------------------------------

TITLE: Optimized Snippet: React Compiler Runtime Memoization
DESCRIPTION: Enhanced version of useFoo hook using React compiler runtime for performance optimization and memoized state tracking
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-via-destructuring-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    ({ x } = { x: [] });
    x.push(props.bar);
    if (props.cond) {
      ({ x } = { x: [] });
      x.push(props.foo);
    }

    mutate(x);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}
```

----------------------------------------

TITLE: Implementing Custom React Hook with Set Manipulation
DESCRIPTION: This snippet defines a custom React hook 'useFoo' that creates and manipulates Sets based on input props. It uses external functions 'makeArray' and 'useHook', and returns two Sets.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-for-of-iterate-values.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray, useHook} from 'shared-runtime';

function useFoo({propArr}: {propArr: Array<number>}) {
  const s1 = new Set<number | Array<number>>([1, 2, 3]);
  s1.add(makeArray(propArr[0]));

  useHook();
  const s2 = new Set();
  for (const el of s1.values()) {
    s2.add(el);
  }

  return [s1, s2];
}
```

----------------------------------------

TITLE: Implementing Memoized React Hook with Aliased References
DESCRIPTION: A React hook function demonstrating complex dependency tracking with aliased variables and nested property access. The hook uses useCallback to memoize a function with references that may cause memoization preservation challenges.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-aliased-var.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useHook(x) {
  const aliasedX = x;
  const aliasedProp = x.y.z;

  return useCallback(() => [aliasedX, x.y.z], [x, aliasedProp]);
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with added memoization logic and dependency tracking. Shows how the compiler optimizes the component by tracking prop changes and caching results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-as-dep-nested-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // props.b + 1 is an non-allocating expression, which means Forget can
// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1
// separately from props.b)
// Correctness:

import { identity, mutate, setProperty } from "shared-runtime";

//   y depends on either props.b or props.b + 1
function PrimitiveAsDepNested(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b) {
    const x = {};
    mutate(x);
    const t1 = props.b + 1;
    let t2;
    if ($[3] !== t1) {
      t2 = identity(t1);
      $[3] = t1;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    const y = t2;
    setProperty(x, props.a);
    t0 = [x, y];
    $[0] = props.a;
    $[1] = props.b;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: PrimitiveAsDepNested,
  params: [{ a: 1, b: 2 }],
  sequentialRenders: [
    // change b
    { a: 1, b: 3 },
    // change b
    { a: 1, b: 4 },
    // change a
    { a: 2, b: 4 },
    // change a
    { a: 3, b: 4 },
  ],
};
```

----------------------------------------

TITLE: Custom React Hook Definition
DESCRIPTION: This code defines a custom React hook called `useCustomHook` that takes a string `src` as input. It utilizes `useRef` to store a unique ID and a boolean flag for tracking destruction. `useEffectEvent` is used to create an event handler that calls `getItem` with the `src` and unique ID.  `useEffect` is used to call getItemEvent on mount. The `getItem` function returns an object containing the `srcName` and `uid`. The function `uniqueId` is used to generate a new id on each call.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  useEffect,
  useRef,
  // @ts-expect-error
  experimental_useEffectEvent as useEffectEvent,
} from 'react';

let id = 0;
function uniqueId() {
  'use no memo';
  return id++;
}

export function useCustomHook(src: string): void {
  const uidRef = useRef(uniqueId());
  const destroyed = useRef(false);
  const getItem = (srcName, uid) => {
    return {srcName, uid};
  };

  const getItemEvent = useEffectEvent(() => {
    if (destroyed.current) return;

    getItem(src, uidRef.current);
  });

  useEffect(() => {
    destroyed.current = false;
    getItemEvent();
  }, []);
}
```

----------------------------------------

TITLE: React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized React component using the `react/compiler-runtime`.  It uses `_c` to create a memoized value for `makeObject(props)`. The compiler ensures that `makeObject` is only called when `props` changes, optimizing performance.  The component still returns a value from the object based on `props.key`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-computed-member-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    t0 = makeObject(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const object = t0;
  return object?.[props.key];
}
```

----------------------------------------

TITLE: Using useRef in React Functional Component - JavaScript
DESCRIPTION: This snippet demonstrates the usage of the `useRef` hook to create two ref objects within a React functional component. The first ref is checked for being null, and if true, the second ref's `current` property is set to 1. It highlights the misuse of accessing ref values during render, which is restricted in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-other.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
"//@flow\nimport {useRef} from 'react';\n\ncomponent C() {\n  const r = useRef(null);\n  const r2 = useRef(null);\n  if (r.current == null) {\n    r2.current = 1;\n  }\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: C,\n  params: [{}],\n};\n"
```

----------------------------------------

TITLE: Optimized React forwardRef with Hooks and Compiler
DESCRIPTION: This code shows an optimized version of the `FancyButton` component, utilizing React's compiler-runtime (`_c`) for memoization. The component checks if the props or ref have changed before re-rendering the button. This optimization avoids unnecessary re-renders and improves performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-e66a744cffbe.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Valid because hooks can be used in anonymous function arguments to
// forwardRef.
const FancyButton = forwardRef(function (props, ref) {
  const $ = _c(3);
  useHook();
  let t0;
  if ($[0] !== props || $[1] !== ref) {
    t0 = <button {...props} ref={ref} />;
    $[0] = props;
    $[1] = ref;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
});

```

----------------------------------------

TITLE: Original React Component with Array Processing
DESCRIPTION: A React component that creates an array of iterators and arrays, transforms them using Object.fromEntries, and displays specific entries. The component accepts a value prop that gets incorporated into the array data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-map-known-mutate-shape.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify, useIdentity} from 'shared-runtime';

/**
 * Also see repro-array-map-known-nonmutate-Boolean, which calls a global
 * function that does *not* mutate its operands.
 */
function Component({value}) {
  const arr = [
    new Set([['foo', 2]]).values(),
    new Set([['bar', 4]]).values(),
    [['baz', value]],
  ];
  useIdentity(null);
  const derived = arr.map(Object.fromEntries);
  return (
    <Stringify>
      {derived.at(0)}
      {derived.at(-1)}
    </Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 5}],
  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],
};
```

----------------------------------------

TITLE: React Component Definition with Destructuring
DESCRIPTION: This code defines a React component named 'Foo' that receives props. It destructures the 'a' property of props to extract 'x', 'y', and the rest into 'z'. The component then returns the value of 'x'.  This snippet uses object destructuring with rest properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  const {x, y, ...z} = props.a;
  return x;
}
```

----------------------------------------

TITLE: Original React Hook Implementation
DESCRIPTION: Original implementation of useBar hook that creates a Set, iterates over it using values(), and handles object mutation. Notable for demonstrating mutable iterator behavior with Set values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-spread-later-mutated.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useBar({arg}) {
  /**
   * Note that mutableIterator is mutated by the later object spread. Therefore,
   * `s.values()` should be memoized within the same block as the object spread.
   * In terms of compiler internals, they should have the same reactive scope.
   */
  const obj = {};
  const s = new Set([obj, 5, 4]);
  const mutableIterator = s.values();
  const arr = [...mutableIterator];

  obj.x = arg;
  return arr;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useBar,
  params: [{arg: 3}],
  sequentialRenders: [{arg: 3}, {arg: 3}, {arg: 4}],
};
```

----------------------------------------

TITLE: Implementing React Component with Conditional Logic in JavaScript
DESCRIPTION: This snippet defines a React component function that performs conditional logic based on props. It uses logical operators to determine values for variables 'a' and 'b', which are then used in the return statement.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(props) {
  let a = props.a || (props.b && props.c && props.d);
  let b = (props.a && props.b && props.c) || props.d;
  return a ? b : props.c;
}
```

----------------------------------------

TITLE: JSX Transformed Output Example
DESCRIPTION: This code shows the output of JSX transformation where children are passed as arguments. Component1 and Component2 are invoked directly as arguments to `React.DOM.div`. This change from wrapping the component calls in an array aims to simplify the generated code and potentially improve performance.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_27

LANGUAGE: JavaScript
CODE:
```
"React.DOM.div(null, Component1(null), Component2(null))"
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that creates an array of mixed values, filters for non-empty strings, and joins them to create a className. Uses makeArray utility and custom string filtering logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-namespace-nesting.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

function Component() {
  const items = makeArray('foo', 'bar', '', null, 'baz', false, 'merp');
  const classname = cx.namespace(...items.filter(isNonEmptyString));
  return <div className={classname}>Ok</div>;
}

function isNonEmptyString(s) {
  return typeof s === 'string' && s.trim().length !== 0;
}

const cx = {
  namespace(...items) {
    return items.join(' ');
  },
};

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Input Component with useCallback and useRef
DESCRIPTION: Original React component implementation using useCallback for memoization and useRef for maintaining mutable state. Shows how refs remain mutable even with memoization guarantees enabled.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-value-preserve-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';

function Component(props) {
  const ref = useRef(null);

  const onChange = useCallback(event => {
    // The ref should still be mutable here even though function deps are frozen in
    // @enablePreserveExistingMemoizationGuarantees mode
    ref.current = event.target.value;
  });

  return <input onChange={onChange} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: JSX Children Transformation
DESCRIPTION: This example illustrates how JSX children are transformed into arguments. Instead of wrapping children in an array, they are now directly passed as arguments to the React.DOM element. This modification simplifies the structure of the transformed code and affects how React components are rendered when using JSX.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_26

LANGUAGE: JSX
CODE:
```
"<div><Component1/><Component2/></div>"
```

----------------------------------------

TITLE: Original React Component Input
DESCRIPTION: Initial React component definition using Flow types, implementing a Foo component that forwards refs to a Stringify component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/component-syntax-ref-gating.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @gating
import {Stringify} from 'shared-runtime';
import * as React from 'react';

component Foo(ref: React.RefSetter<Controls>) {
  return <Stringify ref={ref} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval('(...args) => React.createElement(Foo, args)'),
  params: [{ref: React.createRef()}],
};
```

----------------------------------------

TITLE: Defining Component Logic in React JavaScript
DESCRIPTION: This snippet implements a React component named 'Component'. It manages internal state through variables 'a' and 'b', ensuring that 'a' becomes reactive when 'b' changes. Key inputs include 'props.b', which is pushed into an array, and outputs are the internal states 'c' and 'a'. Dependencies include React's library functionalities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-interleaved-reactivity.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a and b are technically independent, but their mutation is interleaved
  // so they are grouped in a single reactive scope. a does not have any
  // reactive inputs, but b does. therefore, we have to treat a as reactive,
  // since it will be recreated based on a reactive input.
  const a = {};
  const b = [];
  b.push(props.b);
  a.a = null;

  // because a may recreate when b does, it becomes reactive. we have to recreate
  // c if a changes.
  const c = [a];

  // Example usage that could fail if we didn't treat a as reactive:
  //  const [c, a] = Component({b: ...});
  //  assert(c[0] === a);
  return [c, a];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the React component, likely produced by a compiler. It includes memoization and caching strategies to improve performance, while maintaining the same functionality as the original component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-reassignment-in-effect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useState } from "react";

let someGlobal = false;

function Component() {
  const $ = _c(5);
  const [state, setState] = useState(someGlobal);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(_temp, t0);
  let t1;
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      setState(someGlobal);
    };
    t2 = [someGlobal];
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useEffect(t1, t2);

  const t3 = String(state);
  let t4;
  if ($[3] !== t3) {
    t4 = <div>{t3}</div>;
    $[3] = t3;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  return t4;
}
function _temp() {
  someGlobal = true;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining useFoo Function with Shared Runtime Integration
DESCRIPTION: The code snippet imports 'arrayPush' from 'shared-runtime' and defines a function 'useFoo' that processes an object with checks on boolean conditions to produce an output array of modified input. It assumes that 'arrayPush' is a side-effect driven utility affecting state, requiring 'input' objects with nested properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/throw-before-scope-starts.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {arrayPush} from 'shared-runtime';

function useFoo({input, cond}) {
  if (cond) {
    throw new Error('throw with error!');
  }

  // unconditional
  const x = [];
  arrayPush(x, input.a.b);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {a: {b: 2}}, cond: false}],
  sequentialRenders: [
    {input: null, cond: true},
    {input: {a: {b: 2}}, cond: false},
    {input: null, cond: true},
    // preserve nullthrows
    {input: {}, cond: false},
    {input: {a: {b: null}}, cond: false},
    {input: {a: null}, cond: false},
    {input: {a: {b: 3}}, cond: false},
  ],
};

```

----------------------------------------

TITLE: Defining Component and Fixture Entrypoint in JavaScript
DESCRIPTION: This JavaScript snippet defines a function component that takes an input, modifies an object using a closure, and employs a mutation function from a shared runtime. It sets up the component for testing or further integration by exporting the function alongside parameters as FIXTURE_ENTRYPOINT. The snippet is dependent on the 'shared-runtime' for the mutate function. The function accepts a parameter 'a', constructs a mutable object, and returns it. The code snippet is intended for environments where advanced manipulation of state is needed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-computed-mutate-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function component(a) {
  let x = {a};
  let y = {};
  (function () {
    let a = y;
    a['x'] = x;
  })();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['foo'],
};

```

----------------------------------------

TITLE: Destructuring Data Attribute in React Function
DESCRIPTION: This snippet defines a function 'foo' that uses object destructuring to extract a 'data-foo-bar' attribute from its parameter. It then returns this value, demonstrating how to handle data attributes in React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-param-string-literal-key-invalid-identifier.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo({'data-foo-bar': dataTestID}) {
  return dataTestID;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{'data-foo-bar': {}}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining and Exporting a React Component in JavaScript
DESCRIPTION: The snippet defines a React component that converts an object to a boolean and returns both values. It exports a constant to serve as a fixture entry point for a React component named 'TodoAdd'. The function depends on standard JavaScript and React structures. It mainly initializes a component with given parameters and handles basic data manipulations as part of its key functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-Boolean.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {};
  const y = Boolean(x);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Defining useFoo Hook
DESCRIPTION: This snippet defines a custom hook 'useFoo' that takes an object and a boolean indicating if the object is null. It checks the null status, pushes the object's property 'b' to an array when not null, and returns that array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-in-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({obj, objIsNull}) {
  const x = [];
  if (objIsNull) {
    return;
  }
  x.push(obj.b);
  return x;
}
```

----------------------------------------

TITLE: Optimized React Context Access with Compiler Runtime
DESCRIPTION: This code snippet shows the transformed React component App after optimization using the React compiler runtime. The _c function from react/compiler-runtime is used to memoize the values of foo and bar. The component checks if the values have changed before re-rendering the Bar component, thus preventing unnecessary updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-mixed-array-obj.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @lowerContextAccess
function App() {
  const $ = _c(3);
  const context = useContext(MyContext);
  const [foo] = context;
  const { bar } = context;
  let t0;
  if ($[0] !== bar || $[1] !== foo) {
    t0 = <Bar foo={foo} bar={bar} />;
    $[0] = bar;
    $[1] = foo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

```

----------------------------------------

TITLE: Initializing and Connecting Backend to React DevTools
DESCRIPTION: Example of how to use the backend API for a non-browser-based React renderer. This must be called before React packages are imported and run in the same context as React.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-core/README.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
if (process.env.NODE_ENV !== 'production') {
  const { initialize, connectToDevTools } = require("react-devtools-core");

  initialize(settings);
  // Must be called before packages like react or react-native are imported
  connectToDevTools({...config});
}
```

----------------------------------------

TITLE: Initializing Component Callback in React (JavaScript)
DESCRIPTION: This JavaScript snippet defines a React functional component that conditionally accesses object properties and returns a callback function. It illustrates error handling when properties are accessed on potentially null objects, using a fallback when null is detected. Dependencies include React and a custom 'Stringify' module. The snippet expects an object and a flag determining if the object is null as inputs and returns JSX with the evaluated callback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-functionexpr-conditional-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

/**
 * We currently hoist the accessed properties of function expressions,
 * regardless of control flow. This is simply because we wrote support for
 * function expressions before doing a lot of work in PropagateScopeDeps
 * to handle conditionally accessed dependencies.
 *
 * Current evaluator error:
 *  Found differences in evaluator results
 *  Non-forget (expected):
 *  (kind: ok) <div>{"shouldInvokeFns":true,"callback":{"kind":"Function","result":null}}</div>
 *  Forget:
 *  (kind: exception) Cannot read properties of null (reading 'prop')
 */
function Component({obj, isObjNull}) {
  const callback = () => {
    if (!isObjNull) {
      return obj.prop;
    } else {
      return null;
    }
  };
  return <Stringify shouldInvokeFns={true} callback={callback} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{obj: null, isObjNull: true}],
};

```

----------------------------------------

TITLE: Defining Conditional Items in React Component - JavaScript
DESCRIPTION: This snippet defines a React component that initializes an array based on the condition passed through props. It utilizes optional chaining to manipulate the array, allowing elements to be pushed conditionally based on the prop's availability.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/iife-return-modified-later-phi.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function Component(props) {
  const items = (() => {
    if (props.cond) {
      return [];
    } else {
      return null;
    }
  })();
  items?.push(props.a);
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: {}}],
};
```

----------------------------------------

TITLE: Using React Compiler Runtime for Memoization - JavaScript
DESCRIPTION: This snippet defines a function 'foo' using React's compiler runtime for improved optimization based on previous parameter checks. It conditionally updates and memoizes the array derived from parameters 'b' and 'c'. This pattern allows for efficient React component rendering and state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independently-memoize-object-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(7);
  let x;
  if ($[0] !== a || $[1] !== b || $[2] !== c) {
    x = { a };
    let t0;
    if ($[4] !== b || $[5] !== c) {
      t0 = [b, c];
      $[4] = b;
      $[5] = c;
      $[6] = t0;
    } else {
      t0 = $[6];
    }
    x.y = t0;
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Mapping Items with React Component in JavaScript
DESCRIPTION: This JavaScript snippet defines a React component that uses the useFreeze hook to retrieve read-only data and map its items to JSX elements. The code highlights considerations for read effects and memoization when rendering items in a component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.unnecessary-lambda-memoization.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const data = useFreeze(); // assume this returns {items: Array<{...}>}
  // In this call `data` and `data.items` have a read effect *and* the lambda itself
  // is readonly (it doesn\'t capture ony mutable references). Further, we ca
  // theoretically determine that the lambda doesn\'t need to be memoized, since
  // data.items is an Array and Array.prototype.map does not capture its input (callback)
  // in the return value.
  // An observation is that even without knowing the exact type of `data`, if we know
  // that it is a plain, readonly javascript object, then we can infer that any `.map()`
  // calls *must* be Array.prototype.map (or else they are a runtime error), since no
  // other builtin has a .map() function.
  const items = data.items.map(item => <Item item={item} />);
  return <div>{items}</div>;
}

```

----------------------------------------

TITLE: Original Function Implementation
DESCRIPTION: The original function that creates and returns an object with conditional properties based on someVal condition. It demonstrates basic object property assignment and conditional logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-literal-mutated-after-if-else.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  let x = {};
  if (someVal) {
    x = {b};
  } else {
    x = {c};
  }

  x.f = 1;
  return x;
}
```

----------------------------------------

TITLE: React Component with Memoization (Code)
DESCRIPTION: This snippet defines a React component with memoization using `react/compiler-runtime`. It checks if the props have changed since the last render using the `_c` helper. If the props are different, the component re-computes `items` based on the conditional logic, including pushing the `props.a` value, updates the memoized values, and returns the result. Otherwise, it returns the memoized `items` value to avoid re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/iife-return-modified-later-phi.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let items;
  if ($[0] !== props.a || $[1] !== props.cond) {
    let t0;
    if (props.cond) {
      t0 = [];
    } else {
      t0 = null;
    }
    items = t0;

    items?.push(props.a);
    $[0] = props.a;
    $[1] = props.cond;
    $[2] = items;
  } else {
    items = $[2];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: {} }],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization Logic
DESCRIPTION: Compiled version of the React component showing the implementation of memoization logic. Includes compiler-generated code for tracking dependencies and managing reactive state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-reactivity-value-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import {
  CONST_TRUE,
  identity,
  makeObject_Primitives,
  useNoAlias,
} from "shared-runtime";

/**
 * Here the scope for `obj` is pruned because it spans the `useNoAlias()` hook call.
 * Because `obj` is non-reactive, it would by default be excluded as dependency for
 * `result = [...identity(obj)..., obj]`, but this could then cause the values in
 * `result` to be out of sync with `obj`.
 *
 * The fix is to consider pruned memo block outputs as reactive, since they will
 * recreate on every render. This means `thing` depends on both y and z.
 */
function Foo() {
  const $ = _c(3);
  const obj = makeObject_Primitives();

  useNoAlias();

  const shouldCaptureObj = obj != null && CONST_TRUE;
  const t0 = shouldCaptureObj ? identity(obj) : null;
  let t1;
  if ($[0] !== obj || $[1] !== t0) {
    t1 = [t0, obj];
    $[0] = obj;
    $[1] = t0;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const result = t1;

  useNoAlias(result, obj);
  if (shouldCaptureObj && result[0] !== obj) {
    throw new Error("Unexpected");
  }
  return result;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Defining AllocatingPrimitiveAsDepNested Function - React - JavaScript
DESCRIPTION: This snippet defines the function 'AllocatingPrimitiveAsDepNested', which leverages React's memoization to efficiently manage the state based on props. It uses identity functions and mutable objects to optimize rendering. Key dependencies include 'identity', 'mutate', and 'setProperty' from 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-primitive-as-dep-nested-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// bar(props.b) is an allocating expression that produces a primitive, which means
// that Forget should memoize it.
// Correctness:

import {identity, mutate, setProperty} from 'shared-runtime';

//   - y depends on either bar(props.b) or bar(props.b) + 1
function AllocatingPrimitiveAsDepNested(props) {
  let x = {};
  mutate(x);
  let y = identity(identity(props.b) + 1);
  setProperty(x, props.a);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: AllocatingPrimitiveAsDepNested,
  params: [{a: 1, b: 2}],
  sequentialRenders: [
    // change b
    {a: 1, b: 3},
    // change b
    {a: 1, b: 4},
    // change a
    {a: 2, b: 4},
    // change a
    {a: 3, b: 4},
  ],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // bar(props.b) is an allocating expression that produces a primitive, which means
// that Forget should memoize it.
// Correctness:

import { identity, mutate, setProperty } from "shared-runtime";

//   - y depends on either bar(props.b) or bar(props.b) + 1
function AllocatingPrimitiveAsDepNested(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b) {
    const x = {};
    mutate(x);
    const t1 = identity(props.b) + 1;
    let t2;
    if ($[3] !== t1) {
      t2 = identity(t1);
      $[3] = t1;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    const y = t2;
    setProperty(x, props.a);
    t0 = [x, y];
    $[0] = props.a;
    $[1] = props.b;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: AllocatingPrimitiveAsDepNested,
  params: [{ a: 1, b: 2 }],
  sequentialRenders: [
    // change b
    { a: 1, b: 3 },
    // change b
    { a: 1, b: 4 },
    // change a
    { a: 2, b: 4 },
    // change a
    { a: 3, b: 4 },
  ],
};
```

----------------------------------------

TITLE: Memoization Validation with Conditional Rendering - JavaScript
DESCRIPTION: This code snippet expands on the memoization concept by introducing a conditional setup using the '_c' function from 'react/compiler-runtime'. It checks if the current props have changed and conditionally renders the 'ValidateMemoization' component to ensure any updates in inputs are reflected in outputs, thus preserving the memoization guarantees.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-inverted-optionals-parallel-paths.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import { ValidateMemoization } from "shared-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;

  const x$0 = [];
  x$0.push(props?.a.b?.c.d?.e);
  x$0.push(props.a?.b.c?.d.e);
  t0 = x$0;
  let t1;
  if ($[0] !== props.a.b.c.d.e) {
    t1 = <ValidateMemoization inputs={[props.a.b.c.d.e]} output={x} />;
    $[0] = props.a.b.c.d.e;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: Defines a React component that accesses nested properties of the `props.a` object. It pushes values from `props.a?.b` and `props.a.b.c` into an array and returns it. This code snippet serves as the original component before Forget optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/memberexpr-join-optional-chain.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a.b` or a subpath as a dependency.
//
// (1) Since the reactive block producing x unconditionally read props.a.<...>,
//     reading `props.a.b` outside of the block would still preserve nullthrows
//     semantics of source code
// (2) Technically, props.a, props.a.b, and props.a.b.c are all reactive deps.
//     However, `props.a?.b` is only dependent on whether `props.a` is nullish,
//     not its actual value. Since we already preserve nullthrows on `props.a`,
//     we technically do not need to add `props.a` as a dependency.

function Component(props) {
  let x = [];
  x.push(props.a?.b);
  x.push(props.a.b.c);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: {b: {c: 1}}}],
};

```

----------------------------------------

TITLE: Initializing React Component with Shared Runtime in JavaScript
DESCRIPTION: This snippet demonstrates a React component that initializes with a status-based configuration and dynamically applies styles. It imports utilities from a shared runtime for identity checks and defines helper functions `foo` and `getStyles` to derive text and styles from a given status. The component is intended to be the entry point of a fixture, handling a status named "Mofei".
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequential-destructuring-assignment-to-scope-declarations.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(statusName) {
  const {status, text} = foo(statusName);
  const {bg, color} = getStyles(status);
  return (
    <div className={identity(bg)}>
      <span className={identity(color)}>{[text]}</span>
    </div>
  );
}

function foo(name) {
  return {
    status: `<status>`,
    text: `${name}!`,
  };
}

function getStyles(status) {
  return {
    bg: '#eee8d5',
    color: '#657b83',
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['Mofei'],
};

```

----------------------------------------

TITLE: Demonstrating captureOwnerStack API Usage in React
DESCRIPTION: The captureOwnerStack API is a development-only feature that returns an Owner Stack trace, which helps identify which components are responsible for rendering a particular component. It can be used to enhance error overlays or for debugging purposes.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { captureOwnerStack } from 'react';

function DebuggingComponent() {
  // This API only works in development mode
  const ownerStack = captureOwnerStack();
  console.log('Components responsible for rendering this component:', ownerStack);
  
  return <div>Debugging component</div>;
}
```

----------------------------------------

TITLE: Defining React Component with Default Parameters
DESCRIPTION: This snippet defines a React component named 'Component' with default parameters. It also exports a FIXTURE_ENTRYPOINT object for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-param-assignment-pattern.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(x = 'default', y = [{}]) {
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining a Component with Reactive Logic in React
DESCRIPTION: This snippet defines a React component that introduces a reactive mechanism using a custom runtime import. The component modifies its state based on the `props` it receives and optimizes performance by only re-rendering when necessary. It uses an internal array `$` to manage state and track changes. Inputs include the `props` object with a `cond` property. The expected output is an array containing the updated value of `x` based on the evaluation of `cond` in a loop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-reactive-after-fixpoint.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x = 0;

  let value = null;
  for (let i = 0; i < 10; i++) {
    switch (value) {
      case true: {
        x = 1;
        break;
      }
      case false: {
        x = 2;
        break;
      }
    }

    value = props.cond;
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { cond: true },
    { cond: true },
    { cond: false },
    { cond: false },
    { cond: true },
    { cond: false },
    { cond: true },
    { cond: false },
  ],
};

```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: The compiled version of the component showing React's compiler optimizations including memoization and state tracking using the compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-computed-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let x;
  if ($[0] !== a) {
    x = { a };
    const y = {};

    y.x = x.a;
    mutate(y);
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: React Component with Array.from Transformation
DESCRIPTION: This React component demonstrates the use of `Array.from` to create a new array based on an existing one. The component takes a `value` prop, creates an array of objects, and then uses `Array.from` to add an `id` property to each object based on its index. The component then renders the last element of the transformed array using the `Stringify` component. Dependencies: `useIdentity`, `Stringify` from `shared-runtime`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-arg1-captures-arg0.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useIdentity, Stringify} from 'shared-runtime';

/**
 * TODO: Note that this `Array.from` is inferred to be mutating its first
 * argument. This is because React Compiler's typing system does not yet support
 * annotating a function with a set of argument match cases + distinct
 * definitions (polymorphism).
 * 
 * In this case, we should be able to infer that the `Array.from` call is
 * not mutating its 0th argument.
 * The 0th argument should be typed as having `effect:Mutate` only when
 * (1) it might be a mutable iterable or
 * (2) the 1st argument might mutate its callee
 */
function Component({value}) {
  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];
  useIdentity();
  const derived = Array.from(arr, (x, idx) => ({...x, id: idx}));
  return <Stringify>{derived.at(-1)}</Stringify>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 5}],
  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],
};

```

----------------------------------------

TITLE: React Component with useFragment (Compiled Code)
DESCRIPTION: This is the compiled version of the React component `Component`. It uses `react/compiler-runtime` to optimize rendering by caching previous results. The compiled code uses `_c` from `react/compiler-runtime`, `useFragment` from `shared-runtime` to fetch data, and memoizes the rendering of the posts and the final output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/readonly-object-method-calls-mutable-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useFragment } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  const x = makeObject();
  const user = useFragment(
    graphql`
      fragment Component_user on User {
        name
      }
    `,
    props.user,
  );
  const posts = user.timeline.posts.edges.nodes.map((node) => {
    x.y = true;
    return <Post post={node} />;
  });
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  posts.push(t0);
  const count = posts.length;
  foo(count);
  let t1;
  if ($[1] !== posts) {
    t1 = <>{posts}</>;
    $[1] = posts;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component with React compiler runtime optimizations, including memoization cache implementation and value comparison checks for performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-filter-known-nonmutate-Boolean.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify, useIdentity } from "shared-runtime";

/**
 * Also see repro-array-map-known-mutate-shape, which calls a global function
 * that mutates its operands.
 */
function Component(t0) {
  const $ = _c(13);
  const { value } = t0;
  let t1;
  let t2;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = { value: "foo" };
    t2 = { value: "bar" };
    $[0] = t1;
    $[1] = t2;
  } else {
    t1 = $[0];
    t2 = $[1];
  }
  let t3;
  if ($[2] !== value) {
    t3 = [t1, t2, { value }];
    $[2] = value;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const arr = t3;
  useIdentity(null);
  let t4;
  if ($[4] !== arr) {
    t4 = arr.filter(Boolean);
    $[4] = arr;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  const derived = t4;
  let t5;
  if ($[6] !== derived) {
    t5 = derived.at(0);
    $[6] = derived;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  let t6;
  if ($[8] !== derived) {
    t6 = derived.at(-1);
    $[8] = derived;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== t5 || $[11] !== t6) {
    t7 = (
      <Stringify>
        {t5}
        {t6}
      </Stringify>
    );
    $[10] = t5;
    $[11] = t6;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  return t7;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 5 }],
  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],
};
```

----------------------------------------

TITLE: Managing Local Variable Reassignment in React Component JavaScript
DESCRIPTION: This JavaScript snippet demonstrates how to manage the reassignment of a local variable within a React component. It utilizes a function 'mk_reassignlocal' to encapsulate logic for resetting the variable and handling potential state management issues. The useEffect hook is employed to execute the onMount function, which checks the variable reassignment. This implementation must consider React's rendering lifecycle to avoid unexpected behavior. No external dependencies are required, but understanding React's lifecycle is crucial.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-nested-function-reassign-local-variable-in-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import {useEffect} from 'react';
function Component() {
  let local;
  const mk_reassignlocal = () => {
    // Create the reassignment function inside another function, then return it
    const reassignLocal = newValue => {
      local = newValue;
    };
    return reassignLocal;
  };
  const reassignLocal = mk_reassignlocal();
  const onMount = newValue => {
    reassignLocal('hello');
    if (local === newValue) {
      // Without React Compiler, `reassignLocal` is freshly created
      // on each render, capturing a binding to the latest `local`,
      // such that invoking reassignLocal will reassign the same
      // binding that we are observing in the if condition, and
      // we reach this branch
      console.log('`local` was updated!');
    } else {
      // With React Compiler enabled, `reassignLocal` is only created
      // once, capturing a binding to `local` in that render pass.
      // Therefore, calling `reassignLocal` will reassign the wrong
      // version of `local`, and not update the binding we are checking
      // in the if condition.
      //
      // To protect against this, we disallow reassigning locals from
      // functions that escape
      throw new Error('`local` not updated!');
    }
  };
  useEffect(() => {
    onMount();
  }, [onMount]);
  return 'ok';
}
```

----------------------------------------

TITLE: Implementing React Component with State and Event Handling
DESCRIPTION: This snippet defines a React component using the useState hook. It implements nested functions for rendering and event handling, with a main render function that returns a div containing the result of calling function a().
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multiple-calls-to-hoisted-callback-from-other-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';

function Component(props) {
  const [_state, setState] = useState();
  const a = () => {
    return b();
  };
  const b = () => {
    return (
      <>
        <div onClick={() => onClick(true)}>a</div>
        <div onClick={() => onClick(false)}>b</div>
      </>
    );
  };
  const onClick = value => {
    setState(value);
  };

  return <div>{a()}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Initializing React Component with Object Mutation
DESCRIPTION: A React functional component that creates an object, renders it in JSX, and then attempts to modify the object, which is not allowed in React's rendering lifecycle
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-computed-store-to-frozen-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeObject();
  // freeze
  <div>{x}</div>;
  x[0] = true;
  return x;
}
```

----------------------------------------

TITLE: React Component with Multiple Parameters
DESCRIPTION: Defines a React component named `Component` that accepts two parameters, `foo` and `bar`. The component returns a simple `div` element. It also defines and exports a constant `FIXTURE_ENTRYPOINT` which is an object containing the component function and a `params` array to be passed to the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-dont-compile-components-with-multiple-params.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
// Takes multiple parameters - not a component!
function Component(foo, bar) {
  return <div />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [null, null],
};

```

----------------------------------------

TITLE: React Component Definition with Reactive Props
DESCRIPTION: This code defines a React component that reassigns a variable 'x' based on the reactive prop 'props.cond'. The assignment occurs within a function expression to create a context variable. The component returns 'x' wrapped in an array, treating 'x' as reactive due to its dependency on the reactive 'props.cond'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-on-context-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(props) {
  let x;
  // Reassign `x` based on a reactive value, but inside a function expression
  // to make it a context variable
  const f = () => {
    if (props.cond) {
      x = 1;
    } else {
      x = 2;
    }
  };
  // Pass `f` through a function to prevent IIFE inlining optimizations
  const f2 = identity(f);
  f2();

  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `props.cond` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {cond: true},
    {cond: true},
    {cond: false},
    {cond: false},
    {cond: true},
    {cond: false},
    {cond: true},
    {cond: false},
  ],
};

```

----------------------------------------

TITLE: Component Initialization with Simple Logic in React - JavaScript
DESCRIPTION: This snippet demonstrates a simple React component that initializes an array to store the length of a given set of items and a mapped array of items' edges. The function relies on the presence of items and edges and safely uses optional chaining to account for potential null values. This version does not use any advanced caching mechanisms.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/memberexpr-join-optional-chain2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [];
  x.push(props.items?.length);
  x.push(props.items?.edges?.map?.(render)?.filter?.(Boolean) ?? []);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{items: {edges: null, length: 0}}],
};

```

----------------------------------------

TITLE: Compiled JavaScript code of useFoo function
DESCRIPTION: This is the compiled JavaScript code for the `useFoo` function using the React compiler.  It showcases how the compiler optimizes and transforms the original code, including memoization and caching strategies. The `_c` function is likely a runtime helper for memoization. The compiled code utilizes a mutable array `$` to store cached values based on the inputs `a` and `b`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-aliased-capture-aliased-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { arrayPush, setPropertyByKey, Stringify } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(5);
  const { a, b } = t0;
  let t1;
  if ($[0] !== a || $[1] !== b) {
    const x = [];
    const y = { value: a };

    arrayPush(x, y);
    const y_alias = y;
    let t2;
    if ($[3] !== y_alias.value) {
      t2 = () => y_alias.value;
      $[3] = y_alias.value;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    const cb = t2;
    setPropertyByKey(x[0], "value", b);
    t1 = <Stringify cb={cb} shouldInvokeFns={true} />;
    $[0] = a;
    $[1] = b;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: 2, b: 10 }],
  sequentialRenders: [
    { a: 2, b: 10 },
    { a: 2, b: 11 },
  ],
};

```

----------------------------------------

TITLE: React Component Definition with Hoisting
DESCRIPTION: This JavaScript code defines a React component named `hoisting` that demonstrates variable and function hoisting. It imports `Stringify` from `shared-runtime` and defines an `onClick` function within the scope of the component, which accesses the `bar` object defined later. The component returns a `Stringify` element with the `onClick` function passed as a prop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-member-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function hoisting() {
  function onClick(x) {
    return x + bar.baz;
  }
  const bar = {baz: 1};

  return <Stringify onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Defining Custom Hook 'useFoo' in React (JavaScript)
DESCRIPTION: The 'useFoo' function is a custom hook that takes 'minWidth' and 'otherProp' as parameters. It uses the useState hook to manage the width state and utilize useCallback for memoized style computation. The hook utilizes 'arrayPush' from 'shared-runtime' to manage an array of other properties. It ensures that memoized values are preserved across re-renders when dependencies are unchanged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-in-other-reactive-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useState} from 'react';
import {arrayPush} from 'shared-runtime';

// useCallback-produced values can exist in nested reactive blocks, as long
// as their reactive dependencies are a subset of depslist from source
function useFoo(minWidth, otherProp) {
  const [width, setWidth] = useState(1);
  const x = [];
  const style = useCallback(() => {
    return {
      width: Math.max(minWidth, width),
    };
  }, [width, minWidth]);
  arrayPush(x, otherProp);
  return [style, x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [2, 'other'],
};

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useCallback, useState } from "react";
import { arrayPush } from "shared-runtime";

// useCallback-produced values can exist in nested reactive blocks, as long
// as their reactive dependencies are a subset of depslist from source
function useFoo(minWidth, otherProp) {
  const $ = _c(7);
  const [width] = useState(1);
  let t0;
  if ($[0] !== minWidth || $[1] !== otherProp || $[2] !== width) {
    const x = [];
    let t1;
    if ($[4] !== minWidth || $[5] !== width) {
      t1 = () => ({ width: Math.max(minWidth, width) });
      $[4] = minWidth;
      $[5] = width;
      $[6] = t1;
    } else {
      t1 = $[6];
    }
    const style = t1;

    arrayPush(x, otherProp);
    t0 = [style, x];
    $[0] = minWidth;
    $[1] = otherProp;
    $[2] = width;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [2, "other"],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component demonstrating object property access and destructuring with numeric keys. Returns a div containing repeated string values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/numeric-literal-as-object-property-key.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Test() {
  const obj = {
    21: 'dimaMachina',
  };
  // Destructuring assignment
  const {21: myVar} = obj;
  return (
    <div>
      {obj[21]}
      {myVar}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component Definition (Original)
DESCRIPTION: This snippet defines a functional React component named `Component` that accepts `props`. Inside the component, an array `x` is initialized, a value from `props` is pushed into it, and another variable `y` is assigned to `x`. Later, `x` is reassigned to a new empty array and a JSX element using `Component` is created. Finally, another value from `props` is pushed into `y` and the component returns a JSX element using `Component`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [];
  x.push(props.p0);
  let y = x;

  x = [];
  let _ = <Component x={x} />;

  y.push(props.p1);

  return <Component x={x} y={y} />;
}

```

----------------------------------------

TITLE: Using useCallback for Memoization in React
DESCRIPTION: This snippet defines a function `useFoo` that uses `useCallback` to memoize the return value based on identity. It demonstrates a case where a dependency, `x`, is not included in the memoization, showcasing scope pruning due to hook-call flattening. The code demonstrates the challenges and considerations in using memoization with React hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-dep-scope-pruned.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';
import {identity, useIdentity} from 'shared-runtime';

function mutate(_: unknown) {}

/**
 * Repro showing a manual memo whose declaration (useCallback's 1st argument)
 * is memoized, but not its dependency (x). In this case, `x`'s scope is pruned
 * due to hook-call flattening.
 */
function useFoo(a) {
  const x = identity(a);
  useIdentity(2);
  mutate(x);

  return useCallback(() => [x, []], [x]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [3],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useCallback } from "react";
import { identity, useIdentity } from "shared-runtime";

function mutate(_) {}

/**
 * Repro showing a manual memo whose declaration (useCallback's 1st argument)
 * is memoized, but not its dependency (x). In this case, `x`'s scope is pruned
 * due to hook-call flattening.
 */
function useFoo(a) {
  const $ = _c(2);
  const x = identity(a);
  useIdentity(2);
  mutate(x);
  let t0;
  if ($[0] !== x) {
    t0 = () => [x, []];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [3],
};
```

----------------------------------------

TITLE: Defining a Simple React Component in JavaScript
DESCRIPTION: This snippet defines a simple React functional component that returns a JSX element containing escaped HTML characters. It serves as a basic example for building React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-html-entity.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  return <div>&gt;&lt;span &amp;</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component Implementation in JavaScript
DESCRIPTION: A simple React component that computes values from props, calls a function with those values, and renders a Foo component. Includes helper function declarations for demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/interdependent.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * Should produce 1 scope:
 *
 * return: inputs=props.a & props.b; outputs=return
 *   const a = compute(props.a);
 *   const b = compute(props.b);
 *   foo(a, b);
 *   return = <Foo a={a} b={b} />
 */
function Component(props) {
  const a = compute(props.a);
  const b = compute(props.b);
  foo(a, b);
  return <Foo a={a} b={b} />;
}

function compute() {}
function foo() {}
function Foo() {}
```

----------------------------------------

TITLE: React Component Definition with Truthy Attribute
DESCRIPTION: This snippet defines a React component that renders a `Stringify` component with a `truthyAttribute`.  The attribute is used without an explicit value, which in JSX defaults to `true`. This demonstrates how JSX handles boolean attributes implicitly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-default-to-true.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component() {
  // https://legacy.reactjs.org/docs/jsx-in-depth.html#props-default-to-true
  return <Stringify truthyAttribute />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: Original React Component with Potential Memoization Opportunities
DESCRIPTION: A React component that creates arrays from props, with comments identifying potential memoization opportunities. This is the source code before optimization by the React compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-allocating-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a can be independently memoized, is not mutated later
  const a = [props.a];

  // b and c are interleaved and grouped into a single scope,
  // but they are independent values. c does not escape, but
  // we need to ensure that a is memoized or else b will invalidate
  // on every render since a is a dependency.
  const b = [];
  const c = {};
  c.a = a;
  b.push(props.b);

  return b;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Optimizing a Custom Hook with Compiler Runtime in JavaScript
DESCRIPTION: This code refines "useHook" by leveraging "react/compiler-runtime" to cache and compare dependencies, ensuring efficient updates to the closure "x". Specifically, it tracks changes to the function parameters and internal states to only recompute as necessary. This method reduces unnecessary computations and ensures stable function references across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-conditional-capture-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useHook(a, b) {
  const $ = _c(5);
  let t0;
  if ($[0] !== a) {
    t0 = { a };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  const y = b;
  let t1;
  if ($[2] !== y || $[3] !== z) {
    t1 = function () {
      if (y) {
        maybeMutate(z);
      }
    };
    $[2] = y;
    $[3] = z;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const x = t1;
  return x;
}

```

----------------------------------------

TITLE: Input React Function with Stringify Wrapper
DESCRIPTION: Initial implementation of useFoo function that wraps a function returning an object with nested property access
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR

import {Stringify} from 'shared-runtime';

function useFoo({a}) {
  const fn = () => {
    return () => ({
      value: a.b.c,
    });
  };
  return <Stringify fn={fn} shouldInvokeFns={true} />;
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component 'Foo' that conditionally assigns either an empty array or object based on a boolean condition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-conditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  let x;
  true ? (x = []) : (x = {});
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing React Component with Loop and Export (Input Version)
DESCRIPTION: This code defines a React component function with a loop that increments a variable based on props.count. It also exports a fixture entrypoint object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-empty-update.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  for (let i = 0; i < props.count; ) {
    x += i;
    if (x > 10) {
      break;
    }
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Compiled React Components with Forget Optimization
DESCRIPTION: Compiled version of the components with React Forget optimization feature. Includes memoization logic and conditional rendering based on the isForgetEnabled_Fixtures flag. Demonstrates advanced compilation techniques for performance optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-export-gating-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
import { Stringify } from "shared-runtime";

const ErrorView = isForgetEnabled_Fixtures()
  ? (error, _retry) => {
      const $ = _c(2);
      let t0;
      if ($[0] !== error) {
        t0 = <Stringify error={error} />;
        $[0] = error;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : (error, _retry) => <Stringify error={error}></Stringify>;

export const Renderer = isForgetEnabled_Fixtures()
  ? (props) => {
      const $ = _c(1);
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = (
          <div>
            <span />
            <ErrorView />
          </div>
        );
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : (props) => (
      <div>
        <span></span>
        <ErrorView></ErrorView>
      </div>
    );
export const FIXTURE_ENTRYPOINT = {
  fn: eval("Renderer"),
  params: [{}],
};
```

----------------------------------------

TITLE: Using Effect with Inferred Dependencies in React
DESCRIPTION: A React functional component that demonstrates automatic dependency inference with a custom effect hook. The component creates an array from a prop value and passes it to an effect that prints the array. Note that the effect dependency on 'arr' will be automatically inferred.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/no-emit-lint-repro.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @noEmit
import { print } from "shared-runtime";
import useEffectWrapper from "useEffectWrapper";

function ReactiveVariable({ propVal }) {
  const arr = [propVal];
  useEffectWrapper(() => print(arr));
}
```

----------------------------------------

TITLE: Flow-typed React Component Definition
DESCRIPTION: Original Flow-typed component definition using destructuring and nullish coalescing operator for default value handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-reorder.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const foo = undefined;

component C(...{scope = foo ?? null}: any) {
  return scope;
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{scope: undefined}],
};
```

----------------------------------------

TITLE: Enhanced useHook Function with Block Label in React JavaScript
DESCRIPTION: This snippet contains an enhanced version of the useHook function that utilizes a block label, bb0, for the switch statement to manage flow control. It demonstrates an alternate way to organize switch cases in JavaScript, which can be useful for more complex control flow logic within React applications. As with the previous version, it exports a FIXTURE_ENTRYPOINT object providing context for integrating this function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/block-scoping-switch-dead-code.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useHook(a, b) {
  bb0: switch (a) {
    case 1: {
      if (b == null) {
        return;
      }

      console.log(b);
      break bb0;
    }
    case 2: {
      return;
    }
    default: {
      return;
    }
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [1, "foo"],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A simple React component implementation using useCallback hook to memoize a function that sets a global window property. The component renders a div with 'Ok' text.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-unused-usecallback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useCallback, useEffect, useState} from 'react';

function Component() {
  const callback = useCallback(() => {
    window.foo = true;
  }, []);

  return <div>Ok</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Using Conditional Logic in a Custom Hook in React
DESCRIPTION: This snippet shows an alternative implementation of the 'useFoo' function without memoization. It directly assigns values based on the condition provided as an argument. This implementation serves a similar purpose but does not optimize for performance using 'useMemo'. The outputs remain the same (10 or 5), depending on the input condition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo-mult-returns.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";
import { identity } from "shared-runtime";

function useFoo(cond) {
  let t0;
  if (cond) {
    t0 = identity(10);
  } else {
    t0 = identity(5);
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component that creates an empty array and maps over it, updating each item's 'updated' property. Returns both the original and mapped arrays.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-mutating-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [];
  const y = x.map(item => {
    item.updated = true;
    return item;
  });
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing a Basic React Component with ESLint Ignore
DESCRIPTION: This JavaScript code snippet defines a simple React component named 'lowercasecomponent'. The component disables specific React ESLint rules using comments, which can lead to suboptimal performance and unexpected behavior. It returns a JSX element containing an empty array variable. The component does not follow ideal React practices as indicated by the warning messages.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-sketchy-code-use-forget.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/* eslint-disable react-hooks/rules-of-hooks */
function lowercasecomponent() {
  'use forget';
  const x = [];
  // eslint-disable-next-line react-hooks/rules-of-hooks
  return <div>{x}</div>;
}
/* eslint-enable react-hooks/rules-of-hooks */

```

----------------------------------------

TITLE: Original Function Implementation with TypeScript Props
DESCRIPTION: The original function implementation that takes props with a number value x, performs increment and decrement operations, and returns an object with the intermediate values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props: {x: number}) {
  let x = props.x;
  let y = x++;
  let z = x--;
  return {x, y, z};
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{x: 1}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Input React Component with Memo
DESCRIPTION: Initial React component implementation using memo HOC and Stringify component. Includes fixture setup for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-use-before-decl.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import {memo} from 'react';
import {Stringify} from 'shared-runtime';

export default memo(Foo);
function Foo({prop1, prop2}) {
  'use memo';
  return <Stringify prop1={prop1} prop2={prop2} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval('Foo'),
  params: [{prop1: 1, prop2: 2}],
};
```

----------------------------------------

TITLE: Original React Hook Implementation
DESCRIPTION: Defines a custom React hook that conditionally returns either an object with a getValue method or a number 42. Includes fixture setup for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-derived-in-ternary-consequent.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, createHookWrapper} from 'shared-runtime';

function useHook({isCond, value}) {
  return isCond
    ? identity({
        getValue() {
          return value;
        },
      })
    : 42;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{isCond: true, value: 0}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet shows the compiled version of the `Component` function, which includes memoization using the `_c` helper from the `react/compiler-runtime`. The code checks if the value of `props.a?.b.c.d` has changed since the last render. If the value has changed, it calls `foo` and updates the memoized value. This prevents unnecessary re-computation of the `foo` function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-optional-member-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // We should codegen nested optional properties correctly
// (i.e. placing `?` in the correct PropertyLoad)
function Component(props) {
  const $ = _c(2);
  const t0 = props.a?.b.c.d;
  let t1;
  if ($[0] !== t0) {
    t1 = foo(t0);
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  return x;
}

```

----------------------------------------

TITLE: Implementing Fire Mechanism in React Component
DESCRIPTION: This snippet demonstrates a React functional component that imports the fire function from the React library. It defines a foo function to log prop1 and invokes it along with bar() using fire within the useEffect hook. The snippet follows rules about capitalized function calls, which are validated by decorators. The expected output includes calls to fire, logging of prop1, and the return value of CapitalizedCall.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-capitalized-fn-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoCapitalizedCalls @enableFire @panicThreshold(none)
import {fire} from 'react';
const CapitalizedCall = require('shared-runtime').sum;

function Component({prop1, bar}) {
  const foo = () => {
    console.log(prop1);
  };
  useEffect(() => {
    fire(foo(prop1));
    fire(foo());
    fire(bar());
  });

  return CapitalizedCall();
}

```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React Component
DESCRIPTION: Example of incorrect hook usage where the hook call is made conditionally using optional chaining. This violates React's Rules of Hooks which require hooks to be called in a consistent order and unconditionally.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-optional-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const {result} = Module?.useConditionalHook() ?? {};
  return result;
}
```

LANGUAGE: text
CODE:
```
  1 | function Component() {
> 2 |   const {result} = Module?.useConditionalHook() ?? {};
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (2:2)
  3 |   return result;
  4 | }
  5 |
```

----------------------------------------

TITLE: Compiled React Component Output
DESCRIPTION: Compiled version of the React component showing optimization transformations including memo caching and temporary variable management. Includes compiler runtime imports and memoization logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-in-effect-indirect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useState } from "react";

let someGlobal = {};

function Component() {
  const $ = _c(6);
  const [state, setState] = useState(someGlobal);

  const setGlobal = _temp;
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setGlobal();
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  let t2;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      setState(someGlobal.value);
    };
    t3 = [someGlobal];
    $[2] = t2;
    $[3] = t3;
  } else {
    t2 = $[2];
    t3 = $[3];
  }
  useEffect(t2, t3);

  const t4 = String(state);
  let t5;
  if ($[4] !== t4) {
    t5 = <div>{t4}</div>;
    $[4] = t4;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  return t5;
}
function _temp() {
  someGlobal.value = true;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime in JavaScript
DESCRIPTION: This JavaScript snippet shows an optimized version of a React component using compiler-runtime optimizations and state management techniques. The 'setValue' function is conditionally initialized based on a memoization sentinel, improving efficiency. It also demonstrates an alternative approach to managing state memoization via caching symbols.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inadvertent-mutability-readonly-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const [, setValue] = useState(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (e) => setValue((value_0) => value_0 + e.target.value);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onChange = t0;

  useOtherHook();
  let x;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    x = {};
    foo(x, onChange);
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

```

----------------------------------------

TITLE: Validating Conditional Hook Calls in JavaScript
DESCRIPTION: This snippet defines a function 'useHook' which illustrates incorrect usage of the useState hook by calling it conditionally based on an external variable 'a'. The intended rule is that hooks must always be called at the top level of a React component. This validation is important to maintain the rules set by React to ensure reliable and predictable behavior of hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-c906cace44e9.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook() {
  if (a) return;
  useState();
}

```

----------------------------------------

TITLE: React Component with Optional Chaining (Input)
DESCRIPTION: This snippet defines a simple React component named `Component` that accepts `props` as input. It returns the result of calling the function `foo` with the `props` object, using optional chaining to handle cases where `foo` might be null or undefined. This original, uncompiled, definition of the Component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return foo?.(props);
}

```

----------------------------------------

TITLE: Input Implementation of useTest Hook
DESCRIPTION: Original implementation of a custom hook that creates an object with a mutable property and returns an array using makeArray utility.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife-storeprop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray, print} from 'shared-runtime';

function useTest() {
  let w = {};
  return makeArray(
    (w.x = 42),
    w.x,
    (function foo() {
      w.x = 999;
      return 2;
    })(),
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [],
};
```

----------------------------------------

TITLE: Input React Component with Error Handling
DESCRIPTION: Original React component implementation that throws and catches a value from props. Includes a fixture for testing with a value of 42.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-object-method-returns-caught-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {throwInput} from 'shared-runtime';

function Component(props) {
  const object = {
    foo() {
      try {
        throwInput([props.value]);
      } catch (e) {
        return e;
      }
    },
  };
  return object.foo();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized Memoization
DESCRIPTION: This code shows the compiled version of the React component `Component`, where the `useMemo` hook has been transformed by the React compiler. The compiler introduces a `_c` function and an array `$` to store the previous values and the memoized result. This optimization avoids the overhead of calling the original `useMemo` hook and performs a direct comparison to determine if the memoized value needs to be updated.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-noAlloc.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useMemo } from "react";

function Component(t0) {
  const $ = _c(3);
  const { propA, propB } = t0;
  let t1;

  const t2 = propB?.x.y;
  let t3;
  if ($[0] !== propA || $[1] !== t2) {
    t3 = { value: t2, other: propA };
    $[0] = propA;
    $[1] = t2;
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  t1 = t3;
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ propA: 2, propB: { x: { y: [] } } }],
};

```

----------------------------------------

TITLE: React Component using useSharedValue Hook
DESCRIPTION: This code defines a React component `SomeComponent` that uses the `useSharedValue` hook to create a shared value. The component includes a button that, when pressed, attempts to directly mutate the `.value` property of this shared value. This is intended to demonstrate a common pitfall when working with shared values in React and is included for illustrative purposes to highlight the error produced by attempting to mutate this value directly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-non-imported-reanimated-shared-value-writes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableCustomTypeDefinitionForReanimated

/**
 * Test that a global (i.e. non-imported) useSharedValue is treated as an
 * unknown hook.
 */
function SomeComponent() {
  const sharedVal = useSharedValue(0);
  return (
    <Button
      onPress={() => (sharedVal.value = Math.random())}
      title="Randomize"
    />
  );
}

```

----------------------------------------

TITLE: Invalid React Mutation Error
DESCRIPTION: This error message highlights an attempt to mutate a value that should not be mutated directly within a React component. Specifically, it flags the direct mutation of the `sharedVal.value` property within the `onPress` handler of the button. The message indicates that the mutation is invalid and violates React's principles of immutability.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-non-imported-reanimated-shared-value-writes.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   9 |   return (
  10 |     <Button
> 11 |       onPress={() => (sharedVal.value = Math.random())}
     |                       ^^^^^^^^^ InvalidReact: Mutating a value returned from a function whose return value should not be mutated. Found mutation of `sharedVal` (11:11)
  12 |       title="Randomize"
  13 |     />
  14 |   );

```

----------------------------------------

TITLE: React Component with Local Reassignment
DESCRIPTION: This React component defines a local variable `local` and a function `reassignLocal` that attempts to reassign its value. The `onMount` function calls `reassignLocal` and then checks if `local` has been updated. The `useEffect` hook triggers `onMount` on component mount. The component is designed to highlight issues when reassigning local variables inside functions escaping the render scope, revealing inconsistent behavior based on whether the React Compiler is enabled.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect} from 'react';

function Component() {
  let local;

  const reassignLocal = newValue => {
    local = newValue;
  };

  const onMount = newValue => {
    reassignLocal('hello');

    if (local === newValue) {
      // Without React Compiler, `reassignLocal` is freshly created
      // on each render, capturing a binding to the latest `local`,
      // such that invoking reassignLocal will reassign the same
      // binding that we are observing in the if condition, and
      // we reach this branch
      console.log('`local` was updated!');
    } else {
      // With React Compiler enabled, `reassignLocal` is only created
      // once, capturing a binding to `local` in that render pass.
      // Therefore, calling `reassignLocal` will reassign the wrong
      // version of `local`, and not update the binding we are checking
      // in the if condition.
      //
      // To protect against this, we disallow reassigning locals from
      // functions that escape
      throw new Error('`local` not updated!');
    }
  };

  useEffect(() => {
    onMount();
  }, [onMount]);

  return 'ok';
}

```

----------------------------------------

TITLE: Input React Component with Conditional Object Creation
DESCRIPTION: A React component that creates objects and establishes relationships between them based on conditional logic. It demonstrates a pattern where objects need to reference each other.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-property-store.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @debug
function Component(props) {
  const x = {};
  let y;
  if (props.cond) {
    y = {};
  } else {
    y = {a: props.a};
  }
  // This should be inferred as `<store> y` s.t. `x` can still
  // be independently memoized. *But* this also must properly
  // extend the mutable range of the object literals in the
  // if/else branches
  y.x = x;

  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: false, a: 'a!'}],
};
```

----------------------------------------

TITLE: Utilizing useEffect Hook in React Component
DESCRIPTION: This snippet creates a React functional component that uses the useEffect hook. It logs the 'props.value' and lists an empty 'data' object as a dependency. The memoization issue arises because 'data' is reinitialized on every render, leading to potential infinite loops or performance issues. Prerequisites include installing React and understanding its lifecycle hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useEffect-dep-not-memoized.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateMemoizedEffectDependencies
import {useEffect} from 'react';

function Component(props) {
  const data = {};
  useEffect(() => {
    console.log(props.value);
  }, [data]);
  mutate(data);
  return data;
}

```

----------------------------------------

TITLE: Defining a Simple React Component in JavaScript
DESCRIPTION: This snippet defines a simple React component named 'Component' that takes props as an argument and returns an array consisting of the props and a mutated value from a MaybeMutable instance. The function illustrates basic component creation and interaction in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-accessed-outside-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const maybeMutable = new MaybeMutable();
  let x = props;
  return [x, maybeMutate(maybeMutable)];
}

```

----------------------------------------

TITLE: Validating React Hooks Usage
DESCRIPTION: This snippet checks the validity of using React hooks, such as useState and useCallback. It highlights potential pitfalls with inline requires and warns about dangerous patterns. It's designed to recognize expected usages and identify false positives, which may lead to confusion due to naming conventions associated with hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-191029ac48c8.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

// Invalid because it's dangerous.
// Normally, this would crash, but not if you use inline requires.
// This *must* be invalid.
// It's expected to have some false positives, but arguably
// they are confusing anyway due to the use*() convention
// already being associated with Hooks.
useState();
if (foo) {
  const foo = React.useCallback(() => {});
}
useCustomHook();

```

----------------------------------------

TITLE: Exporting Component Metadata with String Literals
DESCRIPTION: This code exports a constant named `FIXTURE_ENTRYPOINT`. This constant is an object containing metadata about the `foo` component, including a reference to the component's function (`fn`), an array of parameters (`params`), and the component's name (`isComponent`). This metadata can be used for testing or other tooling that needs to understand the structure and behavior of the component. This example uses double quotes for strings.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-logical.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Using a temporary function for returning a constant in React
DESCRIPTION: This snippet also defines a function 'useFoo' that uses a temporary function '_temp' returning an array with a constant string. Although it serves the same purpose as the previous snippet, it illustrates an alternative implementation approach using an inner function. This implementation may not be as efficient as the previous one due to losing the memoization benefits of 'useCallback'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-scope-global.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import { useCallback } from "react";
import { CONST_STRING0 } from "shared-runtime";

// It's correct to infer a useCallback block has no reactive dependencies
function useFoo() {
  return _temp;
}
function _temp() {
  return [CONST_STRING0];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Running react-devtools with NPX
DESCRIPTION: Command for running react-devtools using NPX without requiring global installation. NPX allows execution of npm package binaries without installation.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_2

LANGUAGE: shell
CODE:
```
npx react-devtools
```

----------------------------------------

TITLE: Defining a Basic React Component
DESCRIPTION: This snippet demonstrates the creation of a basic functional component named 'ComponentName' that returns a simple JSX element. It does not use any advanced React features like memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-expression-component.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)

const Component = function ComponentName(props) {
  return <Foo />;
};

```

----------------------------------------

TITLE: React Component Definition with Stringify and Conditional Rendering
DESCRIPTION: This code defines a React component `Foo` that takes `a` and `shouldReadA` as props. It uses the `Stringify` component to render the result of a method call, which conditionally accesses the nested property `a.b.c` based on the value of `shouldReadA`. The component is exported as part of `FIXTURE_ENTRYPOINT`, which also defines parameters and sequential renders for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-objectmethod-cond-access.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {Stringify} from 'shared-runtime';

function Foo({a, shouldReadA}) {
  return (
    <Stringify
      objectMethod={{
        method() {
          if (shouldReadA) return a.b.c;
          return null;
        },
      }}
      shouldInvokeFns={true}
    />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{a: null, shouldReadA: true}],
  sequentialRenders: [
    {a: null, shouldReadA: true},
    {a: null, shouldReadA: false},
    {a: {b: {c: 4}}, shouldReadA: true},
  ],
};

```

----------------------------------------

TITLE: Error Handling for Variable Reassignment in React
DESCRIPTION: This snippet captures an error message generated when attempting to reassign a variable after the React render lifecycle has completed. It indicates that reassigning the variable 'x' can result in inconsistent behavior during subsequent renders. The error highlights the importance of managing state correctly in React applications to prevent issues during rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.context-variable-only-chained-assign.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
   8 |   };
   9 |   const fn2 = () => {
> 10 |     const copy2 = (x = 4);
     |                    ^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `x` cannot be reassigned after render (10:10)
  11 |     return [invoke(fn1), copy2, identity(copy2)];
  12 |   };
  13 |   return invoke(fn2);
```

----------------------------------------

TITLE: Implementing Custom React Hook with Conditional Logic
DESCRIPTION: This snippet defines a custom React hook 'useTest' that uses conditional logic and another hook 'useHook'. It demonstrates the use of identity function and primitive object creation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-allocating-ternary-test-instruction-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, makeObject_Primitives} from 'shared-runtime';

function useHook() {}

function useTest({cond}) {
  const val = makeObject_Primitives();

  useHook();
  /**
   * We don't technically need a reactive scope for this ternary as
   * it cannot produce newly allocated values.
   * While identity(...) may allocate, we can teach the compiler that
   * its result is only used as as a test condition
   */
  const result = identity(cond) ? val : null;
  return result;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [{cond: true}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: React component using hooks and custom classes to display a timestamp label. Includes a useServerTime hook and Highlight class for rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-independently-memoized-property-load-for-method-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableAssumeHooksFollowRulesOfReact
function Component({label, highlightedItem}) {
  const serverTime = useServerTime();
  const highlight = new Highlight(highlightedItem);

  const time = serverTime.get();
  // subtle bit here: the binary expression infers the result of the call
  // as a primitive and not needing memoization. the logical is necessary
  // because without it there are no intermediate scopes which observe
  // the result of the binary expression, so its memoization can be pruned
  const timestampLabel = time / 1000 || label;

  return (
    <>
      {highlight.render()}
      {timestampLabel}
    </>
  );
}

function useServerTime() {
  'use no forget';

  return {
    get() {
      return 42000; // would be a constant value from the server
    },
  };
}

class Highlight {
  constructor(value) {
    this.value = value;
  }

  render() {
    return this.value;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{label: '<unused>', highlightedItem: 'Seconds passed: '}],
};
```

----------------------------------------

TITLE: Implementing a React Component with useRef
DESCRIPTION: Original React component implementation that uses useRef to reference an input element and implements a function to modify the ref on button click. This code is annotated with '@validateRefAccessDuringRender' to enable validation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-in-callback-passed-to-jsx-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
import {useRef} from 'react';

function Component() {
  const ref = useRef(null);

  const setRef = () => {
    if (ref.current !== null) {
      ref.current = '';
    }
  };

  const onClick = () => {
    setRef();
  };

  return (
    <>
      <input ref={ref} />
      <button onClick={onClick} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Input Component with Fragments and Item Mapping
DESCRIPTION: React component that conditionally renders Stringify items within a fragment, handling zero-length item scenarios
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-fragment-value.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({items}) {
  return items.length > 0 ? (
    <Foo
      value={
        <>
          {items.map(item => (
            <Stringify key={item.id} item={item} />
          ))}
        </>
      }></Foo>
  ) : null;
}
```

----------------------------------------

TITLE: Original React Component Implementation with Unused Variable
DESCRIPTION: The original component initializes and increments a local variable before overwriting it with a prop value and returning it. This implementation includes code that has no effect on the final output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-postfix-update.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let i = 0;
  i++;
  i = props.i;
  return i;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{i: 42}],
};
```

----------------------------------------

TITLE: Input: Conditional Switch Statement Dependency Management
DESCRIPTION: Function demonstrating handling of conditional dependencies in a switch statement using identity and props access
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-missing-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useCondDepInSwitchMissingDefault(props, other) {
  const x = {};
  switch (identity(other)) {
    case 1:
      x.a = props.a.b;
      break;
    case 2:
      x.b = props.a.b;
      break;
  }
  return x;
}
```

----------------------------------------

TITLE: Defining a Component with Non-Reactive Logic in React
DESCRIPTION: This snippet defines a React component that uses a loop and a switch statement to assign values based on a prop. The values are determined by the prop `cond`, and although the value of `x` is set non-reactively, it depends on a reactive variable `value`, which affects the overall outcome. Inputs include the `props` object with a `cond` property. The output is an array containing the value of `x` determined during execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-reactive-after-fixpoint.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;

  let value = null;
  loop: for (let i = 0; i < 10; i++) {
    switch (value) {
      case true: {
        x = 1;
        break loop;
      }
      case false: {
        x = 2;
        break loop;
      }
    }

    value = props.cond;
  }

  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" variable `value` used as the switch test
  // condition. That variable is initially null on the first iteration
  // of the loop, but is later set to `props.value` which is reactive.
  // Therefore x should be treated as reactive.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {cond: true},
    {cond: true},
    {cond: false},
    {cond: false},
    {cond: true},
    {cond: false},
    {cond: true},
    {cond: false},
  ],
};

```

----------------------------------------

TITLE: Opting Out of Automatic Batching in React 18
DESCRIPTION: Method to opt out of the new automatic batching behavior in React 18 for specific state updates.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_12

LANGUAGE: javascript
CODE:
```
flushSync
```

----------------------------------------

TITLE: Check Various Visibility and Invocation of useState Hook in JavaScript
DESCRIPTION: This snippet repeats the earlier examples of functions invoking useState, structured similarly but follows a valid pattern by ensuring all functions are correctly formatted. Comment annotations indicate that the snippets serve to highlight the invalid forms of hook usage based on React's conventions. The hooks should only be defined in certain ways to maintain usability.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-fadd52c1e460.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @skip
// Unsupported input

// Currently invalid.
// These are variations capturing the current heuristic--
// we only allow hooks in PascalCase or useFoo functions.
// We *could* make some of these valid. But before doing it,
// consider specific cases documented above that contain reasoning.
function a() {
  useState();
}

const whatever = function b() {
  useState();
};

const c = () => {
  useState();
};

let d = () => {
  return useState();
};
e = () => {
  useState();
};

({
  f: () => {
    useState();
  },
});
({
  g() {
    useState();
  },
});
const {
  j = () => {
    useState();
  },
} = {};
({
  k = () => {
    useState();
  },
} = {});

```

----------------------------------------

TITLE: Setting react-compiler Rule in ESLint
DESCRIPTION: Example configuration for setting the react-compiler rule to error in the rules section. Aids in surfacing errors identified by the React compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_4

LANGUAGE: json
CODE:
```
{
    "rules": {
        "react-compiler/react-compiler": "error"
    }
}
```

----------------------------------------

TITLE: Input: Defining a Conditional Component with TypeScript in React
DESCRIPTION: The original component definition using TypeScript with conditional type narrowing. It manipulates an object with a discriminated union type (HasA | HasC) and performs conditional rendering based on a boolean prop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/hoist-deps-diff-ssa-instance1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, shallowCopy, Stringify, useIdentity} from 'shared-runtime';

type HasA = {kind: 'hasA'; a: {value: number}};
type HasC = {kind: 'hasC'; c: {value: number}};
function Foo({cond}: {cond: boolean}) {
  let x: HasA | HasC = shallowCopy({kind: 'hasA', a: {value: 2}});
  /**
   * This read of x.a.value is outside of x's identifier mutable
   * range + scope range. We mark this ssa instance (x_@0) as having
   * a non-null object property `x.a`.
   */
  Math.max(x.a.value, 2);
  if (cond) {
    x = shallowCopy({kind: 'hasC', c: {value: 3}});
  }

  /**
   * Since this x (x_@2 = phi(x_@0, x_@1)) is a different ssa instance,
   * we cannot safely hoist a read of `x.a.value`
   */
  return <Stringify val={!cond && [(x as HasA).a.value + 2]} />;
}
export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{cond: false}],
  sequentialRenders: [{cond: false}, {cond: true}],
};
```

----------------------------------------

TITLE: Configuring a Sandboxed `iframe` (Backend)
DESCRIPTION: This JavaScript snippet configures the React DevTools backend within a sandboxed iframe.  It initializes the DevTools hook before React loads and listens for a message from the frontend to activate the backend.  This message-based activation is necessary due to the iframe's sandboxed environment.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_4

LANGUAGE: javascript
CODE:
```
import { activate, initialize } from "react-devtools-inline/backend";

// The DevTools hook needs to be installed before React is even required!
// The safest way to do this is probably to install it in a separate script tag.
initialize(window);

// Wait for the frontend to let us know that it's ready.
function onMessage({ data }) {
  switch (data.type) {
    case "activate-backend":
      window.removeEventListener("message", onMessage);

      activate(window);
      break;
    default:
      break;
  }
}

window.addEventListener("message", onMessage);
```

----------------------------------------

TITLE: Defining a React Component with Hooks in JavaScript
DESCRIPTION: This snippet defines a simple React functional component that uses a custom hook and the identity function from shared-runtime. The component conditionally modifies a state variable based on props and returns an array containing that state variable. The useHook() call is placed specifically to prevent memoization of the variable x.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-may-invalidate-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useHook, identity} from 'shared-runtime';

function Component(props) {
  let x = 42;
  if (props.cond) {
    x = [];
  }
  useHook(); // intersperse a hook call to prevent memoization of x
  identity(x);

  const y = [x];

  return [y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'sathya'}],
};
```

----------------------------------------

TITLE: React Component with useFragment (Input)
DESCRIPTION: This React component `Component` uses the `useFragment` hook to fetch user data based on a GraphQL fragment. It iterates over the user's timeline posts, rendering each post with a `<Post>` component. The component then adds an empty object to the posts array, calculates the length, and passes the length to a `foo` function before rendering the posts.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/readonly-object-method-calls-mutable-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useFragment} from 'shared-runtime';

function Component(props) {
  const x = makeObject();
  const user = useFragment(
    graphql`
      fragment Component_user on User {
        name
      }
    `,
    props.user
  );
  const posts = user.timeline.posts.edges.nodes.map(node => {
    x.y = true;
    return <Post post={node} />;
  });
  posts.push({});
  const count = posts.length;
  foo(count);
  return <>{posts}</>;
}

```

----------------------------------------

TITLE: Error Output for Generator in useMemo
DESCRIPTION: This error message indicates that the use of a YieldExpression within the useMemo hook is not currently supported. It points to the specific line where the yield statement is used.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useMemo-callback-generator.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  4 |   // add support for generators in the future.
  5 |   let x = useMemo(function* () {
> 6 |     yield a;
    |     ^^^^^^^ Todo: (BuildHIR::lowerExpression) Handle YieldExpression expressions (6:6)
  7 |   }, []);
  8 |   return x;
  9 | }
```

----------------------------------------

TITLE: Defining a React Component with Conditional FBT Translations
DESCRIPTION: This snippet defines a React component that uses FBT for internationalization. It conditionally renders different translated labels based on various conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/lambda-with-fbt.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {fbt} from 'fbt';

function Component() {
  const buttonLabel = () => {
    if (!someCondition) {
      return <fbt desc="My label">{'Purchase as a gift'}</fbt>;
    } else if (
      !iconOnly &&
      showPrice &&
      item?.current_gift_offer?.price?.formatted != null
    ) {
      return (
        <fbt desc="Gift button's label">
          {'Gift | '}
          <fbt:param name="price">
            {item?.current_gift_offer?.price?.formatted}
          </fbt:param>
        </fbt>
      );
    } else if (!iconOnly && !showPrice) {
      return <fbt desc="Gift button's label">{'Gift'}</fbt>;
    }
  };

  return (
    <View>
      <Button text={buttonLabel()} />
    </View>
  );
}
```

----------------------------------------

TITLE: Demonstrating React Component Ownership in JSX
DESCRIPTION: This code example illustrates the concept of component ownership in React, showing how props are passed from an owner component to its rendered elements.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_4

LANGUAGE: jsx
CODE:
```
<Parent><Child /></Parent>
```

----------------------------------------

TITLE: Implementing React Component with Dependency Propagation
DESCRIPTION: This snippet defines a React component that demonstrates dependency propagation and nullthrows behavior. It uses optional chaining and nested object access to showcase reactive dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/memberexpr-join-optional-chain.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
// To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a.b` or a subpath as a dependency.
//
// (1) Since the reactive block producing x unconditionally read props.a.<...>,
//     reading `props.a.b` outside of the block would still preserve nullthrows
//     semantics of source code
// (2) Technically, props.a, props.a.b, and props.a.b.c are all reactive deps.
//     However, `props.a?.b` is only dependent on whether `props.a` is nullish,
//     not its actual value. Since we already preserve nullthrows on `props.a`,
//     we technically do not need to add `props.a` as a dependency.

function Component(props) {
  let x = [];
  x.push(props.a?.b);
  x.push(props.a.b.c);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: {b: {c: 1}}}],
};
```

----------------------------------------

TITLE: Original Implementation of useMakeCallback Hook with JSX
DESCRIPTION: A React hook that creates a callback function to update state based on an object's value property. The callback is passed to a Stringify component with a flag to invoke functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/jsx-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow
import {Stringify} from 'shared-runtime';

/**
 * Assume that functions captured directly as jsx attributes are invoked and
 * that their property loads are hoistable.
 */
function useMakeCallback({
  obj,
  setState,
}: {
  obj: {value: number};
  setState: (newState: number) => void;
}) {
  return <Stringify cb={() => setState(obj.value)} shouldInvokeFns={true} />;
}

const setState = (arg: number) => {
  'use no memo';
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{obj: {value: 1}, setState}],
  sequentialRenders: [
    {obj: {value: 1}, setState},
    {obj: {value: 2}, setState},
  ],
};
```

----------------------------------------

TITLE: React Component Input
DESCRIPTION: This code defines a simple React component named `Component` that accepts props. It initializes an array `a` and an object `b`, calls a function `foo` with them, and then returns a div element with `a` and `b` passed as props. The function `foo` is defined but empty.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-call-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {}

function Component(props) {
  const a = [];
  const b = {};
  foo(a, b);
  let _ = <div a={a} />;
  foo(a, b);
  return <div a={a} b={b} />;
}

```

----------------------------------------

TITLE: Initializing React Component with Unresolved Effect Dependencies
DESCRIPTION: Demonstrates a React component using useEffect with a function that references external variable, causing dependency inference failure
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.non-inlined-effect-fn.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import {useEffect} from 'react';

function Component({foo}) {
  function f() {
    console.log(foo);
  }

  // No inferred dep array, the argument is not a lambda
  useEffect(f);
}
```

----------------------------------------

TITLE: Error Handling for Invalid Type Configuration
DESCRIPTION: This snippet shows the error that arises when the expected type configuration for the imported module is not a hook, as indicated by the error message. This highlights the importance of adhering to naming conventions for module exports in React projects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hooklike-module-default-not-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  2 |
  3 | function Component() {
> 4 |   return <div>{foo()}</div>;
    |                ^^^ InvalidConfig: Invalid type configuration for module. Expected type for `import ... from 'useDefaultExportNotTypedAsHook'` to be a hook based on the module name (4:4)
  5 | }
  6 |

```

----------------------------------------

TITLE: Handling Exceptions in React - JavaScript
DESCRIPTION: This JavaScript function demonstrates a regression test in a React component, where an error is thrown if a condition is met (e.g., 'page' is null). The useState hook is mentioned, indicating it is part of a React component's logic. This snippet requires React library environment with use of useState hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-0e2214abc294.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// Valid because exceptions abort rendering\nfunction RegressionTest() {\n  if (page == null) {\n    throw new Error('oh no!');\n  }\n  useState();\n}
```

LANGUAGE: JavaScript
CODE:
```
// Valid because exceptions abort rendering\nfunction RegressionTest() {\n  if (page == null) {\n    throw new Error("oh no!");\n  }\n\n  useState();\n}
```

----------------------------------------

TITLE: React Component with Mutable References using let
DESCRIPTION: Example component showing mutable variable declarations using let. Demonstrates how variables can be aliased and mutated through references even when not directly modified in the code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-liverange-loop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function mutate() {}
function cond() {}

function Component(props) {
  let a = {};
  let b = {};
  let c = {};
  let d = {};
  while (true) {
    mutate(a, b);
    if (cond(a)) {
      break;
    }
  }

  // all of these tests are seemingly readonly, since the values are never directly
  // mutated again. but they are all aliased by `d`, which is later modified, and
  // these are therefore mutable references:
  if (a) {
  }
  if (b) {
  }
  if (c) {
  }
  if (d) {
  }

  mutate(d, null);
}
```

----------------------------------------

TITLE: Input React Component with Flow Types
DESCRIPTION: Original React component code with Flow type annotations. Defines a Foo type with a bar string property and demonstrates type casting and property assignment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-cast-expression.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow
type Foo = {bar: string};
function Component(props) {
  const x = {bar: props.bar};
  const y = (x: Foo);
  y.bar = 'hello';
  const z = (y: Foo);
  return z;
}
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Mutating Dependencies with React in JavaScript
DESCRIPTION: Defines a useFoo function to process and mutate an array based on property conditions. It utilizes a mutate function from a shared runtime to apply mutations to the array. The code manages dependencies and tracks changes using conditionals and an external dependency checker.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {mutate} from 'shared-runtime';

function useFoo(props) {
  let x = [];
  x.push(props.bar);
  if (props.cond) {
    x = {};
    x = [];
    x.push(props.foo);
  } else {
    x = [];
    x = [];
    x.push(props.bar);
  }
  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{bar: 'bar', foo: 'foo', cond: true}],
  sequentialRenders: [
    {bar: 'bar', foo: 'foo', cond: true},
    {bar: 'bar', foo: 'foo', cond: true},
    {bar: 'bar', foo: 'foo', cond: false},
  ],
};

```

----------------------------------------

TITLE: Implementing a Basic Host Config for a Custom React Renderer
DESCRIPTION: Example of a minimal Host Config implementation that would be required for a custom renderer. Shows essential methods for creating instances and handling DOM-like mutations.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
const HostConfig = {
  createInstance(type, props) {
    // e.g. DOM renderer returns a DOM node
  },
  // ...
  supportsMutation: true, // it works by mutating nodes
  appendChild(parent, child) {
    // e.g. DOM renderer would call .appendChild() here
  },
  // ...
};
```

----------------------------------------

TITLE: React Invalid Hook Call Error
DESCRIPTION: This error message indicates that a hook is being called conditionally, violating the Rules of Hooks in React. The error specifically points to line 6 where `local.useFoo()` is being called inside an `if` statement. This error prevents React from correctly managing hook state and effects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-conditionally-methodcall-hooklike-property-of-local.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  4 |   const local = makeObject_Primitives();
  5 |   if (props.cond) {
> 6 |     local.useFoo();
    |     ^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)
  7 |   }
  8 | }
  9 |

```

----------------------------------------

TITLE: Defining a Basic React Component - JavaScript
DESCRIPTION: This snippet defines a functional React component named 'Component' that initializes a text variable containing double quotes and passes it as a prop to a child component. The 'Child' component simply returns the received text. This is useful for testing string interpolation in React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-jsx-attribute-escaped-constant-propagation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
export function Component() {
  // Test what happens if a string with double-quotes is interpolated via constant propagation
  const text = 'Some "text"';
  return <Child text={text} />;
}

function Child(props) {
  return props.text;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Defining a Simple Component in React (JavaScript)
DESCRIPTION: This snippet defines a simple functional component that calls a method, 'foo.bar', with a spread of props. It returns the result of that method call as the component's output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-call-spread.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = foo.bar(...props.a, null, ...props.b);
  return x;
}
```

----------------------------------------

TITLE: Input Component with useEffect and Member Expression
DESCRIPTION: The original React component with a useEffect hook that uses nested object properties. The special comment @inferEffectDependencies indicates that React should automatically infer the dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-memberexpr-merge.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect} from 'react';
import {print} from 'shared-runtime';

function ReactiveMemberExprMerge({propVal}) {
  const obj = {a: {b: propVal}};
  useEffect(() => print(obj.a, obj.a.b));
}
```

----------------------------------------

TITLE: Analyzing React/JavaScript Hook Naming Conventions
DESCRIPTION: The code snippet demonstrates various valid naming patterns for hooks in a React JavaScript environment, clarifying common misconceptions associated with naming. It requires familiarity with React and JavaScript syntax. The examples illustrate valid patterns that do not match the use[A-Z] or PascalCase naming conventions and do not result in warnings or errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-df4d750736f3.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because they're not matching use[A-Z].
fooState();
_use();
_useState();
use_hook();
// also valid because it's not matching the PascalCase namespace
jest.useFakeTimer();

```

----------------------------------------

TITLE: Processing Items Asynchronously in React Component
DESCRIPTION: This asynchronous function 'Component' takes a prop 'items', iterates over it using 'for await' to accommodate asynchronous data, and pushes each item to an array 'x', which is then returned. The function demonstrates handling asynchronous iterable objects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-await-loops.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
async function Component({items}) {
  const x = [];
  for await (const item of items) {
    x.push(item);
  }
  return x;
}

```

----------------------------------------

TITLE: Defining Original React Component with Memoization
DESCRIPTION: This snippet defines a React component with a memoized callback function. It uses the 'mutate' function from 'shared-runtime' and renders a 'Foo' component with the memoized callback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/maybe-mutate-object-in-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {mutate} = require('shared-runtime');

function Component(props) {
  const object = {};
  // We optimistically assume function calls within callbacks don't mutate (unless the function
  // is known to be called during render), so this should get memoized
  const onClick = () => {
    mutate(object);
  };
  return <Foo callback={onClick}>{props.children}</Foo>;
}

function Foo({children}) {
  return children;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{children: <div>Hello</div>}],
};
```

----------------------------------------

TITLE: Defining a Basic Component in React with JavaScript
DESCRIPTION: This snippet defines a basic React component that uses a switch statement to assign a value to `x` based on a prop condition. It demonstrates handling reactivity by treating `x` as influenced by a reactive prop. The `FIXTURE_ENTRYPOINT` object outlines test scenarios with sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-switch-case-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  switch (props.cond) {
    case true: {
      x = 1;
      break;
    }
    case false: {
      x = 2;
      break;
    }
    default: {
      x = 3;
    }
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `props.cond` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {cond: true},
    {cond: true},
    {cond: false},
    {cond: false},
    {cond: true},
    {cond: false},
    {cond: true},
    {cond: false},
  ],
};
```

----------------------------------------

TITLE: Testing Valid React Element Types with isValidElementType
DESCRIPTION: Demonstrates how to use react-is to verify if different React components are valid element types, including class components, function components, forwarded refs, and Context components.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import React from "react";
import * as ReactIs from "react-is";

class ClassComponent extends React.Component {
  render() {
    return React.createElement("div");
  }
}

const FunctionComponent = () => React.createElement("div");

const ForwardRefComponent = React.forwardRef((props, ref) =>
  React.createElement(Component, { forwardedRef: ref, ...props })
);

const Context = React.createContext(false);

ReactIs.isValidElementType("div"); // true
ReactIs.isValidElementType(ClassComponent); // true
ReactIs.isValidElementType(FunctionComponent); // true
ReactIs.isValidElementType(ForwardRefComponent); // true
ReactIs.isValidElementType(Context.Provider); // true
ReactIs.isValidElementType(Context.Consumer); // true
```

----------------------------------------

TITLE: Defining React Component - JavaScript
DESCRIPTION: This snippet defines a React functional component named 'Component'. It initializes a variable 'x', modifies its value based on a logical condition, and returns the final value. The component takes 'props' as an argument but does not currently use it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-conditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  (x = 1) && (x = 2);
  return x;
}
```

----------------------------------------

TITLE: Input React Component with Error Handling
DESCRIPTION: Original React component implementation that creates a callback function to handle thrown inputs. The component attempts to throw a value from props and catches any resulting errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-function-expression-returns-caught-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {throwInput} from 'shared-runtime';

function Component(props) {
  const callback = () => {
    try {
      throwInput([props.value]);
    } catch (e) {
      return e;
    }
  };
  return callback();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Enhanced Props Logging with Dispatcher Guard in React
DESCRIPTION: This snippet provides a more complex React component that uses dispatcher guards and structured logging of props. It employs useFire and useEffect to control side effects based on props changes, ensuring that the component behaves correctly between renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/hook-guard.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { $dispatcherGuard } from "react-compiler-runtime";
import { c as _c, useFire } from "react/compiler-runtime"; // @enableFire @enableEmitHookGuards
import { fire } from "react";

function Component(props) {
  const $ = _c(3);
  try {
    $dispatcherGuard(0);
    const foo = _temp;
    const t0 = (function () {
      try {
        $dispatcherGuard(2);
        return useFire(foo);
      } finally {
        $dispatcherGuard(3);
      }
    })();
    let t1;
    if ($[0] !== props || $[1] !== t0) {
      t1 = () => {
        t0(props);
      };
      $[0] = props;
      $[1] = t0;
      $[2] = t1;
    } else {
      t1 = $[2];
    }
    (function () {
      try {
        $dispatcherGuard(2);
        return useEffect(t1);
      } finally {
        $dispatcherGuard(3);
      }
    })();
    return null;
  } finally {
    $dispatcherGuard(1);
  }
}
function _temp(props_0) {
  console.log(props_0);
}

```

----------------------------------------

TITLE: React Component with useCallback Implementation
DESCRIPTION: Implements a React component using useCallback hook with primitive object mutations. The component creates mutable objects, assigns props values, and returns a memoized callback function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-maybe-modify-free-variable-dont-preserve-memoization-guarantee.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees:false
import {useCallback} from 'react';
import {identity, makeObject_Primitives, mutate, useHook} from 'shared-runtime';

function Component(props) {
  const free = makeObject_Primitives();
  const free2 = makeObject_Primitives();
  const part = free2.part;
  useHook();
  const callback = useCallback(() => {
    const x = makeObject_Primitives();
    x.value = props.value;
    mutate(x, free, part);
  }, [props.value]);

  mutate(free, part);
  return callback;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Creating an Internationalized React Component with FBT
DESCRIPTION: This snippet demonstrates how to create a React component using the FBT library for internationalization. It includes a parameterized greeting and exports a fixture for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-to-string.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component(props) {
  const element = (
    <fbt desc={'Dialog to show to user'}>
      Hello <fbt:param name="user name">{props.name}</fbt:param>
    </fbt>
  );
  return element.toString();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Jason'}],
};
```

----------------------------------------

TITLE: React Component with Inferred useEffect Dependency - JavaScript
DESCRIPTION: This is a transformed version of the `Component` from the input, likely representing the output of a compiler or static analysis tool. The `useEffect` hook's dependency array has been updated to include `[arrRef]`, contrasting with the input snippet's attempt to avoid it. It still accesses and modifies `arrRef.current`. This snippet appears under a 'Code' heading, suggesting it is the processed output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/mutate-after-useeffect-ref-access.expect.md#_snippet_1

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)

import { useEffect, useRef } from "react";
import { print } from "shared-runtime";

function Component(t0) {
  const { arrRef } = t0;

  useEffect(() => print(arrRef.current), [arrRef]);
  arrRef.current.val = 2;
  return arrRef;
}

```

----------------------------------------

TITLE: React Component Definition with Props
DESCRIPTION: This JavaScript code defines a React component named `Component` that accepts `props` as input. It creates an array `c_0` containing the values of `props.a` and `props.b.c` and returns this array. The `FIXTURE_ENTRYPOINT` object specifies the component and sample parameters for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/option-enable-change-variable-codegen.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableChangeVariableCodegen
function Component(props) {
  const c_0 = [props.a, props.b.c];
  return c_0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 3.14, b: {c: true}}],
};

```

----------------------------------------

TITLE: Compiled React Hook with Optimizations
DESCRIPTION: The compiled version of the hook with React compiler optimizations. Includes memoization logic to prevent unnecessary recomputation of makeArray calls and Set creation when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-constructor.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

function useHook(t0) {
  const $ = _c(7);
  const { el1, el2 } = t0;
  let s;
  if ($[0] !== el1 || $[1] !== el2) {
    s = new Set();
    let t1;
    if ($[3] !== el1) {
      t1 = makeArray(el1);
      $[3] = el1;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    s.add(t1);
    let t2;
    if ($[5] !== el2) {
      t2 = makeArray(el2);
      $[5] = el2;
      $[6] = t2;
    } else {
      t2 = $[6];
    }
    s.add(t2);
    $[0] = el1;
    $[1] = el2;
    $[2] = s;
  } else {
    s = $[2];
  }
  return s.size;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ el1: 1, el2: "foo" }],
  sequentialRenders: [
    { el1: 1, el2: "foo" },
    { el1: 2, el2: "foo" },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Optimizations
DESCRIPTION: This is the compiler-optimized version of the React component. The React compiler has added memoization logic using an array cache to store dependent values (a and props.c) and the resulting array b, preventing unnecessary recalculations on re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-primitive-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);

  const a = props.a + props.b;
  let b;
  if ($[0] !== a || $[1] !== props.c) {
    b = [];
    const c = {};
    c.a = a;
    b.push(props.c);
    $[0] = a;
    $[1] = props.c;
    $[2] = b;
  } else {
    b = $[2];
  }
  return b;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Optimized version of the React component using compiler runtime for memoization and efficient re-rendering
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-fragment-value.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(t0) {
  const $ = _c(2);
  const { items } = t0;
  let t1;
  if ($[0] !== items) {
    t1 = items.length > 0 ? <Foo value={<>{items.map(_temp)}</>} /> : null;
    $[0] = items;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Aborting Request in React
DESCRIPTION: Method to stop rendering and abandon incomplete work. Behavior differs based on request creation method - createRequest encodes errors in unfinished slots, while createPrerenderRequest omits unfinished content.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_10

LANGUAGE: typescript
CODE:
```
abort(request: Request): void
```

----------------------------------------

TITLE: React useState Mutation Error
DESCRIPTION: This snippet shows the error produced by a React linter when direct mutation of a state variable is detected. The linter points out the line where `x.value` is being directly modified, suggesting the use of the setter function `setX` instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-function-expression-mutates-immutable-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  3 |   const onChange = e => {
  4 |     // INVALID! should use copy-on-write and pass the new value
> 5 |     x.value = e.target.value;
    |     ^ InvalidReact: Mutating a value returned from 'useState()', which should not be mutated. Use the setter function to update instead. Found mutation of `x` (5:5)
  6 |     setX(x);
  7 |   };
  8 |   return <input value={x.value} onChange={onChange} />;
```

----------------------------------------

TITLE: Error Handling for Incorrect useEffect Hook Usage
DESCRIPTION: This error message indicates that the useEffect hook is being used incorrectly in the function nonReactFn. It highlights the need for a proper dependency array to avoid breaking the build, signaling developer attention to fix this issue. Understanding the implications of React's compiler diagnostics is crucial.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.callsite-in-non-react-fn.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  3 |
  4 | function nonReactFn(arg) {
> 5 |   useEffect(() => [1, 2, arg]);
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: [InferEffectDependencies] React Compiler is unable to infer dependencies of this effect. This will break your build! To resolve, either pass your own dependency array or fix reported compiler bailout diagnostics. (5:5)
  6 | }
  7 |
```

----------------------------------------

TITLE: Initializing React Component with Inline Effect
DESCRIPTION: First code snippet showing a React functional component using useEffect to mutate an external object's property directly within the effect callback
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-external-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect} from 'react';

let x = {a: 42};

function Component(props) {
  useEffect(() => {
    x.a = 10;
  });
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Using Fragments in React Component (JavaScript)
DESCRIPTION: This JavaScript code snippet illustrates a React component employing the `useFragment` hook from 'shared-runtime' to fetch user data. It maps through the user's post timeline and generates a list of <Post> components. Input is 'props.user', and the component returns the rendered posts wrapped in a fragment. This version lacks caching or memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/readonly-object-method-calls.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useFragment} from 'shared-runtime';

function Component(props) {
  const user = useFragment(
    graphql`
      fragment Component_user on User {
        name
      }
    `,
    props.user
  );
  const posts = user.timeline.posts.edges.nodes.map(node => (
    <Post post={node} />
  ));
  posts.push({});
  const count = posts.length;
  foo(count);
  return <>{posts}</>;
}

```

----------------------------------------

TITLE: Using State and Optional Chaining in React Component
DESCRIPTION: This snippet demonstrates a more complex React component function that uses the React compiler runtime for state management. It checks if the props have changed and utilizes optional chaining to invoke an object's method safely. The function optimizes performance by storing the previous result of the computation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-method-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    const x = makeObject(props);
    const y = makeObject(props);
    t0 = x.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  return z;
}
```

----------------------------------------

TITLE: Optimized React Component with State Tracking
DESCRIPTION: Enhances the initial React component with an optimization mechanism using a caching system to only recompute the component structure when necessary, exploiting the runtime caching provided by React. This optimization is driven by changes in the props.p0 value, demonstrating state tracking and rendering efficiency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.p0) {
    const x = {};
    const y = [];
    x.y = y;
    const child = <Component data={y} />;
    x.y.push(props.p0);
    t0 = <Component data={x}>{child}</Component>;
    $[0] = props.p0;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

```

----------------------------------------

TITLE: Optimized React Component Rendering with Conditional Logic
DESCRIPTION: This code snippet uses a React component function with internal caching logic for rendering. It imports from 'react/compiler-runtime' and checks conditions to manage and optimize repeated renders. It uses the 'useRef' hook and evaluates conditions to reuse previous renders, minimizing unnecessary updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-not-added-to-dep-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender:false
function Foo(t0) {
  const $ = _c(4);
  const { a } = t0;
  const ref = useRef();
  let t1;
  if ($[0] !== a) {
    t1 = { a, val: ref.current };
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  let t2;
  if ($[2] !== x) {
    t2 = <VideoList videos={x} />;
    $[2] = x;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

```

----------------------------------------

TITLE: React Component with State Update and Export
DESCRIPTION: This snippet defines a React component named 't' that uses the useState hook to trigger a state update with `setstate(1)`. It then returns the value of the `foo` prop. The `FIXTURE_ENTRYPOINT` object exports metadata about the component, including a reference to the component function, the expected parameter names ('TodoAdd'), and the component's name ('TodoAdd').
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function t(props) {
  let [, setstate] = useState();
  setstate(1);
  return props.foo;
}

export const FIXTURE_ENTRYPOINT = {
  fn: t,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Handling JavaScript Const Reassignment
DESCRIPTION: This JavaScript snippet defines a function that tries to reassign a const variable, triggering an error. No external dependencies are required. The const keyword is used to declare a variable `x`, which cannot be reassigned, leading to an 'InvalidJS' error when reassignment is attempted at line 3. The function takes no parameters and showcases the immutability constraint of const variables in JavaScript.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-const.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const x = 0;
  x = 1;
}

```

LANGUAGE: javascript
CODE:
```
1 | function Component() {
2 |   const x = 0;
> 3 |   x = 1;
    |   ^ InvalidJS: Cannot reassign a `const` variable. `x` is declared as const (3:3)
4 | }
5 |

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: The original component function that creates and mutates objects based on an input parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-computed-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let x = {a};
  let y = {};

  y.x = x['a'];
  mutate(y);
  return x;
}
```

----------------------------------------

TITLE: Incorrect React Hook Usage
DESCRIPTION: This JavaScript snippet demonstrates how a React hook (`Foo.useFoo`) should not be used. Instead of calling the hook directly, it's assigned to a variable `x`, and then `x` is called. This is an invalid usage of React hooks and will result in an error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.propertyload-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const x = Foo.useFoo;
  return x();
}

```

----------------------------------------

TITLE: Advanced Memoization Strategy with React and Shared Runtime
DESCRIPTION: This React component demonstrates an advanced memoization approach using hooks and conditional logic. It utilizes 'react/compiler-runtime' and 'shared-runtime' dependencies to manage and preserve component states efficiently. The component tracks multiple parameters to ensure minimal re-computation and employs ValidateMemoization to check inputs and outputs. Key props include 'props.items', and the component returns a React element conditioned on memoized states, optimizing React performance through memoization guarantees.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-single-with-unconditional.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR
import { ValidateMemoization } from "shared-runtime";
function Component(props) {
  const $ = _c(7);
  let t0;
  let x;
  if ($[0] !== props.items) {
    x = [];
    x.push(props?.items);
    x.push(props.items);
    $[0] = props.items;
    $[1] = x;
  } else {
    x = $[1];
  }
  t0 = x;
  const data = t0;
  let t1;
  if ($[2] !== props.items) {
    t1 = [props.items];
    $[2] = props.items;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== data || $[5] !== t1) {
    t2 = <ValidateMemoization inputs={t1} output={data} />;
    $[4] = data;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
```

----------------------------------------

TITLE: JSX Comment Node Support
DESCRIPTION: This code snippet demonstrates the support for comment nodes within JSX.  Comments enclosed within curly braces and forward slashes are now recognized and will not be rendered in the output. This feature allows developers to include comments directly within JSX code for documentation or temporary code exclusion.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_25

LANGUAGE: JSX
CODE:
```
"<div>{/* this is a comment and won't be rendered */}</div>"
```

----------------------------------------

TITLE: Original React Component with Destructuring Parameters
DESCRIPTION: Basic React component that takes a regular parameter 'foo' and uses array destructuring for the rest parameter 'bar'. Returns an array containing both parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-array-pattern.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(foo, ...[bar]) {
  return [foo, bar];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['foo', ['bar', 'baz']],
};
```

----------------------------------------

TITLE: React Component with Implicit Return
DESCRIPTION: Similar React component using implicit return instead of explicit undefined. Includes same fixture configuration but with double-quoted strings.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-undefined.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  if (props.cond) {
    return;
  }
  return props.value;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component Error Message
DESCRIPTION: This snippet shows the error message generated when attempting to use the incorrect React component. It highlights the specific line where the error occurs and provides an explanation of why this approach violates React's rules for pure components and hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-destructure-to-local-global-variables.expect.md#2025-04-22_snippet_1

LANGUAGE: plaintext
CODE:
```
  1 | function Component(props) {
  2 |   let a;
> 3 |   [a, b] = props.value;
    |       ^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (3:3)
  4 |
  5 |   return [a, b];
  6 | }
```

----------------------------------------

TITLE: Implementing Effect with Dynamic Ref Dependency - JavaScript
DESCRIPTION: This React functional component `Component` initializes two mutable references, `arr` and `other`, using `useRef`. A variable `derived` is assigned one of these refs based on the boolean `cond` prop. A `useEffect` hook is defined which accesses the `.current` value of the `derived` ref. The component returns the `arr` ref.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-ref-ternary.expect.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useRef, useEffect} from 'react';
import {print, mutate} from 'shared-runtime';

function Component({cond}) {
  const arr = useRef([]);
  const other = useRef([]);
  // Although arr and other are both stable, derived is not
  const derived = cond ? arr : other;
  useEffect(() => {
    mutate(derived.current);
    print(derived.current);
  });
  return arr;
}
```

----------------------------------------

TITLE: Original React Component with Memoization Comments
DESCRIPTION: This is the input React component with comments explaining the memoization strategy. It demonstrates how primitives and objects are handled differently with regard to memoization needs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-primitive-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a does not need to be memoized ever, even though it's a
  // dependency of c, which exists in a scope that has a memoized
  // output. it doesn't need to be memoized bc the value is a primitive type.
  const a = props.a + props.b;

  // b and c are interleaved and grouped into a single scope,
  // but they are independent values. c does not escape, but
  // we need to ensure that a is memoized or else b will invalidate
  // on every render since a is a dependency.
  const b = [];
  const c = {};
  c.a = a;
  b.push(props.c);

  return b;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Filtering Non-Zero Numbers from Array with Type Annotations in React
DESCRIPTION: This snippet defines a useArray function that filters out zero values from an input array of numbers. It utilizes type annotations to enable compiler optimizations. The FIXTURE_ENTRYPOINT exports the function with a sample input for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/todo_type-annotations-props.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableUseTypeAnnotations
function useArray(items: Array<number>) {
  // With type information we know that the callback cannot escape
  // and does not need to be memoized, only the result needs to be
  // memoized:
  return items.filter(x => x !== 0);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useArray,
  params: [[1, 0, 2, 0, 3, 0, 42]],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the React component using compiler runtime techniques. It includes memoization and conditional rendering to improve performance. The component's logic remains the same, but its implementation is more efficient.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-array-declaration-to-context-var.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.value) {
    const [t0] = props.value;
    x = t0;
    const foo = () => {
      x = identity(props.value[0]);
    };

    foo();
    $[0] = props.value;
    $[1] = x;
  } else {
    x = $[1];
  }
  let t0;
  if ($[2] !== x) {
    t0 = <div>{x}</div>;
    $[2] = x;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: [42] }],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized Memoization
DESCRIPTION: This is the compiler-optimized version of the component where useMemo has been replaced with a custom caching mechanism. It uses a Symbol.for('react.memo_cache_sentinel') to determine if recalculation is needed, storing the component and render results in a cache array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-as-jsx-element-tag.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { Stringify } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  let Component;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    Component = Stringify;
    let t0;

    t0 = Component;
    Component = t0;
    $[0] = Component;
  } else {
    Component = $[0];
  }
  let t0;
  if ($[1] !== props) {
    t0 = <Component {...props} />;
    $[1] = props;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
```

----------------------------------------

TITLE: React Component with useCallback Memoization
DESCRIPTION: This React component `useFoo` attempts to memoize a callback using `useCallback`. However, the React Compiler identifies that the memoization could not be preserved because the dependency array `[x]` is causing issues during compilation. Specifically, the compiler cannot guarantee the existing memoization due to how `x` is being handled.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.todo-useCallback-captures-invalidating-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useCallback} from 'react';

// False positive:
// We currently bail out on this because we don't understand
// that `() => [x]` gets pruned because `x` always invalidates.
function useFoo(props) {
  const x = [];
  useHook();
  x.push(props);

  return useCallback(() => [x], [x]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}]],
};
```

----------------------------------------

TITLE: Error Handling for Memoization in React Hook
DESCRIPTION: This snippet illustrates the error message generated when React cannot preserve the memoization guarantees due to mismatched dependencies. The error indicates that the inferred dependencies did not match the manually specified dependencies, which may lead to unexpected value changes during re-renders. This provides insight into debugging and optimizing React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.hoist-useCallback-infer-conditional-value-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (6:14)
```

----------------------------------------

TITLE: Input React Component with Object Property Iteration
DESCRIPTION: Original React component that iterates through object properties, skipping the 'continue' property. Uses object spread operator to clone props.value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-continue.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  const object = {...props.value};
  for (const y in object) {
    if (y === 'continue') {
      continue;
    }
    x = object[y];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: {a: 'a', continue: 'skip', b: 'hello!'}}],
  sequentialRenders: [
    {value: {a: 'a', continue: 'skip', b: 'hello!'}},
    {value: {a: 'a', continue: 'skip', b: 'hello!'}},
    {value: {a: 'skip!', continue: true}},
    {value: {a: 'a', continue: 'skip', b: 'hello!'}},
    {value: {a: 'skip!', continue: true}},
    {value: {a: 'a', continue: 'skip', b: 'hello!'}},
    {value: {a: 'skip!', continue: true}},
    {value: {a: 'skip!', continue: true}},
  ],
};
```

----------------------------------------

TITLE: Using useState in React Component - JavaScript
DESCRIPTION: This snippet defines a React functional component utilizing the useState hook to manage internal state and render a div element containing that state value. It imports useState from React and defines auxiliary functions to handle data transformations. It establishes a clear entry point for testing the component with predefined parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-and-other-hook-unpruned-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react'; // @enableChangeDetectionForDebugging

function useOther(x) {
  return x;
}

function Component(props) {
  const w = f(props.x);
  const z = useOther(w);
  const [x, _] = useState(z);
  return <div>{x}</div>;
}

function f(x) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: 42}],
  isComponent: true,
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component that performs calculations using imported utility functions. Takes props with 'a' and 'b' values and returns an array of computed results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoization-comments.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableMemoizationComments
import {addOne, getNumber, identity} from 'shared-runtime';

function Component(props) {
  const x = identity(props.a);
  const y = addOne(x);
  const z = identity(props.b);
  return [x, y, z];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1, b: 10}],
};
```

----------------------------------------

TITLE: React DOM Server Configuration
DESCRIPTION: Server-side rendering configuration including error handling, stream abortion, and HTML optimization features.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_7

LANGUAGE: javascript
CODE:
```
renderToPipeableStream(element, {
  bootstrapScriptContent: scriptContent,
  onRecoverableError: (error, componentStack) => {
    // Handle error with component stack
  },
  onShellError: (error) => {
    // Handle shell error
  }
});
```

----------------------------------------

TITLE: React Component with Icon Rendering
DESCRIPTION: This React component, `ViewModeSelector`, renders a `Dropdown` component with a custom checkable indicator.  The `renderIcon` function is defined to return an `AcceptIcon` component.  The code attempts to set the `displayName` property of the `renderIcon` function, which causes an immutability error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-function-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
export function ViewModeSelector(props) {
  const renderIcon = () => <AcceptIcon />;
  renderIcon.displayName = 'AcceptIcon';

  return <Dropdown checkableIndicator={{children: renderIcon}} />;
}
```

----------------------------------------

TITLE: React Component with useMemo
DESCRIPTION: This code defines a React component `Component` that uses `useMemo` to memoize an object based on `propA` and a nested property `propB.x.y`. The `useMemo` hook ensures that the object is only re-created when either `propA` or `propB.x.y` changes, thus optimizing performance by preventing unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-noAlloc.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';

function Component({propA, propB}) {
  return useMemo(() => {
    return {
      value: propB?.x.y,
      other: propA,
    };
  }, [propA, propB.x.y]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{propA: 2, propB: {x: {y: []}}}],
};

```

----------------------------------------

TITLE: Input Implementation of Conditional Subpath Optimization in React
DESCRIPTION: Original code showing a function that accesses 'props.a.b' unconditionally and 'props.a' conditionally. This represents the code as written by the developer before the React Compiler processes it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/subpath-order1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// When a conditional dependency `props.a` is a subpath of an unconditional
// dependency `props.a.b`, we can access `props.a` while preserving program
// semantics (with respect to nullthrows).
// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`

import {identity} from 'shared-runtime';

// ordering of accesses should not matter
function useConditionalSubpath1(props, cond) {
  const x = {};
  x.b = props.a.b;
  if (identity(cond)) {
    x.a = props.a;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useConditionalSubpath1,
  params: [{a: {b: 3}}, false],
};
```

----------------------------------------

TITLE: Defining a React Component with Invalid Ref Access - JavaScript
DESCRIPTION: This snippet defines a functional React component that attempts to access the 'current' property of a ref during the render phase, which is against React's rules. It highlights an invalid operation that generates a specific error message when executed. Key parameters include 'props' which should contain a 'ref'. The expected output is an error message indicating that accessing 'current' during render is invalid.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-write-ref-prop-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender @compilationMode(infer)
function Component(props) {
  const ref = props.ref;
  ref.current = true;
  return <div>{value}</div>;
}

```

----------------------------------------

TITLE: Defining a Component with Array Manipulation in JavaScript
DESCRIPTION: This snippet demonstrates defining a React component named 'Component' that utilizes 'makeArray' from 'shared-runtime'. It processes a set of numbers by popping elements from an array, calculating their sum, and returning the modified array along with the computed sum. Dependency on the 'shared-runtime' module is required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-in-while-loop-condition.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

// @flow
function Component() {
  const items = makeArray(0, 1, 2);
  let item;
  let sum = 0;
  while ((item = items.pop())) {
    sum += item;
  }
  return [items, sum];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with useEffect and State Update
DESCRIPTION: This React component initializes a state variable `state` using `useState`. It then defines two functions, `f` and `g`, where `g` calls `f`, which updates the state using `setState`. The `useEffect` hook then calls `g`, which indirectly updates the state. This can cause performance issues as highlighted in the logs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-setState-in-useEffect-transitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger @validateNoSetStateInPassiveEffects
import {useEffect, useState} from 'react';

function Component() {
  const [state, setState] = useState(0);
  const f = () => {
    setState(s => s + 1);
  };
  const g = () => {
    f();
  };
  useEffect(() => {
    g();
  });
  return state;
}

```

----------------------------------------

TITLE: Demonstrating Memoization Violation with useCallback in React
DESCRIPTION: This code shows an unsound memoization pattern where a mutable array is both used in the callback function and as a dependency. The array is later reassigned, which breaks memoization guarantees. React Compiler detects this and refuses to optimize the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.invalid-useCallback-captures-reassigned-context.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useCallback} from 'react';
import {makeArray} from 'shared-runtime';

// This case is already unsound in source, so we can safely bailout
function Foo(props) {
  let x = [];
  x.push(props);

  // makeArray() is captured, but depsList contains [props]
  const cb = useCallback(() => [x], [x]);

  x = makeArray();

  return cb;
}
export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Frontend Initialization
DESCRIPTION: This JavaScript snippet shows how to initialize the React DevTools frontend, which returns a React component for rendering. The `initialize` function configures the DevTools interface to listen to the window where the backend hook is injected.  The returned component should be rendered using `ReactDOMClient.createRoot` because it uses concurrent React features.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { initialize } from 'react-devtools-inline/frontend';

// This should be the iframe the backend hook has been installed in.
const iframe = document.getElementById(frameID);
const contentWindow = iframe.contentWindow;

// This returns a React component that can be rendered into your app.
// e.g. render(<DevTools {...props} />);
const DevTools = initialize(contentWindow);
```

----------------------------------------

TITLE: Defining Custom Hook with Dependency Management - React - JavaScript
DESCRIPTION: This snippet defines a custom hook 'useFoo' that combines two input values using the 'useNoAlias' function from shared-runtime to ensure proper compilation and state management. It returns an object containing the computed value, ensuring efficient updates only when necessary. The hook is set up for potential optimization with a dependency array mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-compile-hooks-with-multiple-params.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
import {useNoAlias} from 'shared-runtime';

// This should be compiled by Forget
function useFoo(value1, value2) {
  return {
    value: useNoAlias(value1 + value2),
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [1, 2],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
import { useNoAlias } from "shared-runtime";

// This should be compiled by Forget
function useFoo(value1, value2) {
  const $ = _c(2);

  const t0 = useNoAlias(value1 + value2);
  let t1;
  if ($[0] !== t0) {
    t1 = { value: t0 };
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [1, 2],
};
```

----------------------------------------

TITLE: Calculating Aggregate Counts in React - JavaScript
DESCRIPTION: This snippet defines a React functional component 'HomeDiscoStoreItemTileRating' that calculates the total count of aggregates for a given item. It initializes a count variable and iterates over item aggregates to sum their counts, which is then displayed in a Text component. The use of 'useFragment' suggests reliance on a library for efficient data fetching or state management. Key dependencies include React and the specific library that facilitates 'useFragment'. Expect inputs related to the item structure and outputs as a visual representation of count in the UI. Limitations include the necessity of correctly structured item data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/repro-scope-missing-mutable-range.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function HomeDiscoStoreItemTileRating(props) {
  const item = useFragment();
  let count = 0;
  const aggregates = item?.aggregates || [];
  aggregates.forEach(aggregate => {
    count += aggregate.count || 0;
  });

  return <Text>{count}</Text>;
}

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function HomeDiscoStoreItemTileRating(props) {
  const $ = _c(4);
  const item = useFragment();
  let count;
  if ($[0] !== item?.aggregates) {
    count = 0;
    const aggregates = item?.aggregates || [];
    aggregates.forEach((aggregate) => {
      count = count + (aggregate.count || 0);
      count;
    });
    $[0] = item?.aggregates;
    $[1] = count;
  } else {
    count = $[1];
  }
  let t0;
  if ($[2] !== count) {
    t0 = <Text>{count}</Text>;
    $[2] = count;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

```

----------------------------------------

TITLE: Using Reactive Dependencies in Conditional Scopes - JavaScript
DESCRIPTION: This snippet defines a function 'useReactiveDepsInCondScope' that handles reactive dependencies within a conditional scope. It utilizes 'CONST_FALSE' and 'identity' from 'shared-runtime' to manage dependencies based on the conditional status of the scope. This implementation creates a new object 'x' and conditionally assigns a temporary variable 'tmp' using an identity function when the condition is met. It is designed to work with predefined constants and objects from the 'shared-runtime'. The function is exported as a part of the FIXTURE_ENTRYPOINT with its parameters defined.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cond-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_FALSE, identity} from 'shared-runtime';\n\nfunction useReactiveDepsInCondScope(props) {\n  let x = {};\n  if (CONST_FALSE) {\n    let tmp = identity(props.a.b);\n    x.a = tmp;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useReactiveDepsInCondScope,\n  params: [{}],\n};
```

----------------------------------------

TITLE: Implementing Memoization with useCallback in React - JavaScript
DESCRIPTION: This snippet defines a React functional component that uses the useCallback hook to memoize a function based on specified dependencies. It aims to optimize performance by ensuring the function is not recreated unless dependencies change. Dependencies include propA.a and propB.x.y, and the function performs a mutation on an object before returning a value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-infer-less-specific-conditional-access.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';
import {mutate} from 'shared-runtime';

function Component({propA, propB}) {
  return useCallback(() => {
    const x = {};
    if (propA?.a) {
      mutate(x);
      return {
        value: propB.x.y,
      };
    }
  }, [propA?.a, propB.x.y]);
}
```

----------------------------------------

TITLE: Function Definition with Conditional Element Handling in JavaScript
DESCRIPTION: This snippet defines a function named 'foo' that processes a 'props' object, conditionally assigning and modifying an 'x' array. If 'props.cond' is true, 'x' is re-initialized and altered based on 'props.foo'. Dependencies include appropriate JavaScript runtime supporting dynamic object destructuring. Inputs are 'props' and the output is an array 'x', which contains elements based on 'props'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-via-destructuring.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let {x} = {x: []};
  x.push(props.bar);
  if (props.cond) {
    ({x} = {x: {}});
    ({x} = {x: []});
    x.push(props.foo);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Handling Component Error in React
DESCRIPTION: This code snippet provides an error message associated with the 'Component' function, highlighting an invariant violation due to an improper reference to a const declaration. It indicates that certain coding practices should be adhered to prevent runtime issues.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.call-args-destructuring-asignment-complex.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Component(props) {
  2 |   let x = makeObject();
> 3 |   x.foo(([[x]] = makeObject()));
    |          ^^^^^ Invariant: Const declaration cannot be referenced as an expression (3:3)
  4 |   return x;
  5 | }
  6 |

```

----------------------------------------

TITLE: Implementing FBT with Multiple Plural Tags in React
DESCRIPTION: A React component demonstrating the use of multiple fbt:plural tags within a single fbt component. The component displays text about rewrites and months, with pluralization based on count parameters. The implementation includes detailed comments about inconsistencies between standard fbt and 'Forget' evaluation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-multiple-fbt-plural.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

/**
 * Forget + fbt inconsistency. Evaluator errors with the following
 *   Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok) 1 rewrite to Rust  2 months traveling
 *   Forget:
 *   (kind: ok) 1 rewrites to Rust  2 months traveling
 *
 * The root issue here is that fbt:plural/enum/pronoun read `.start` and `.end` from
 * babel nodes to slice into source strings for some complex dedupe logic
 * (see [_getStringVariationCombinations](https://github.com/facebook/fbt/blob/main/packages/babel-plugin-fbt/src/JSFbtBuilder.js#L297))
 *
 *
 * Since Forget does not add `.start` and `.end` for babel nodes it synthesizes,
 * [getRawSource](https://github.com/facebook/fbt/blob/main/packages/babel-plugin-fbt/src/FbtUtil.js#L666-L673)
 * simply returns the whole source code string. As a result, all fbt nodes dedupe together
 * and _getStringVariationCombinations ends up early exiting (before adding valid candidate values).
 *
 *
 *
 * For fbt:plural tags specifically, the `count` node require that a `.start/.end`
 * (see [code in FbtPluralNode](https://github.com/facebook/fbt/blob/main/packages/babel-plugin-fbt/src/fbt-nodes/FbtPluralNode.js#L87-L90))
 */
function Foo({rewrites, months}) {
  return (
    <fbt desc="Test fbt description">
      <fbt:plural count={rewrites} name="number of rewrites" showCount="yes">
        rewrite
      </fbt:plural>
      to Rust 
      <fbt:plural count={months} name="number of months" showCount="yes">
        month
      </fbt:plural>
      traveling
    </fbt>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{rewrites: 1, months: 2}],
};
```

----------------------------------------

TITLE: Implementing a Custom Hook with Object-Wrapped Callbacks in React
DESCRIPTION: Defines a custom hook 'useMakeCallback' that returns an object containing callback functions that access array elements. The hook takes an object parameter with an 'arr' property and returns functions to access values from the array elements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/return-object-of-functions.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * Assume that only directly returned functions or JSX attributes are invoked.
 * Conservatively estimate that functions wrapped in objects or other containers
 * might never be called (and therefore their property loads are not hoistable).
 */
function useMakeCallback({arr}) {
  return {
    getElement0: () => arr[0].value,
    getElement1: () => arr[1].value,
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{arr: [1, 2]}],
  sequentialRenders: [{arr: [1, 2]}, {arr: []}],
};
```

----------------------------------------

TITLE: Input React Components with Error Handler
DESCRIPTION: Original React component definitions including an ErrorView component for error handling and a Renderer component with basic structure. Uses shared-runtime's Stringify component for error display.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-export-gating-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import {Stringify} from 'shared-runtime';

const ErrorView = (error, _retry) => <Stringify error={error}></Stringify>;

export const Renderer = props => (
  <div>
    <span></span>
    <ErrorView></ErrorView>
  </div>
);

export const FIXTURE_ENTRYPOINT = {
  fn: eval('Renderer'),
  params: [{}],
};
```

----------------------------------------

TITLE: Defining useFoo Hook with Conditional State Update - JavaScript
DESCRIPTION: This snippet defines a custom React hook 'useFoo' that takes in props and conditionally updates state based on these props. It utilizes the 'mutate' function to modify the state in an array 'x', either initializing it or reusing the existing data based on the current props. The hook reacts to changes in 'bar', 'cond', and 'foo' to update its internal state accordingly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-destruction-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {mutate} from 'shared-runtime';

function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond ? (({x} = {x: {}}), ([x] = [[]]), x.push(props.foo)) : null;
  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};
```

----------------------------------------

TITLE: Implementing React Component with Conditional Rendering in JavaScript
DESCRIPTION: This snippet defines a React component 'useFoo' that conditionally renders based on input data. It uses imported utility functions for object manipulation and a Stringify component for display. The component includes a labeled block for flow control.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-jsx-and-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  Stringify,
  makeObject_Primitives,
  mutate,
  mutateAndReturn,
} from 'shared-runtime';

function useFoo({data}) {
  let obj = null;
  let myDiv = null;
  label: {
    if (data.cond) {
      obj = makeObject_Primitives();
      if (data.cond1) {
        myDiv = <Stringify value={mutateAndReturn(obj)} />;
        break label;
      }
      mutate(obj);
    }
  }

  return myDiv;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{data: {cond: true, cond1: true}}],
  sequentialRenders: [
    {data: {cond: true, cond1: true}},
    {data: {cond: true, cond1: true}},
  ],
};
```

----------------------------------------

TITLE: Rendering React Component without Compiler Runtime - JavaScript
DESCRIPTION: Defines a basic React component that initializes and renders elements using arrays and objects without involving any compiler runtime. It highlights a simple approach to component rendering that involves invoking a 'foo' function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-call-jsx-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @Pass runMutableRangeAnalysis
function foo() {}

function Component(props) {
  const a = [];
  const b = {};
  foo(a, b);
  if (foo()) {
    let _ = <div a={a} />;
  }
  foo(a, b);
  return <div a={a} b={b} />;
}
```

----------------------------------------

TITLE: Defining a Functional Component with Flow Suppressions - JavaScript
DESCRIPTION: This JavaScript snippet defines a functional component named 'Foo' which is using Flow type checking. The component includes a Flow suppression comment that indicates to the compiler to ignore specific rule violations related to React Hooks. The function takes props as an argument, calls a hook function called 'useX', and returns null. This is a common pattern in React when you need to bypass certain type checks temporarily.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.bailout-on-flow-suppression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFlowSuppressions

function Foo(props) {
  // $FlowFixMe[react-rule-hook]
  useX();
  return null;
}

```

----------------------------------------

TITLE: Original React Component Function
DESCRIPTION: This snippet shows the original implementation of a React component function. It uses let declarations and includes an unused object declaration inside a conditional block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-binary-operator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let a = some();
  let b = someOther();
  if (a > b) {
    let m = {};
  }
}
```

----------------------------------------

TITLE: React Component Definition with Ternary Logic (Input)
DESCRIPTION: Defines a React functional component named 'ternary' that accepts 'props' as input. It uses nested ternary operators to conditionally assign values to variables 'a' and 'b' based on the values of props. The component returns 'b' if 'a' is truthy, otherwise it returns null.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ternary-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function ternary(props) {
  const a = props.a && props.b ? props.c || props.d : props.e ?? props.f;
  const b = props.a ? (props.b && props.c ? props.d : props.e) : props.f;
  return a ? b : null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: ternary,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This React component `Foo` takes `props` as input, accesses `props.a`, and calls the `bar` function with it. It then uses optional chaining to access the `b` property of the result. Finally, it calls the `useBar` hook with the value of `y` and returns the result.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  let x = bar(props.a);
  let y = x?.b;

  let z = useBar(y);
  return z;
}
```

----------------------------------------

TITLE: Defining React Component Function with Object Creation and Method Call
DESCRIPTION: This snippet shows the original React component function 'foo' that creates objects, renders them in JSX, and performs a method call. It demonstrates the use of constants and JSX syntax within a function component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call-computed.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  // Construct and freeze x, y
  const x = makeObject(a);
  const y = makeObject(a);
  <div>
    {x}
    {y}
  </div>;

  // z should depend on `x`, `y.method`, and `b`
  const z = x[y.method](b);
  return z;
}
```

----------------------------------------

TITLE: Implementing Conditional Rendering in React Component
DESCRIPTION: This snippet defines a React component that conditionally renders an array based on props. It demonstrates the use of a labeled block and conditional logic to control array content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-break-labeled.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * props.b *does* influence `a`
 */
function Component(props) {
  const a = [];
  a.push(props.a);
  label: {
    if (props.b) {
      break label;
    }
    a.push(props.c);
  }
  a.push(props.d);
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Input Component with Initial State and Callback
DESCRIPTION: Initial implementation of a React component with variable reassignment and a callback function referencing a context variable
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/incompatible-destructuring-kinds.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {Stringify} from 'shared-runtime';

function Component({}) {
  let a = 'a';
  let b = '';
  [a, b] = [null, null];
  // NOTE: reference `a` in a callback to force a context variable
  return <Stringify a={a} b={b} onClick={() => a} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing Custom React Hook 'useFoo' in JavaScript
DESCRIPTION: This snippet defines a custom React hook 'useFoo' that manipulates an object based on input conditions. It uses utility functions from 'shared-runtime' and includes error handling. The hook is exported with test fixtures for different render scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-in-nested-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate, setProperty, throwErrorWithMessageIf} from 'shared-runtime';

function useFoo({value, cond}) {
  let y = [value];
  let x = {cond};

  try {
    mutate(x);
    throwErrorWithMessageIf(x.cond, 'error');
  } catch {
    setProperty(x, 'henderson');
    return x;
  }
  setProperty(x, 'nevada');
  y.push(x);

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{value: 4, cond: true}],
  sequentialRenders: [
    {value: 4, cond: true},
    {value: 5, cond: true},
    {value: 5, cond: false},
  ],
};
```

----------------------------------------

TITLE: React Component with FBT Input
DESCRIPTION: Original React component using FBT for internationalization. Shows how to use fbt.param to interpolate dynamic values into translated strings.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component(props) {
  const text = fbt(
    `${fbt.param('(key) count', props.count)} items`,
    '(description) Number of items'
  );
  return <div>{text}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{count: 2}],
};
```

----------------------------------------

TITLE: Defining a Reactive Component with Props - JavaScript
DESCRIPTION: This snippet defines a simple React component called 'Component' which processes incoming props through two arrays to illustrate reactivity. The component generates a reactive output based on mutations in arrays 'a' and 'b'. Key parameters include 'props' which contains the input condition 'cond'. The output is an array containing the reactive value of 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-update.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a and b are independent but their mutations are interleaved, so
  // they get grouped in a reactive scope. this means that a becomes
  // reactive since it will effectively re-evaluate based on a reactive
  // input
  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(10);

  // Downstream consumer of a, which initially seems non-reactive except
  // that a becomes reactive, per above
  const c = [a];

  let x;
  for (let i = 0; i < 10; i += c[0][0]) {
    x = 1;
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `c[0]` which becomes reactive via
  // being interleaved with `b`.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the component using memoization. It imports a compiler runtime function, memoizes the object creation and mutation, and only recalculates when props change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-with-store-to-parameter.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const mutate = _temp;
  let x;
  if ($[0] !== props) {
    x = makeObject(props);
    mutate(x);
    $[0] = props;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
function _temp(object, key, value) {
  object.updated = true;
  object[key] = value;
}
```

----------------------------------------

TITLE: Defining React Component with Conditional Property Handling - JavaScript
DESCRIPTION: This snippet defines a more complex version of the `Foo` component, leveraging a caching mechanism for props. It uses the `react/compiler-runtime` library's `_c` function to check if the current props differ from previous ones and conditionally extracts properties. The `FIXTURE_ENTRYPOINT` remains similar, serving the same purpose of component identification.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element-with-rest.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(props) {
  const $ = _c(2);
  let rest;
  if ($[0] !== props.a) {
    const { unused, ...t0 } = props.a;
    rest = t0;
    $[0] = props.a;
    $[1] = rest;
  } else {
    rest = $[1];
  }
  return rest;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with explicit memoization logic implemented using compiler runtime. Shows how the compiler optimizes state management and memoization checks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-pruned-scope-leaks-value-via-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import invariant from "invariant";
import {
  makeObject_Primitives,
  mutate,
  sum,
  useIdentity,
} from "shared-runtime";

/**
 * Here, `z`'s original memo block is removed due to the inner hook call.
 * However, we also infer that `z` is non-reactive, so by default we would create
 * the memo block for `thing = [y, z]` as only depending on `y`.
 *
 * This could then mean that `thing[1]` and `z` may not refer to the same value,
 * since z recreates every time but `thing` doesn't correspondingly invalidate.
 *
 * The fix is to consider pruned memo block outputs as reactive, since they will
 * recreate on every render. This means `thing` depends on both y and z.
 */
function MyApp(t0) {
  const $ = _c(6);
  const { count } = t0;
  const z = makeObject_Primitives();
  const x = useIdentity(2);
  let t1;
  if ($[0] !== count || $[1] !== x) {
    t1 = sum(x, count);
    $[0] = count;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const y = t1;
  mutate(z);
  const z2 = z;
  let t2;
  if ($[3] !== y || $[4] !== z2) {
    t2 = [y, z2];
    $[3] = y;
    $[4] = z2;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const thing = t2;
  if (thing[1] !== z) {
    invariant(false, "oh no!");
  }
  return thing;
}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [{ count: 2 }],
  sequentialRenders: [{ count: 2 }, { count: 2 }, { count: 3 }],
};
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This snippet shows the compiled output of the React component.  It imports `_c` from `react/compiler-runtime` which is presumably a compiler-generated function used for memoization. The compiled component caches the `div` element, using `Symbol.for("react.memo_cache_sentinel")` as a sentinel value to check if the element is already cached.  The purpose is to avoid re-rendering the same element unnecessarily.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
const Component = (props) => {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
};
```

----------------------------------------

TITLE: Compiler-Optimized React Component
DESCRIPTION: The compiler-optimized version of the same component using react/compiler-runtime. It implements memoization to avoid regenerating the div array when the 'b' prop hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-dependency-if-within-while.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const someGlobal = true;
export default function Component(props) {
  const $ = _c(2);
  const { b } = props;
  let t0;
  if ($[0] !== b) {
    const items = [];
    let i = 0;
    while (i < 10) {
      if (someGlobal) {
        items.push(<div key={i}>{b}</div>);
        i++;
      }
    }

    t0 = <>{items}</>;
    $[0] = b;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ b: 42 }],
  sequentialRenders: [
    { b: 0 },
    { b: 0 },
    { b: 42 },
    { b: 42 },
    { b: 0 },
    { b: 42 },
    { b: 0 },
    { b: 42 },
  ],
};
```

----------------------------------------

TITLE: Defining React Component with Default Parameter in JavaScript
DESCRIPTION: This snippet defines a simple React component named 'Component' that takes an optional parameter 'x' with a default value of [-1, 1]. The component simply returns the value of 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-array-with-unary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(x = [-1, 1]) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Implementing React Component with Nested Message Renderer
DESCRIPTION: Demonstrates a React component that uses an arrow function to define a nested Message component which renders the message from component state. The component uses class fields syntax and arrow functions for method definitions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/class-component-with-render-helper.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
class Component {
  _renderMessage = () => {
    const Message = () => {
      const message = this.state.message;
      return <div>{message}</div>;
    };
    return <Message />;
  };

  render() {
    return this._renderMessage();
  }
}
```

----------------------------------------

TITLE: Defining React Components with 'use forget' Directive
DESCRIPTION: Input code showing React components with and without the 'use forget' directive. Components with this directive will be optimized by React's compiler to avoid unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-instrument-forget-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableEmitInstrumentForget @compilationMode(annotation)

function Bar(props) {
  'use forget';
  return <div>{props.bar}</div>;
}

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}

function Foo(props) {
  'use forget';
  return <Foo>{props.bar}</Foo>;
}
```

----------------------------------------

TITLE: React Compiler Error: InvalidReact (JavaScript)
DESCRIPTION: This error message indicates that the React Compiler failed to infer the dependencies of the effect created by `useMyEffect`. The compiler suggests either providing a dependency array manually or fixing any compiler bailout diagnostics that might be preventing the inference. The error points to the line where `useMyEffect` is called within the non-React function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.callsite-in-non-react-fn-default-import.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  3 |
  4 | function nonReactFn(arg) {
> 5 |   useMyEffect(() => [1, 2, arg]);
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: [InferEffectDependencies] React Compiler is unable to infer dependencies of this effect. This will break your build! To resolve, either pass your own dependency array or fix reported compiler bailout diagnostics. (5:5)
  6 | }
  7 |

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Original implementation of a React component that creates an array by doubling values from an items array using destructuring and loop operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-destructure.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let x = [];
  let items = [{v: 0}, {v: 1}, {v: 2}];
  for (const {v} of items) {
    x.push(v * 2);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Stopping Stream Flow in React
DESCRIPTION: Method to pause or end the writing of serialized output for a request. Supports streaming backpressure implementation and can be resumed with startFlowing.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-server/README.md#2025-04-21_snippet_9

LANGUAGE: typescript
CODE:
```
stopFlowing(request: Request): void
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This snippet defines a functional React component that accepts a `name` prop and renders a string containing "hello world" and the value of the `name` prop. It imports a `SharedRuntime` module and uses its `Stringify` component. The component is exported as `FIXTURE_ENTRYPOINT`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-localvar-memberexpr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as SharedRuntime from 'shared-runtime';
function Component({name}) {
  const localVar = SharedRuntime;
  return <localVar.Stringify>hello world {name}</localVar.Stringify>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'sathya'}],
};
```

----------------------------------------

TITLE: Initializing React Component with Fire Event
DESCRIPTION: Defines a React functional component using a custom fire event with useEffect and dependency tracking. The component logs props and triggers a fire event within the effect hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-rewrite-deps-no-array-literal.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = props => {
    console.log(props);
  };

  const deps = [foo, props];

  useEffect(() => {
    fire(foo(props));
  }, deps);

  return null;
}
```

----------------------------------------

TITLE: Managing State with useFoo in JavaScript
DESCRIPTION: The useFoo function manipulates an array based on properties in the props object. It includes dependencies on shared-runtime for array manipulation. Key properties include 'cond', 'foo', and 'bar'. Inputs affect the returned array structure, which handles conditional replacements and additions via arrayPush. Expected outputs vary based on conditions within, and state management includes caching state for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-ternary-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {arrayPush} from 'shared-runtime';
function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond
    ? ((x = {}), (x = []), x.push(props.foo))
    : ((x = []), (x = []), x.push(props.bar));
  arrayPush(x, 4);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};
```

----------------------------------------

TITLE: Using React Compiler Runtime in a Memoized Component
DESCRIPTION: This snippet imports the React compiler runtime and defines a memoized component that processes cached values. It demonstrates the use of memoization in function components and the handling of special characters in JSX.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-html-entity.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div>{"<span &"}</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining useFoo Function with Input and Loop Logic (original)
DESCRIPTION: This JavaScript code defines the `useFoo` function, which takes an object with an `input` property (containing nested properties `a` and `b`) and a `max` property. It initializes an array `x`, iterates up to `max`, pushes the final `i` value and `input.a.b` into the array, and returns the array.  It also defines the `FIXTURE_ENTRYPOINT` object which specifies the function to test, the initial parameters and a list of `sequentialRenders` which are used to test different input scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-loop-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({input, max}) {
  const x = [];
  let i = 0;
  while (true) {
    i += 1;
    if (i > max) {
      break;
    }
  }
  x.push(i);
  x.push(input.a.b); // unconditional
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {a: {b: 2}}, max: 8}],
  sequentialRenders: [
    {input: {a: {b: 2}}, max: 8},
    // preserve nullthrows
    {input: null, max: 8},
    {input: {}}, max: 8},
    {input: {a: {b: null}}, max: 8},
    {input: {a: null}, max: 8},
    {input: {a: {b: 3}}, max: 8},
  ],
};

```

----------------------------------------

TITLE: Defining React Component with Memoization - JavaScript
DESCRIPTION: This snippet defines a React component that uses memoization techniques. It creates a context object with a unique key and memoized value, then mutates the key. The component is exported as a fixture for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-object-mutated-later.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate} from 'shared-runtime';

function Component(props) {
  const key = {};
  const context = {
    [key]: identity([props.value]),
  };
  mutate(key);
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Creating a Custom React Hook
DESCRIPTION: The function useFoo is a custom React Hook that iterates five times and conditionally appends a property's value of an object to an array. It takes in an object and a boolean indicating if the object is null. It returns an array containing the value of obj.a up to five times.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/loop-break-in-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function useFoo({obj, objIsNull}) {
  const x = [];
  for (let i = 0; i < 5; i++) {
    if (objIsNull) {
      continue;
    }
    x.push(obj.a);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{obj: null, objIsNull: true}],
  sequentialRenders: [
    {obj: null, objIsNull: true},
    {obj: {a: 2}, objIsNull: false},
    // check we preserve nullthrows
    {obj: {a: undefined}, objIsNull: false},
    {obj: undefined, objIsNull: false},
    {obj: {a: undefined}, objIsNull: false},
  ],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Defines a React component that uses the identity function from shared-runtime to process an array of values including a function, boolean, number, and string.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-calls-global-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(x = identity([() => {}, true, 42, 'hello'])) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Optimizing a React Hook with Compiler Runtime
DESCRIPTION: This variant of the function useFoo incorporates use of React's compiler runtime for optimization. It stores the previous state and compares it to minimize unnecessary re-calculations. The function takes an object and a null indicator boolean and returns an array, caching results using compiler hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/loop-break-in-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(t0) {
  const $ = _c(3);
  const { obj, objIsNull } = t0;
  let x;
  if ($[0] !== obj || $[1] !== objIsNull) {
    x = [];
    for (let i = 0; i < 5; i++) {
      if (objIsNull) {
        continue;
      }

      x.push(obj.a);
    }
    $[0] = obj;
    $[1] = objIsNull;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ obj: null, objIsNull: true }],
  sequentialRenders: [
    { obj: null, objIsNull: true },
    { obj: { a: 2 }, objIsNull: false },
    // check we preserve nullthrows
    { obj: { a: undefined }, objIsNull: false },
    { obj: undefined, objIsNull: false },
    { obj: { a: undefined }, objIsNull: false },
  ],
};
```

----------------------------------------

TITLE: Defining Memoized Component in React - JavaScript
DESCRIPTION: This snippet implements a memoized version of a React component that tracks whether the cache should be updated based on a sentinel value. If the cache is invalid, it initializes an array, processes it through a temporary function to update items, and returns the processed arrays. The component uses the 'react/compiler-runtime' import for memoization and expects props as input, outputting arrays based on internal logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-mutating-lambda-noAlias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [];
    const y = x.map(_temp);
    t0 = [x, y];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp(item) {
  item.updated = true;
  return item;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing useHook Function in React JavaScript
DESCRIPTION: The JavaScript function useHook showcases a custom hook in a React application. It operates based on a switch statement that checks the first parameter. If the condition is met, it logs the second parameter. This function is associated with a FIXTURE_ENTRYPOINT export that defines its usage context within the application. The function requires no external dependencies and accepts numerical and variable inputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/block-scoping-switch-dead-code.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useHook(a, b) {
  switch (a) {
    case 1:
      if (b == null) {
        return;
      }
      console.log(b);
      break;
    case 2:
      return;
    default:
      return;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [1, 'foo'],
};

```

----------------------------------------

TITLE: Initializing Memoized Component with Conditional Logic
DESCRIPTION: A React component using useMemo to create a memoized array with conditional pushing of items based on props, accompanied by memoization validation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hoist-optional-member-expression-with-conditional-optional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
  const data = useMemo(() => {
    const x = [];
    x.push(props?.items);
    if (props.cond) {
      x.push(props?.items);
    }
    return x;
  }, [props?.items, props.cond]);
  return (
    <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />
  );
}
```

----------------------------------------

TITLE: Ensuring Memoization in useFoo with Symbol Comparison
DESCRIPTION: Illustrates a React hook function 'useFoo' that employs a Symbol comparison to determine the memoization cache sentinel. It uses the _c function for memoization management, along with useRef and useCallback. The snippet also exports 'useFoo' in FIXTURE_ENTRYPOINT, requiring React for execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/preserve-use-memo-ref-missing-ok.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useCallback, useRef } from "react";

function useFoo() {
  const $ = _c(1);
  const ref = useRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      if (ref != null) {
        ref.current();
      }
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Defining a Simple Component
DESCRIPTION: This snippet defines a simple React component that retrieves and mutates data based on props passed to it. It uses `bar` to get items and modifies them with the `mutate` function. The component then returns the items and a computed count.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-reactive-via-mutation-of-computed-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const items = bar();
  mutate(items[props.key], props.a);

  const count = foo(items.length + 1);

  return {items, count};
}

```

----------------------------------------

TITLE: React Compiler Logs for Dynamic Component Creation
DESCRIPTION: Compiler logs showing React validation errors. Two errors are reported: one for components created during render resetting state, and another for potential dynamic component creation. The compilation succeeds despite the warnings, with details about memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-method-call.expect.md#2025-04-21_snippet_2

LANGUAGE: json
CODE:
```
{"kind":"CompileError","detail":{"options":{"reason":"Components created during render will reset their state each time they are created. Declare components outside of render. ","description":null,"severity":"InvalidReact","suggestions":null,"loc":{"start":{"line":4,"column":10,"index":110},"end":{"line":4,"column":19,"index":119},"filename":"invalid-dynamically-constructed-component-method-call.ts"}}}},"fnLoc":null}
{"kind":"CompileError","detail":{"options":{"reason":"The component may be created during render","description":null,"severity":"InvalidReact","suggestions":null,"loc":{"start":{"line":3,"column":20,"index":83},"end":{"line":3,"column":35,"index":98},"filename":"invalid-dynamically-constructed-component-method-call.ts"}}}},"fnLoc":null}
{"kind":"CompileSuccess","fnLoc":{"start":{"line":2,"column":0,"index":37},"end":{"line":5,"column":1,"index":125},"filename":"invalid-dynamically-constructed-component-method-call.ts"}},"fnName":"Example","memoSlots":4,"memoBlocks":2,"memoValues":2,"prunedMemoBlocks":0,"prunedMemoValues":0}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that demonstrates issues with function reference effect annotations. Uses Array.map and demonstrates mutation effects through array operations. Shows how Read effects on Array.map operands can lead to incorrect behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mixedreadonly-mutating-map.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  arrayPush,
  identity,
  makeArray,
  Stringify,
  useFragment,
} from 'shared-runtime';

function Component({extraJsx}) {
  const x = makeArray();
  const items = useFragment();
  const jsx = items.a.map((item, i) => {
    arrayPush(x, 2);
    return <Stringify item={item} key={i} />;
  });
  const offset = jsx.length;
  for (let i = 0; i < extraJsx; i++) {
    jsx.push(<Stringify item={0} key={i + offset} />);
  }
  const count = jsx.length;
  identity(count);
  return (
    <>
      <Stringify x={x} count={count} />
      {jsx[0]}
    </>
  );
}
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{extraJsx: 0}],
  sequentialRenders: [{extraJsx: 0}, {extraJsx: 1}],
};
```

----------------------------------------

TITLE: React Hook Call Order Error (JavaScript)
DESCRIPTION: This error message shows that the `useArray()` hook is being called conditionally within the `Component` function.  React's Rules of Hooks require that hooks be called in the same order during every render of a component. Calling a hook inside an `if` statement violates this rule, resulting in an `InvalidReact` error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-non-hook-imported-as-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  4 |   let data;
  5 |   if (props.cond) {
> 6 |     data = useArray();
    |            ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)
  7 |   }
  8 |   return data;
  9 | }

```

----------------------------------------

TITLE: Defining React Component with TypeScript
DESCRIPTION: This snippet defines a React component using TypeScript annotations. It takes a prop 'id' and uses it to create an array, then returns the first element of that array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-satisfies-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableUseTypeAnnotations
function Component(props: {id: number}) {
  const x = makeArray(props.id) satisfies number[];
  const y = x.at(0);
  return y;
}

function makeArray<T>(x: T): Array<T> {
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 42}],
};
```

----------------------------------------

TITLE: Using React.unstable_AsyncMode in JavaScript
DESCRIPTION: Example of using the new React.unstable_AsyncMode API, which replaced React.unstable_AsyncComponent.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_19

LANGUAGE: JavaScript
CODE:
```
<React.unstable_AsyncMode>
  <MyAsyncComponent />
</React.unstable_AsyncMode>
```

----------------------------------------

TITLE: Wrapping inner tree with Context Providers
DESCRIPTION: This snippet illustrates where to find the code responsible for wrapping the inner React tree with the appropriate Context Providers. It directs attention to the `src/legacy/createLegacyRoot.js` file and the `Bridge` component, which receives the aggregated Context object and uses it to provide the Context values to the inner tree. It also suggests that more Providers can be added there if necessary.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/nesting/README.md#2025-04-21_snippet_5

LANGUAGE: javascript
CODE:
```
/*
* `src/legacy/createLegacyRoot.js`: Look for the `Bridge` component which receives that object and wraps its children with the appropriate Context Providers. **You can wrap them with more Providers there** if your app requires them.
*/
```

----------------------------------------

TITLE: React Component with useMemo
DESCRIPTION: This React component utilizes `useMemo` to memoize the `handlers` object based on the `props.value`. It also includes a switch statement that logs the `handlers.value` to the console if `props.test` is true. The component returns the memoized `handlers` object. This is intended to be the original, uncompiled source.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/block-scoping-switch-variable-scoping.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';

function Component(props) {
  const outerHandlers = useMemo(() => {
    let handlers = {value: props.value};
    switch (props.test) {
      case true: {
        console.log(handlers.value);
        break;
      }
      default: {
      }
    }
    return handlers;
  });
  return outerHandlers;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{test: true, value: 'hello'}],
};

```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React Component
DESCRIPTION: Example of incorrect React hook implementation using optional chaining operator which violates the Rules of Hooks. The code demonstrates a pattern that would cause runtime errors as hooks must be called in a consistent order.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-optionalcall.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const {result} = useConditionalHook?.() ?? {};
  return result;
}
```

LANGUAGE: plaintext
CODE:
```
  1 | function Component() {
> 2 |   const {result} = useConditionalHook?.() ?? {};
    |                    ^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (2:2)
  3 |   return result;
  4 | }
  5 |
```

----------------------------------------

TITLE: Compiled Router Component with React Runtime
DESCRIPTION: Compiled version of the Router component using React compiler runtime with caching mechanism for optimization. Includes the same test fixture setup but with proper string escaping.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-immutable-collection.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Router(t0) {
  const $ = _c(3);
  const { title, mapping } = t0;
  let array;
  if ($[0] !== mapping || $[1] !== title) {
    array = [];
    for (const [, entry] of mapping) {
      array.push([title, entry]);
    }
    $[0] = mapping;
    $[1] = title;
    $[2] = array;
  } else {
    array = $[2];
  }
  return array;
}

const routes = new Map([
  ["about", "/about"],
  ["contact", "/contact"],
]);

export const FIXTURE_ENTRYPOINT = {
  fn: Router,
  params: [],
  sequentialRenders: [
    {
      title: "Foo",
      mapping: routes,
    },
    {
      title: "Bar",
      mapping: routes,
    },
  ],
};
```

----------------------------------------

TITLE: Creating and Exporting React Component in JavaScript
DESCRIPTION: This JavaScript snippet defines a React functional component named 'Component' with predefined constant values. It exports a fixture configuration object which includes the component function, its parameters, and a flag indicating its nature as a component. This snippet seems to be geared towards testing or integration within a larger React application context.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-arrayexpression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const a = 1;
  const b = 2;
  const x = [a, b];
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React useFoo Hook - Transformed Code
DESCRIPTION: This is the transformed version of the `useFoo` hook. It utilizes the `react/compiler-runtime` to memoize the array `x` and the conditional push operation based on the input `props`. The `_c` function is a compiler-generated function that handles dependency tracking and memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-destruction.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function useFoo(props) {
  const $ = _c(5);
  let x;
  if ($[0] !== props.bar) {
    x = [];
    x.push(props.bar);
    $[0] = props.bar;
    $[1] = x;
  } else {
    x = $[1];
  }
  if ($[2] !== props.cond || $[3] !== props.foo) {
    props.cond ? (([x] = [[]]), x.push(props.foo)) : null;
    $[2] = props.cond;
    $[3] = props.foo;
    $[4] = x;
  } else {
    x = $[4];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};

```

----------------------------------------

TITLE: Optimized React Component Definition and Export
DESCRIPTION: This snippet is an optimized version of the previous code. It defines the same React functional component 'Component' without the unused variable. The component is exported as part of the FIXTURE_ENTRYPOINT object with the same structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-const.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return props.value;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Defining React Component with Props and JSX in JavaScript
DESCRIPTION: This snippet defines a React component named 'Component' that renders a div element with props. It also includes a helper function 'Foo' and demonstrates object creation and JSX usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constructor.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {}

function Component(props) {
  const a = [];
  const b = {};
  new Foo(a, b);
  let _ = <div a={a} />;
  new Foo(b);
  return <div a={a} b={b} />;
}
```

----------------------------------------

TITLE: Error Message for Async useMemo
DESCRIPTION: This section captures the error message that arises when trying to use an async function inside the useMemo hook in React. It specifies the line number and the reason for the error, aiding in debugging.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ReactUseMemo-async-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  1 | function component(a, b) {
> 2 |   let x = React.useMemo(async () => {
    |                         ^^^^^^^^^^^^^
> 3 |     await a;
    | ^^^^^^^^^^^^
> 4 |   }, []);
    | ^^^^ InvalidReact: useMemo callbacks may not be async or generator functions (2:4)
  5 |   return x;
  6 | }
  7 |
```

----------------------------------------

TITLE: Original React Hook Implementation Before Compiler Optimization
DESCRIPTION: The original useFoo hook implementation that takes props, manipulates an array based on conditional logic, and returns it. It demonstrates array manipulation operations and conditional assignment patterns in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-destruction-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond ? (({x} = {x: {}}), ([x] = [[]]), x.push(props.foo)) : null;
  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};
```

----------------------------------------

TITLE: Implementing React Component with FBT Internationalization
DESCRIPTION: This snippet defines a React component that uses the FBT framework for internationalization. It renders a div with a hover title that includes a parameterized greeting. The component also exports a fixture for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbs-params.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {fbs} from 'fbt';

function Component(props) {
  return (
    <div
      title={
        <fbs desc={'Dialog to show to user'}>
          Hello <fbs:param name="user name">{props.name}</fbs:param>
        </fbs>
      }>
      Hover me
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Sathya'}],
};
```

----------------------------------------

TITLE: useCallback Example with Compiler Hints
DESCRIPTION: This code snippet demonstrates a React component that uses useCallback to memoize a function. The `@validatePreserveExistingMemoizationGuarantees` compiler hint suggests that the compiler should preserve any existing memoization guarantees. The component returns a memoized function that returns an array containing the `propA` prop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-with-no-depslist.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';

// Compiler can produce any memoization it finds valid if the
// source listed no memo deps
function Component({propA}) {
  // @ts-ignore
  return useCallback(() => {
    return [propA];
  });
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{propA: 2}],
};

```

----------------------------------------

TITLE: React Error Handling for Invalid Ref Access - JavaScript
DESCRIPTION: This snippet displays an error message indicating that ref values (the `current` property) cannot be accessed during render cycles in React. This serves as a warning for developers regarding appropriate use of refs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-other.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
"   6 |   const r2 = useRef(null);\n   7 |   if (r.current == null) {\n>  8 |     r2.current = 1;\n     |     ^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (8:8)\n   9 |   }\n  10 | }\n  11 |\n"
```

----------------------------------------

TITLE: Rendering a React Component with Props
DESCRIPTION: This snippet defines a simple React component and a child component that receives text props. The 'Component' function is exported for usage elsewhere, with a specific child 'Child' that renders the text prop passed from the parent component. 'FIXTURE_ENTRYPOINT' encapsulates the 'Component' function as an export along with parameter definitions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-in-jsx-attribute-escaped.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
export function Component() {
  return <Child text='Some \"text\"' />;
}

function Child(props) {
  return props.text;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Calculating Sum from Queue - JavaScript
DESCRIPTION: This snippet defines a Component function that calculates the sum of numbers in an array using a while loop to pop values off the queue. It returns the total sum of the numbers. It's an example of basic programming logic in a React functional component context.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-with-assignment-in-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const queue = [1, 2, 3];
  let value = 0;
  let sum = 0;
  while ((value = queue.pop()) != null) {
    sum += value;
  }
  return sum;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Source code for a React component that demonstrates prop destructuring, renaming, and the identity function. Uses ES6 destructuring syntax and exports a test fixture.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-same-property-identifier-names.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(props) {
  const {
    x: {destructured},
    sameName: renamed,
  } = props;
  const sameName = identity(destructured);

  return [sameName, renamed];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: {destructured: 0}, sameName: 2}],
};
```

----------------------------------------

TITLE: Original React Component with Type Annotations
DESCRIPTION: Initial implementation of a React component with TypeScript annotations that creates an array from a numeric ID prop and returns its first element. Includes generic array creation helper function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableUseTypeAnnotations
function Component(props: {id: number}) {
  const x = makeArray(props.id) as number[];
  const y = x.at(0);
  return y;
}

function makeArray<T>(x: T): Array<T> {
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 42}],
};
```

----------------------------------------

TITLE: Defining React Component with Mutation Functionality
DESCRIPTION: This snippet defines a JavaScript function component that uses a mutation function 'mutate' from a shared runtime. The component constructs an object with the passed parameter and mutates another object using the 'mutate' function. The component returns the mutated object and is configured to be used as a fixture entry point.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function Component({a}) {
  let x = {a};
  let y = {};
  const f0 = function () {
    let a = y;
    a.x = x;
  };
  f0();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 2}],
  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],
};

```

----------------------------------------

TITLE: Creating a Custom Hook with Memoization - React - JavaScript
DESCRIPTION: This snippet defines a custom React hook, 'useHook', utilizing 'useCallback' to return the current value of a passed ref. It ensures that the memoization guarantees are preserved, although there may be issues indicated by the compiler about matching inferred dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-invalid-useCallback-read-maybeRef.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';

function useHook(maybeRef) {
  return useCallback(() => {
    return [maybeRef.current];
  }, [maybeRef]);
}

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component function that processes arrays based on input parameters and a FLAG condition. Takes two parameters and returns an array of processed results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-reassign-to-variable-without-mutable-range.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @debug
function Component(a, b) {
  let x = [];
  let y = [];
  let z = foo(a);
  if (FLAG) {
    x = bar(z);
    y = baz(b);
  }
  return [x, y];
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A basic React component that creates an array by multiplying each item in a source array by 2. This represents the code before compiler optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let x = [];
  let items = [0, 1, 2];
  for (const ii of items) {
    x.push(ii * 2);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing React Component with Error Handling in JavaScript
DESCRIPTION: This code defines a React component that attempts to push a prop value into an array and throw it, then catches any errors and modifies them. It also exports a fixture for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-value-modified-in-catch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {throwInput} = require('shared-runtime');

function Component(props) {
  try {
    const y = [];
    y.push(props.y);
    throwInput(y);
  } catch (e) {
    e.push(props.e);
    return e;
  }
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{y: 'foo', e: 'bar'}],
};
```

----------------------------------------

TITLE: React Hooks Validation Error Output
DESCRIPTION: Shows the error messages produced when attempting to use React Hooks inside loops and conditions. The errors indicate violations of React's Rules of Hooks, specifically the rule about consistent hook calling order.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-1b9527f967f3.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   5 | function useHookInLoops() {
   6 |   while (a) {
>  7 |     useHook1();
     |     ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)

InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (9:9)

InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (12:12)

InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (14:14)
   8 |     if (b) return;
   9 |     useHook2();
  10 |   }
```

----------------------------------------

TITLE: Using useRef in React Component - JavaScript
DESCRIPTION: This snippet defines a React component using the useRef hook to handle mutable references within a functional component. The function f is invoked with the ref object if the current property is null. It demonstrates managing component state with useRef but improperly accesses the ref during render, leading to an error. Dependencies include the React library and its hooks. Inputs are parameters within the FIXTURE_ENTRYPOINT, and outputs are manipulations based on the ref's state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-call-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow
import {useRef} from 'react';

component C() {
  const r = useRef(null);
  if (r.current == null) {
    f(r);
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{}],
};

```

----------------------------------------

TITLE: React Error: Invalid Update
DESCRIPTION: This error message indicates that a value used previously in JSX is being updated.  React's rendering process expects values used in JSX to remain immutable. The error suggests moving the mutation before the JSX usage to avoid the issue.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-after-aliased-freeze.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  11 |   // y is MaybeFrozen at this point, since it may alias to x
  12 |   // (which is the above line freezes)
> 13 |   y.push(props.p2);
     |   ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (13:13)
  14 |
  15 |   return <Component x={x} y={y} />;
  16 | }

```

----------------------------------------

TITLE: Using Fragment Hooks in React
DESCRIPTION: This code demonstrates the use of the useFragment hook to read fragment data within a React functional component. It shows how data is conditionally assigned based on a prop, but also reveals an important limitation regarding the consistent order of hook calls.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-aliased-hook-import.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useFragment as readFragment} from 'shared-runtime';

function Component(props) {
  let data;
  if (props.cond) {
    data = readFragment();
  }
  return data;
}

```

----------------------------------------

TITLE: Invalid Hook Usage in React Component
DESCRIPTION: Example showing incorrect pattern of assigning a Hook to a variable and calling it, which violates React's rules of Hooks requiring consistent function references across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-dynamic-hook-via-hooklike-local.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const someFunction = useContext(FooContext);
  const useOhItsNamedLikeAHookNow = someFunction;
  useOhItsNamedLikeAHookNow();
}

```

LANGUAGE: text
CODE:
```
  2 |   const someFunction = useContext(FooContext);
  3 |   const useOhItsNamedLikeAHookNow = someFunction;
> 4 |   useOhItsNamedLikeAHookNow();
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be the same function on every render, but this value may change over time to a different function. See https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks (4:4)
  5 | }
  6 |

```

----------------------------------------

TITLE: React Side-Effect Error
DESCRIPTION: This snippet displays the error message generated by React when a component attempts to reassign a variable defined outside of its scope. The error message suggests using `useState` instead if the variable is used in rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.reassign-global-fn-arg.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  3 | export default function MyApp() {
  4 |   const fn = () => {
> 5 |     b = 2;
    |     ^ InvalidReact: Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) (5:5)
  6 |   };
  7 |   return foo(fn);
  8 | }
```

----------------------------------------

TITLE: Incorrect React useRef Access During Render
DESCRIPTION: This code demonstrates an invalid pattern of accessing a ref's current property during component render. React's rules prohibit accessing ref.current during render as shown in the accompanying error message.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-nonif.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow
import {useRef} from 'react';

component C() {
  const r = useRef(null);
  const guard = r.current == null;
  if (guard) {
    r.current = 1;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining React Component with Frozen Array (JavaScript)
DESCRIPTION: This snippet defines a React component that creates an array, aliases it, freezes it using a custom hook, and passes it to another function. It demonstrates the concept of freezing objects and how aliases are affected.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/frozen-after-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const a = [];
  const b = a;
  useFreeze(a);
  foo(b); // should be readonly, value is guaranteed frozen via alias
  return b;
}

function useFreeze() {}
function foo(x) {}
```

----------------------------------------

TITLE: Implementing useMakeCallback Hook with useMemo in React
DESCRIPTION: A custom React hook that creates a callback function which updates state based on object value. It uses useMemo to cache the callback and only recreate it when obj.value or shouldSynchronizeState changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/use-memo-returned.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState, useMemo} from 'react';
import {useIdentity} from 'shared-runtime';

/**
 * Assume that conditionally called functions can be invoked and that their
 * property loads are hoistable to the function declaration site.
 */
function useMakeCallback({
  obj,
  shouldSynchronizeState,
}: {
  obj: {value: number};
  shouldSynchronizeState: boolean;
}) {
  const [state, setState] = useState(0);
  const cb = useMemo(() => {
    return () => {
      if (obj.value !== 0) setState(obj.value);
    };
  }, [obj.value, shouldSynchronizeState]);
  useIdentity(null);
  return cb;
}
export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{obj: {value: 1}}],
  sequentialRenders: [{obj: {value: 1}}, {obj: {value: 2}}],
};
```

----------------------------------------

TITLE: Implementing React Component with Array Iteration
DESCRIPTION: This snippet defines a React component that creates an array of objects, iterates over them, and renders their JSON representations. It uses utility functions for object creation and mutation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives, mutateAndReturn, toJSON} from 'shared-runtime';

function Component(_props) {
  const collection = [makeObject_Primitives()];
  const results = [];
  for (const item of collection) {
    results.push(<div key={toJSON(item)}>{toJSON(mutateAndReturn(item))}</div>);
  }
  return <div>{results}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Defining React Component with Type Checking in JavaScript
DESCRIPTION: This code defines a React component with TypeScript-like type checking. It uses the 'identity' function from a shared runtime and demonstrates the use of the 'satisfies' keyword for type assertion. The component takes a prop 'id' and returns it after type checking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-satisfies-number.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableUseTypeAnnotations
import {identity} from 'shared-runtime';

function Component(props: {id: number}) {
  const x = identity(props.id);
  const y = x satisfies number;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 42}],
};
```

LANGUAGE: javascript
CODE:
```
// @enableUseTypeAnnotations
import { identity } from "shared-runtime";

function Component(props) {
  const x = identity(props.id);
  const y = x satisfies number;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 42 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized Effect Dependencies
DESCRIPTION: The compiled output after the React compiler processes the component. It introduces memoization through a closure variable $ and conditionally recreates callbacks and dependency arrays only when values change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/infer-deps-custom-config.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { print, useSpecialEffect } from "shared-runtime";

function CustomConfig(t0) {
  const $ = _c(7);
  const { propVal } = t0;
  let t1;
  let t2;
  if ($[0] !== propVal) {
    t1 = () => print(propVal);
    t2 = [propVal];
    $[0] = propVal;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useSpecialEffect(t1, t2, [propVal]);
  let t3;
  let t4;
  let t5;
  if ($[3] !== propVal) {
    t3 = () => print(propVal);
    t4 = [propVal];
    t5 = [propVal];
    $[3] = propVal;
    $[4] = t3;
    $[5] = t4;
    $[6] = t5;
  } else {
    t3 = $[4];
    t4 = $[5];
    t5 = $[6];
  }
  useSpecialEffect(t3, t4, t5);
}
```

----------------------------------------

TITLE: Compiled React Component with Optimized Dependencies
DESCRIPTION: The compiler-transformed version of the component that shows how React's compiler handles useRef dependencies. It creates a memoized callback and correctly determines that the useRef value is stable, resulting in an empty dependency array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-ref.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect, useRef } from "react";
import { print } from "shared-runtime";

/**
 * Special case of `infer-effect-deps/nonreactive-dep`.
 *
 * We know that local `useRef` return values are stable, regardless of
 * inferred memoization.
 */
function NonReactiveRefInEffect() {
  const $ = _c(1);
  const ref = useRef("initial value");
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => print(ref.current);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(t0, []);
}
```

----------------------------------------

TITLE: Compiled React Component with Caching
DESCRIPTION: Compiled version of the component with React's compiler runtime caching implementation. Uses an array for caching previous values and conditionally rebuilds arrays only when dependencies change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dependencies-outputs.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b) {
  const $ = _c(5);
  let x;
  if ($[0] !== a) {
    x = [];
    x.push(a);
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  let y;
  if ($[2] !== b || $[3] !== x) {
    y = [];
    if (x.length) {
      y.push(x);
    }
    if (b) {
      y.push(b);
    }
    $[2] = b;
    $[3] = x;
    $[4] = y;
  } else {
    y = $[4];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization (JavaScript)
DESCRIPTION: This snippet presents an optimized version of the same component using compiler-generated code for memoization and state management. It uses a custom caching mechanism to avoid unnecessary re-renders and function recreations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-scopes-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableInstructionReordering
import { useState } from "react";

function Component() {
  const $ = _c(4);
  const [state, setState] = useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setState(_temp);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onClick = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <button onClick={onClick}>Increment</button>;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== state) {
    t2 = (
      <>
        <span>Count: {state}</span>
        {t1}
      </>
    );
    $[2] = state;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}
function _temp(s) {
  return s + 1;
}
```

----------------------------------------

TITLE: Implementing React Function Component with Optional Chaining in JavaScript
DESCRIPTION: This snippet defines a React function component 'useFoo' that accepts a props object with a nullable value property. It uses optional chaining to access nested properties and passes them to a custom hook called 'useNoAlias'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-ternary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useNoAlias} from 'shared-runtime';

function useFoo(props: {value: {x: string; y: string} | null}) {
  const value = props.value;
  return useNoAlias(value?.x, value?.y) ? {} : null;
}

export const FIXTURE_ENTRYPONT = {
  fn: useFoo,
  props: [{value: null}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Implementation
DESCRIPTION: This snippet shows the compiled version of the React component using React's compiler runtime. It implements the memoization strategies described in the input component, using a cache array and conditional checks to avoid unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-allocating-nested-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(7);
  let t0;
  if ($[0] !== props.a) {
    t0 = [props.a];
    $[0] = props.a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const a = t0;
  let t1;
  if ($[2] !== a) {
    t1 = [a];
    $[2] = a;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const b = t1;
  let c;
  if ($[4] !== b || $[5] !== props.b) {
    c = [];
    const d = {};
    d.b = b;
    c.push(props.b);
    $[4] = b;
    $[5] = props.b;
    $[6] = c;
  } else {
    c = $[6];
  }
  return c;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Transformed Hoisting Example using React Compiler
DESCRIPTION: This code snippet represents the transformed code after being processed by the React compiler. It shows how the compiler optimizes the code, potentially caching values and using temporary variables to improve performance. The code leverages `react/compiler-runtime` to manage the component's lifecycle and state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-object-method.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function hoisting() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = {
      foo() {
        return bar();
      },
    };

    const bar = _temp;

    t0 = x.foo();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  return 1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
};

```

----------------------------------------

TITLE: Compiled React Fragment Implementation
DESCRIPTION: Compiled version with React compiler runtime optimizations. Implements memoization using array-based caching for data and transformed values. Includes compiler-specific transformations for performance optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-logical-expression-instruction-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * This is a weird case as data has type `BuiltInMixedReadonly`.
 * The only scoped value we currently infer in this program is the
 * PropertyLoad `data?.toString`.
 */
import { useFragment } from "shared-runtime";

function Foo() {
  const $ = _c(4);
  const data = useFragment();
  let t0;
  if ($[0] !== data) {
    t0 = data?.toString() || "";
    $[0] = data;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = [t0];
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Compiled: React Compiler Output with Memoization for Allocating Primitive
DESCRIPTION: The React compiler's output that includes memoization logic. It stores the computed value (bar(props).b + 1) and its result to avoid recalculation on re-renders when the dependency hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-primitive-as-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // bar(props.b) is an allocating expression that produces a primitive, which means
// that Forget should memoize it.
// Correctness:
//   - y depends on either bar(props.b) or bar(props.b) + 1
function AllocatingPrimitiveAsDep(props) {
  const $ = _c(2);
  const t0 = bar(props).b + 1;
  let t1;
  if ($[0] !== t0) {
    t1 = foo(t0);
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const y = t1;
  return y;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization Cache
DESCRIPTION: The compiled version of the Foo component that includes React's compiler runtime memoization. It uses a symbol-based cache sentinel to avoid redundant rendering of the same content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-jsxtext-stringliteral-distinction.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div> {", "}</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with Mutator (Input)
DESCRIPTION: This React component receives a `mutator` prop and defines two functions, `poke` and `hide`, which call methods on the mutator. These functions are then passed as props to a `Foo` component. The component uses arrow functions for concise event handlers.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-member-expr-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component({mutator}) {
  const poke = () => {
    mutator.poke();
  };

  const hide = () => {
    mutator.user.hide();
  };

  return <Foo poke={poke} hide={hide}></Foo>;
}
```

----------------------------------------

TITLE: React Component with Mutation
DESCRIPTION: This snippet defines a React component that takes a prop 'a', creates an object 'x' with 'a', and then mutates an object 'y' within a function 'f0'. The 'mutate' function is called on 'y', and finally, 'y' is returned. The component is exported as FIXTURE_ENTRYPOINT for testing and demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';
function Component({a}) {
  let x = {a};
  let y = {};
  const f0 = function () {
    y.x = x;
  };
  f0();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 2}],
  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],
};

```

----------------------------------------

TITLE: Defining a Component in React with Global Dependencies
DESCRIPTION: This snippet defines a React component that utilizes global utilities to create and stringify an array. The function parameter takes an object containing a number, which is used to initialize the array. The component utilizes 'Stringify' from shared-runtime to display the result of pushing the number into the array. It does not memoize 'Stringify' as it's a read from a global context.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-global-load-cached.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';
import {makeArray} from 'shared-runtime';

/**
 * Here, we don't need to memoize Stringify as it is a read off of a global.
 * TODO: in PropagateScopeDeps (hir), we should produce a sidemap of global rvals
 * and avoid adding them to `temporariesUsedOutsideDefiningScope`.
 */
function Component({num}: {num: number}) {
  const arr = makeArray(num);
  return <Stringify value={arr.push(num)}></Stringify>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{num: 2}],
};

```

----------------------------------------

TITLE: Optimized React Component
DESCRIPTION: Simplified version of the same component that removes the continue statement and uses basic assignment operators. Maintains identical functionality while improving code readability.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-empty-update-with-continue.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  for (let i = 0; i < props.count; ) {
    x = x + i;
    i = i + 1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component with Manual useEffect Dependencies - JavaScript
DESCRIPTION: Defines a React functional component `Component` that receives a ref (`arrRef`) as a prop. It uses `useEffect` to print the current value of the ref's `current` property. The `useEffect` dependency array is intentionally omitted (or empty in the code) despite accessing `arrRef.current`, as indicated by the comment "@inferEffectDependencies". It also modifies `arrRef.current` directly after the effect.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/mutate-after-useeffect-ref-access.expect.md#_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)

import {useEffect, useRef} from 'react';
import {print} from 'shared-runtime';

function Component({arrRef}) {
  // Avoid taking arr.current as a dependency
  useEffect(() => print(arrRef.current));
  arrRef.current.val = 2;
  return arrRef;
}

```

----------------------------------------

TITLE: Mutating Object Properties in Functional Component - React - JavaScript
DESCRIPTION: This snippet demonstrates a React functional component that uses an immediately invoked function expression (IIFE) to mutate an object based on its parameters. The function accepts props 'a' and 'b', mutates them, and manages a returned object that encapsulates both mutated values. It showcases variable shadowing within a block scope and its effect on the outer scope.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-capture-ref-before-rename.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import {mutate} from 'shared-runtime';

function Component({a, b}) {
  let z = {a};
  (function () {
    mutate(z);
  })();
  let y = z;

  {
    // z is shadowed & renamed but the lambda is unaffected.
    let z = {b};
    y = {y, z};
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 2, b: 3}],
  sequentialRenders: [
    {a: 2, b: 3},
    {a: 2, b: 3},
    {a: 2, b: 4},
    {a: 3, b: 4},
  ],
};
```

----------------------------------------

TITLE: Unoptimized React Component Implementation
DESCRIPTION: This snippet shows the original, unoptimized implementation of a React component. It processes an array by popping items and doubling them.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let x = [1, 2, 3];
  let ret = [];
  do {
    let item = x.pop();
    ret.push(item * 2);
  } while (x.length);
  return ret;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component with FBT Parameter - Source
DESCRIPTION: Source code showing a React component using FBT JSX syntax for internationalization. Includes parameter interpolation with text prop and percentage symbol.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-with-jsx-fragment-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';
import {identity} from 'shared-runtime';

function Component(props) {
  return (
    <Foo
      value={
        <fbt desc="Description of the parameter">
          <fbt:param name="value">{<>{identity(props.text)}</>}</fbt:param>%
        </fbt>
      }
    />
  );
}
```

----------------------------------------

TITLE: Input: React Component with Fire Event Handler
DESCRIPTION: Initial implementation of a React component using fire events and logging props. Uses basic React hooks and event firing mechanism with minimal optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/repeated-calls.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = () => {
    console.log(props);
  };
  useEffect(() => {
    fire(foo(props));
    fire(foo(props));
  });

  return null;
}
```

----------------------------------------

TITLE: Implementing React Component with Memoization (JavaScript)
DESCRIPTION: This snippet defines a React component that uses memoization to optimize rendering performance. It conditionally renders content based on props and caches the result for subsequent renders with the same prop values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-leave-case.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { Stringify } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.p0 || $[1] !== props.p1) {
    const x = [];
    let y;
    if (props.p0) {
      x.push(props.p1);
      y = x;
    }

    t0 = (
      <Stringify>
        {x}
        {y}
      </Stringify>
    );
    $[0] = props.p0;
    $[1] = props.p1;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
```

----------------------------------------

TITLE: Testing React Elements with react-is
DESCRIPTION: Demonstrates how to check if a JSX element is a valid React element using isElement and typeOf functions.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
import React from "react";
import * as ReactIs from 'react-is';

ReactIs.isElement(<div />); // true
ReactIs.typeOf(<div />) === ReactIs.Element; // true
```

----------------------------------------

TITLE: Defining Original React Component with Compute Function
DESCRIPTION: This snippet shows the original React component that computes values based on props and renders a Foo component. It includes comments describing the expected scope analysis.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independent.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * Should produce 3 scopes:
 *
 * a: inputs=props.a, outputs=a
 *   a = compute(props.a);
 * b: inputs=props.b, outputs=b
 *   b = compute(props.b);
 * return: inputs=a, b outputs=return
 *   return = <Foo a={a} b={b} />
 */
function Component(props) {
  const a = compute(props.a);
  const b = compute(props.b);
  return <Foo a={a} b={b} />;
}

function compute() {}
function foo() {}
function Foo() {}
```

----------------------------------------

TITLE: Importing Event Priority Constants for getCurrentEventPriority
DESCRIPTION: Demonstrates how to import and use event priority constants when implementing the getCurrentEventPriority method in a React renderer
SOURCE: https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import {
  DiscreteEventPriority,
  ContinuousEventPriority,
  DefaultEventPriority,
} from 'react-reconciler/constants';

const HostConfig = {
  // ...
  getCurrentEventPriority() {
    return DefaultEventPriority;
  },
  // ...
}

const MyRenderer = Reconciler(HostConfig);
```

----------------------------------------

TITLE: Defining a React Component with Logging
DESCRIPTION: This JavaScript code defines a simple React component that changes its output behavior based on a function passed to it. It includes console logging to demonstrate the flow of execution and outputs 'A', 'arg', and 'original'. This snippet requires React to function appropriately as it is a part of a component structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-call-evaluation-order.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Should print A, arg, original

function Component() {
  const changeF = o => {
    o.f = () => console.log('new');
  };
  const x = {
    f: () => console.log('original'),
  };

  (console.log('A'), x).f((changeF(x), console.log('arg'), 1));
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Initializing Object References with 'const' in React Component
DESCRIPTION: This snippet shows object reference assignment using 'const' variable declarations in a React component function. It creates multiple objects with constant references and assigns properties between them before calling a 'mutate' function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-alias-fields.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function component() {
  const x = {};
  const p = {};
  const q = {};
  const y = {};

  x.y = y;
  p.y = x.y;
  q.y = p.y;

  mutate(q);
}
```

----------------------------------------

TITLE: Defining React Components with 'use forget' Directive
DESCRIPTION: This snippet defines three React components: Bar, NoForget, and Foo. The Bar and Foo components use the 'use forget' directive for optimization. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating @compilationMode(annotation)
function Bar(props) {
  'use forget';
  return <div>{props.bar}</div>;
}

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}

function Foo(props) {
  'use forget';
  return <Foo>{props.bar}</Foo>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval('Bar'),
  params: [{bar: 2}],
};
```

----------------------------------------

TITLE: Input React Hook Implementation
DESCRIPTION: Original source code for a React custom hook that handles numerical arguments and conditional array manipulation. Uses identity and useIdentity hooks from shared runtime with TypeScript-style type annotations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-non-null-destructure.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {identity, useIdentity} from 'shared-runtime';

function useFoo({arg, cond}: {arg: number; cond: boolean}) {
  const maybeObj = useIdentity({value: arg});
  const {value} = maybeObj;
  useIdentity(null);
  /**
   * maybeObj.value should be inferred as the dependency of this scope
   * since we know that maybeObj is safe to read from (i.e. non-null)
   * due to the above destructuring instruction
   */
  const arr = [];
  if (cond) {
    arr.push(identity(maybeObj.value));
  }
  return {arr, value};
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{arg: 2, cond: false}],
};
```

----------------------------------------

TITLE: Compiled React Counter Component with Optimizations
DESCRIPTION: This snippet shows the compiled version of the React counter component with optimizations. It uses memoization and conditional rendering to improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState } from "react";
import { Stringify } from "shared-runtime";

function Component() {
  const $ = _c(8);
  const [state, setState] = useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Stringify text="Counter" />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== state) {
    t1 = <span>{state}</span>;
    $[1] = state;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== state) {
    t2 = (
      <button data-testid="button" onClick={() => setState(state + 1)}>
        increment
      </button>
    );
    $[3] = state;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== t1 || $[6] !== t2) {
    t3 = (
      <div>
        {t0}
        {t1}
        {t2}
      </div>
    );
    $[5] = t1;
    $[6] = t2;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Input React Component Implementation
DESCRIPTION: Original React component that spreads props.value into a new object and iterates through its properties until encountering a 'break' key. Returns the last visited property value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  const object = {...props.value};
  for (const y in object) {
    if (y === 'break') {
      break;
    }
    x = object[y];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  // should return 'a'
  params: [{a: 'a', break: null, c: 'C!'}],
};
```

----------------------------------------

TITLE: Original React Component with Memoization
DESCRIPTION: Original source code showing a React component that processes an array of items using a mapping function. The component demonstrates how function references are memoized when returned as part of the component's output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-noAlias-escaping-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const f = item => item;
  const x = [...props.items].map(f); // `f` doesn't escape here...
  return [x, f]; // ...but it does here so it's memoized
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{items: [{id: 1}]}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Error Handling for Conditional Hooks in React
DESCRIPTION: This snippet is an error message indicating that the useFragment hook is being called conditionally within the Component function. It emphasizes that hooks must always be called in the same order regardless of control flow structures, and provides a link to the React documentation for further guidelines.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-conditional-call-aliased-hook-import.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  4 |   let data;
  5 |   if (props.cond) {
> 6 |     data = readFragment();
    |            ^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)
  7 |   }
  8 |   return data;
  9 | }

```

----------------------------------------

TITLE: Original React Component with Potential Performance Issues
DESCRIPTION: A React function component that computes values which could be memoized for better performance. It creates a variable 'a' from foo() and a variable 'b' that depends on props and 'a'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-load-primitive-as-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let a = foo();
  // freeze `a` so we know the next line cannot mutate it
  <div>{a}</div>;

  // b should be dependent on `props.a`
  let b = bar(a[props.a] + 1);
  return b;
}
```

----------------------------------------

TITLE: Original useMakeCallback Hook Implementation in React
DESCRIPTION: A React custom hook that creates a callback function to update state when an object's value doesn't match the current state. The hook uses useState and an external useIdentity hook, and immediately executes the callback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/direct-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';
import {useIdentity} from 'shared-runtime';

function useMakeCallback({obj}: {obj: {value: number}}) {
  const [state, setState] = useState(0);
  const cb = () => {
    if (obj.value !== state) setState(obj.value);
  };
  useIdentity();
  cb();
  return [cb];
}
export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{obj: {value: 1}}],
  sequentialRenders: [{obj: {value: 1}}, {obj: {value: 2}}],
};
```

----------------------------------------

TITLE: Implementing Error-Handled React Component in JavaScript
DESCRIPTION: This snippet defines a React component 'useFoo' that safely handles potential null values and uses a try-catch block for error handling. It also includes a fixture for testing with various input scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-maybe-null-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

/**
 * Not safe to hoist read of maybeNullObject.value.inner outside of the
 * try-catch block, as that might throw
 */
function useFoo(maybeNullObject: {value: {inner: number}} | null) {
  const y = [];
  try {
    y.push(identity(maybeNullObject.value.inner));
  } catch {
    y.push('null');
  }

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [null],
  sequentialRenders: [null, {value: 2}, {value: 3}, null],
};
```

----------------------------------------

TITLE: Original React Component with Destructuring
DESCRIPTION: A React component that performs object and array destructuring on props, demonstrating the need for memoization of derived objects and arrays.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-destructured-rest-element.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // b is an object, must be memoized even though the input is not memoized
  const {a, ...b} = props.a;
  // d is an array, mut be memoized even though the input is not memoized
  const [c, ...d] = props.c;
  return <div b={b} d={d}></div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining Animated SVG Component with Reanimated
DESCRIPTION: This code defines a React component that animates an SVG path using Reanimated's `useAnimatedProps` hook. It calculates the path based on a shared value `radius` and updates the SVG path's `d` attribute. The component uses `Svg` and `AnimatedPath` components, assumed to be available from a relevant library.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reanimated-no-memo-arg.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableCustomTypeDefinitionForReanimated
import {useAnimatedProps} from 'react-native-reanimated';
function Component() {
  const radius = useSharedValue(50);

  const animatedProps = useAnimatedProps(() => {
    // draw a circle
    const path = `
    M 100, 100
    m -${radius.value}, 0
    a ${radius.value},${radius.value} 0 1,0 ${radius.value * 2},0
    a ${radius.value},${radius.value} 0 1,0 ${-radius.value * 2},0
    `;
    return {
      d: path,
    };
  });

  // attach animated props to an SVG path using animatedProps
  return (
    <Svg>
      <AnimatedPath animatedProps={animatedProps} fill="black" />
    </Svg>
  );
}
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: React Component without useCallback Implementation
DESCRIPTION: Alternative implementation of the same component without using useCallback for memoization. Creates mutable objects and returns a non-memoized callback function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-maybe-modify-free-variable-dont-preserve-memoization-guarantee.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees:false
import { useCallback } from "react";
import {
  identity,
  makeObject_Primitives,
  mutate,
  useHook,
} from "shared-runtime";

function Component(props) {
  const free = makeObject_Primitives();
  const free2 = makeObject_Primitives();
  const part = free2.part;
  useHook();
  const callback = () => {
    const x = makeObject_Primitives();
    x.value = props.value;
    mutate(x, free, part);
  };

  mutate(free, part);
  return callback;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Defining Optimized React Component with Conditional State Handling - JavaScript
DESCRIPTION: This code snippet defines an optimized version of the 'Component' which includes a mechanism to track previous state values and update the component's state only when necessary, thus potentially improving performance in rendering processes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function Component(t0) {
  const $ = _c(3);
  const { foo, bar } = t0;
  let x;
  if ($[0] !== bar || $[1] !== foo) {
    x = { foo };
    const y = { bar };
    const f0 = function () {
      const a = { y };
      const b = x;
      a.x = b;
    };

    f0();
    mutate(y);
    $[0] = bar;
    $[1] = foo;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ foo: 2, bar: 3 }],
  sequentialRenders: [
    { foo: 2, bar: 3 },
    { foo: 2, bar: 3 },
    { foo: 2, bar: 4 },
    { foo: 3, bar: 4 },
  ],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet presents an optimized version of the React component using the compiler runtime. It includes memoization techniques to improve performance by caching rendered elements and data. The useData hook is also optimized using a cache sentinel.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(2);
  const data = useData();
  let t0;
  if ($[0] !== data) {
    const items = [];
    for (let i = MIN; i <= MAX; i = i + INCREMENT, i) {
      items.push(<div key={i} onClick={() => data.set(i)} />);
    }

    t0 = <>{items}</>;
    $[0] = data;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

const MIN = 0;
const MAX = 3;
const INCREMENT = 1;

function useData() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = new Map();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  params: [],
  fn: Component,
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: The React compiler-optimized version of the component that implements memoization based on props.foo. It uses React's compiler runtime to cache and reuse the object between renders when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-computed.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.foo) {
    x = {};
    x.foo = x.foo + x.bar;
    x.foo(props.foo);
    $[0] = props.foo;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized React Compiler GraphQL Fragment
DESCRIPTION: React component with compiler runtime optimization for GraphQL fragment memoization, using a cached approach to prevent redundant fragment creation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/tagged-template-literal.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = graphql`
      fragment F on T {
        id
      }
    `;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const t = t0;
  return t;
}
```

----------------------------------------

TITLE: Compiled React Component with Hoisting
DESCRIPTION: This snippet shows the output of the React compiler applied to the `hoisting` function. It uses the `react/compiler-runtime` to manage component memoization and avoid unnecessary re-renders. The compiler transforms the function to use a cache and hoisted variable assignments.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-let-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function hoisting() {
  const $ = _c(1);
  let foo;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    foo = () => bar + baz;

    let bar;
    bar = 3;
    let baz;
    baz = 2;
    $[0] = foo;
  } else {
    foo = $[0];
  }
  return foo();
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Optimizing React Component Rendering with Compiler in JavaScript
DESCRIPTION: This snippet offers an optimized version of a React component using 'react/compiler-runtime'. By caching inputs and outputs, it minimizes re-renders when properties remain unchanged. This approach showcases advanced performance techniques within React, leveraging internal compiler utilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-runs-inference.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";
function Component(t0) {
  const $ = _c(6);
  const { a } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = { a };
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const z = t1;
  let t2;
  if ($[2] !== z) {
    t2 = () => <Stringify>{z}</Stringify>;
    $[2] = z;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const p = t2;
  let t3;
  if ($[4] !== p) {
    t3 = p();
    $[4] = p;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1 }],
  sequentialRenders: [{ a: 1 }, { a: 1 }, { a: 2 }],
};
```

----------------------------------------

TITLE: Defining React Component with TypeScript-like Typing in JavaScript
DESCRIPTION: This snippet defines a React component that takes a 'name' prop and returns a user object. It uses TypeScript-like type annotations within JavaScript.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  type User = {name: string};
  const user: User = {name: props.name};
  return user;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Mofei'}],
};
```

----------------------------------------

TITLE: Input React Component Definition
DESCRIPTION: Initial React component definition showing ErrorView and Renderer components with basic error handling functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-gating-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import {Stringify} from 'shared-runtime';

const ErrorView = (error, _retry) => <Stringify error={error}></Stringify>;

const Renderer = props => (
  <div>
    <span></span>
    <ErrorView></ErrorView>
  </div>
);

export default Renderer;

export const FIXTURE_ENTRYPOINT = {
  fn: eval('Renderer'),
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with Conditional State Updates
DESCRIPTION: This code defines a React component `Component` that uses `useState` to manage two boolean state variables `x` and `y`. The `setState` function is conditionally assigned to either `setX` or `setY` based on the `props.cond` value. The resulting `setState` function is then passed as a prop to a child component `Foo`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-phi-setState-type.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import invariant from 'invariant';
import {useState} from 'react';

function Component(props) {
  const [x, setX] = useState(false);
  const [y, setY] = useState(false);
  let setState;
  if (props.cond) {
    setState = setX;
  } else {
    setState = setY;
  }
  const setState2 = setState;
  const stateObject = {setState: setState2};
  return (
    <Foo
      cond={props.cond}
      setX={setX}
      setY={setY}
      setState={stateObject.setState}
    />
  );
}

function Foo({cond, setX, setY, setState}) {
  if (cond) {
    invariant(setState === setX, 'Expected the correct setState function');
  } else {
    invariant(setState === setY, 'Expected the correct setState function');
  }
  return 'ok';
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {cond: true},
    {cond: true},
    {cond: false},
    {cond: false},
    {cond: true},
    {cond: false},
    {cond: true},
    {cond: false},
  ],
};

```

----------------------------------------

TITLE: Error Message for Invalid Capitalized Function Call - JavaScript
DESCRIPTION: This snippet shows the error output that occurs when the function 'Foo' attempts to call 'Bar'. It explains that capitalized function names should be used only for React components and that the user has options to fix this issue. The snippet highlights key line references for debugging.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-function-call-aliased.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 | function Foo() {
  3 |   let x = Bar;
> 4 |   x(); // ERROR
    |   ^^^ InvalidReact: Capitalized functions are reserved for components, which must be invoked with JSX. If this is a component, render it with JSX. Otherwise, ensure that it has no hook calls and rename it to begin with a lowercase letter. Alternatively, if you know for a fact that this function is not a component, you can allowlist it via the compiler config. Bar may be a component. (4:4)
  5 | }
  6 |

```

----------------------------------------

TITLE: React Component with Memoization - Compiled Code
DESCRIPTION: Compiled version of the React component showing the internal implementation of memoization using compiler runtime helpers. Includes caching logic and optimized rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-log-default-import.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { ValidateMemoization } from "shared-runtime";
import typedLog from "shared-runtime";

export function Component(t0) {
  const $ = _c(17);
  const { a, b } = t0;
  let t1;
  let t2;
  if ($[0] !== a) {
    t2 = { a };
    $[0] = a;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const item1 = t1;
  let t3;
  let t4;
  if ($[2] !== b) {
    t4 = { b };
    $[2] = b;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  t3 = t4;
  const item2 = t3;
  typedLog(item1, item2);
  let t5;
  if ($[4] !== a) {
    t5 = [a];
    $[4] = a;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] !== item1 || $[7] !== t5) {
    t6 = <ValidateMemoization inputs={t5} output={item1} />;
    $[6] = item1;
    $[7] = t5;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  if ($[9] !== b) {
    t7 = [b];
    $[9] = b;
    $[10] = t7;
  } else {
    t7 = $[10];
  }
  let t8;
  if ($[11] !== item2 || $[12] !== t7) {
    t8 = <ValidateMemoization inputs={t7} output={item2} />;
    $[11] = item2;
    $[12] = t7;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  let t9;
  if ($[14] !== t6 || $[15] !== t8) {
    t9 = (
      <>
        {t6}
        {t8}
      </>
    );
    $[14] = t6;
    $[15] = t8;
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  return t9;
}
```

----------------------------------------

TITLE: Compiled Output of React Hook with Dependency Tracking (Code)
DESCRIPTION: The compiled version of the custom hook showing how React's compiler transforms the code to track dependencies. It uses the _c utility from compiler-runtime to memoize the result based on tracked dependencies (cond and props.a.b) that appear in all code paths.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-nested-ifelse.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths

import { getNull, identity } from "shared-runtime";

function useCondDepInNestedIfElse(props, cond) {
  const $ = _c(3);
  let x;
  if ($[0] !== cond || $[1] !== props.a.b) {
    x = {};
    if (identity(cond)) {
      if (getNull()) {
        x.a = props.a.b;
      } else {
        x.b = props.a.b;
      }
    } else {
      if (identity(cond)) {
        x.c = props.a.b;
      } else {
        x.d = props.a.b;
      }
    }
    $[0] = cond;
    $[1] = props.a.b;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInNestedIfElse,
  params: [{ a: { b: 2 } }, true],
};
```

----------------------------------------

TITLE: FBT Component Compiled Output
DESCRIPTION: Compiled version of the FBT component with optimization for parameter caching. Shows how the JSX-style FBT syntax is transformed into function calls with caching logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

const _ = fbt;
function Component(t0) {
  const $ = _c(2);
  const { value } = t0;
  let t1;
  if ($[0] !== value) {
    t1 = fbt._(
      "Before text {paramName}",
      [
        fbt._param(
          "paramName",

          value,
        ),
      ],
      { hk: "3z5SVE" },
    );
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "hello world" }],
};
```

----------------------------------------

TITLE: Input: React Conditional Array Population Function
DESCRIPTION: A function that conditionally populates an array based on input object properties, with early return logic for null objects
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-return-in-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({obj, objIsNull}) {
  const x = [];
  if (objIsNull) {
    return;
  } else {
    x.push(obj.a);
  }
  x.push(obj.b);
  return x;
}
```

----------------------------------------

TITLE: Defining React Functional Component with Props - JavaScript
DESCRIPTION: This snippet defines a functional React component 'Foo' that takes a 'data' prop and outputs a Stringify component, demonstrating how to manage properties dynamically. It utilizes optional chaining to safely access nested properties in the 'data' object. Dependencies include 'shared-runtime' for the Stringify component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/repro-invariant.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {Stringify} from 'shared-runtime';

function Foo({data}) {
  return (
    <Stringify foo={() => data.a.d} bar={data.a?.b.c} shouldInvokeFns={true} />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{data: {a: null}}],
  sequentialRenders: [{data: {a: {b: {c: 4}}}}],
};
```

----------------------------------------

TITLE: Initializing React Component with Nullthrows Behavior in JavaScript
DESCRIPTION: This snippet defines a React component that utilizes the `props.a` as a core dependency while `props.a.b` is used conditionally. It demonstrates handling of potentially null or undefined properties using optional chaining. The component aggregates values into an array and returns it. Dependencies include an environment capable of executing JavaScript with support for React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/conditional-member-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
```javascript
// To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a` as a dependency (since `props.a.b` is
// a conditional dependency, i.e. gated behind control flow)

function Component(props) {
  let x = [];
  x.push(props.a?.b);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: null}],
};

```
```

----------------------------------------

TITLE: Implementing React Component with Generator in useMemo
DESCRIPTION: This code snippet defines a React component that attempts to use a generator function within a useMemo hook. The purpose is to yield a value, but this is not currently supported and leads to an error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.useMemo-callback-generator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  // we don't handle generators at all so this test isn't
  // useful for now, but adding this test in case we do
  // add support for generators in the future.
  let x = useMemo(function* () {
    yield a;
  }, []);
  return x;
}
```

----------------------------------------

TITLE: Basic React Component Implementation
DESCRIPTION: Initial implementation of a React component using forwardRef and Stringify component with test fixture setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-use-before-decl-ref.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import {createRef, forwardRef} from 'react';
import {Stringify} from 'shared-runtime';

const Foo = forwardRef(Foo_withRef);
function Foo_withRef(props, ref) {
  return <Stringify ref={ref} {...props} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval('(...args) => React.createElement(Foo, args)'),
  params: [{prop1: 1, prop2: 2, ref: createRef()}],
};
```

----------------------------------------

TITLE: Defining React Component with Try-Catch Block in JavaScript
DESCRIPTION: This snippet defines a React component that returns the result of a callback function. The callback function contains a try-catch block that returns an empty array or undefined.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-function-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const callback = () => {
    try {
      return [];
    } catch (e) {
      return;
    }
  };
  return callback();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing Recursive Function in JavaScript
DESCRIPTION: A recursive function that takes two parameters (x, y) and either makes a recursive call with modified parameters or returns an array containing y multiplied by 10. The function uses strict mode and is exported as default.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-forget-module-level.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
'use no forget';

export default function foo(x, y) {
  if (x) {
    return foo(false, y);
  }
  return [y * 10];
}
```

LANGUAGE: javascript
CODE:
```
"use no forget";

export default function foo(x, y) {
  if (x) {
    return foo(false, y);
  }
  return [y * 10];
}
```

----------------------------------------

TITLE: Defining React Component with Loop and Conditional Logic
DESCRIPTION: This snippet defines a React component that initializes an array, performs a do-while loop with conditional logic, and mutates the array based on a prop condition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-conditional-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [0, 1, 2, 3];
  do {
    if (x === 0) {
      break;
    }
    mutate(x);
  } while (props.cond);
  return x;
}
```

----------------------------------------

TITLE: React Component Input
DESCRIPTION: This code defines a React component `useFoo` that takes `props` as input and calls a `foo` function with `props.x`. It also declares a variable `makeReadOnly` that conflicts with a later import.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/emit-freeze-conflicting-imports.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableEmitFreeze @instrumentForget

let makeReadOnly = 'conflicting identifier';
function useFoo(props) {
  return foo(props.x);
}

```

----------------------------------------

TITLE: Refactored React Component with Separated Effect
DESCRIPTION: Second code snippet demonstrating a refactored version of the React component where the effect callback is extracted into a separate function, maintaining the same external object mutation behavior
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-external-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useEffect } from "react";

let x = { a: 42 };

function Component(props) {
  useEffect(_temp);
}
function _temp() {
  x.a = 10;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Defining a Function with Simplified Object Manipulation in JavaScript
DESCRIPTION: This JavaScript snippet defines a function named 'foo' that takes three arguments (a, b, c). It uses spread syntax to create a new object 'y' based on nested properties of 'b', modifies 'y', and recursively calls itself with a nested property of 'a'. This version omits the const x = a.x and [a.b.c] lines from the original.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-properties.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const y = { ...b.c.d };
  y.z = c.d.e;
  foo(a.b.c);
}
```

----------------------------------------

TITLE: Validating JSX Usage in React Component
DESCRIPTION: This JavaScript code snippet demonstrates a React component where JSX is used inside a try statement. It attempts to validate if JSX usage within try statements is allowed or not. This snippet shows a basic React component implementation where JSX is used, and errors can potentially be thrown if the pattern is disallowed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-invalid-jsx-in-try-with-finally.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @validateNoJSXInTryStatements
function Component(props) {
  let el;
  try {
    el = <div />;
  } finally {
    console.log(el);
  }
  return el;
}
```

----------------------------------------

TITLE: Implementing a Recursive Function with IIFE in JavaScript
DESCRIPTION: This implementation of 'foo' calculates a sum using recursion. It includes both direct recursion and an immediately invoked function expression (IIFE) that makes another recursive call, potentially causing redundant calculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/recursive-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(x) {
  if (x <= 0) {
    return 0;
  }
  return x + foo(x - 1) + (() => foo(x - 2))();
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [10],
};
```

----------------------------------------

TITLE: Creating a React Component with Helper Function and Test Fixture
DESCRIPTION: This code defines a React component that calls an external function, contains an internal helper function that returns JSX, and exports a test fixture entry point. The component takes props, processes them with function f, renders a helper component, and returns the result.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-no-component-nested-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function Component(props) {
  const result = f(props);
  function helper() {
    return <foo />;
  }
  helper();
  return result;
}

function f(props) {
  return props;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining useFoo Hook with Nested Functions in JavaScript
DESCRIPTION: This snippet defines a custom React hook 'useFoo' with nested functions and console logging. It imports an 'identity' function and exports a fixture for testing. The code uses specific variable names for module-level constants.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables-nested-object-method.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableChangeVariableCodegen
import {identity} from 'shared-runtime';

const $ = 'module_$';
const t0 = 'module_t0';
const c_0 = 'module_c_0';
function useFoo(props: {value: number}): number {
  const a = {
    foo() {
      const b = {
        bar() {
          console.log($);
          console.log(t0);
          console.log(c_0);
          return identity(props.value);
        },
      };
      return b;
    },
  };
  return a.foo().bar();
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: React Component Context Dependency Verification in JavaScript
DESCRIPTION: This snippet is an enhanced version of the Foo function where a compiler-runtime cache is utilized to track changes. It manages conditional context variables using useCallback and preserves memoization guarantees. Dependencies include react/compiler-runtime and shared-runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-captures-reassigned-context-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useCallback } from "react";
import { Stringify } from "shared-runtime";

/**
 * TODO: we're currently bailing out because `contextVar` is a context variable
 * and not recorded into the PropagateScopeDeps LoadLocal / PropertyLoad
 * sidemap. Previously, we were able to avoid this as `BuildHIR` hoisted
 * `LoadContext` and `PropertyLoad` instructions into the outer function, which
 * we took as eligible dependencies.
 *
 * One solution is to simply record `LoadContext` identifiers into the
 * temporaries sidemap when the instruction occurs *after* the context
 * variable's mutable range.
 */
function Foo(props) {
  const $ = _c(6);
  let contextVar;
  if ($[0] !== props.cond) {
    if (props.cond) {
      contextVar = { val: 2 };
    } else {
      contextVar = {};
    }
    $[0] = props.cond;
    $[1] = contextVar;
  } else {
    contextVar = $[1];
  }
  let t0;
  if ($[2] !== contextVar.val) {
    t0 = () => [contextVar.val];
    $[2] = contextVar.val;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  contextVar;
  const cb = t0;
  let t1;
  if ($[4] !== cb) {
    t1 = <Stringify cb={cb} shouldInvokeFns={true} />;
    $[4] = cb;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ cond: true }],
};

```

----------------------------------------

TITLE: Component Initialization and Execution in React with JavaScript
DESCRIPTION: Defines a function Component that initializes state variables z and y, and updates z based on a specific logic. It uses Math.max to potentially modify y.b. The component supports sequential rendering with specified parameters in FIXTURE_ENTRYPOINT. Dependencies include React and must export a default component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-no-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Component({a, b}) {
  let z = {a};
  let y = {b};
  let x = function () {
    z.a = 2;
    return Math.max(y.b, 0);
  };
  x();
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 2, b: 3}],
  sequentialRenders: [
    {a: 2, b: 3},
    {a: 2, b: 3},
    {a: 4, b: 3},
    {a: 4, b: 5},
  ],
};

```

----------------------------------------

TITLE: Utilizing useIdentity Hook in React
DESCRIPTION: This snippet defines a React component, Foo, which uses the useIdentity hook to create a memoized callback for accessing an object property. The identity function ensures immutability beyond this point. The component takes an object as a prop and renders a Stringify component with evaluated properties. Dependencies include the shared-runtime package. The component expects an object with a val1 parameter as input and outputs a JSX element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-call-freezes-captured-memberexpr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useIdentity, Stringify, identity} from 'shared-runtime';

function Foo({val1}) {
  // `x={inner: val1}` should be able to be memoized
  const x = {inner: val1};

  // Any references to `x` after this hook call should be read-only
  const cb = useIdentity(() => x.inner);

  // With enableTransitivelyFreezeFunctionExpressions, it's invalid
  // to write to `x` after it's been frozen.
  // TODO: runtime validation for DX
  const copy = identity(x);
  return <Stringify copy={copy} cb={cb} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{val1: 1}],
  sequentialRenders: [{val1: 1}, {val1: 1}],
};
```

----------------------------------------

TITLE: Optimized React Component with State Management in JavaScript
DESCRIPTION: This snippet implements a more complex version of the Component function using internal mutable state via the _c function from 'react/compiler-runtime'. It checks for changes in props and stores previous values to optimize re-rendering and maintain local state, showcasing advanced React component handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-accessed-outside-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(6);
  let t0;
  let t1;
  if ($[0] !== props) {
    const maybeMutable = new MaybeMutable();
    const x = props;
    t0 = x;
    t1 = maybeMutate(maybeMutable);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t0 || $[4] !== t1) {
    t2 = [t0, t1];
    $[3] = t0;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

```

----------------------------------------

TITLE: Optimized Item Rendering with Fragment in React
DESCRIPTION: This snippet features a more advanced version of a React component utilizing the 'useFragment' hook and internal caching. It uses a temporary variable to simplify rendering by checking if the items have changed and only re-maps them if necessary. It demonstrates efficient item rendering and reuse of values with React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-logical.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useFragment } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  const item = useFragment(
    graphql`
      fragment F on T {
        id
      }
    `,
    props.item,
  );
  let t0;
  if ($[0] !== item.items) {
    t0 = item.items?.map(_temp) ?? [];
    $[0] = item.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function _temp(item_0) {
  return renderItem(item_0);
}

```

----------------------------------------

TITLE: React Component Input Implementation
DESCRIPTION: Original source code showing a React component that conditionally reassigns a variable based on a shouldReassign prop using conditionalInvoke utility.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reactive-implicit-control-flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {conditionalInvoke} from 'shared-runtime';

// same as context-variable-reactive-explicit-control-flow.js, but make
// the control flow implicit

function Component({shouldReassign}) {
  let x = null;
  const reassign = () => {
    x = 2;
  };
  conditionalInvoke(shouldReassign, reassign);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{shouldReassign: true}],
  sequentialRenders: [{shouldReassign: false}, {shouldReassign: true}],
};
```

----------------------------------------

TITLE: Type Alias Parameter Annotation Input
DESCRIPTION: Original TypeScript code showing type alias usage for function parameter annotation. Defines a Bar type alias as string and uses it through another type alias Foo as a parameter type.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-annotation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
type Bar = string;
function TypeAliasUsedAsParamAnnotation() {
  type Foo = Bar;
  const fun = (f: Foo) => {
    console.log(f);
  };
  fun('hello, world');
}

export const FIXTURE_ENTRYPOINT = {
  fn: TypeAliasUsedAsParamAnnotation,
  params: [],
};
```

----------------------------------------

TITLE: Testing React Context Components with react-is
DESCRIPTION: Shows how to determine if elements are Context Providers or Consumers using isContextConsumer, isContextProvider, and typeOf functions from react-is.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import React from "react";
import * as ReactIs from 'react-is';

const ThemeContext = React.createContext("blue");

ReactIs.isContextConsumer(<ThemeContext.Consumer />); // true
ReactIs.isContextProvider(<ThemeContext.Provider />); // true
ReactIs.typeOf(<ThemeContext.Provider />) === ReactIs.ContextProvider; // true
ReactIs.typeOf(<ThemeContext.Consumer />) === ReactIs.ContextConsumer; // true
```

----------------------------------------

TITLE: Creating React Components with Conditional Hooks - JavaScript
DESCRIPTION: This snippet illustrates the improper implementation of React hooks within a component function, specifically showing how a hook is used conditionally, which violates the React Rules of Hooks. The expected warning is highlighted in the accompanying error output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-d842d36db450.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function createComponent() {
  return function ComponentWithConditionalHook() {
    if (cond) {
      useConditionalHook();
    }
  };
}


```

LANGUAGE: javascript
CODE:
```
  4 |   return function ComponentWithConditionalHook() {
  5 |     if (cond) {
> 6 |       useConditionalHook();
    |       ^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (6:6)
  7 |     }
  8 |   };
  9 | }
```

----------------------------------------

TITLE: React Context Mutation Error Message
DESCRIPTION: Error output highlighting the issue of attempting to mutate a context value returned by useContext(), which is not allowed in React
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-mutate-context.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  1 | function Component(props) {
  2 |   const context = useContext(FooContext);
> 3 |   context.value = props.value;
    |   ^^^^^^^ InvalidReact: Mutating a value returned from 'useContext()', which should not be mutated (3:3)
  4 |   return context.value;
  5 | }
```

----------------------------------------

TITLE: React Component Input Implementation
DESCRIPTION: Basic React component implementation that renders multiple Text components with different character values including whitespace, Korean, Tamil and English text.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-string-attribute-expression-container.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  return (
    <div>
      <Text value={'\n'} />
      <Text value={'A\tE'} />
      <Text value={''} />
      <Text value={'Lauren'} />
      <Text value={''} />
      <Text value={'Sathya'} />
    </div>
  );
}

function Text({value}) {
  return <span>{value}</span>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: The original implementation of a React component that creates a closure with a function y and an object x. It demonstrates basic component structure with parameter passing and function exports.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutate-captured-arg-separately.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let y = function () {
    m(x);
  };

  let x = {a};
  m(x);
  return y;
}

function m(x) {}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [{name: 'Jason'}],
};
```

----------------------------------------

TITLE: Defining React Hook with Dynamic Array Manipulation in JavaScript
DESCRIPTION: This code snippet defines a React hook `useFoo`, which manipulates an array `x` based on the boolean condition `props.cond`. The hook adds properties `bar` or `foo` to the array. No external dependencies are required other than standard ECMAScript 2015+ features for JavaScript. Input properties include `cond`, `foo`, and `bar`. The output is an array with added elements based on the input condition, with potential constraints in managing stateful complexity.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};
```

----------------------------------------

TITLE: Memoization using React.memo with Hooks - JavaScript
DESCRIPTION: This snippet illustrates the valid use of hooks within anonymous function arguments to React.memo in JavaScript. It defines a functional component that utilizes a hook to render a button element. The snippet involves conditions to optimize the rendering process, crucial for performance improvements. The key dependency is React and an understanding of hooks is necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-28a78701970c.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Unsupported input

// Valid because hooks can be used in anonymous function arguments to
// React.memo.
const MemoizedFunction = React.memo(props => {
  useHook();
  return <button {...props} />;
});
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @skip
// Unsupported input

// Valid because hooks can be used in anonymous function arguments to
// React.memo.
const MemoizedFunction = React.memo((props) => {
  const $ = _c(2);
  useHook();
  let t0;
  if ($[0] !== props) {
    t0 = <button {...props} />;
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
});
```

----------------------------------------

TITLE: Using Shared Runtime with Component in JavaScript
DESCRIPTION: This JavaScript snippet defines a React functional component using hooks and functions from 'shared-runtime'. It imports 'useIdentity' and 'Stringify' to manipulate and display an array derived from a passed value. The component demonstrates the non-mutating use of 'Array.from'. The snippet includes an exported entry point to instantiate the component with various initial states.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-captures-arg0.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useIdentity, Stringify} from 'shared-runtime';

/**
 * TODO: Note that this `Array.from` is inferred to be mutating its first
 * argument. This is because React Compiler's typing system does not yet support
 * annotating a function with a set of argument match cases + distinct
 * definitions (polymorphism)
 *
 * In this case, we should be able to infer that the `Array.from` call is
 * not mutating its 0th argument.
 * The 0th argument should be typed as having `effect:Mutate` only when
 * (1) it might be a mutable iterable or
 * (2) the 1st argument might mutate its callee
 */
function Component({value}) {
  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];
  useIdentity();
  const derived = Array.from(arr);
  return <Stringify>{derived.at(-1)}</Stringify>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 5}],
  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],
};

```

----------------------------------------

TITLE: React Context Access
DESCRIPTION: This code snippet demonstrates a React component, App, that accesses values from a context called MyContext. It uses the useContext hook to retrieve the context and then destructures the context to extract foo and bar. These values are then passed as props to another component called Bar.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-mixed-array-obj.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @lowerContextAccess
function App() {
  const context = useContext(MyContext);
  const [foo] = context;
  const {bar} = context;
  return <Bar foo={foo} bar={bar} />;
}

```

----------------------------------------

TITLE: Exporting React Components in JavaScript
DESCRIPTION: This snippet defines and exports a React component named 'Component' which utilizes a child component called 'Child'. The 'Component' is also set as a property in a 'FIXTURE_ENTRYPOINT' object, allowing it to be executed with parameters. The child component displays the text passed as a property.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-in-jsx-attribute.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
export function Component() {
  return <Child text='Some \"text\"' />;
}

function Child(props) {
  return props.text;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Implementing Dynamic Item Generation in React Component
DESCRIPTION: This snippet shows a React component that generates a list of div elements based on a range of values. It uses a custom hook 'useData' and creates onClick handlers for each item. The component demonstrates the use of context variables and closure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const data = useData();
  const items = [];
  // NOTE: `i` is a context variable because it's reassigned and also referenced
  // within a closure, the `onClick` handler of each item
  for (let i = MIN; i <= MAX; i += INCREMENT) {
    items.push(<div key={i} onClick={() => data.set(i)} />);
  }
  return <>{items}</>;
}

const MIN = 0;
const MAX = 3;
const INCREMENT = 1;

function useData() {
  return new Map();
}

export const FIXTURE_ENTRYPOINT = {
  params: [],
  fn: Component,
};
```

----------------------------------------

TITLE: Defining a JavaScript Function
DESCRIPTION: This code defines a simple JavaScript function named `foo` that takes an object `a` as input, extracts the value of `a.b`, creates an array containing this value, and returns the array. It showcases basic object property access and array creation in JavaScript.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a) {
  const x = [a.b];
  return x;
}
```

----------------------------------------

TITLE: React Hook Input Implementation
DESCRIPTION: Initial hook implementation showing the input structure with imports and hook definition. The hook takes an object with a value property and returns one of two constant strings based on identity check.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-call-in-ternary-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  createHookWrapper,
  identity,
  CONST_STRING0,
  CONST_STRING1,
} from 'shared-runtime';

function useHook({value}) {
  return {
    getValue() {
      return identity(value);
    },
  }.getValue()
    ? CONST_STRING0
    : CONST_STRING1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{value: 0}],
};
```

----------------------------------------

TITLE: Managing Object State in React - JavaScript
DESCRIPTION: This snippet illustrates object manipulation within a React component using JavaScript. The function Foo attempts to delete a property in an external object, which raises an InvalidReact error due to prohibited direct manipulation of external variables. React hooks or effects should be used to manage such state changes properly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.mutate-property-from-global.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
let wat = {};

function Foo() {
  delete wat.foo;
  return wat;
}
```

----------------------------------------

TITLE: Refactored Fire Mechanism in React Component
DESCRIPTION: This snippet showcases an updated implementation of the same React component where the useFire hook is utilized for the foo and bar functions. It destructures props directly in the function parameter and sets up useEffect to invoke the useFire instances accordingly. The component continues to maintain capitalized function call validation and integrates the shared runtime sum function as before.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-capitalized-fn-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useFire } from "react/compiler-runtime"; // @validateNoCapitalizedCalls @enableFire @panicThreshold(none)
import { fire } from "react";
const CapitalizedCall = require("shared-runtime").sum;

function Component(t0) {
  const { prop1, bar } = t0;
  const foo = () => {
    console.log(prop1);
  };
  const t1 = useFire(foo);
  const t2 = useFire(bar);

  useEffect(() => {
    t1(prop1);
    t1();
    t2();
  });
  return CapitalizedCall();
}

```

----------------------------------------

TITLE: Complex Calculation Implementation in React Test Fixture
DESCRIPTION: A test fixture implementation that performs multiple arithmetic operations and conditional logging. Exports a function through FIXTURE_ENTRYPOINT with metadata about its usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const a = 1;
  const b = 2;
  const c = 3;
  const d = a + b;
  const e = d * c;
  const f = e / d;
  const g = f - e;

  if (g) {
    console.log('foo');
  }

  const h = g;
  const i = h;
  const j = i;
  return j;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Evaluating Expression Sequence Points in JavaScript React Fixture
DESCRIPTION: A function that demonstrates sequence point evaluation in JavaScript. It contains a variable initialization and a complex return statement where the variable is both read and modified within the same expression.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/expression-with-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function f() {
  let x = 1;
  return x + (x = 2) + x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing useFoo Hook with Variable Reassignment
DESCRIPTION: A hook function that attempts to modify a closure variable directly, which can lead to unexpected rendering behavior in React. The code demonstrates an anti-pattern that React lints warn against.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-in-hook-return-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo() {
  let x = 0;
  return value => {
    x = value;
  };
}
```

----------------------------------------

TITLE: React Component with Mutable Object and Function Expression
DESCRIPTION: This code snippet defines a React component that demonstrates the complexities of managing dependencies when dealing with mutable objects and function expressions.  The `getId` function expression captures the value of `obj.id` which is later mutated. Correct dependency tracking is critical to ensure `getId` returns the updated value. The component uses utilities from 'shared-runtime' like `shallowCopy`, `identity`, `mutate`, and `setPropertyByKey`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/aliased-nested-scope-fn-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableTransitivelyFreezeFunctionExpressions:false
import {
  Stringify,
  mutate,
  identity,
  setPropertyByKey,
  shallowCopy,
} from 'shared-runtime';
/**
 * Function expression version of `aliased-nested-scope-truncated-dep`.
 * 
 * In this fixture, the output would be invalid if propagateScopeDeps did not
 * avoid adding MemberExpression dependencies which would other evaluate during
 * the mutable ranges of their base objects.
 * This is different from `aliased-nested-scope-truncated-dep` which *does*
 * produce correct output regardless of MemberExpression dependency truncation.
 * 
 * Note while other expressions evaluate inline, function expressions *always*
 * represent deferred evaluation. This means that
 * (1) it's always safe to reorder function expression creation until its
 *     earliest potential invocation
 * (2) it's invalid to eagerly evaluate function expression dependencies during
 *     their respective mutable ranges.
 */

function Component({prop}) {
  let obj = shallowCopy(prop);

  const aliasedObj = identity(obj);

  // When `obj` is mutable (either directly or through aliases), taking a
  // dependency on `obj.id` is invalid as it may change before getId() is invoked
  const getId = () => obj.id;

  mutate(aliasedObj);
  setPropertyByKey(aliasedObj, 'id', prop.id + 1);

  // Calling getId() should return prop.id + 1, not the prev
  return <Stringify getId={getId} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{prop: {id: 1}}],
  sequentialRenders: [{prop: {id: 1}}, {prop: {id: 1}}, {prop: {id: 2}}],
};

```

----------------------------------------

TITLE: Original Component Function with Nested Closures
DESCRIPTION: This is the original implementation of a component function that creates nested closures accessing a variable from an outer scope. The function initializes an object and returns a nested function that logs a value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-expr-in-nested-func.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a: {a}};
  let x = function () {
    (function () {
      console.log(z.a.a);
    })();
  };
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining Custom Hook with Memoization in React
DESCRIPTION: This snippet defines a custom hook, useFoo, which utilizes the useRef hook to create a reference and the useMemo hook to return a memoized array created by a shared utility function. The purpose is to optimize performance by preventing unnecessary computations on each render. Note that the usage of the reference's current property during render is restricted, leading to an error during execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-mutable-ref-not-preserved.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees:true

import {useRef, useMemo} from 'react';
import {makeArray} from 'shared-runtime';

function useFoo() {
  const r = useRef();
  return useMemo(() => makeArray(r), []);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: Invalid Hook Reference in React Component
DESCRIPTION: Example of incorrect hook usage where 'useFoo' is referenced directly as a value in a ternary operation instead of being called as a hook function. This violates React's rules of hooks which require hooks to be called at the top level of components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-as-conditional-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = props.cond ? (useFoo ? 1 : 2) : 3;
  return x;
}
```

LANGUAGE: plaintext
CODE:
```
  1 | function Component(props) {
> 2 |   const x = props.cond ? (useFoo ? 1 : 2) : 3;
    |                           ^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)
  3 |   return x;
  4 | }
  5 |
```

----------------------------------------

TITLE: Transformed React Component Implementation
DESCRIPTION: Shows how React transforms the component by extracting nested functions into separate named functions, hoisting them, and replacing closure variables with direct values for better performance and optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rewrite-phis-in-lambda-capture-context.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component() {
  const get4 = _temp2;
  return get4;
}
function _temp2() {
  while (bar()) {
    if (baz) {
      bar();
    }
  }
  return _temp;
}
function _temp() {
  return 4;
}
```

----------------------------------------

TITLE: Memoized React Component using Compiler Runtime
DESCRIPTION: This snippet shows the transformed React component after being processed by the React compiler runtime. The `_c` function from `react/compiler-runtime` is used to memoize the function. This approach avoids manual `useCallback` usage, potentially improving performance by leveraging compiler optimizations. The compiler generates the memoization logic with the $[0], $[1], and $[2] array to save previous values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-alias-property-load-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useCallback } from "react";
import { sum } from "shared-runtime";

function Component(t0) {
  const $ = _c(3);
  const { propA, propB } = t0;
  const x = propB.x.y;
  let t1;
  if ($[0] !== propA.x || $[1] !== x) {
    t1 = () => sum(propA.x, x);
    $[0] = propA.x;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ propA: { x: 2 }, propB: { x: { y: 3 } } }],
};

```

----------------------------------------

TITLE: Original React Component with Default Array Destructuring
DESCRIPTION: A React component that destructures an array value from props with a default value of [-1, 1]. Uses array destructuring pattern with default values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-default-array-with-unary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [x = [-1, 1]] = props.value;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: []}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: This snippet shows the original implementation of a React component. It creates an array with objects and the prop value, joins it with a closure, and returns the result.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-join.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [{}, [], props.value];
  const y = x.join(() => 'this closure gets stringified, not called');
  foo(y);
  return [x, y];
}
```

----------------------------------------

TITLE: Original React Component with FBT Internationalization
DESCRIPTION: A React component using the FBT internationalization library to display localized messages with dynamic parameters. The component renders a greeting with the user's name and available actions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-params.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component(props) {
  return (
    <div>
      <fbt desc={'Dialog to show to user'}>
        Hello <fbt:param name="user name">{props.name}</fbt:param>
      </fbt>
      <fbt desc={'Available actions|response'}>
        <fbt:param name="actions|response">{props.actions}</fbt:param>
      </fbt>
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component with Error Handling
DESCRIPTION: Implementation of a React component with try-catch block handling potential errors. Returns either a constant value 42 or falls back to the default prop value if an error occurs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-immediately-returns.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = props.default;
  try {
    // note: has to be a primitive, we want an instruction that cannot throw
    // to ensure there is no maybe-throw terminal
    const y = 42;
    return y;
  } catch (e) {
    x = e;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{default: 42}],
};
```

----------------------------------------

TITLE: Input React Component with Fragment Usage
DESCRIPTION: Original React component implementation using useFragment hook to handle post data with media, comments, and URLs. Demonstrates fragment usage and event handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-mixed-scope-declarations-and-locals.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useFragment} from 'shared-runtime';

function Component(props) {
  const post = useFragment(
    graphql`
      fragment F on T {
        id
      }
    `,
    props.post
  );
  const allUrls = [];
  // `media` and `urls` are exported from the scope that will wrap this code,
  // but `comments` is not (it doesn't need to be memoized, bc the callback
  // only checks `comments.length`)
  // because of the scope, the let declaration for media and urls are lifted
  // out of the scope, and the destructure statement ends up turning into
  // a reassignment, instead of a const declaration. this means we try to
  // reassign `comments` when there's no declaration for it.
  const {media, comments, urls} = post;
  const onClick = e => {
    if (!comments.length) {
      return;
    }
    console.log(comments.length);
  };
  allUrls.push(...urls);
  return <Media media={media} onClick={onClick} />;
}
```

----------------------------------------

TITLE: React Hook Error Message
DESCRIPTION: This code shows the error message generated when a React hook is misused, specifically when it is passed as a regular value instead of being called. The error message indicates the location of the error and provides a link to React documentation for more information.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-pass-hook-as-call-arg.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  1 | function Component(props) {
> 2 |   return foo(useFoo);
    |              ^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)
  3 | }
  4 |

```

----------------------------------------

TITLE: Implementing Error Handling in a React Component - JavaScript
DESCRIPTION: This snippet demonstrates the use of nested try-catch blocks within a React component to manage potential errors when accessing props. It imports an identity function from a shared runtime, applies it to a prop, and handles errors with a fallback rendering and logging mechanism. The snippet requires React and assumes the availability of the identity function. Inputs are component props and outputs are rendered JSX elements or logs. Limitations include the absence of a catch clause handling for the outer try block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-invalid-jsx-in-catch-in-outer-try-with-finally.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoJSXInTryStatements
import {identity} from 'shared-runtime';

function Component(props) {
  let el;
  try {
    let value;
    try {
      value = identity(props.foo);
    } catch {
      el = <div value={value} />;
    }
  } finally {
    console.log(el);
  }
  return el;
}

```

----------------------------------------

TITLE: Defining a Conditional Component in React - JavaScript
DESCRIPTION: This snippet defines a simple React component that checks a condition from props to determine its return value. It initializes a variable based on the condition and calls utility functions to enforce immutability on the output value. Key parameters include 'cond', which dictates the flow, and 'x', the output value when the condition is true.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-freeze-possibly-mutable-arguments.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const cond = props.cond;
  const x = props.x;
  let a;
  if (cond) {
    a = x;
  } else {
    a = [];
  }
  useFreeze(a); // should freeze, value *may* be mutable
  useFreeze(a); // should be readonly
  call(a); // should be readonly
  return a;
}

function useFreeze(x) {}
function call(x) {}
```

----------------------------------------

TITLE: Defining a Function and Exporting an Object in JavaScript
DESCRIPTION: This snippet defines a function `foo` which adds two elements from a props array and exports an object `FIXTURE_ENTRYPOINT` containing a reference to the function and component parameters. The function uses destructuring to extract values from `props.a`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-array-middle-element.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props) {
  const [x, unused, y] = props.a;
  return x + y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Using Conditional Dependencies in React - Initializing
DESCRIPTION: This snippet defines the function 'useCondDepInNestedIfElse' which manages dependencies conditionally based on the input state. It checks if certain properties are accessed in given condition paths and sets up the reactive state accordingly. It imports necessary functions from 'shared-runtime' to determine conditional logic control. Key parameters include 'props', which holds the property values, and 'cond', a boolean that dictates which code path to take.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-nested-ifelse-missing.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// props.a.b should NOT be added as a unconditional dependency to the reactive
// scope that produces x if it is not accessed in every path

import {identity, getNull} from 'shared-runtime';

function useCondDepInNestedIfElse(props, cond) {
  const x = {};
  if (identity(cond)) {
    if (getNull()) {
      x.a = props.a.b;
    }
  } else {
    x.d = props.a.b;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInNestedIfElse,
  params: [{a: {b: 2}}, true],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // props.a.b should NOT be added as a unconditional dependency to the reactive
// scope that produces x if it is not accessed in every path

import { identity, getNull } from "shared-runtime";

function useCondDepInNestedIfElse(props, cond) {
  const $ = _c(3);
  let x;
  if ($[0] !== cond || $[1] !== props) {
    x = {};
    if (identity(cond)) {
      if (getNull()) {
        x.a = props.a.b;
      }
    } else {
      x.d = props.a.b;
    }
    $[0] = cond;
    $[1] = props;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInNestedIfElse,
  params: [{ a: { b: 2 } }, true],
};
```

----------------------------------------

TITLE: Simulating Multi-touch Interactions with DOM Event Testing Library
DESCRIPTION: This example demonstrates how to dispatch multiple pointer events to simulate multi-touch interactions. It shows activating two different pointers with unique IDs to test multi-touch gesture handling.
SOURCE: https://github.com/facebook/react/blob/main/packages/dom-event-testing-library/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
// first pointer is active
target.pointerdown({pointerId: 1, pointerType});
// second pointer is active
target.pointerdown({pointerId: 2, pointerType});
```

----------------------------------------

TITLE: Accessing ref.current During Render in React Component
DESCRIPTION: This code snippet demonstrates an incorrect React pattern - accessing ref.current during component rendering. React restricts this because refs should not be accessed during the render phase as noted by the validation directive.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-mutate-ref-arg-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender:true
function Foo(props, ref) {
  console.log(ref.current);
  return <div>{props.bar}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{bar: 'foo'}, {ref: {cuurrent: 1}}],
  isComponent: true,
};
```

----------------------------------------

TITLE: Input Component with Mutation and Closure
DESCRIPTION: An initial implementation of a component that creates nested objects, uses a closure, and calls a mutate function on the object
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-2-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function component(foo, bar) {
  let x = {foo};
  let y = {bar};
  (function () {
    let a = {y};
    let b = x;
    a.x = b;
  })();
  mutate(y);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['foo', 'bar'],
};
```

----------------------------------------

TITLE: React Component Input with Ref Access
DESCRIPTION: Original React component implementation showing a basic ref access pattern using useRef hook. The component creates and returns a function that accesses the ref's current value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-ref-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @validateRefAccessDuringRender @validatePreserveExistingMemoizationGuarantees

import {useRef} from 'react';

component Foo() {
  const ref = useRef();

  const s = () => {
    return ref.current;
  };

  return s;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component that returns an object with three properties. Uses external functions getNumber and identity, with props.id as an input parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mege-consecutive-scopes-dont-merge-with-different-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {getNumber, identity} = require('shared-runtime');

function Component(props) {
  // Two scopes: one for `getNumber()`, one for the object literal.
  // Neither has dependencies so they should merge
  return {a: getNumber(), b: identity(props.id), c: ['static']};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 42}],
};
```

----------------------------------------

TITLE: Memoizing Component with Conditional Array Manipulation
DESCRIPTION: Demonstrates a React component using useMemo with conditional array population and optional chaining, which triggers memoization preservation warning
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hoist-optional-member-expression-with-conditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
  const data = useMemo(() => {
    const x = [];
    x.push(props?.items);
    if (props.cond) {
      x.push(props.items);
    }
    return x;
  }, [props?.items, props.cond]);
  return (
    <ValidateMemoization inputs={[props?.items, props.cond]} output={data} />
  );
}
```

----------------------------------------

TITLE: Input React useMemo Implementation
DESCRIPTION: Original React code showing a useMemo hook implementation with a constant string dependency. The function useFoo returns a memoized array containing a constant string.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-scope-global.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';
import {CONST_STRING0} from 'shared-runtime';

// It's correct to infer a useMemo block has no reactive dependencies
function useFoo() {
  return useMemo(() => [CONST_STRING0], [CONST_STRING0]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: React Hook Implementation with Inline Function
DESCRIPTION: This snippet defines a React hook, `useMyHook`, that returns an inline function. This inline function, when called, updates the value of the variable `b` to 2. The module also exports a `FIXTURE_ENTRYPOINT` to facilitate testing of the hook's functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-global-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
let b = 1;

export default function useMyHook() {
  const fn = () => {
    b = 2;
  };
  return fn;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useMyHook,
  params: [],
};

```

----------------------------------------

TITLE: Implementing React Component with Default Array Destructuring in JavaScript
DESCRIPTION: This snippet defines a React component that uses array destructuring with a default value. It destructures the first element of props.value array, defaulting to 42 if the array is empty or undefined. The component returns this value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-past-end-of-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // destructure past end of empty array, should evaluate to default
  const [x = 42] = props.value;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: []}],
};
```

----------------------------------------

TITLE: Custom Wall with Unique ID
DESCRIPTION: This JavaScript snippet provides an alternative custom "wall" implementation that utilizes a unique ID to ensure that only messages intended for a specific DevTools instance are processed. This is particularly useful when multiple DevTools instances may be rendered on the same page, preventing cross-communication.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_7

LANGUAGE: javascript
CODE:
```
const uid = "some-unique-string-shared-between-both-pieces";
const wall = {
  listen(listener) {
    window.addEventListener("message", (event) => {
      if (event.data.uid === uid) {
        listener(event.data);
      }
    });
  },
  send(event, payload) {
    window.postMessage({ event, payload, uid }, "*");
  },
};
```

----------------------------------------

TITLE: Using React Hooks for Local State Management in JavaScript
DESCRIPTION: This snippet defines a React component using the useEffect and useIdentity hooks to manage local variables. The component attempts to reassign a local variable within hooks, leading to potential inconsistencies if React Compiler optimizations are enabled. Key dependencies include 'useEffect' and 'useIdentity' from 'shared-runtime'. The function expects a callback for identity updates and logs inconsistencies or throws errors based on the React Compiler's state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-reassign-local-variable-in-hook-argument.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect} from 'react';
import {useIdentity} from 'shared-runtime';

function Component() {
  let local;

  const reassignLocal = newValue => {
    local = newValue;
  };

  const callback = newValue => {
    reassignLocal('hello');

    if (local === newValue) {
      // Without React Compiler, `reassignLocal` is freshly created
      // on each render, capturing a binding to the latest `local`,
      // such that invoking reassignLocal will reassign the same
      // binding that we are observing in the if condition, and
      // we reach this branch
      console.log('`local` was updated!');
    } else {
      // With React Compiler enabled, `reassignLocal` is only created
      // once, capturing a binding to `local` in that render pass.
      // Therefore, calling `reassignLocal` will reassign the wrong
      // version of `local`, and not update the binding we are checking
      // in the if condition.
      //
      // To protect against this, we disallow reassigning locals from
      // functions that escape
      throw new Error('`local` not updated!');
    }
  };

  useIdentity(() => {
    callback();
  });

  return 'ok';
}
```

----------------------------------------

TITLE: Original React Component with Spread Operator
DESCRIPTION: A React component that calls a method with spread arguments. The component calls a method on the 'foo' object using the method name from props and spreads array arguments with a null value in between.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-call-spread.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = foo[props.method](...props.a, null, ...props.b);
  return x;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows an optimized version of the 'Foo' component using React's compiler-runtime for memoization. It caches the result of conditional rendering to improve performance in subsequent renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-scopes-begin-same-instr-valueblock.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, mutate } from "shared-runtime";

function Foo(t0) {
  const $ = _c(2);
  const { cond } = t0;
  let x;
  if ($[0] !== cond) {
    x = identity(identity(cond)) ? { a: 2 } : { b: 2 };

    mutate(x);
    $[0] = cond;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ cond: false }],
  sequentialRenders: [
    { cond: false },
    { cond: false },
    { cond: true },
    { cond: true },
  ],
};
```

----------------------------------------

TITLE: React Component with Compiler Runtime
DESCRIPTION: This code shows the compiled version of a React component using the 'react/compiler-runtime'.  The '_c' function seems to be responsible for memoization and caching of values and elements to optimize rendering.  The code checks for changes in 'props.value' and the 'onClick' handler to determine if re-renders are necessary, storing the results in the '$' array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/drop-methodcall-usecallback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as React from "react";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.value) {
    t0 = () => {
      console.log(props.value);
    };
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onClick = t0;
  let t1;
  if ($[2] !== onClick) {
    t1 = <div onClick={onClick} />;
    $[2] = onClick;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};

```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: Compiler-optimized version using runtime caching to avoid recreating and recalculating array values. Implements conditional logic to reuse cached values when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-expression-computed.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.x) {
    x = [props.x];

    x[0] = x[0] * 2;
    x["0"] = x["0"] + 3;
    $[0] = props.x;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ x: 2 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component Transformation with Compiler Runtime
DESCRIPTION: This code shows the transformed version of the React component `Component` and its helper components using `react/compiler-runtime`. The `_c` function seems to be a core part of the compiler runtime, managing memoization and caching. The code optimizes the re-rendering of components by caching previous results based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-child-stored-in-id.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableJsxOutlining
function Component(t0) {
  const $ = _c(3);
  const { arr } = t0;
  const x = useX();
  let t1;
  if ($[0] !== arr || $[1] !== x) {
    t1 = arr.map((i) => {
      arr.map((i_0, id) => {
        const T0 = _temp;
        const child = <T0 i={i_0} x={x} />;

        const jsx = <div>{child}</div>;
        return jsx;
      });
    });
    $[0] = arr;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
function _temp(t0) {
  const $ = _c(5);
  const { i: i, x: x } = t0;
  let t1;
  if ($[0] !== i) {
    t1 = <Baz i={i} />;
    $[0] = i;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== t1 || $[3] !== x) {
    t2 = <Bar x={x}>{t1}</Bar>;
    $[2] = t1;
    $[3] = x;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

function Bar(t0) {
  const $ = _c(3);
  const { x, children } = t0;
  let t1;
  if ($[0] !== children || $[1] !== x) {
    t1 = (
      <>
        {x}
        {children}
      </>
    );
    $[0] = children;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Baz(t0) {
  const $ = _c(2);
  const { i } = t0;
  let t1;
  if ($[0] !== i) {
    t1 = <>{i}</>;
    $[0] = i;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function useX() {
  return "x";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arr: ["foo", "bar"] }],
};
```

----------------------------------------

TITLE: Defining useFoo Component with Compiler Optimizations (Code)
DESCRIPTION: This snippet defines the `useFoo` component with optimizations added by the React compiler runtime (indicated by `_c`).  It caches the result of computations using an array `$` and compares current props against cached values to avoid unnecessary re-renders and mutations. `FIXTURE_ENTRYPOINT` object configures the component for testing with specific initial parameters and sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-via-destructuring-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { mutate } from "shared-runtime";

function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    ({ x } = { x: [] });
    x.push(props.bar);
    if (props.cond) {
      ({ x } = { x: [] });
      x.push(props.foo);
    }

    mutate(x);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ bar: "bar", foo: "foo", cond: true }],
  sequentialRenders: [
    { bar: "bar", foo: "foo", cond: true },
    { bar: "bar", foo: "foo", cond: true },
    { bar: "bar", foo: "foo", cond: false },
  ],
};

```

----------------------------------------

TITLE: Defining a Memoized React Component - JavaScript
DESCRIPTION: This snippet demonstrates a memoized version of the React 'Component' using the 'react/compiler-runtime' library to enhance performance. It checks if the memoization cache is hit and accordingly returns the child component with the text prop. This snippet showcases advanced React techniques for optimizing component rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-jsx-attribute-escaped-constant-propagation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
export function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Child text={'Some "text"'} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function Child(props) {
  return props.text;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Compiled React Component 'Foo' with Memoization
DESCRIPTION: This snippet shows the compiled version of the 'Foo' component, incorporating memoization using React's compiler runtime. It uses a Symbol to check if the memoized value needs to be recalculated.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-logical.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    true && ((x = []), null);
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: React Compiler Runtime Memoization Implementation
DESCRIPTION: An optimized version of the React component using compiler runtime memoization techniques. Implements caching and state management with dynamic rendering and performance optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/validate-no-set-state-in-render-uncalled-function-with-mutable-range-is-valid.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const $ = _c(7);
  const logEvent = useLogging(props.appId);
  const [currentStep, setCurrentStep] = useState(0);
  let t0;
  if ($[0] !== logEvent) {
    t0 = (errorEvent) => {
      logEvent(errorEvent);
      setCurrentStep(1);
    };
    $[0] = logEvent;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onSubmit = t0;
  switch (currentStep) {
    case 0: {
      let t1;
      if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = <OtherComponent data={{ foo: "bar" }} />;
        $[2] = t1;
      } else {
        t1 = $[2];
      }
      return t1;
    }
    // ... rest of implementation
  }
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization (Compiled Version)
DESCRIPTION: This snippet shows the compiled and optimized version of the React component. It uses memoization to cache rendered content and avoid unnecessary re-renders. The component still implements the same conditional rendering logic as the input version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-propagate-type-of-ternary-nested.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function V0(t0) {
  const $ = _c(2);
  const { v1 } = t0;
  v5(V6.v7({ v8: V9.va }));
  let t1;
  if ($[0] !== v1) {
    t1 = (
      <ComponentC cd="TxqUy" ce="oh`]uc" cf="Bdbo" c10={!V9.va && v11.v12}>
        gmhubcw
        {v1 === V3.V13 ? (
          <c14
            c15={
              "L^]w\\T\\qrGmqrlQyrvBgf\\inuRdkEqwVPwixiriYGSZmKJf]E]RdT{N[WyVPiEJIbdFzvDohJV[BV`H[[K^xoy[HOGKDqVzUJ^h"
            }
          >
            iawyneijcgamsfgrrjyvhjrrqvzexxwenxqoknnilmfloafyvnvkqbssqnxnexqvtcpvjysaiovjxyqrorqskfph
          </c14>
        ) : v16.v17("pyorztRC]EJzVuP^e") ? (
          <c14
            c15={
              "CRinMqvmOknWRAKERI]RBzB_LXGKQe{SUpoN[\\gL[`bLMOhvFqDVVMNOdY"
            }
          >
            goprinbjmmjhfserfuqyluxcewpyjihektogc
          </c14>
        ) : (
          <c14 c15={"H\\\\GAcTc\\lfGMW[yHriCpvW`w]niSIKj\\kdgFI"}>
            yejarlvudihqdrdgpvahovggdnmgnueedxpbwbkdvvkdhqwrtoiual
          </c14>
        )}
        hflmn
      </ComponentC>
    );
    $[0] = v1;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const vb = t1;
  return vb;
}
```

----------------------------------------

TITLE: React Compiler Optimized Output with Memoization
DESCRIPTION: The compiler-transformed version of the same component with memoization added. It uses React's compiler runtime to cache computations and avoid unnecessary re-renders by tracking parameter changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-shadowing-within-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(9);
  let x;
  if ($[0] !== a || $[1] !== b || $[2] !== c) {
    x = [];
    if (a) {
      let y;
      if ($[4] !== b || $[5] !== c) {
        y = [];
        if (b) {
          y.push(c);
        }
        $[4] = b;
        $[5] = c;
        $[6] = y;
      } else {
        y = $[6];
      }
      let t0;
      if ($[7] !== y) {
        t0 = <div>{y}</div>;
        $[7] = y;
        $[8] = t0;
      } else {
        t0 = $[8];
      }
      x.push(t0);
    }
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Managing Component States React JavaScript
DESCRIPTION: The snippet provides a React component implementation that involves calculating and mutating variables, followed by rendering a JSX element. The 'Component' function computes values based on props and conditionally mutates them before returning a 'Foo' component with the updated values. Dependencies include React and any supporting compiler runtime for code optimization. Props a, b, and c are inputs affecting the computation and rendering processes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independent-across-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function compute() {}
function mutate() {}
function foo() {}
function Foo() {}

/**
 * Should produce 3 scopes:
 *
 * a: inputs=props.a & props.c; outputs=a
 *   a = compute(props.a);
 *   if (props.c)
 *     mutate(a)
 * b: inputs=props.b & props.c; outputs=b
 *   b = compute(props.b);
 *   if (props.c)
 *     mutate(b)
 * return: inputs=a, b outputs=return
 *   return = <Foo a={a} b={b} />
 */
function Component(props) {
  const a = compute(props.a);
  const b = compute(props.b);
  if (props.c) {
    mutate(a);
    mutate(b);
  }
  return <Foo a={a} b={b} />;
}

```

----------------------------------------

TITLE: Input Snippet: Dynamic Array Manipulation in React Hook
DESCRIPTION: Initial implementation of useFoo hook with array mutation and conditional logic based on props
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-via-destructuring-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function useFoo(props) {
  let {x} = {x: []};
  x.push(props.bar);
  if (props.cond) {
    ({x} = {x: {}});
    ({x} = {x: []});
    x.push(props.foo);
  }
  mutate(x);
  return x;
}
```

----------------------------------------

TITLE: Defining Component Function in JavaScript
DESCRIPTION: This snippet defines a basic component function that initializes an object with an input parameter, and uses an IIFE to manipulate the object's properties. It returns the initialized object and is designed to exhibit simple state-like behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-indirect-mutate-alias-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let x = {a};
  (function () {
    let q = x;
    (function () {
      q.b = 1;
    })();
  })();

  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [2],
};
```

----------------------------------------

TITLE: Implementing a React Component with Array Manipulation
DESCRIPTION: This snippet defines a React component that performs array manipulation based on props. It uses a do-while loop to process an array and create a new array with modified values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-compound-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [1, 2, 3];
  let ret = [];
  do {
    let item = x.pop();
    ret.push(item * 2);
  } while (x.length && props.cond);
  return ret;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component with Inferred useEffect Dependencies (JS)
DESCRIPTION: Shows the same React functional component 'Component' as the previous snippet, but with explicit dependencies '[arr, foo]' added to the 'useEffect' hook. This version represents the output after an analysis tool (indicated by '@inferEffectDependencies') has attempted to infer the necessary dependencies for the effect callback. Including 'arr' as a dependency is notable, given that 'arr' is mutated within the component's render phase and the effect itself, which can lead to potential re-rendering loops or unexpected behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/mutate-after-useeffect.expect.md#_snippet_1

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import { useEffect } from "react";

function Component(t0) {
  const { foo } = t0;
  const arr = [];
  useEffect(() => arr.push(foo), [arr, foo]);
  arr.push(2);
  return arr;
}
```

----------------------------------------

TITLE: Benchmark Execution Variants
DESCRIPTION: Collection of benchmark command variations for different testing scenarios, including local/remote comparisons, repository targeting, and headless mode
SOURCE: https://github.com/facebook/react/blob/main/scripts/bench/README.md#2025-04-21_snippet_2

LANGUAGE: bash
CODE:
```
# Compare local repo vs remote merge base repo
yarn start

# Compare local repo vs remote merge base repo without building
yarn start --skip-build

# Run local repo benchmarks only
yarn start --local

# Run remote merge base repo benchmarks only
yarn start --remote

# Run remote main repo benchmarks
yarn start --remote=main

# Run both local and remote benchmarks
yarn start --remote --local

# Run benchmarks in Chrome headless mode
yarn start --headless

# Run benchmarks matching specific string
yarn start --benchmark=hacker
```

----------------------------------------

TITLE: Hoisting Example in Javascript
DESCRIPTION: This code snippet demonstrates a hoisting scenario in JavaScript. It defines a function `hoisting` that creates an object `x` with a method `foo` that calls another function `bar`.  The function `bar` is defined later, showcasing hoisting. The return value of `x.foo()` is returned.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-object-method.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function hoisting() {
  const x = {
    foo() {
      return bar();
    },
  };
  const bar = () => {
    return 1;
  };

  return x.foo(); // OK: bar's value is only accessed outside of its TDZ
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
};

```

----------------------------------------

TITLE: Destructuring Error with Computed Properties
DESCRIPTION: An error message indicating a limitation in handling computed properties within an object pattern during the build or transformation process. The error suggests that the current implementation cannot fully process dynamic property destructuring.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.error.object-pattern-computed-key.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  3 | const SCALE = 2;
  4 | function Component(props) {
> 5 |   const {[props.name]: value} = props;
    |          ^^^^^^^^^^^^^^^^^^^ Todo: (BuildHIR::lowerAssignment) Handle computed properties in ObjectPattern (5:5)
  6 |   return value;
  7 | }
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that processes props.items, creating an array with length and filtered edge mappings. Uses optional chaining for null safety.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/memberexpr-join-optional-chain2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function Component(props) {
  const x = [];
  x.push(props.items?.length);
  x.push(props.items?.edges?.map?.(render)?.filter?.(Boolean) ?? []);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{items: {edges: null, length: 0}}],
};
```

----------------------------------------

TITLE: Defining React Functional Component - Basic Version
DESCRIPTION: This JavaScript snippet defines a functional component that takes an argument 'a', creates an object 't' containing 'a', and calls the inner function 'x' that accesses 'foo' method of 'a'. It also exports a constant as a fixture for testing with a sample 'foo' implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisted-function-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let t = {a};
  x(t); // hoisted call
  function x(p) {
    p.a.foo();
  }
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [
    {
      foo: () => {
        console.log(42);
      },
    },
  ],
};
```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React Component
DESCRIPTION: This code shows an anti-pattern where a hook (useFoo) is called conditionally inside an if statement. This violates React's Rules of Hooks which require hooks to be called in the same order on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-conditionally-call-prop-named-like-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({cond, useFoo}) {
  if (cond) {
    useFoo();
  }
}
```

LANGUAGE: plaintext
CODE:
```
  1 | function Component({cond, useFoo}) {
  2 |   if (cond) {
> 3 |     useFoo();
    |     ^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (3:3)
  4 |   }
  5 | }
  6 |

```

----------------------------------------

TITLE: React Component Definition and Export (Code)
DESCRIPTION: Defines a functional React component named `Component` that renders a div containing the text "Hello world". This version seems to utilize an internal React feature, possibly related to memoization, indicated by the `_c` import and the use of `Symbol.for("react.memo_cache_sentinel")`. The `FIXTURE_ENTRYPOINT` exports the component with metadata.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/target-flag-meta-internal.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react"; // @target="donotuse_meta_internal"

function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div>Hello world</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};

```

----------------------------------------

TITLE: Defining React Component 'Foo' with Array Operations
DESCRIPTION: This snippet defines a React component 'Foo' that creates an array of objects, selects a value based on a constant, and invokes a function with the result. It also exports a fixture for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-array-access-member-expr-captured.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_NUMBER0, invoke} from 'shared-runtime';

function Foo() {
  const x = [{value: 0}, {value: 1}, {value: 2}];
  const param = CONST_NUMBER0;
  const foo = () => {
    return x[param].value;
  };

  return invoke(foo);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Hook Implementation with Conditional Logic
DESCRIPTION: Implements a custom React hook 'useFoo' that manages state based on a condition parameter. Uses labeled blocks and conditional logic to handle state mutations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({cond}) {
  let items: any = {};
  b0: {
    if (cond) {
      // Mutable range of `items` begins here, but its reactive scope block
      // should be aligned to above the if-branch
      items = [];
    } else {
      break b0;
    }
    items.push(2);
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: true}],
  sequentialRenders: [
    {cond: true},
    {cond: true},
    {cond: false},
    {cond: false},
    {cond: true},
  ],
};
```

----------------------------------------

TITLE: Defining Original React Component Function
DESCRIPTION: This snippet defines a React component function 'Foo' that initializes an empty array and returns it. It also exports a FIXTURE_ENTRYPOINT object containing the function and empty props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-sequence.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  let x;
  (x = []), null;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Original Function Implementation
DESCRIPTION: Original function implementation showing a simple component that uses shallowCopy and performs a method call. Includes test fixture setup for the function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {addOne, shallowCopy} from 'shared-runtime';

function foo(a, b, c) {
  // Construct and freeze x
  const x = shallowCopy(a);
  <div>{x}</div>;

  // y should depend on `x` and `b`
  const y = x.foo(b);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{foo: addOne}, 3],
  isComponent: false,
};
```

----------------------------------------

TITLE: Demonstrating Incorrect Hook Usage in React - JavaScript
DESCRIPTION: This snippet shows two JavaScript functions that incorrectly use hooks inside functions that are not valid React component or custom hook definitions. The usage of `useHookInsideNormalFunction` within a plain JavaScript function violates React's rules of hooks, which state that hooks can only be called at the top level of a React function component or a custom hook. No specific dependencies are required, but correct understanding of React hooks usage is expected. Inputs and outputs are not applicable as the functions themselves are faulty by demonstration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-5a7ac9a6e8fa.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @skip
// Passed but should have failed

// These are neither functions nor hooks.
function _normalFunctionWithHook() {
  useHookInsideNormalFunction();
}

function _useNotAHook() {
  useHookInsideNormalFunction();
}

```

----------------------------------------

TITLE: Implementing Conditional Dependency Tracking in React
DESCRIPTION: Original implementation of a React hook that accesses props.a unconditionally and props.a.b conditionally. This demonstrates how React handles dependency tracking when a property path is a superpath of another.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// When an unconditional dependency `props.a` is the subpath of a conditional
// dependency `props.a.b`, we can safely overestimate and only track `props.a`
// as a dependency

import {identity} from 'shared-runtime';

// ordering of accesses should not matter
function useConditionalSuperpath1({props, cond}) {
  const x = {};
  x.a = props.a;
  if (identity(cond)) {
    x.b = props.a.b;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useConditionalSuperpath1,
  params: [{props: {a: null}, cond: false}],
  sequentialRenders: [
    {props: {a: null}, cond: false},
    {props: {a: {}}, cond: true},
    {props: {a: {b: 3}}, cond: true},
    {props: {}, cond: false},
    // test that we preserve nullthrows
    {props: {a: {b: undefined}}, cond: true},
    {props: {a: undefined}, cond: true},
  ],
};
```

----------------------------------------

TITLE: Preserving Nullthrows Behavior in React JavaScript
DESCRIPTION: This JavaScript snippet defines a React component that manages its internal state by conditionally accessing properties of the input props. The component creates an array, conditionally pushing the property 'props.a.b' based on its presence. The snippet emphasizes the preservation of nullthrows behavior and defining dependencies correctly. This approach ensures that the code remains reactive. No external dependencies are required beyond standard React imports.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/conditional-member-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
// To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a` as a dependency (since `props.a.b` is
// a conditional dependency, i.e. gated behind control flow)

function Component(props) {
  let x = [];
  x.push(props.a?.b);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: null}],
};
```

----------------------------------------

TITLE: React Component with Array Destructuring (Rest Operator)
DESCRIPTION: Defines a React component `foo` that receives props and uses array destructuring with the rest operator to extract the first two elements and the rest into separate variables. The function returns the sum of the first two elements (x and y).
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-array-rest-element.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props) {
  const [x, y, ...z] = props.a;
  return x + y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Original Function with Complex Destructuring
DESCRIPTION: Original JavaScript function implementing complex nested destructuring patterns on input parameters with spread operators.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const [
    d,
    [
      {
        e: {f},
        ...g
      },
    ],
    ...h
  ] = a;
  const {
    l: {
      m: [[n], ...o],
    },
    p,
  } = b;
  return [d, f, g, h, n, o, p];
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Original Component Implementation with Primitive Handling
DESCRIPTION: Original component function showing primitive value handling and object property assignment. Demonstrates type inference through usage patterns.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-polymorphic.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let p = makePrimitive();
  p + p; // infer p as primitive
  let o = {};

  let x = {};

  x.t = p; // infer x.t as primitive
  let z = x.t;

  x.t = o; // generalize x.t
  let y = x.t;
  return y;
}
```

----------------------------------------

TITLE: Implementing React Component with Object Declaration
DESCRIPTION: Defines a basic React component function with conditional logic and exports a test fixture object. The fixture includes the component function reference, parameters array, and component identifier.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-args-test-binary-operator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  if (a > b) {
    let m = {};
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining React Component with Props Destructuring - JavaScript
DESCRIPTION: This snippet defines a functional React component `Foo` that destructures props to extract particular properties. It handles an unused property by excluding it from the returned object. The `FIXTURE_ENTRYPOINT` is an exported constant that references the `Foo` function and includes its parameters and metadata for component identification.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element-with-rest.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  // can't remove `unused` since it affects which properties are copied into `rest`
  const {unused, ...rest} = props.a;
  return rest;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: React Component with No Memo Directive
DESCRIPTION: Implements a React component that takes props and renders a div element. The component uses a 'use no memo' directive and creates an array from props.foo. Includes a fixture entrypoint configuration for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  'use no memo';
  let x = [props.foo];
  return <div x={x}>"foo"</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{foo: 1}],
  isComponent: true,
};
```

LANGUAGE: javascript
CODE:
```
function Component(props) {
  "use no memo";
  let x = [props.foo];
  return <div x={x}>"foo"</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ foo: 1 }],
  isComponent: true,
};
```

----------------------------------------

TITLE: Optimizing Component Rendering with React Compiler - JavaScript
DESCRIPTION: This snippet optimizes component rendering using the 'react/compiler-runtime'. It caches props to avoid unnecessary rendering. Dependencies include 'react/compiler-runtime' and 'shared-runtime'. Key parameters 'foo' and 'bar' dictate rendering conditions. Outputs are dynamic based on internal component mutations and state caching mechanisms.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-arr.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";
function Component(t0) {
  const $ = _c(3);
  const { foo, bar } = t0;
  let y;
  if ($[0] !== bar || $[1] !== foo) {
    const x = { foo };
    y = { bar };
    const f0 = function () {
      const a = [y];
      const b = x;
      a.x = b;
    };

    f0();
    mutate(y);
    $[0] = bar;
    $[1] = foo;
    $[2] = y;
  } else {
    y = $[2];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ foo: 2, bar: 3 }],
  sequentialRenders: [
    { foo: 2, bar: 3 },
    { foo: 2, bar: 3 },
    { foo: 2, bar: 4 },
    { foo: 3, bar: 4 },
  ],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component implementation that takes props with an x value, processes it through an identity function, and returns an object with the transformed value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-object-declaration-to-context-var.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(props) {
  let {x} = props;
  const foo = () => {
    x = identity(props.x);
  };
  foo();
  return {x};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: 42}],
};
```

----------------------------------------

TITLE: Transformed Function with Explicit Destructuring in JavaScript
DESCRIPTION: This snippet shows a transformed version of the 'foo' function where the object destructuring is done explicitly in the function body. The 'FIXTURE_ENTRYPOINT' export remains the same.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-param-string-literal-key.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(t0) {
  const { data: dataTestID } = t0;
  return dataTestID;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{ data: {} }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Creating a Memoized Callback Hook in React
DESCRIPTION: Implements a custom React hook that creates a memoized callback using useIdentity. The hook takes an object and a setState function, then returns a callback that updates state with the object's value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/hook-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper, useIdentity} from 'shared-runtime';

/**
 * Assume that functions passed hook arguments are invoked and that their
 * property loads are hoistable.
 */
function useMakeCallback({
  obj,
  setState,
}: {
  obj: {value: number};
  setState: (newState: number) => void;
}) {
  const cb = useIdentity(() => setState(obj.value));
  return cb;
}

const setState = (arg: number) => {
  'use no memo';
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useMakeCallback),
  params: [{obj: {value: 1}, setState}],
  sequentialRenders: [
    {obj: {value: 1}, setState},
    {obj: {value: 2}, setState},
  ],
};
```

----------------------------------------

TITLE: Implementing useCallback with Dependency Mismatch in React
DESCRIPTION: A React component that uses useCallback with manually specified dependencies that don't match what the React Compiler would infer. The component attempts to memoize a function that returns propB.x.y when propA is truthy, but the dependency array may not correctly capture all dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.hoist-useCallback-conditional-access-own-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';

function Component({propA, propB}) {
  return useCallback(() => {
    if (propA) {
      return {
        value: propB.x.y,
      };
    }
  }, [propA, propB.x.y]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{propA: 1, propB: {x: {y: []}}}],
};
```

----------------------------------------

TITLE: Refactored React Component Function
DESCRIPTION: This snippet demonstrates the refactored version of the component function. It uses const declarations for improved immutability and removes the unnecessary object declaration inside the conditional block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-binary-operator.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function component() {
  const a = some();
  const b = someOther();
  if (a > b) {
  }
}
```

----------------------------------------

TITLE: Original Worklet Function Implementation
DESCRIPTION: Defines a React hook 'useFoo' that returns a worklet-annotated function. The function is marked with a 'worklet' directive and returns a constant value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-function-one-line-directive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo() {
  const update = () => {
    'worklet';
    return 1;
  };
  return update;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component Validation Code
DESCRIPTION: This code snippet defines a React component similar to the previous one, but focuses on function calls without assigning them to variables.  It validates that calls like Boolean(true), Number(3), String("foo"), React$useState(0), React.useState(1), and THIS_IS_A_CONSTANT() are correctly invoked within the component function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capitalized-function-allowlist.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @validateNoCapitalizedCalls @hookPattern:".*\b(use[^$]+)$"
import * as React from "react";
const React$useState = React.useState;
const THIS_IS_A_CONSTANT = () => {};
function Component() {
  Boolean(true);
  Number(3);
  String("foo");
  React$useState(0);
  React.useState(1);
  THIS_IS_A_CONSTANT();
  return 3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};

```

----------------------------------------

TITLE: Configuring Claude Desktop for React MCP Server
DESCRIPTION: JSON configuration for Claude Desktop to use the React MCP Server. The configuration specifies the node executable path and the path to the React MCP Server's index.js file.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/react-mcp-server/README.md#2025-04-21_snippet_0

LANGUAGE: json
CODE:
```
{
  "mcpServers": {
    "react": {
      "command": "/Users/<username>/.asdf/shims/node",
      "args": [
        "/Users/<username>/code/react/compiler/packages/react-mcp-server/dist/index.js"
      ]
    }
  }
}
```

----------------------------------------

TITLE: React Component Input
DESCRIPTION: This snippet defines a simple React component that takes `props` as input, calls `makeObject` with these props, and returns a value from the resulting object based on `props.key`. It assumes `makeObject` is defined elsewhere. This is the initial, unoptimized version of the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-computed-member-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const object = makeObject(props);
  return object?.[props.key];
}
```

----------------------------------------

TITLE: Memoizing React Component Arguments
DESCRIPTION: This code snippet imports shared-runtime utilities and uses React's useMemo to memoize component arguments. The purpose is to map nodes and validate memoization by comparing input and output through ValidateMemoization. The Component is structured to test sequential rendering scenarios with various argument configurations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {identity, ValidateMemoization} from 'shared-runtime';
import {useMemo} from 'react';

function Component({arg}) {
  const data = useMemo(() => {
    return arg?.items.edges?.nodes.map(identity);
  }, [arg?.items.edges?.nodes]);
  return (
    <ValidateMemoization inputs={[arg?.items.edges?.nodes]} output={data} />
  );
}
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arg: null}],
  sequentialRenders: [
    {arg: null},
    {arg: null},
    {arg: {items: {edges: null}}},
    {arg: {items: {edges: null}}},
    {arg: {items: {edges: {nodes: [1, 2, 'hello']}}}},
    {arg: {items: {edges: {nodes: [1, 2, 'hello']}}}},
  ],
};

```

----------------------------------------

TITLE: Original React Component with useMemo
DESCRIPTION: React component demonstrating useMemo usage to memoize array operations. Uses ValidateMemoization component to verify correct memoization behavior. Includes test fixtures for sequential rendering with different prop combinations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-nonmutating-loop-local-collection.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {ValidateMemoization} from 'shared-runtime';

function Component({a, b}) {
  const x = useMemo(() => {
    return [a];
  }, [a]);
  const y = useMemo(() => {
    const items = [b];
    for (const i of x) {
      items.push(i);
    }
    return items;
  }, [x, b]);
  return (
    <>
      <ValidateMemoization inputs={[a]} output={x} />
      <ValidateMemoization inputs={[x, b]} output={y} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 0, b: 0}],
  sequentialRenders: [
    {a: 1, b: 0},
    {a: 1, b: 1},
    {a: 0, b: 1},
  ],
};
```

----------------------------------------

TITLE: Defining a Memoized Function for React - JavaScript
DESCRIPTION: This snippet defines a function 'foo' which accepts three parameters and memoizes a derived array based on dependencies 'b' and 'c'. It returns an object containing 'a' and the memoized array. No specific dependencies are required beyond JavaScript runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independently-memoize-object-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const x = {a: a};
  // NOTE: this array should memoize independently from x, w only b,c as deps
  x.y = [b, c];

  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining a React Component
DESCRIPTION: This code snippet defines a React component named 'Component' that uses the 'makeObject' function to create an object and invoke a method on it. The snippet captures the initialization of a component and demonstrates an expected error when trying to destructure a const declaration improperly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.call-args-destructuring-asignment-complex.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = makeObject();
  x.foo(([[x]] = makeObject()));
  return x;
}

```

----------------------------------------

TITLE: Creating Component with Array Manipulation - React - JavaScript
DESCRIPTION: This snippet defines a React functional component that merges two arrays from props into a single array, inserting a null between them. It utilizes the 'makeArray' utility function for this transformation. The component is intended for integration in a testing fixture, which provides its parameters in a structured way.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-spread.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

function Component(props) {
  const x = makeArray(...props.a, null, ...props.b);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: [1, 2], b: [2, 3, 4]}],
};
```

----------------------------------------

TITLE: Optimizing React Component with Default Value Assignment in JavaScript
DESCRIPTION: This snippet shows an optimized version of the previous component. Instead of using array destructuring with a default value, it explicitly checks if the first element is undefined and assigns the default value accordingly. The functionality remains the same.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-past-end-of-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [t0] = props.value;
  const x = t0 === undefined ? 42 : t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: [] }],
};
```

----------------------------------------

TITLE: React Component with useMemo
DESCRIPTION: This React component uses `React.useState` to initialize a state variable `x` to 0. It then employs `React.useMemo` to calculate an `expensiveNumber` based on `x` using the `calculateExpensiveNumber` function from 'shared-runtime'. The component renders a div containing the calculated `expensiveNumber`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-namespace-import.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as React from 'react';
import {calculateExpensiveNumber} from 'shared-runtime';

function Component(props) {
  const [x] = React.useState(0);
  const expensiveNumber = React.useMemo(() => calculateExpensiveNumber(x), [x]);

  return <div>{expensiveNumber}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: Defining Functional Component with Static Text in React
DESCRIPTION: This snippet defines a simple React functional component named 'Test' which returns a static JSX element containing a string that references 'pageNumber'. It serves as a basic demonstration of component creation in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-bracket-in-text.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Test() {
  return (
    <div>
      If the string contains the string &#123;pageNumber&#125; it will be
      replaced by the page number.
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [],
};

```

----------------------------------------

TITLE: Defining Function Component with Callback in React
DESCRIPTION: This snippet defines a simple React functional component, 'Foo', which includes a callback function to track the render count. The component uses 'Stringify' from 'shared-runtime' to allow for rendering with the callback. The main purpose is to establish the structure of a React component with state management based on function invocation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-global-in-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

let renderCount = 0;
function Foo() {
  const cb = () => {
    renderCount += 1;
    return renderCount;
  };
  return <Stringify cb={cb} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This code defines a simple React component named 'Component' that receives 'props' as input. It creates an array containing the 'count' prop, an object using 'makeObject_Primitives', and renders a div containing the array. The component also logs the created object to the console. The 'FIXTURE_ENTRYPOINT' provides a way to invoke the component with predefined parameters for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-overlapping-scopes-store-const-used-later.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify, makeObject_Primitives} from 'shared-runtime';

function Component(props) {
  const array = [props.count];
  const x = makeObject_Primitives();
  const element = <div>{array}</div>;
  console.log(x);
  return <div>{element}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{count: 42}],
};
```

----------------------------------------

TITLE: Defining Component and Exporting Fixture Entrypoint in JavaScript
DESCRIPTION: This snippet demonstrates how to define a simple component in JavaScript and export it as a fixture entry point. The component processes an input parameter and performs an operation via a nested function. It is designed to be reusable for different input configurations as specified by the fixture entry point.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let t = {a};
  function x(p) {
    p.foo();
  }
  x(t);
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Original React Component Implementation with External Function Call
DESCRIPTION: A simple React component that creates a div element with style properties derived from props, includes an array child, and calls an external shallowCopy function. The component is exported through a FIXTURE_ENTRYPOINT object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/createElement-freeze.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import React from 'react';
import {shallowCopy} from 'shared-runtime';

function Component(props) {
  const childProps = {style: {width: props.width}};
  const element = React.createElement('div', childProps, ['hello world']);
  shallowCopy(childProps); // function that in theory could mutate, we assume not bc createElement freezes
  return element;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing Conditional Reference Hook in React
DESCRIPTION: A React hook that uses conditional ref selection and attempts to create a memoized callback with potential optimization challenges
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.preserve-use-memo-ref-missing-reactive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';

function useFoo({cond}) {
  const ref1 = useRef<undefined | (() => undefined)>();
  const ref2 = useRef<undefined | (() => undefined)>();
  const ref = cond ? ref1 : ref2;

  return useCallback(() => {
    if (ref != null) {
      ref.current();
    }
  }, []);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: Optimized React Component Implementation
DESCRIPTION: The optimized version of the component that directly assigns the prop value to the variable and returns it. Unnecessary initialization and increment operations have been removed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-postfix-update.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let i;

  i = props.i;
  return i;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ i: 42 }],
};
```

----------------------------------------

TITLE: Input: React Component with useSharedValue Hook
DESCRIPTION: A React component that uses the useSharedValue hook from react-native-reanimated to create a button that updates a shared value with random numbers. The component demonstrates how shared values can be modified in event handlers.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reanimated-shared-value-writes.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableCustomTypeDefinitionForReanimated
import {useSharedValue} from 'react-native-reanimated';

/**
 * https://docs.swmansion.com/react-native-reanimated/docs/2.x/api/hooks/useSharedValue/
 *
 * Test that shared values are treated as ref-like, i.e. allowing writes outside
 * of render
 */
function SomeComponent() {
  const sharedVal = useSharedValue(0);
  return (
    <Button
      onPress={() => (sharedVal.value = Math.random())}
      title="Randomize"
    />
  );
}
```

----------------------------------------

TITLE: Defining Enhanced Input Handler with State Management in JavaScript
DESCRIPTION: This snippet defines an enhanced version of the React component that utilizes a runtime helper from the 'react/compiler-runtime' module. It manages input state and checks conditions before pushing the input to an array, thereby returning the appropriate value based on the state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.input) {
    const x = [];
    const y = x;
    y.push(props.input);

    t0 = [x[0]];
    $[0] = props.input;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { input: 42 },
    { input: 42 },
    { input: "sathya" },
    { input: "sathya" },
    { input: 42 },
    { input: "sathya" },
    { input: 42 },
    { input: "sathya" },
  ],
};
```

----------------------------------------

TITLE: Optimized React Implementation Without useMemo
DESCRIPTION: Optimized version that removes the useMemo hook and directly calculates the minimum value. This implementation shows the transformed code after optimization, maintaining the same functionality but with simpler execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-nonallocating.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";

// It's correct to infer a useMemo value is non-allocating
// and not provide it with a reactive scope
function useFoo(num1, num2) {
  let t0;
  t0 = Math.min(num1, num2);
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [2, 3],
};
```

----------------------------------------

TITLE: Defining Component Props - TypeScript
DESCRIPTION: This snippet defines the props interface for a functional component in TypeScript. It allows for optional props and ensures type safety while accessing component properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/non-null-assertion.expect.md#2025-04-21_snippet_0

LANGUAGE: typescript
CODE:
```
interface ComponentProps {
  name?: string;
}
```

----------------------------------------

TITLE: Implementing a Simple Logging Hook in JavaScript
DESCRIPTION: This snippet defines a simple 'useHook' function that generates a logging array while looping from 0 to 'end'. It demonstrates the use of nested blocks for conditional breaks and logging at different stages of the loop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/labeled-break-within-label-loop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useHook(end) {
  const log = [];
  for (let i = 0; i < end + 1; i++) {
    log.push(`${i} @A`);
    bb0: {
      if (i === end) {
        break bb0;
      }
      log.push(`${i} @B`);
    }
    log.push(`${i} @C`);
  }
  return log;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [1],
};
```

----------------------------------------

TITLE: React Component with useInsertionEffect
DESCRIPTION: This React component `Component` utilizes the `useInsertionEffect` hook to perform side effects. The effect depends on a `data` object, which is newly created on each render and thus cannot be memoized, which triggers a warning from the React Compiler. The `mutate` function is called on the `data` object after the effect is executed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useInsertionEffect-dep-not-memoized.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateMemoizedEffectDependencies
import {useInsertionEffect} from 'react';

function Component(props) {
  const data = {};
  useInsertionEffect(() => {
    console.log(props.value);
  }, [data]);
  mutate(data);
  return data;
}

```

----------------------------------------

TITLE: Using new React.createRef() API in JavaScript
DESCRIPTION: Example of using the new React.createRef() API introduced in React 16.3 as an alternative to callback refs.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_16

LANGUAGE: JavaScript
CODE:
```
const myRef = React.createRef();
```

----------------------------------------

TITLE: Processing Component Props in JavaScript
DESCRIPTION: This JavaScript snippet defines a functional component that processes its props and manages intermediate states within arrays. The function constructs arrays based on input properties {a, b, c} and performs mutations on them to dictate a specific output structure. It illustrates basic usage of arrays and the modification of values based on the input props. No external dependencies are required, but understanding of JavaScript array operations is necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-access-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({a, b, c}) {
  const x = [a];
  const y = [null, b];
  const z = [[], [], [c]];
  x[0] = y[1];
  z[0][0] = x[0];
  return [x, z];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1, b: 20, c: 300}],
  sequentialRenders: [
    {a: 2, b: 20, c: 300},
    {a: 3, b: 20, c: 300},
    {a: 3, b: 21, c: 300},
    {a: 3, b: 22, c: 300},
    {a: 3, b: 22, c: 301},
  ],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component 'Foo' that conditionally initializes and returns an array. Shows the basic implementation before compilation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-logical-no-sequence.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  let x;
  true && (x = []);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining React Component with Getter Property in Object Literal
DESCRIPTION: A React component that creates an object with a getter property accessing the component's props. The getter returns the 'value' prop passed to the component, which is then rendered inside a div element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-get-syntax.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({value}) {
  const object = {
    get value() {
      return value;
    },
  };
  return <div>{object.value}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{value: 0}],
  sequentialRenders: [{value: 1}, {value: 2}],
};
```

----------------------------------------

TITLE: Starting React DevTools Development Environment
DESCRIPTION: Command for starting the React DevTools development environment in the react-devtools package. Used for testing changes to the DevTools application itself.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_7

LANGUAGE: shell
CODE:
```
yarn start
```

----------------------------------------

TITLE: Implementing React Component with Optional Chaining Error
DESCRIPTION: This code defines a React component using the useNoAlias hook with optional chaining on nullable props. The component receives an object with a nullable value property that has x and y string properties, then attempts to use optional chaining to safely access these properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-logical-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useNoAlias} from 'shared-runtime';

function useFoo(props: {value: {x: string; y: string} | null}) {
  const value = props.value;
  return useNoAlias(value?.x, value?.y) ?? {};
}

export const FIXTURE_ENTRYPONT = {
  fn: useFoo,
  props: [{value: null}],
};
```

----------------------------------------

TITLE: Defining React Component with FBT for Internationalization in JavaScript
DESCRIPTION: This snippet defines a React component 'Foo' that uses the FBT library to create an internationalized message. It takes two names as props and renders a message stating that these two people accepted the user's pull request.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace-two-subtrees.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Foo({name1, name2}) {
  return (
    <fbt desc="Text that is displayed when two people accepts the user's pull request.">
      <fbt:param name="user1">
        <span key={name1}>
          <b>{name1}</b>
        </span>
      </fbt:param>
      and
      <fbt:param name="user2">
        <span key={name2}>
          <b>{name2}</b>
        </span>
      </fbt:param>
      accepted your PR!
    </fbt>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{name1: 'Mike', name2: 'Jan'}],
};
```

----------------------------------------

TITLE: Rendering FBT Content in React Component
DESCRIPTION: This snippet shows a React functional component that uses the FBT library for internationalization. It requires the 'fbt' module and renders an FBT element with a description and text content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-locally-require-fbt.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const fbt = require('fbt');

  return <fbt desc="Description">{'Text'}</fbt>;
}
```

----------------------------------------

TITLE: Defining React Component with Props (JavaScript)
DESCRIPTION: This snippet defines a React component named MyComponentName that takes props as input. It creates an object x, applies some operations based on props, and returns an array containing x.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-emit-make-read-only.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableEmitFreeze true

function MyComponentName(props) {
  let x = {};
  foo(x, props.a);
  foo(x, props.b);

  let y = [];
  y.push(x);
  return y;
}
```

----------------------------------------

TITLE: Input React Hook Implementation
DESCRIPTION: Original implementation of a React hook that returns either an object with getValue method or a number based on a condition. Uses createHookWrapper for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-in-ternary-consequent.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper} from 'shared-runtime';

function useHook({isCond, value}) {
  return isCond
    ? {
        getValue() {
          return value;
        },
      }
    : 42;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{isCond: true, value: 0}],
};
```

----------------------------------------

TITLE: Implementing a React Component with Switch Statement Logic
DESCRIPTION: A React functional component that processes input props through a switch statement. The component stores props.a in an array, initializes x with props.b, and potentially updates x to props.d if props.c matches the array containing props.a.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-switch-case.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const a = [props.a];
  let x = props.b;
  switch (props.c) {
    case a: {
      x = props.d;
    }
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining React Component with Flow Type Annotations in JavaScript
DESCRIPTION: This snippet defines a React component using Flow type annotations. It imports the 'identity' function, defines a component that takes props with an 'id' property, and exports a fixture for testing the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-number_.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableUseTypeAnnotations
import {identity} from 'shared-runtime';

function Component(props: {id: number}) {
  const x = identity(props.id);
  const y = (x: number);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 42}],
};
```

----------------------------------------

TITLE: React Compiler Transformed Component with Memoization
DESCRIPTION: The transformed version uses React's compiler runtime to implement memoization. It uses a special sentinel value to determine if it should recompute the result or return a cached version, improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-reassign-in-rval.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Forget should call the original x (x = foo()) to compute result
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    let x = foo();
    const result = x((x = bar()), 5);
    t0 = [result, x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows the compiler-optimized version of the Component. It uses memoization to cache results and avoid unnecessary re-computations. The optimization includes checks for changed props and caching of intermediate results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-hoisting-variable-collision.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.items) {
    t0 = props.items.map(_temp);
    $[0] = props.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const items = t0;
  let t1;
  if ($[2] !== items) {
    t1 = [42, items];
    $[2] = items;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
function _temp(x) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ items: [0, 42, null, undefined, { object: true }] }],
};
```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimization
DESCRIPTION: This snippet shows the compiled version of the React component using `react/compiler-runtime`. It utilizes caching and conditional execution based on the input parameters 'foo' and 'bar'. The `_c` function from the compiler runtime is used to cache the component's state and avoid unnecessary re-execution if the inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-arr-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { mutate } = require("shared-runtime");

function component(foo, bar) {
  const $ = _c(3);
  let y;
  if ($[0] !== bar || $[1] !== foo) {
    const x = { foo };
    y = { bar };

    const a = [y];
    const b = x;
    a.x = b;

    mutate(y);
    $[0] = bar;
    $[1] = foo;
    $[2] = y;
  } else {
    y = $[2];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["foo", "bar"],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This JavaScript code represents the compiled version of the React component `hoisting`. It utilizes `react/compiler-runtime` for memoization and optimization.  The compiled component checks for a memoized value and either reuses it or creates a new `Stringify` element with the `onClick` function as a prop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-member-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function hoisting() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const onClick = function onClick(x) {
      return x + bar.baz;
    };

    const bar = { baz: 1 };

    t0 = <Stringify onClick={onClick} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows the optimized version of the Component after React compilation. It uses memoization to avoid unnecessary re-renders and optimizes the component's logic for better performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-reference-changes-type.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";
function Component(t0) {
  const $ = _c(2);
  const { a } = t0;
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = 1;

    y = x;

    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 2 }],
  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the React component using memoization. It imports a compiler runtime function for caching and only updates the result when the sum changes. The test fixture remains the same as in the input version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dce-circular-reference.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  const { data } = t0;
  let x = 0;
  for (const item of data) {
    const { current, other } = item;
    x = x + current;
    identity(other);
  }
  let t1;
  if ($[0] !== x) {
    t1 = [x];
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      data: [
        { current: 2, other: 3 },
        { current: 4, other: 5 },
      ],
    },
  ],
};
```

----------------------------------------

TITLE: React useCallback Compiled Code
DESCRIPTION: This snippet shows the transformed code of the 'Foo' component, supposedly compiled for optimization. It uses a '_c' function (likely from "react/compiler-runtime") to manage memoization. The 'x' variable and the useCallback's memoized function are stored in an array '$', and the code conditionally recomputes them based on prop changes to preserve memoization guarantees.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-captures-reassigned-context.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { useCallback } from "react";
import { makeArray } from "shared-runtime";

// This case is fine, as all reassignments happen before the useCallback
function Foo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props) {
    x = [];
    x.push(props);
    x = makeArray();
    $[0] = props;
    $[1] = x;
  } else {
    x = $[1];
  }
  let t0;
  if ($[2] !== x) {
    t0 = () => [x];
    $[2] = x;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  x;
  const cb = t0;
  return cb;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}]
};
```

----------------------------------------

TITLE: Compiled Component with Dependency Tracking (Code)
DESCRIPTION: This is the compiled version of the `useOnlyConditionalDependencies` React component. It utilizes `react/compiler-runtime` for memoization and dependency tracking. The component checks if the `cond` or `props` have changed to determine if the conditional property reads need to be re-evaluated, optimizing rendering by avoiding unnecessary computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/no-uncond.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
"import { c as _c } from \"react/compiler-runtime\"; // When an object's properties are only read conditionally, we should\n\nimport { identity } from \"shared-runtime\";\n\n// track the base object as a dependency.\nfunction useOnlyConditionalDependencies(t0) {\n  const $ = _c(3);\n  const { props, cond } = t0;\n  let x;\n  if ($[0] !== cond || $[1] !== props) {\n    x = {};\n    if (identity(cond)) {\n      x.b = props.a.b;\n      x.c = props.a.b.c;\n    }\n    $[0] = cond;\n    $[1] = props;\n    $[2] = x;\n  } else {\n    x = $[2];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useOnlyConditionalDependencies,\n  params: [{ props: { a: { b: 2 } }, cond: true }],\n  sequentialRenders: [\n    { props: { a: { b: 2 } }, cond: true },\n    { props: null, cond: false },\n    // check we preserve nullthrows\n    { props: { a: { b: { c: undefined } } }, cond: true },\n    { props: { a: { b: undefined } }, cond: true },\n    { props: { a: { b: { c: undefined } } }, cond: true },\n    { props: undefined, cond: true },\n  ],\n};\n"
```

----------------------------------------

TITLE: Defining React Component with FBT Internationalization
DESCRIPTION: This snippet defines a React component using the FBT framework for internationalization. It imports the FBT library, creates a component that renders internationalized text with a parameterized value, and exports a fixture for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-single-space-btw-param-and-text.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

const _ = fbt;
function Component({value}: {value: string}) {
  return (
    <fbt desc="descdesc">
      Before text <fbt:param name="paramName">{value}</fbt:param> after text
    </fbt>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'hello world'}],
};
```

----------------------------------------

TITLE: React Hook Final Implementation
DESCRIPTION: Final implementation of the hook with destructured parameter handling. The code maintains the same functionality but uses explicit parameter destructuring in the hook function signature.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-call-in-ternary-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import {
  createHookWrapper,
  identity,
  CONST_STRING0,
  CONST_STRING1,
} from "shared-runtime";

function useHook(t0) {
  const { value } = t0;
  return {
    getValue() {
      return identity(value);
    },
  }.getValue()
    ? CONST_STRING0
    : CONST_STRING1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ value: 0 }],
};
```

----------------------------------------

TITLE: Original React Component with Optional Chaining
DESCRIPTION: A React component that maps over post comments using optional chaining. Uses @enablePropagateDepsInHIR directive for compilation optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reactive-dependencies-non-optional-properties-inside-optional-chain.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function Component(props) {
  return props.post.feedback.comments?.edges?.map(render);
}
```

----------------------------------------

TITLE: Defining a Component with Conditional Fire and Effect - JavaScript
DESCRIPTION: This snippet defines a React component that conditionally executes a function when a specific prop condition is met, leveraging the fire and useEffect hooks for side effects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-validate-conditional-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire @panicThreshold(none)
import {fire, useEffect} from 'react';
import {Stringify} from 'shared-runtime';

/**
 * When @enableFire is specified, retry compilation with validation passes (e.g.
 * hook usage) disabled
 */
function Component(props) {
  const foo = props => {
    console.log(props);
  };

  if (props.cond) {
    useEffect(() => {
      fire(foo(props));
    });
  }

  return <Stringify />;
}

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component with conditional rendering based on props. Shows basic array manipulation and conditional returns without proper memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/partial-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function Component(props) {
  let x = [];
  let y = null;
  if (props.cond) {
    x.push(props.a);
    // oops no memo!
    return x;
  } else {
    y = foo();
    if (props.b) {
      return;
    }
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, a: 42}],
};
```

----------------------------------------

TITLE: Ternary Operator in React Component
DESCRIPTION: This JavaScript code defines a React component named `ternary` that takes `props` as input. Inside the component, a ternary operator is used to conditionally assign values to the variable `x` based on the value of `props.a`. The component then returns the sum of `x` and `y`. The `FIXTURE_ENTRYPOINT` object exports the component and its configuration for testing or usage elsewhere.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ternary-assignment-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function ternary(props) {
  let x = 0;
  const y = props.a ? (x = 1) : (x = 2);
  return x + y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: ternary,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component Definition with Mutable Array Logic (Input)
DESCRIPTION: This code snippet defines a React component that conditionally initializes an array `y` based on `props.cond` and `props.cond2`. It then pushes an object `x` into the array and returns both `x` and `y`. The snippet demonstrates a scenario where the mutable range of array literals must be handled carefully for proper memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-array-push-consecutive-phis.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {makeArray} from 'shared-runtime';

function Component(props) {
  const x = {};
  let y;
  if (props.cond) {
    if (props.cond2) {
      y = [props.value];
    } else {
      y = [props.value2];
    }
  } else {
    y = [];
  }
  // This should be inferred as `<store> y` s.t. `x` can still
  // be independently memoized. *But* this also must properly
  // extend the mutable range of the array literals in the
  // if/else branches
  y.push(x);

  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, cond2: true, value: 42}],
  sequentialRenders: [
    {cond: true, cond2: true, value: 3.14},
    {cond: true, cond2: true, value: 42},
    {cond: true, cond2: true, value: 3.14},
    {cond: true, cond2: false, value2: 3.14},
    {cond: true, cond2: false, value2: 42},
    {cond: true, cond2: false, value2: 3.14},
    {cond: false},
    {cond: false},
  ],
};

```

----------------------------------------

TITLE: Implementing useHook with Set and Array Manipulation in JavaScript
DESCRIPTION: This snippet defines a custom React hook 'useHook' that uses Set and Array manipulation. It takes an object with 'el1' and 'el2' properties, creates a Set, manipulates arrays, and returns the size of the Set.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-add-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

function useHook({el1, el2}) {
  const s = new Set();
  const arr = makeArray(el1);
  s.add(arr);
  // Mutate after store
  arr.push(el2);

  s.add(makeArray(el2));
  return s.size;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{el1: 1, el2: 'foo'}],
  sequentialRenders: [
    {el1: 1, el2: 'foo'},
    {el1: 2, el2: 'foo'},
  ],
};
```

----------------------------------------

TITLE: React Hook Definition: useFoo
DESCRIPTION: Defines a React hook named `useFoo` that takes an `onClose` function as a prop. It initializes a button using `StaticText1` and a `Stringify` component, configuring its primary and secondary actions. The secondary action's onPress handler relies on a `dispatcher` which is initialized using `useHook` after the button's initialization. The hook returns the button.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisted-declaration-with-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {StaticText1, Stringify, identity, useHook} from 'shared-runtime';

/**
 * `button` and `dispatcher` must end up in the same memo block. It would be
 * invalid for `button` to take a dependency on `dispatcher` as dispatcher
 * is created later.
 */
function useFoo({onClose}) {
  const button = StaticText1 ?? (
    <Stringify
      primary={{
        label: identity('label'),
        onPress: onClose,
      }}
      secondary={{
        onPress: () => {
          dispatcher.go('route2');
        },
      }}
    />
  );

  const dispatcher = useHook();

  return button;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{onClose: identity()}],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that creates and manipulates arrays with object references. The component creates two arrays, maps over one, and modifies a property on the mapped result.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-non-mutating-lambda-mutated-result.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [{}];
  const y = x.map(item => {
    return item;
  });
  y[0].flag = true;
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Input React Component Definition
DESCRIPTION: Original React component implementation showing state management with useFeature prop and nested Stringify component rendering
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/allow-props-named-like-hooks.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component({useFeature}) {
  let x;
  if (useFeature) {
    x = [useFeature + useFeature].push(-useFeature);
  }
  let y = useFeature;
  let z = useFeature.useProperty;
  return (
    <Stringify val={useFeature}>
      {x}
      {y}
      {z}
    </Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{useFeature: {useProperty: true}}],
};
```

----------------------------------------

TITLE: Running React DevTools Scheduling Profiler Fixture with Shell Commands
DESCRIPTION: Shell commands for downloading the latest experimental React build and running the scheduling profiler fixture. This needs to be executed from the root directory of the React project.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/devtools/scheduling-profiler/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
# In the root directory
# Download the latest *experimental* React build
scripts/release/download-experimental-build.js

# Run this fixtures
fixtures/devtools/scheduling-profiler/run.js
```

----------------------------------------

TITLE: Defining Foo Component with Stringify - Initial Version
DESCRIPTION: This snippet defines the Foo component in React using a functional approach. It uses the Stringify component to conditionally return the value of 'a.b.c' based on the prop 'shouldReadA'. The FIXTURE_ENTRYPOINT constant is prepared for testing with an initial setup of parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-cond-access-not-hoisted.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR

import {Stringify} from 'shared-runtime';

function Foo({a, shouldReadA}) {
  return (
    <Stringify
      fn={() => {
        if (shouldReadA) return a.b.c;
        return null;
      }}
      shouldInvokeFns={true}
    />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{a: null, shouldReadA: true}],
  sequentialRenders: [
    {a: null, shouldReadA: true},
    {a: null, shouldReadA: false},
    {a: {b: {c: 4}}, shouldReadA: true},
  ],
};

```

----------------------------------------

TITLE: Installing ESLint via npm
DESCRIPTION: Command to install ESLint as a dev dependency using npm. ESLint is required to lint JavaScript projects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
npm i eslint --save-dev
```

----------------------------------------

TITLE: Testing React useMemo Cache Behavior with Module Variables
DESCRIPTION: A test component that demonstrates how useMemo caches values across renders when module-level variables change. This shows potential issues when module state changes between renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-dont-refresh-const-changes-prod.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
import {useEffect, useMemo, useState} from 'react';
import {ValidateMemoization} from 'shared-runtime';

let pretendConst = 0;

function unsafeResetConst() {
  pretendConst = 0;
}

function unsafeUpdateConst() {
  pretendConst += 1;
}

function Component() {
  useState(() => {
    // unsafe: reset the constant when first rendering the instance
    unsafeResetConst();
  });
  // UNSAFE! changing a module variable that is read by a component is normally
  // unsafe, but in this case we're simulating a fast refresh between each render
  unsafeUpdateConst();

  // In production mode (no @enableResetCacheOnSourceFileChanges) memo caches are not
  // reset unless the deps change
  const value = useMemo(() => [{pretendConst}], []);

  return <ValidateMemoization inputs={[]} output={value} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Creating a Custom Hook in JavaScript
DESCRIPTION: This snippet defines a custom hook "useHook" which initializes a function "x" that conditionally mutates an object based on input parameters. The mutation assumes no alterations if function "x" is not invoked during render. Dependencies include potential functions that may modify state and are called within the hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-conditional-capture-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function useHook(a, b) {
  let z = {a};
  let y = b;
  let x = function () {
    if (y) {
      // we don\'t know for sure this mutates, so we should assume
      // that there is no mutation so long as `x` isn\'t called
      // during render
      maybeMutate(z);
    }
  };
  return x;
}

```

----------------------------------------

TITLE: Defining React Component with onClick Handler
DESCRIPTION: This code defines a React component named `Component` with an `onClick` handler. The handler attempts to modify two global variables, `someUnknownGlobal` and `moduleLocal`. The component returns a div element with the `onClick` handler attached. This is expected to be used in an event handler or effect where modifying globals is allowed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-reassignment-to-global-function-jsx-prop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const onClick = () => {
    // Cannot assign to globals
    someUnknownGlobal = true;
    moduleLocal = true;
  };
  // It's possible that this could be an event handler / effect function,
  // but we don't know that and optimistically assume it will only be
  // called by an event handler or effect, where it is allowed to modify globals
  return <div onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This snippet defines a simple React component using JSX syntax. It takes `props` as input and returns a `div` element.  The `@compilationMode(infer)` directive suggests that the code should be compiled with type inference enabled.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
const Component = props => {
  return <div />;
};
```

----------------------------------------

TITLE: Initializing Component with Props - JavaScript
DESCRIPTION: This code snippet defines a function component in JavaScript that takes props as its input. The component utilizes an inner function to manipulate a local array and outputs the first element of this array. It is intended to serve as a demonstration of how props input can be used to affect a component's behavior in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [];
  const f = arg => {
    const y = x;
    y.push(arg);
  };
  f(props.input);

  return [x[0]];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {input: 42},
    {input: 42},
    {input: 'sathya'},
    {input: 'sathya'},
    {input: 42},
    {input: 'sathya'},
    {input: 42},
    {input: 'sathya'},
  ],
};
```

----------------------------------------

TITLE: Defining React Component Function with Closure
DESCRIPTION: This snippet defines a React component function 'f' that creates a closure to set a variable 'x' and returns a div element. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutated-non-reactive-to-reactive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function f(a) {
  let x;
  (() => {
    x = {a};
  })();
  return <div x={x} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Demonstrating JavaScript Variable Hoisting in Function
DESCRIPTION: Illustrates how variable declarations are hoisted, causing undefined behavior before actual initialization. Shows a function that returns NaN due to accessing an undefined variable before its assignment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoisting-simple-var-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function hoisting() {
  function addOne(b) {
    // a is undefined (only the declaration is hoisted, not the init) but shouldn't throw
    return a + b;
  }
  const result = addOne(2);
  var a = 1;

  return result; // OK: returns NaN. The code is semantically wrong but technically correct
}
```

----------------------------------------

TITLE: Using the Frontend API for React DevTools UI
DESCRIPTION: Example showing how to use the frontend API to render DevTools UI into a DOM element and start a socket server for communication between backend and frontend.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-core/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import DevtoolsUI from "react-devtools-core/standalone";

// See the full list of API methods in documentation below.
const { setContentDOMNode, startServer } = DevtoolsUI;

// Render DevTools UI into a DOM element.
setContentDOMNode(document.getElementById("container"));

// Start socket server used to communicate between backend and frontend.
startServer(
  // Port defaults to 8097
  1234,

  // Host defaults to "localhost"
  "example.devserver.com",

  // Optional config for secure socket (WSS).
  {
    key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
    cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')
  }
);
```

----------------------------------------

TITLE: Original React Component with Mutable State
DESCRIPTION: A simple React component that initializes a variable, modifies it through a closure, and returns it. This represents the code before React compiler transformation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-primitive-in-context.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 5;
  let foo = () => {
    x = {};
  };
  foo();
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining React Component with Closure in JavaScript
DESCRIPTION: This snippet defines a React component function that creates a closure to maintain access to a local variable. It also exports a FIXTURE_ENTRYPOINT object for testing or integration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-variable-in-nested-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a};
  let x = function () {
    (function () {
      console.log(z);
    })();
  };
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Input React Component Function with JSX
DESCRIPTION: A simple React component function that conditionally renders content based on input parameters. It creates arrays and renders JSX elements with conditional logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-shadowing-within-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let x = [];
  if (a) {
    let y = [];
    if (b) {
      y.push(c);
    }

    x.push(<div>{y}</div>);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component that processes array operations on props. It creates an array from props, pushes a value, and accesses an element using the at() method.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-property-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const a = [props.a, props.b, 'hello'];
  const x = a.push(42);
  const y = a.at(props.c);

  return {a, x, y};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1, b: 2, c: 0}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Enhanced React Component with State Management and Multiple Condition Checks - JavaScript
DESCRIPTION: This snippet expands upon the previous component by implementing conditional checks for caching previous state and avoiding unnecessary re-renders. It showcases an additional implementation detail with a more complex state management strategy and conditions to update state and render output only when necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-with-prefix.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @hookPattern:".*\b(use[^$]+)$"

import * as React from "react";
import { makeArray, useHook } from "shared-runtime";

const React$useState = React.useState;
const React$useMemo = React.useMemo;
const Internal$Reassigned$useHook = useHook;

function Component() {
  const $ = _c(8);
  const [state] = React$useState(0);
  const object = Internal$Reassigned$useHook();
  let t0;
  if ($[0] !== object) {
    t0 = JSON.stringify(object);
    $[0] = object;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const json = t0;
  let t1;
  let t2;
  if ($[2] !== state) {
    t1 = makeArray(state);
    const doubledArray = t1;

    t2 = doubledArray.join("");
    $[2] = state;
    $[3] = t2;
    $[4] = t1;
  } else {
    t2 = $[3];
    t1 = $[4];
  }
  let t3;
  if ($[5] !== json || $[6] !== t2) {
    t3 = (
      <div>
        {t2}
        {json}
      </div>
    );
    $[5] = json;
    $[6] = t2;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Initial React Component Function Implementation in JavaScript
DESCRIPTION: This snippet shows the initial implementation of a React component function. It demonstrates conditional assignment and mutation of variables.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-alias-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let x = 'foo';
  if (a) {
    x = 'bar';
  } else {
    x = 'baz';
  }
  let y = x;
  mutate(y);
  return y;
}
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: Defines a React component named 'Component' that accepts a 'name' prop. It uses `<SharedRuntime.Stringify>` to render a string including the name. The `FIXTURE_ENTRYPOINT` exports the component and a set of params used when evaluating the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-memberexpr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as SharedRuntime from 'shared-runtime';
function Component({name}) {
  return <SharedRuntime.Stringify>hello world {name}</SharedRuntime.Stringify>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'sathya'}],
};

```

----------------------------------------

TITLE: Refactored React Component with Const Declarations in JavaScript
DESCRIPTION: This snippet shows a refactored version of the component function. It uses const instead of let for variable declarations, improving code quality and following modern JavaScript best practices.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
function component(props) {
  const a = props.a || (props.b && props.c && props.d);
  const b = (props.a && props.b && props.c) || props.d;
  return a ? b : props.c;
}
```

----------------------------------------

TITLE: Implementing Original React Component in JavaScript
DESCRIPTION: This snippet defines a React component that processes an array, filtering out zero and dividing non-zero elements by 2. It also exports a fixture for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-continue.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const x = [0, 1, 2, 3];
  const ret = [];
  for (const item of x) {
    if (item === 0) {
      continue;
    }
    ret.push(item / 2);
  }
  return ret;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimizing Context Rendering in React JavaScript
DESCRIPTION: This snippet refines the context access pattern by incorporating memoization to optimize rendering. It uses an array from the useContext hook to determine when to update the component, reducing unnecessary renders. The App function compares current context values with previously stored values to decide if the component needs to re-render. Dependencies include a React component named Bar and an imported helper _c from the react/compiler-runtime package.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-array-destructuring.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @lowerContextAccess
function App() {
  const $ = _c(3);
  const [foo, bar] = useContext(MyContext);
  let t0;
  if ($[0] !== bar || $[1] !== foo) {
    t0 = <Bar foo={foo} bar={bar} />;
    $[0] = bar;
    $[1] = foo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

```

----------------------------------------

TITLE: Defining Counter Function in JavaScript
DESCRIPTION: The 'useFoo' function encapsulates a counter within a closure. It returns the current count and increments it upon each call. This pattern allows for maintaining state across invocations while providing an avenue for functional programming in JavaScript.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-handle-update-context-identifiers.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo() {
  let counter = 2;
  const fn = () => {
    return counter++;
  };

  return fn();
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: Implementing a conditional function with React test fixture (Final version)
DESCRIPTION: The revised implementation of the foo function that uses 'const' instead of 'let' for the y variable. This demonstrates proper variable declaration practices with immutable values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-phi-primitive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  let x;
  if (a) {
    x = 1;
  } else {
    x = 2;
  }

  const y = x;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [true, false],
  isComponent: false,
};
```

----------------------------------------

TITLE: Rendering HTML from a Server Component
DESCRIPTION: This JavaScript snippet demonstrates the usage of the experimental_renderToHTML function to render an EmailTemplate component to HTML, which is then sent as an email. The function must be awaited as it is asynchronous.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-markup/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { experimental_renderToHTML as renderToHTML } from 'react-markup';
import EmailTemplate from './my-email-template-component.js'

async function action(email, name) {
  "use server";
  // ... in your server, e.g. a Server Action...
  const htmlString = await renderToHTML(<EmailTemplate name={name} />);
  // ... send e-mail using some e-mail provider
  await sendEmail({ to: email, contentType: 'text/html', body: htmlString });
}
```

----------------------------------------

TITLE: Original React Component with FBT
DESCRIPTION: Source React component using FBT for internationalization. The component conditionally renders a div containing internationalized text with a parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-value-for-temporary-reactive-scope-with-early-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
import {identity, makeObject_Primitives} from 'shared-runtime';
import fbt from 'fbt';

function Component(props) {
  const object = makeObject_Primitives();
  const cond = makeObject_Primitives();
  if (!cond) {
    return null;
  }

  return (
    <div className="foo">
      {fbt(
        'Lorum ipsum' + fbt.param('thing', object.b) + ' blah blah blah',
        'More text'
      )}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Fragment Implementation
DESCRIPTION: Original implementation showing a React component using useFragment hook with optional chaining for toString conversion. Handles a special case where data has type BuiltInMixedReadonly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-logical-expression-instruction-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * This is a weird case as data has type `BuiltInMixedReadonly`.
 * The only scoped value we currently infer in this program is the
 * PropertyLoad `data?.toString`.
 */
import {useFragment} from 'shared-runtime';

function Foo() {
  const data = useFragment();
  return [data?.toString() || ''];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This snippet defines a React component `VideoTab` that uses `useRef` to create a ref. It then defines a function `x` that accesses the `current` property of the ref within a `console.log` statement. This function is then passed as the `videos` prop to a `VideoList` component. The `@validateRefAccessDuringRender false` comment indicates that ref access during render is disabled.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-field-not-added-to-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender false
function VideoTab() {
  const ref = useRef();
  let x = () => {
    console.log(ref.current.x);
  };

  return <VideoList videos={x} />;
}

```

----------------------------------------

TITLE: Defining Component Function - JavaScript
DESCRIPTION: This snippet defines a component function that returns another function targeting an object's method 'foo'. It initializes 'x' as a function that takes an argument 'a' which is expected to be an object with the method 'foo'. Only the outer function is exported as part of the FIXTURE_ENTRYPOINT object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-function-1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let x = function (a) {
    a.foo();
  };
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that creates an array from props and returns an object with array properties. Demonstrates array manipulation and object creation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-properties.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const a = [props.a, props.b, 'hello'];
  const x = a.length;
  const y = a.push;
  return {a, x, y, z: a.concat};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: [1, 2], b: 2}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Custom configuration with legacy config format
DESCRIPTION: Advanced setup using legacy config (.eslintrc) with manual configuration of individual rules for finer control.
SOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_6

LANGUAGE: javascript
CODE:
```
{
  "plugins": [
    // ...
    "react-hooks"
  ],
  "rules": {
    // ...
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

----------------------------------------

TITLE: Using Memoization for Caching Props in React (JavaScript)
DESCRIPTION: This code snippet defines a React functional component that utilizes the 'useMemoCache' hook to cache the incoming 'props.value'. If the cached value is undefined, it initializes the cache with the new value. The memoized result is returned, which helps optimize component rendering by preventing unnecessary re-computation of prop values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/skip-useMemoCache.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {c as useMemoCache} from 'react/compiler-runtime';

function Component(props) {
  const $ = useMemoCache();
  let x;
  if ($[0] === undefined) {
    x = [props.value];
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Defining Original React Component in JavaScript
DESCRIPTION: This snippet defines a simple React component that destructures a property from its input and returns an object. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-object-pattern.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(t) {
  let {a} = t;
  let y = {a};
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [{a: 42}],
};
```

----------------------------------------

TITLE: Input React Components with Forget Feature
DESCRIPTION: Original React component definitions using the 'forget' directive. Includes Bar, NoForget, and recursive Foo components with basic props handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/codegen-instrument-forget-gating-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableEmitInstrumentForget @compilationMode(annotation) @gating

function Bar(props) {
  'use forget';
  return <div>{props.bar}</div>;
}

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}

function Foo(props) {
  'use forget';
  if (props.bar < 0) {
    return props.children;
  }
  return (
    <Foo bar={props.bar - 1}>
      <NoForget />
    </Foo>
  );
}

global.DEV = true;
export const FIXTURE_ENTRYPOINT = {
  fn: eval('Foo'),
  params: [{bar: 2}],
};
```

----------------------------------------

TITLE: Building DevTools Dependencies from Source
DESCRIPTION: Command for building the dependencies required by React DevTools from source. This must be run from the root of the repository before starting local development of DevTools.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_8

LANGUAGE: shell
CODE:
```
yarn build-for-devtools
```

----------------------------------------

TITLE: Original React Component with FBT Implementation
DESCRIPTION: A React component that uses FBT for internationalization, demonstrating parameter interpolation with a text value. The component wraps text content in FBT tags and includes a parameter placeholder.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-whitespace-within-text.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

const _ = fbt;
function Component({value}: {value: string}) {
  return (
    <fbt desc="descdesc">
      Before text <fbt:param name="paramName">{value}</fbt:param> after text
      more text and more and more and more and more and more and more and more
      and more and blah blah blah blah
    </fbt>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'hello world'}],
};
```

----------------------------------------

TITLE: Defining MyApp Component - JavaScript
DESCRIPTION: This snippet defines a functional React component, MyApp, which returns an input element with a pattern attribute. It serves as a fixture to demonstrate a bug in Babel's generator when dealing with escape sequences within JSX attributes. The component is exported alongside its entry point metadata.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-preserve-escape-character.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * Fixture showing `@babel/generator` bug with jsx attribute strings containing
 * escape sequences. Note that this is only a problem when generating jsx
 * literals.
 *
 * When using the jsx transform to correctly lower jsx into
 * `React.createElement` calls, the escape sequences are preserved correctly
 * (see evaluator output).
 */
function MyApp() {
  return <input pattern="\w" />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [],
};

```

----------------------------------------

TITLE: Defining and Exporting useFoo Hook - React - JavaScript
DESCRIPTION: This snippet imports a shared runtime and defines a hook called useFoo. It returns a callback rendering a text element with a value of '4'. The hook is exported as part of a fixture entry point. Dependencies include 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-memberexpr-tag-in-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as SharedRuntime from 'shared-runtime';
function useFoo() {
  const MyLocal = SharedRuntime;
  const callback = () => {
    return <MyLocal.Text value={4} />;
  };
  return callback();
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Input React Component with Mutable State
DESCRIPTION: A React component that initializes an array, transforms it to an object via a function call, and returns it. This represents the source code before React compiler optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-object-in-context.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [];
  let foo = () => {
    x = {};
  };
  foo();
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Managing Relay Environment and Mutator in React Component
DESCRIPTION: This snippet demonstrates the implementation of a React component that uses a Relay environment, encapsulated within a Mutator class. Relay acts as a backend for the component, facilitating data management. The component setup ensures immutability, treating instances as read-only. Key features include setting up the environment, initializing the mutator, and a demonstration of ensuring immutability and state management within the component. There are no dependencies mentioned other than the custom hook, `useOtherHook`, which is assumed to be part of a larger framework or additional library.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inadvertent-mutability-readonly-class.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const env = useRelayEnvironment();
  // Note: this is a class has no mutable methods, ie it always treats `this` as readonly
  const mutator = new Mutator(env);

  useOtherHook();

  // `x` should be independently memoizeable, since foo(x, mutator) cannot mutate
  // the mutator.
  const x = {};
  foo(x, mutator);
  return x;
}

class Mutator {}

```

----------------------------------------

TITLE: Component Definition with Stringify
DESCRIPTION: This code defines a React component named `Component` that takes a `kind` prop and other props. It uses a switch statement based on the `kind` prop to determine which component to render. In the default case, it renders a `Stringify` component, passing along all other props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-with-only-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component({kind, ...props}) {
  switch (kind) {
    default:
      return <Stringify {...props} />;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{kind: 'foo', a: 1, b: true, c: 'sathya'}],
};

```

----------------------------------------

TITLE: React Component with useMemo
DESCRIPTION: This code defines a React component that utilizes `useMemo` for memoization. It takes `propA` and `propB` as props. Inside `useMemo`, it conditionally returns an object with a `value` property based on the presence of `propA?.a`. If `propA?.a` exists, it also calls `mutate(x)` on an empty object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-infer-less-specific-conditional-access.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {mutate} from 'shared-runtime';

function Component({propA, propB}) {
  return useMemo(() => {
    const x = {};
    if (propA?.a) {
      mutate(x);
      return {
        value: propB.x.y,
      };
    }
  }, [propA?.a, propB.x.y]);
}

```

----------------------------------------

TITLE: Original useMemo Hook Definition
DESCRIPTION: This code defines a custom hook `useFoo` that uses `useMemo` to memoize a value. The intention is to produce memo blocks with fewer dependencies than the source code initially suggests, demonstrating a potential optimization by the React compiler. It takes two parameters, 'a' and 'b', but only 'a' is used in the returned memoized value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-fewer-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';

// It's correct to produce memo blocks with fewer deps than source
function useFoo(a, b) {
  return useMemo(() => [a], [a, b]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [1, 2],
};

```

----------------------------------------

TITLE: Basic Async React Component in JavaScript
DESCRIPTION: Simple React component that loads user data asynchronously and renders the user's name. Demonstrates basic async/await pattern with data fetching.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/await.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
async function Component(props) {
  const user = await load(props.id);
  return <div>{user.name}</div>;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization Cache
DESCRIPTION: The compiled version of the React components with memoization cache implementation. Uses compiler runtime utilities to optimize rendering and maintain memoization state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-call-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { ValidateMemoization } from "shared-runtime";
import { use, useMemo } from "react";

const FooContext = React.createContext(null);
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Inner />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props.value) {
    t1 = <FooContext.Provider value={props.value}>{t0}</FooContext.Provider>;
    $[1] = props.value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Inner(props) {
  const $ = _c(7);
  const input = use(FooContext);
  let t0;
  let t1;
  if ($[0] !== input) {
    t1 = [input];
    $[0] = input;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const output = t0;
  let t2;
  if ($[2] !== input) {
    t2 = [input];
    $[2] = input;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== output || $[5] !== t2) {
    t3 = <ValidateMemoization inputs={t2} output={output} />;
    $[4] = output;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
  sequentialRenders: [
    { value: null },
    { value: 42 },
    { value: 42 },
    { value: null },
    { value: null },
    { value: 42 },
    { value: null },
    { value: 42 },
    { value: null },
  ],
};
```

----------------------------------------

TITLE: Memoization in React Component with Custom Compiler
DESCRIPTION: Implements a React component utilizing a custom compiler runtime to perform memoization. It maintains the state of memoized values across renders using an array-based cache, minimizing computational cost. This approach preserves memoization guarantees and optimizes rendering by checking dependencies before recalculating.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-single-with-unconditional.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import { ValidateMemoization } from "shared-runtime";
function Component(props) {
  const $ = _c(7);
  let t0;
  let x;
  if ($[0] !== props.items) {
    x = [];
    x.push(props?.items);
    x.push(props.items);
    $[0] = props.items;
    $[1] = x;
  } else {
    x = $[1];
  }
  t0 = x;
  const data = t0;
  let t1;
  if ($[2] !== props.items) {
    t1 = [props.items];
    $[2] = props.items;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== data || $[5] !== t1) {
    t2 = <ValidateMemoization inputs={t1} output={data} />;
    $[4] = data;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}

```

----------------------------------------

TITLE: Original JavaScript Function with Conditional Logic
DESCRIPTION: A JavaScript function that declares variables, performs a conditional check, and returns an object. This represents the input code before React compiler optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-objectexpression-phi.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  let y = 2;

  if (x > 1) {
    x = 2;
  } else {
    y = 3;
  }

  let t = {x: x, y: y};
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Utilizing Compiler Runtime for Array Mutations in JavaScript
DESCRIPTION: This snippet uses the react/compiler-runtime library to illustrate a similar mutation process as in the first snippet, demonstrating the usage of _c for memoization. The function Foo is used to handle input arguments and manage array mutations, showcasing condition-based checks to decide when mutations should occur.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-concat-should-capture.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

/**
 * Fixture showing why `concat` needs to capture both the callee and rest args.
 * Here, observe that arr1's values are captured into arr2.
 *  - Later mutations of arr2 may write to values within arr1.
 *  - Observe that it's technically valid to separately memoize the array arr1
 *    itself.
 */
function Foo(t0) {
  const $ = _c(2);
  const { inputNum } = t0;
  let arr2;
  if ($[0] !== inputNum) {
    const arr1 = [{ a: 1 }, {}];
    arr2 = arr1.concat([1, inputNum]);
    mutate(arr2[0]);
    $[0] = inputNum;
    $[1] = arr2;
  } else {
    arr2 = $[1];
  }
  return arr2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ inputNum: 2 }],
  sequentialRenders: [{ inputNum: 2 }, { inputNum: 3 }],
};
```

----------------------------------------

TITLE: React Component with FBT Internationalization - Source
DESCRIPTION: Original source code for a React component that uses FBT for internationalization. Handles pluralization of vote counts and parameter interpolation for voting options.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-trailing-whitespace.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';
import {identity} from 'shared-runtime';

function Component(props) {
  return (
    <span>
      <fbt desc="Title">
        <fbt:plural count={identity(props.count)} name="count" showCount="yes">
          vote
        </fbt:plural>{' '}
        for <fbt:param name="option">{props.option} </fbt:param>
      </fbt>
      !
    </span>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{count: 42, option: 'thing'}],
  sequentialRenders: [
    {count: 42, option: 'thing'},
    {count: 42, option: 'thing'},
    {count: 1, option: 'other'},
    {count: 1, option: 'other'},
    {count: 42, option: 'thing'},
    {count: 1, option: 'other'},
    {count: 42, option: 'thing'},
    {count: 1, option: 'other'},
  ],
};
```

----------------------------------------

TITLE: Using Hooks within a React Component in JavaScript
DESCRIPTION: Demonstrates the implementation of a React component with an incorrect usage of hooks, where a hook is invoked based on a condition inside the component, leading to a runtime error. The correct pattern requires hooks to be called unconditionally to maintain consistent ordering across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-condtionally-call-hooklike-property-of-local.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives} from 'shared-runtime';

function Component(props) {
  const local = makeObject_Primitives();
  if (props.cond) {
    const foo = local.useFoo;
    foo();
  }
}

```

----------------------------------------

TITLE: Defining Component and Exporting Fixture in React - JavaScript
DESCRIPTION: This snippet defines a simple React functional component that takes props and returns an object containing two properties. It sets up an export named FIXTURE_ENTRYPOINT that includes the component function and associated parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-objectexpression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const a = 1;
  const b = 2;
  const x = {a: a, b: b};
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Optimizing Component Rendering in React with Memoization
DESCRIPTION: This code snippet depicts an optimized implementation of a React component using memoization techniques to enhance rendering efficiency. It utilizes internal caching through an array '$' to track and minimize re-computation when component props change. This pattern is a common React optimization strategy for components handling dynamic input values. The snippet depends on the 'react/compiler-runtime', indicating an integration for additional React compiler optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-access-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0) {
  const $ = _c(6);
  const { a, b, c } = t0;
  let t1;
  if ($[0] !== a || $[1] !== b || $[2] !== c) {
    const x = [a];
    let t2;
    if ($[4] !== b) {
      t2 = [null, b];
      $[4] = b;
      $[5] = t2;
    } else {
      t2 = $[5];
    }
    const y = t2;
    const z = [[], [], [c]];
    x[0] = y[1];
    z[0][0] = x[0];
    t1 = [x, z];
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1, b: 20, c: 300 }],
  sequentialRenders: [
    { a: 2, b: 20, c: 300 },
    { a: 3, b: 20, c: 300 },
    { a: 3, b: 21, c: 300 },
    { a: 3, b: 22, c: 300 },
    { a: 3, b: 22, c: 301 },
  ],
};

```

----------------------------------------

TITLE: Server-Side Rendering Stream Methods
DESCRIPTION: New streaming methods for server-side rendering in React 16.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_22

LANGUAGE: javascript
CODE:
```
ReactDOMServer.renderToNodeStream()
ReactDOMServer.renderToStaticNodeStream()
```

----------------------------------------

TITLE: React Component with Context Input Test
DESCRIPTION: Defines React components that test context access patterns and memoization. Component renders a Provider with an Inner component that conditionally uses context value and validates memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-conditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {ValidateMemoization} from 'shared-runtime';
import {use, useMemo} from 'react';

const FooContext = React.createContext(null);
function Component(props) {
  return (
    <FooContext.Provider value={props.value}>
      <Inner cond={props.cond} />
    </FooContext.Provider>
  );
}

function Inner(props) {
  let input = null;
  if (props.cond) {
    input = use(FooContext);
  }
  const output = useMemo(() => [input], [input]);
  return <ValidateMemoization inputs={[input]} output={output} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, value: 42}],
  sequentialRenders: [
    // change cond true->false
    {cond: true, value: 42},
    {cond: false, value: 42},

    // change value
    {cond: false, value: null},
    {cond: false, value: 42},

    // change cond false->true
    {cond: true, value: 42},

    // change cond true->false, change unobserved value, change cond false->true
    {cond: false, value: 42},
    {cond: false, value: null},
    {cond: true, value: 42},
  ],
};
```

----------------------------------------

TITLE: React Component with useMemo and Validation
DESCRIPTION: This snippet defines a React component that uses `useMemo` to memoize a derived value based on an optional property (`arg?.items`). It then uses `ValidateMemoization` from `shared-runtime` to ensure the memoization is working as expected.  The component takes an argument `arg` that may or may not have an `items` property. The memoized value `data` is an array containing the value of `arg?.items`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-single.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR
import {ValidateMemoization} from 'shared-runtime';
import {useMemo} from 'react';
function Component({arg}) {
  const data = useMemo(() => {
    const x = [];
    x.push(arg?.items);
    return x;
  }, [arg?.items]);
  return <ValidateMemoization inputs={[arg?.items]} output={data} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arg: {items: 2}}],
  sequentialRenders: [
    {arg: {items: 2}},
    {arg: {items: 2}},
    {arg: null},
    {arg: null},
  ],
};

```

----------------------------------------

TITLE: Defining Component with Conditional Dependencies (Input)
DESCRIPTION: This code defines a React component `useOnlyConditionalDependencies` that conditionally reads properties from the `props.a` object based on the `cond` prop. The component returns a new object `x` containing the conditionally read properties. It imports the `identity` function from `shared-runtime` and uses it as part of the conditional logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/no-uncond.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
"// When an object's properties are only read conditionally, we should\n\nimport {identity} from 'shared-runtime';\n\n// track the base object as a dependency.\nfunction useOnlyConditionalDependencies({props, cond}) {\n  const x = {};\n  if (identity(cond)) {\n    x.b = props.a.b;\n    x.c = props.a.b.c;\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useOnlyConditionalDependencies,\n  params: [{props: {a: {b: 2}}, cond: true}],\n  sequentialRenders: [\n    {props: {a: {b: 2}}, cond: true},\n    {props: null, cond: false},\n    // check we preserve nullthrows\n    {props: {a: {b: {c: undefined}}}, cond: true},\n    {props: {a: {b: undefined}}, cond: true},\n    {props: {a: {b: {c: undefined}}}, cond: true},\n    {props: undefined, cond: true},\n  ],\n};\n"
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This JavaScript code represents the optimized version of the React component using React's compiler runtime. It uses the `_c` function to memoize the conditional prop value and the resulting component instance, preventing unnecessary re-renders when the conditional value hasn't changed. The `_c` function manages a cache (`$`) to store and reuse values, improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-spread.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(5);

  const t0 = props.cond ? props.foo : props.bar;
  let t1;
  if ($[0] !== t0) {
    t1 = { bar: t0 };
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== props || $[3] !== t1) {
    t2 = <Component {...props} {...t1} />;
    $[2] = props;
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

```

----------------------------------------

TITLE: Input Fixture: React Component with Conditional Rendering
DESCRIPTION: A basic React component demonstrating a simple implementation with an early return condition and fallback logic using makeArray
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-no-declarations-reassignments-dependencies.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

let ENABLE_FEATURE = false;

function Component(props) {
  let x = [];
  if (ENABLE_FEATURE) {
    x.push(42);
    return x;
  } else {
    console.log('fallthrough');
  }
  return makeArray(props.a);
}
```

----------------------------------------

TITLE: Setting up React DOM Fixtures
DESCRIPTION: Commands to set up and run DOM fixtures for testing React in different browser environments. First builds React, then navigates to the fixtures directory, installs dependencies, and runs the development script.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/dom/README.md#2025-04-21_snippet_0

LANGUAGE: bash
CODE:
```
cd fixtures/dom
yarn
yarn dev
```

----------------------------------------

TITLE: Implementing a Custom React Hook with Conditional Object Property Access
DESCRIPTION: A React hook that conditionally accesses an object property based on a nullability flag. It uses labeled blocks to control flow and avoids accessing properties when the object is null.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-in-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({obj, objIsNull}) {
  const x = [];
  b0: {
    if (objIsNull) {
      break b0;
    }
    x.push(obj.a);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{obj: null, objIsNull: true}],
  sequentialRenders: [
    {obj: null, objIsNull: true},
    {obj: {a: 2}, objIsNull: false},
    // check we preserve nullthrows
    {obj: {a: undefined}, objIsNull: false},
    {obj: undefined, objIsNull: false},
    {obj: {a: undefined}, objIsNull: false},
  ],
};
```

----------------------------------------

TITLE: React Compiler Output with Memoization
DESCRIPTION: This code shows the compiled version of the React component. It utilizes `react/compiler-runtime` to optimize rendering by memoizing intermediate results. The compiler-generated code uses an array `$` to store and reuse previously computed values, reducing unnecessary re-renders if the inputs haven't changed. The `_c` function from `react/compiler-runtime` is crucial for this memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-jsx-stored-in-id.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableJsxOutlining
function Component(t0) {
  const $ = _c(7);
  const { arr } = t0;
  const x = useX();
  let t1;
  if ($[0] !== arr || $[1] !== x) {
    let t2;
    if ($[3] !== x) {
      t2 = (i, id) => {
        const T0 = _temp;
        const jsx = <T0 i={i} key={id} x={x} />;
        return jsx;
      };
      $[3] = x;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    t1 = arr.map(t2);
    $[0] = arr;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = <>{t1}</>;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
function _temp(t0) {
  const $ = _c(5);
  const { i: i, x: x } = t0;
  let t1;
  if ($[0] !== i) {
    t1 = <Baz i={i} />;
    $[0] = i;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== t1 || $[3] !== x) {
    t2 = <Bar x={x}>{t1}</Bar>;
    $[2] = t1;
    $[3] = x;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

function Bar(t0) {
  const $ = _c(3);
  const { x, children } = t0;
  let t1;
  if ($[0] !== children || $[1] !== x) {
    t1 = (
      <>
        {x}
        {children}
      </>
    );
    $[0] = children;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Baz(t0) {
  const { i } = t0;
  return i;
}

function useX() {
  return "x";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arr: ["foo", "bar"] }],
};

```

----------------------------------------

TITLE: React Component with Compiler Runtime
DESCRIPTION: This code represents a compiled version of the previous React component, utilizing the `react/compiler-runtime`. It initializes a reactive scope using `_c(1)` and stores it in `$`. The component performs similar operations as before but leverages the reactive scope to manage the variables. It then uses the reactive scope to memoize the result of the computation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-do-while.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);

  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(false);

  const c = [a];

  let x = 0;
  do {
    x = x + 1;
  } while (c[0][0]);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};

```

----------------------------------------

TITLE: Compiled React Component with Optimizations
DESCRIPTION: Compiled version of the component with added memoization and optimization. Uses compiler-runtime utilities to cache computed values and conditional renders for better performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-separate-scopes-for-divs.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

const DISPLAY = true;
function Component(t0) {
  const $ = _c(9);
  const { cond: t1, id } = t0;
  const cond = t1 === undefined ? false : t1;
  let t2;
  if ($[0] !== id) {
    t2 = identity(styles.a, id !== null ? styles.b : {});
    $[0] = id;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] !== t2) {
    t3 = <div className={t2} />;
    $[2] = t2;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== cond) {
    t4 = cond === false && (
      <div className={identity(styles.c, DISPLAY ? styles.d : {})} />
    );
    $[4] = cond;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  let t5;
  if ($[6] !== t3 || $[7] !== t4) {
    t5 = (
      <>
        {t3}
        {t4}
      </>
    );
    $[6] = t3;
    $[7] = t4;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  return t5;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: false, id: 42 }],
  sequentialRenders: [
    { cond: false, id: 4 },
    { cond: true, id: 4 },
    { cond: true, id: 42 },
  ],
};

const styles = {
  a: "a",
  b: "b",
  c: "c",
  d: "d",
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component with added memoization logic, dependency tracking, and early return handling. Includes runtime optimizations and caching mechanisms.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/partial-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(6);
  let t0;
  let y;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const x = [];
      if (props.cond) {
        x.push(props.a);
        t0 = x;
        break bb0;
      } else {
        let t1;
        if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
          t1 = foo();
          $[5] = t1;
        } else {
          t1 = $[5];
        }
        y = t1;
        if (props.b) {
          t0 = undefined;
          break bb0;
        }
      }
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.cond;
    $[3] = t0;
    $[4] = y;
  } else {
    t0 = $[3];
    y = $[4];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, a: 42 }],
};
```

----------------------------------------

TITLE: Compiled useMakeCallback Hook with React Compiler Optimizations
DESCRIPTION: The React compiler-transformed version of the hook with memoization. It uses a closure array (_c(5)) to cache values between renders, only recreating the callback and return array when dependencies change, improving performance by avoiding unnecessary recreations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/direct-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState } from "react";
import { useIdentity } from "shared-runtime";

function useMakeCallback(t0) {
  const $ = _c(5);
  const { obj } = t0;
  const [state, setState] = useState(0);
  let t1;
  if ($[0] !== obj.value || $[1] !== state) {
    t1 = () => {
      if (obj.value !== state) {
        setState(obj.value);
      }
    };
    $[0] = obj.value;
    $[1] = state;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const cb = t1;

  useIdentity();
  cb();
  let t2;
  if ($[3] !== cb) {
    t2 = [cb];
    $[3] = cb;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{ obj: { value: 1 } }],
  sequentialRenders: [{ obj: { value: 1 } }, { obj: { value: 2 } }],
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization
DESCRIPTION: Compiled version of the useFoo hook with added memoization from the React compiler. Uses an array of cached values to prevent unnecessary recalculations when inputs haven't changed, optimizing performance across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/jsx-and-passed.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(8);
  const { arr1 } = t0;
  let t1;
  if ($[0] !== arr1[0]) {
    t1 = (e) => arr1[0].value + e.value;
    $[0] = arr1[0];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const cb1 = t1;
  let t2;
  if ($[2] !== arr1 || $[3] !== cb1) {
    t2 = arr1.map(cb1);
    $[2] = arr1;
    $[3] = cb1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const x = t2;
  let t3;
  if ($[5] !== cb1 || $[6] !== x) {
    t3 = [x, cb1];
    $[5] = cb1;
    $[6] = x;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useFoo),
  params: [{ arr1: [], arr2: [] }],
  sequentialRenders: [
    { arr1: [], arr2: [] },
    { arr1: [], arr2: null },
    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The React compiler's output for the component, including memoization logic with a cache array. Despite compiling the code, the compiler still detects and logs the error regarding JSX in a catch block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-catch-in-outer-try-with-catch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger @validateNoJSXInTryStatements
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let el;
  try {
    let value;
    try {
      let t0;
      if ($[0] !== props.foo) {
        t0 = identity(props.foo);
        $[0] = props.foo;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      value = t0;
    } catch {
      let t0;
      if ($[2] !== value) {
        t0 = <div value={value} />;
        $[2] = value;
        $[3] = t0;
      } else {
        t0 = $[3];
      }
      el = t0;
    }
  } catch {
    return null;
  }
  return el;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component with React compiler-runtime features added. It implements memoization to cache the dynamically created component and rendered output, using an array to store previous values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-method-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger @validateStaticComponents
function Example(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.foo) {
    t0 = props.foo.bar();
    $[0] = props.foo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const Component = t0;
  let t1;
  if ($[2] !== Component) {
    t1 = <Component />;
    $[2] = Component;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
```

----------------------------------------

TITLE: Compiled React Component with compiler-runtime
DESCRIPTION: This is the compiled version of the React component using `react/compiler-runtime`. It optimizes the component by using a mutable object to store intermediate values and track prop changes for memoization. The compiled code uses `_c` from `react/compiler-runtime` and labels for branching.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-multiple-if-else.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";

function Component(props) {
  const $ = _c(6);
  let t0;
  bb0: {
    let y;
    if (
      $[0] !== props.a ||
      $[1] !== props.b ||
      $[2] !== props.cond ||
      $[3] !== props.cond2
    ) {
      y = [];
      if (props.cond) {
        y.push(props.a);
      }
      if (props.cond2) {
        t0 = y;
        break bb0;
      }

      y.push(props.b);
      $[0] = props.a;
      $[1] = props.b;
      $[2] = props.cond;
      $[3] = props.cond2;
      $[4] = y;
      $[5] = t0;
    } else {
      y = $[4];
      t0 = $[5];
    }
    t0 = y;
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1, b: 2, cond2: false }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Optimizations
DESCRIPTION: Compiled version of the React component showing the internal memoization implementation using Symbol.for('react.memo_cache_sentinel') for cache detection and optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-value-preserve-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees
import { useCallback, useRef } from "react";

function Component(props) {
  const $ = _c(2);
  const ref = useRef(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (event) => {
      ref.current = event.target.value;
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onChange = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <input onChange={onChange} />;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Initial implementation of a React component with forget directive and feature flag setup. Includes a Bar component and feature flag check function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/conflicting-gating-fn.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating

export const isForgetEnabled_Fixtures = () => {
  'use no forget';
  return false;
};

export function Bar(props) {
  'use forget';
  return <div>{props.bar}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval('Bar'),
  params: [{bar: 2}],
};
```

----------------------------------------

TITLE: Defining MyApp Component with Memoization - JavaScript
DESCRIPTION: This snippet defines a variant of the MyApp component that leverages the React memoization feature. It checks against a cache sentinel to determine whether to return a new input element or the cached version, ensuring efficient rendering. The component is returned with an input element containing an updated pattern attribute syntax.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-preserve-escape-character.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * Fixture showing `@babel/generator` bug with jsx attribute strings containing
 * escape sequences. Note that this is only a problem when generating jsx
 * literals.
 *
 * When using the jsx transform to correctly lower jsx into
 * `React.createElement` calls, the escape sequences are preserved correctly
 * (see evaluator output).
 */
function MyApp() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <input pattern={"\\w"} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [],
};

```

----------------------------------------

TITLE: Defining ComponentA with Greeting Message in JavaScript
DESCRIPTION: The function 'componentA' takes 'props' as an argument and constructs a greeting message using template literals. It appends an empty string to demonstrate string operations. The function returns the constructed message string. No external dependencies are required, and it expects 'props' to have 'a' and 'b' properties, which are used in the message.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/template-literal.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function componentA(props) {
  let t = `hello ${props.a}, ${props.b}!`;
  t += ``;
  return t;
}

```

LANGUAGE: javascript
CODE:
```
function componentA(props) {
  let t = `hello ${props.a}, ${props.b}!`;
  t = t + ``;
  return t;
}

```

----------------------------------------

TITLE: React Component Implementation without Type Annotations in JavaScript
DESCRIPTION: This snippet shows the implementation of the React component without Flow type annotations. It imports the 'identity' function, defines the Component function, and exports the FIXTURE_ENTRYPOINT for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-number_.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { identity } from "shared-runtime";

function Component(props) {
  const x = identity(props.id);
  const y = (x: number);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 42 }],
};
```

----------------------------------------

TITLE: Managing Array Values with React and JavaScript
DESCRIPTION: This snippet demonstrates the use of array operations, including adding elements to an array and mutating it using external methods imported from a shared runtime utility. It manages mutability in React's render context by pushing values into an array and mutating its state. Essential parameters include the input object with value property. The outcome is a modified array after attempting catches of potential errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-try.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import {arrayPush, mutate} from 'shared-runtime';

function useFoo({value}) {
  let items = null;
  try {
    // Mutable range of `items` begins here, but its reactive scope block
    // should be aligned to above the try-block
    items = [];
    arrayPush(items, value);
  } catch {
    // ignore
  }
  mutate(items);
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{value: 2}],
  sequentialRenders: [{value: 2}, {value: 2}, {value: 3}],
};

```

----------------------------------------

TITLE: Defining Component and Exporting Fixture Entrypoint in JavaScript
DESCRIPTION: This snippet demonstrates the creation of a JavaScript function `component` that returns a closure logging its internal state `z`. The returned function encapsulates the state and logs it when invoked. It is exported with the entry point `FIXTURE_ENTRYPOINT`, which specifies execution parameters. The component is defined with logging behavior to visualize its state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-arrow-function-1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a};
  let x = () => {
    console.log(z);
  };
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Defining Reactive Components in React - JavaScript
DESCRIPTION: This JavaScript snippet defines a component that conditionally mutates reactive values. The component function applies conditional logic on props to control the reactivity of variables x and y, ultimately rendering a reactive output. No additional dependencies are required aside from React itself. Expected input is a props object, and the output is an array containing a boolean value. The snippet controls reactivity based on the component's sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-via-mutation-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // x is mutated conditionally based on a reactive value,
  // so it needs to be considered reactive
  let x = [];
  if (props.cond) {
    x.push(1);
  }
  // Since x is reactive, y is now reactively controlled too:
  let y = false;
  if (x[0]) {
    y = true;
  }
  // Thus this value should be reactive on `y`:
  return [y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {cond: true},
    {cond: true},
    {cond: false},
    {cond: false},
    {cond: true},
    {cond: false},
    {cond: true},
    {cond: false},
  ],
};

```

----------------------------------------

TITLE: Original React Component Definition
DESCRIPTION: This code snippet defines a React component function named `component` that takes two parameters, `a` and `b`. It initializes local variables `y` and `z` with the provided parameters and defines an inner function `x` that modifies the value of `z.a`. The function then calls `x` and returns `z`. The `FIXTURE_ENTRYPOINT` object configures the component for testing or execution with predefined parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  let y = {b};
  let z = {a};
  let x = function () {
    z.a = 2;
    y.b;
  };
  x();
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [{a: 'val1', b: 'val2'}],
  isComponent: false,
};

```

----------------------------------------

TITLE: Original React Function Implementation
DESCRIPTION: The original function creates arrays conditionally based on input parameters. It demonstrates a typical React pattern that would benefit from memoization to avoid recreating arrays on each render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-within-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let x = [];
  if (a) {
    let y = [];
    if (b) {
      y.push(c);
    }

    x.push(y);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining a React Hook with Conditional Dependencies in Switch Statement
DESCRIPTION: A React Hook that conditionally accesses props.a.b inside a switch statement, demonstrating how properties not accessed in every path are handled as conditional dependencies by the React compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-missing-case.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// props.a.b should NOT be added as a unconditional dependency to the reactive
// scope that produces x if it is not accessed in every path

import {identity} from 'shared-runtime';

function useCondDepInSwitchMissingCase(props, other) {
  const x = {};
  switch (identity(other)) {
    case 1:
      x.a = props.a.b;
      break;
    case 2:
      x.b = 42;
      break;
    default:
      x.c = props.a.b;
      break;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInSwitchMissingCase,
  params: [{a: {b: 2}}, 2],
};
```

----------------------------------------

TITLE: Implementing React Component with Data Processing
DESCRIPTION: This snippet defines a React component that processes an array of data objects, summing the 'current' values and calling an identity function on 'other' values. It also includes a test fixture for the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dce-circular-reference.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component({data}) {
  let x = 0;
  for (const item of data) {
    const {current, other} = item;
    x += current;
    identity(other);
  }
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      data: [
        {current: 2, other: 3},
        {current: 4, other: 5},
      ],
    },
  ],
};
```

----------------------------------------

TITLE: Defining Component Function - React JavaScript
DESCRIPTION: This JavaScript snippet defines a React component function that initializes an item with memoization. The function uses a component-level prop 'a' to create an item, which is then mapped over; minimizing unnecessary re-renders. The 'FIXTURE_ENTRYPOINT' serves as an interface for testing purposes and requires an object parameter with a nested 'id' attribute.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-captures-receiver-noAlias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // This item is part of the receiver, should be memoized
  const item = {a: props.a};
  const items = [item];
  const mapped = items.map(item => item);
  return mapped;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: {id: 42}}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that destructures and processes props, demonstrating a simple state transformation using an identity function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-object-assignment-to-context-var.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(props) {
  let x;
  ({x} = props);
  const foo = () => {
    x = identity(props.x);
  };
  foo();
  return {x};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: 42}],
};
```

----------------------------------------

TITLE: Defining Function and Fixture Entry Point in JavaScript
DESCRIPTION: The snippet defines a function 'bar' that manipulates elements of arrays using closures and returns a specific element. It also exports an object 'FIXTURE_ENTRYPOINT' that includes the function and its parameters for testing. The function 'bar' requires no additional dependencies and is invoked with tuples where each tuple contains two numbers.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function bar(a, b) {
  let x = [a, b];
  let y = {};
  let t = {};
  (function () {
    y = x[0][1];
    t = x[1][0];
  })();

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [
    [1, 2],
    [2, 3],
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with useMemo and useEffect
DESCRIPTION: This code snippet presents a compiled version of the `useFoo` component, potentially optimized by the `react/compiler-runtime`.  It utilizes the `_c` function (likely a compiler runtime utility) to manage memoization and caching. The compiled code aims to achieve the same behavior as the original, where a function calling `someGlobal` is memoized and then called within `useEffect`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-namespace-pruned.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as React from "react";

function someGlobal() {}
function useFoo() {
  const $ = _c(2);
  let t0;
  t0 = _temp;
  const fn = t0;
  let t1;
  let t2;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      fn();
    };
    t2 = [fn];
    $[0] = t1;
    $[1] = t2;
  } else {
    t1 = $[0];
    t2 = $[1];
  }
  React.useEffect(t1, t2);
  return null;
}
function _temp() {
  someGlobal();
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Compiled React Counter Component
DESCRIPTION: This snippet shows the compiled version of the React counter component. It includes optimizations and caching mechanisms for improved performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expr-directive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  "use strict";
  const $ = _c(3);

  const [count, setCount] = React.useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = function update() {
      "worklet";

      setCount(_temp);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const update = t0;
  let t1;
  if ($[1] !== count) {
    t1 = <button onClick={update}>{count}</button>;
    $[1] = count;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
function _temp(count_0) {
  return count_0 + 1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Initializing Component with Compiler Runtime - JavaScript
DESCRIPTION: This snippet shows an advanced initialization of a React component leveraging the React compiler runtime. It introduces a caching strategy using an array and conditionally updates component state based on input. The component maintains its rendered output across multiple sequential renderings, demonstrating optimizations in state persistence.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.input) {
    const x = [];
    const f = (arg) => {
      const y = x;
      y.push(arg);
    };

    f(props.input);

    t0 = [x[0]];
    $[0] = props.input;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { input: 42 },
    { input: 42 },
    { input: "sathya" },
    { input: "sathya" },
    { input: 42 },
    { input: "sathya" },
    { input: 42 },
    { input: "sathya" },
  ],
};
```

----------------------------------------

TITLE: Analyzing JavaScript Hook Usage in React
DESCRIPTION: This code snippet demonstrates the improper usage of the useState hook within an anonymous class in JavaScript. It highlights a scenario where the snippet passes certain tests even though it theoretically should not. The snippet does not provide any specific input or output as it serves more as a structural example.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-2c51251df67a.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

(class {
  useHook() {
    useState();
  }
});
```

----------------------------------------

TITLE: Input React Function Component Definition
DESCRIPTION: Original React component code showing nested function declarations with default parameters and closures. The code creates a function that returns nested functions with default parameter values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/deeply-nested-function-expressions-with-params.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {
  return (function t() {
    let x = {};
    let y = {};
    return function a(x = () => {}) {
      return (function b(y = []) {
        return [x, y];
      })();
    };
  })();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Component with Relay Environment and Mutator
DESCRIPTION: This snippet presents a React component that integrates a Relay environment using a Mutator class. This setup promotes immutability, preventing direct alterations to `this`, and allows for the component's state and dependencies to be managed effectively. The Mutator class facilitates read-only operations, contributing to a stable component state. Supporting functions like `useOtherHook` and `foo` are essential for functionality but are assumed to be defined externally.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inadvertent-mutability-readonly-class.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const env = useRelayEnvironment();

  const mutator = new Mutator(env);

  useOtherHook();

  const x = {};
  foo(x, mutator);
  return x;
}

class Mutator {}

```

----------------------------------------

TITLE: Original React Function with Conditional Rendering
DESCRIPTION: A React function that conditionally manipulates arrays based on input parameters and renders JSX elements. It includes conditional logic, array operations, and JSX rendering with a switch statement for different cases.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment-separate-scopes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let x = [];
  if (a) {
    x.push(a);
  }
  let y = <div>{x}</div>;

  switch (b) {
    case 0: {
      x = [];
      x.push(b);
      break;
    }
    default: {
      x = [];
      x.push(c);
    }
  }
  return (
    <div>
      {y}
      {x}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Original React Component with inferEffectDependencies Directive
DESCRIPTION: A simple React component that creates an array containing a prop value and passes it to useEffect. The @inferEffectDependencies directive tells the React compiler to automatically determine and apply the correct dependencies for the effect.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect} from 'react';
import {print} from 'shared-runtime';

function ReactiveVariable({propVal}) {
  const arr = [propVal];
  useEffect(() => print(arr));
}
```

----------------------------------------

TITLE: Defining Component Logic and JSX Rendering with React - JavaScript
DESCRIPTION: This snippet defines a functional React component that uses a state management approach to handle the rendering of either a primary or an alternate component based on the props received. It employs an inner MaybeMutable class to manage potential state changes. The JSX return statement reflects nested components with dynamic tags, influenced by the component's props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-tag-evaluation-order-non-global.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {StaticText1, StaticText2} from 'shared-runtime';

function MaybeMutable() {
  return {};
}
function maybeMutate(x) {}

function Component(props) {
  const maybeMutable = new MaybeMutable();
  let Tag = props.component;
  // NOTE: the order of evaluation in the lowering is incorrect:
  // the jsx element's tag observes `Tag` after reassignment, but should observe
  // it before the reassignment.

  // Currently, Forget preserves jsx whitespace in the source text.
  // prettier-ignore
  return (
    <Tag>{((Tag = props.alternateComponent), maybeMutate(maybeMutable))}<Tag /></Tag>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{component: StaticText1, alternateComponent: StaticText2}],
  isComponent: true,
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { StaticText1, StaticText2 } from "shared-runtime";

function MaybeMutable() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function maybeMutate(x) {}

function Component(props) {
  const $ = _c(11);
  let T0;
  let Tag;
  let t0;
  if ($[0] !== props.alternateComponent || $[1] !== props.component) {
    const maybeMutable = new MaybeMutable();
    Tag = props.component;

    T0 = Tag;
    t0 = ((Tag = props.alternateComponent), maybeMutate(maybeMutable));
    $[0] = props.alternateComponent;
    $[1] = props.component;
    $[2] = T0;
    $[3] = Tag;
    $[4] = t0;
  } else {
    T0 = $[2];
    Tag = $[3];
    t0 = $[4];
  }
  let t1;
  if ($[5] !== Tag) {
    t1 = <Tag />;
    $[5] = Tag;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  let t2;
  if ($[7] !== T0 || $[8] !== t0 || $[9] !== t1) {
    t2 = (
      <T0>
        {t0}
        {t1}
      </T0>
    );
    $[7] = T0;
    $[8] = t0;
    $[9] = t1;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ component: StaticText1, alternateComponent: StaticText2 }],
  isComponent: true,
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Initial implementation of a React component that creates a mutable object and array, demonstrating object capture and mutation patterns. Uses helper functions makeObject_Primitives and mutate.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-capture-in-method-receiver-and-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives, mutate} from 'shared-runtime';

function Component() {
  // a's mutable range should be the same as x's mutable range,
  // since a is captured into x (which gets mutated later)
  let a = makeObject_Primitives();

  let x = [];
  x.push(a);

  mutate(x);
  return [x, a];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized Component with State Management in JavaScript React
DESCRIPTION: This snippet features a more complex version of the React component which utilizes the 'react/compiler-runtime' to manage its state and optimize performance by checking prop changes before instantiating Foo. It ensures that the Foo object is only created if the props have changed, employing memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/new-spread.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.bar || $[1] !== props.foo) {
    t0 = new Foo(...props.foo, null, ...[props.bar]);
    $[0] = props.bar;
    $[1] = props.foo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const x = t0;
  return x;
}
```

----------------------------------------

TITLE: Efficient Dependency Management in React Component - JavaScript
DESCRIPTION: The code refines a React component by applying optimizations like caching dependencies and utilizing the 'useFire' hook. It demonstrates dependency tracking to prevent unnecessary re-renders. Dependencies such as 'props.bar' are monitored, and effects are fired accordingly, offering a more efficient lifecycle management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/fire-and-autodeps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c, useFire } from "react/compiler-runtime"; // @enableFire @inferEffectDependencies
import { fire, useEffect } from "react";

function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.bar) {
    t0 = (arg) => {
      console.log(arg, props.bar);
    };
    $[0] = props.bar;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const foo = t0;
  const t1 = useFire(foo);
  let t2;
  if ($[2] !== props || $[3] !== t1) {
    t2 = () => {
      t1(props);
    };
    $[2] = props;
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  useEffect(t2, [props]);
  return null;
}

```

----------------------------------------

TITLE: Using Hook in Component - JavaScript
DESCRIPTION: This snippet imports a hook from 'ReactCompilerTest' and attempts to use it within a functional component named 'Component'. It aims to demonstrate hook usage but encounters a type error due to incorrect configuration of the hook. Dependencies required include 'ReactCompilerTest'. Key parameters are the hook being invoked. The expected output is the return of the hook or a type error message if the hook is misconfigured.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hook-name-not-typed-as-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useHookNotTypedAsHook} from 'ReactCompilerTest';

function Component() {
  return useHookNotTypedAsHook();
}

```

----------------------------------------

TITLE: Modifying React Hook Using Compiler Runtime with State Reallocation in JavaScript
DESCRIPTION: The code snippet introduces a more complex version of `useFoo`, utilizing a compiler-runtime hook (`_c`) for stateful logic within a React hook. It checks and reallocates an array `x` based on changes in properties such as `bar`, `cond`, and `foo`. Required dependencies include `react/compiler-runtime` for state management. The input includes conditional and numerical properties with the output being an adjusted state maintained over time. It's constrained by the complexity of managing multiple state checks inline.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(props) {
  const $ = _c(5);
  let x;
  if ($[0] !== props.bar) {
    x = [];
    x.push(props.bar);
    $[0] = props.bar;
    $[1] = x;
  } else {
    x = $[1];
  }
  if ($[2] !== props.cond || $[3] !== props.foo) {
    props.cond ? ((x = []), x.push(props.foo)) : null;
    $[2] = props.cond;
    $[3] = props.foo;
    $[4] = x;
  } else {
    x = $[4];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiled version of the component showing how the React compiler optimizes the useMemo implementation. It includes cache checking and updating logic using compiler runtime utilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-with-no-depslist.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useMemo } from "react";

// Compiler can produce any memoization it finds valid if the
// source listed no memo deps
function Component(t0) {
  const $ = _c(2);
  const { propA } = t0;
  let t1;
  let t2;
  if ($[0] !== propA) {
    t2 = [propA];
    $[0] = propA;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ propA: 2 }],
};
```

----------------------------------------

TITLE: Memoizing React Component with Context
DESCRIPTION: This code snippet demonstrates memoizing a React component using `react/compiler-runtime` and context. The `_c` function is used to create a memoized version of the component that only re-renders if the `bar` or `foo` context values have changed. It initializes a cache `$` and updates it with the new values, preventing unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-property-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @lowerContextAccess
function App() {
  const $ = _c(3);
  const context = useContext(MyContext);
  const foo = context.foo;
  const bar = context.bar;
  let t0;
  if ($[0] !== bar || $[1] !== foo) {
    t0 = <Bar foo={foo} bar={bar} />;
    $[0] = bar;
    $[1] = foo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

```

----------------------------------------

TITLE: Compiled React Component with Optimizations
DESCRIPTION: The compiled version of the React component with compiler runtime optimizations. Implements memoization using Symbol references and caching mechanisms, with separated helper functions for filtering and mapping operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-declarations-in-reactive-scope-with-early-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
function Component() {
  const $ = _c(7);
  const items = useItems();
  let t0;
  let t1;
  let t2;
  if ($[0] !== items) {
    t2 = Symbol.for("react.early_return_sentinel");
    bb0: {
      t0 = items.filter(_temp);
      const filteredItems = t0;
      if (filteredItems.length === 0) {
        let t3;
        if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
          t3 = (
            <div>
              <span />
            </div>
          );
          $[4] = t3;
        } else {
          t3 = $[4];
        }
        t2 = t3;
        break bb0;
      }

      t1 = filteredItems.map(_temp2);
    }
    $[0] = items;
    $[1] = t1;
    $[2] = t2;
    $[3] = t0;
  } else {
    t1 = $[1];
    t2 = $[2];
    t0 = $[3];
  }
  if (t2 !== Symbol.for("react.early_return_sentinel")) {
    return t2;
  }
  let t3;
  if ($[5] !== t1) {
    t3 = <>{t1}</>;
    $[5] = t1;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}
function _temp2(t0) {
  const [item_0] = t0;
  return <Stringify item={item_0} />;
}
function _temp(t0) {
  const [item] = t0;
  return item.name != null;
}
```

----------------------------------------

TITLE: Initialize and Export useFoo Function with Parameters and Tests in JavaScript
DESCRIPTION: Implements the useFoo function which conditionally returns a predefined object or an array with elements added via arrayPush. The function uses a condition value and input parameters, handling potential edge cases like null inputs. The function and its usage are exported as FIXTURE_ENTRYPOINT, alongside test scenarios for various input states. The use of arrayPush from 'shared-runtime' is required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/return-before-scope-starts.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {arrayPush} from 'shared-runtime';

function useFoo({input, cond}) {
  if (cond) {
    return {result: 'early return'};
  }

  // unconditional
  const x = [];
  arrayPush(x, input.a.b);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {a: {b: 2}}, cond: false}],
  sequentialRenders: [
    {input: null, cond: true},
    {input: {a: {b: 2}}, cond: false},
    {input: null, cond: true},
    // preserve nullthrows
    {input: {}, cond: false},
    {input: {a: {b: null}}, cond: false},
    {input: {a: null}, cond: false},
    {input: {a: {b: 3}}, cond: false},
  ],
};

```

----------------------------------------

TITLE: Defining Conditional List Manipulation with React (JavaScript)
DESCRIPTION: The Foo function takes a default list and a condition, generates a custom list using the makeArray function, and sorts it if the condition is true. It uses useHook from the shared-runtime, showcasing React paradigms for state or effect management. The function combines both sorting logic and conditional rendering based on the input parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/value-block-mutates-outer-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray, useHook} from 'shared-runtime';

/**
 * Here, the cond ? [...] : defaultList value block produces two
 * new values (each with its own scope):
 *   $0 = ["text"]
 *   $1 = { text: $0 }
 * The same value block also mutates customList, so it must be
 * merged with the scope producing customList
 */
function Foo({defaultList, cond}) {
  const comparator = (a, b) => a - b;
  useHook();
  const customList = makeArray(1, 5, 2);
  useHook();
  const result = cond
    ? [...customList.sort(comparator), {text: ['text']}]
    : defaultList;

  return result;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{defaultList: [2, 4], cond: true}],
};

```

LANGUAGE: javascript
CODE:
```
import { makeArray, useHook } from "shared-runtime";

/**
 * Here, the cond ? [...] : defaultList value block produces two
 * new values (each with its own scope):
 *   $0 = ["text"]
 *   $1 = { text: $0 }
 * The same value block also mutates customList, so it must be
 * merged with the scope producing customList
 */
function Foo(t0) {
  const { defaultList, cond } = t0;
  const comparator = _temp;
  useHook();
  const customList = makeArray(1, 5, 2);
  useHook();
  const result = cond
    ? [...customList.sort(comparator), { text: ["text"] }]
    : defaultList;
  return result;
}
function _temp(a, b) {
  return a - b;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ defaultList: [2, 4], cond: true }],
};

```

----------------------------------------

TITLE: Optimized Reactive Ref with Compiler Runtime - JavaScript
DESCRIPTION: This snippet shows an optimized version of the previous reactive reference management using a compiler runtime (_c). It demonstrates conditional rendering and memoization techniques, ensuring that components re-render only when certain dependencies change. Dependencies include the react/compiler-runtime and shared-runtime packages. The Parent function has been enhanced for performance using the _c function, where reference states are cached for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-ref-param.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useRef, forwardRef } from "react";
import { Stringify } from "shared-runtime";

/**
 * Fixture showing that Ref types may be reactive.
 * We should always take a dependency on ref values (the outer box) as
 * they may be reactive. Pruning should be done in
 * `pruneNonReactiveDependencies`
 */

function Parent(t0) {
  const $ = _c(2);
  const { cond } = t0;
  const ref1 = useRef(1);
  const ref2 = useRef(2);
  const ref = cond ? ref1 : ref2;
  let t1;
  if ($[0] !== ref) {
    t1 = <Child ref={ref} />;
    $[0] = ref;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function ChildImpl(_props, ref) {
  const $ = _c(4);
  let t0;
  if ($[0] !== ref) {
    t0 = () => ref.current;
    $[0] = ref;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const cb = t0;
  let t1;
  if ($[2] !== cb) {
    t1 = <Stringify cb={cb} shouldInvokeFns={true} />;
    $[2] = cb;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

const Child = forwardRef(ChildImpl);

export const FIXTURE_ENTRYPOINT = {
  fn: Parent,
  params: [{ cond: true }],
  sequentialRenders: [{ cond: true }, { cond: false }],
};
```

----------------------------------------

TITLE: Using React Compiler Runtime and Hoisting in JavaScript
DESCRIPTION: This snippet showcases a more complex implementation of the hoisting function using React's compiler runtime. It demonstrates a memoization pattern to cache results and appropriately handles variable scopes for `foo`, `bar`, and `baz`. It uses the compiler runtime to manage reactivity and state more directly, ensuring correct behavior in a React application.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-let-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function hoisting() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const qux = () => {
      let result;

      result = foo();
      return result;
    };

    let foo;
    foo = () => bar + baz;

    let bar;
    bar = 3;
    const baz = 2;
    t0 = qux();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Initial implementation of a React component with an inline arrow function and variable reassignment. The component invokes a function that returns an object and modifies a local variable.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-colliding-identifier.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {invoke} from 'shared-runtime';

function Component() {
  let x = 2;
  const fn = () => {
    return {x: 'value'};
  };
  invoke(fn);
  x = 3;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Invalid React Hook Call in Callback Function
DESCRIPTION: This code snippet illustrates an invalid React hook usage by calling `useHookInsideCallback` within a callback function passed to `useEffect`. This violates the Rules of Hooks, which state that hooks must be called at the top level of a function component or custom hook, not within function expressions or callbacks. The expected output is a runtime error indicating the violation of hook rules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-0de1224ce64b.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
function createComponent() {
  return function ComponentWithHookInsideCallback() {
    useEffect(() => {
      useHookInsideCallback();
    });
  };
}

```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Optimized version of the component with React compiler runtime additions. Implements caching mechanism using Symbol.for() and maintains reference equality checks for props and computed values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-mutate-outer-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { shallowCopy, throwErrorWithMessage } = require("shared-runtime");

function Component(props) {
  const $ = _c(5);
  let x;
  if ($[0] !== props) {
    x = [];
    try {
      let t0;
      if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = throwErrorWithMessage("oops");
        $[2] = t0;
      } else {
        t0 = $[2];
      }
      x.push(t0);
    } catch {
      let t0;
      if ($[3] !== props.a) {
        t0 = shallowCopy({ a: props.a });
        $[3] = props.a;
        $[4] = t0;
      } else {
        t0 = $[4];
      }
      x.push(t0);
    }
    $[0] = props;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1 }],
};
```

----------------------------------------

TITLE: Input Implementation of useBar Hook
DESCRIPTION: Original source code implementation of a React hook that demonstrates Set iterator behavior with object spreads. Uses memoization and returns an array combining an input argument with Set values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-spread-mutable-iterator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useBar({arg}) {
  'use memo';

  /**
   * Note that mutableIterator is mutated by the later object spread. Therefore,
   * `s.values()` should be memoized within the same block as the object spread.
   * In terms of compiler internals, they should have the same reactive scope.
   */
  const s = new Set([1, 5, 4]);
  const mutableIterator = s.values();

  return [arg, ...mutableIterator];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useBar,
  params: [{arg: 3}],
  sequentialRenders: [{arg: 3}, {arg: 3}, {arg: 4}],
};
```

----------------------------------------

TITLE: React Component with useMemo (Compiled Code)
DESCRIPTION: This snippet presents the compiled version of the React component, leveraging `react/compiler-runtime` for enhanced memoization. It uses `_c` from `react/compiler-runtime` to cache and optimize the component's calculations. The `useMemo` hook is used to memoize a value based on the input prop `a`. `FIXTURE_ENTRYPOINT` is an object used for testing that specifies the component, its initial parameters, and the flag `isComponent`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple-preserved-nomemo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @disableMemoizationForDebugging
import { useMemo } from "react";

function Component(t0) {
  const $ = _c(5);
  const { a } = t0;
  let t1;
  if ($[0] !== a || true) {
    t1 = () => [a];
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel") || true) {
    t2 = [];
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const x = useMemo(t1, t2);
  let t3;
  if ($[3] !== x || true) {
    t3 = <div>{x}</div>;
    $[3] = x;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 42 }],
  isComponent: true,
};

```

----------------------------------------

TITLE: Original Component Function Definition in React
DESCRIPTION: A React component function that returns a closure which logs either an argument or a prop value. The returned function captures the props reference to access props.str when no arguments are provided.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassigned-phi-in-returned-function-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return () => {
    let str;
    if (arguments.length) {
      str = arguments[0];
    } else {
      str = props.str;
    }
    global.log(str);
  };
}
```

----------------------------------------

TITLE: Compiled Version of useMakeCallback Hook with React Compiler Runtime
DESCRIPTION: The optimized version of the useMakeCallback hook after processing by React's compiler runtime. It replaces useMemo with an explicit caching mechanism using the _c utility for storing and retrieving cached values based on dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/use-memo-returned.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState, useMemo } from "react";
import { useIdentity } from "shared-runtime";

/**
 * Assume that conditionally called functions can be invoked and that their
 * property loads are hoistable to the function declaration site.
 */
function useMakeCallback(t0) {
  const $ = _c(2);
  const { obj, shouldSynchronizeState } = t0;

  const [, setState] = useState(0);
  let t1;
  let t2;
  if ($[0] !== obj.value) {
    t2 = () => {
      if (obj.value !== 0) {
        setState(obj.value);
      }
    };
    $[0] = obj.value;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const cb = t1;

  useIdentity(null);
  return cb;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{ obj: { value: 1 } }],
  sequentialRenders: [{ obj: { value: 1 } }, { obj: { value: 2 } }],
};
```

----------------------------------------

TITLE: React Compiler Runtime Optimized Component
DESCRIPTION: Transformed component using React compiler runtime with memoization and cache mechanisms to optimize rendering and state management
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/incompatible-destructuring-kinds.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { Stringify } from "shared-runtime";

function Component(t0) {
  const $ = _c(4);
  let a;
  let b;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    a = "a";

    const [t2, t3] = [null, null];
    t1 = t3;
    a = t2;
    $[0] = a;
    $[1] = b;
    $[2] = t1;
  } else {
    a = $[0];
    b = $[1];
    t1 = $[2];
  }
  b = t1;
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = <Stringify a={a} b={b} onClick={() => a} />;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component Function with JSX
DESCRIPTION: The original function creates a JSX element through a nested function and returns it. It uses a global variable GLOBAL_IS_X that is captured in the component closure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-into-function-expression-global.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const isX = GLOBAL_IS_X;
  const getJSX = () => {
    return <Child x={isX}></Child>;
  };
  const result = getJSX();
  return result;
}
```

----------------------------------------

TITLE: Original React Component with Change Detection Debugging
DESCRIPTION: A simple React component with conditional array creation and modification based on props. The '@enableChangeDetectionForDebugging' directive is used to enable compiler debugging features.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/change-detect-reassign.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableChangeDetectionForDebugging
function Component(props) {
  let x = null;
  if (props.cond) {
    x = [];
    x.push(props.value);
  }
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component with react/compiler-runtime
DESCRIPTION: This snippet shows the compiled version of the React component. It uses the `_c` function from `react/compiler-runtime` to achieve memoization. The compiled code optimizes the component by storing previous values and only re-rendering when necessary, avoiding unnecessary computations and re-renders of its children.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(4);
  let t0;
  let t1;
  if ($[0] !== a) {
    t1 = [a];
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const x = t0;
  let t2;
  if ($[2] !== x) {
    t2 = <Foo x={x} />;
    $[2] = x;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}
```

----------------------------------------

TITLE: Enhanced Memoization in React with Compiler Runtime
DESCRIPTION: This snippet showcases an advanced version of the `useFoo` hook utilizing React's compiler runtime for memoization. It introduces a caching mechanism with checks against a sentinel value, allowing for more complex state management. The dependency on the React library and the compiler runtime is required, and the hook takes no parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/todo-ensure-constant-prop-decls-get-removed.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";

// Todo: we currently only generate a `constVal` declaration when
// validatePreserveExistingMemoizationGuarantees is enabled, as the
// StartMemoize instruction uses `constVal`.
// Fix is to rewrite StartMemoize instructions to remove constant
// propagated values
function useFoo() {
  const $ = _c(1);
  const constVal = 0;
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [0];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  t0 = t1;
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing React Component with Scoped Variables
DESCRIPTION: This code defines a React component that demonstrates variable scoping. It creates an object 'x', then defines a new 'x' in a block scope, modifies it, but returns the original object 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-reassign-shadowed-primitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const x = {};
  {
    let x = 56;
    const fn = function () {
      x = 42;
    };
    fn();
  }
  return x; // should return {}
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining React Component with Memoization
DESCRIPTION: This snippet defines a React component that demonstrates memoization techniques. It conditionally renders elements based on prop values and uses ValidateMemoization for testing. The component is designed to showcase fine-grained memoization that is difficult to achieve with useMemo.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-if-dep-is-inner-declaration-of-previous-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {ValidateMemoization} from 'shared-runtime';

// Achieving Forget's level of memoization precision in this example isn't possible with useMemo
// without significantly altering the code, so disable the non-Forget evaluation of this fixture.
// @disableNonForgetInSprout
function Component({a, b, c}) {
  const x = [];
  let y;
  if (a) {
    y = [b];
  }
  x.push(c);

  // this scope should not merge with the above scope because y does not invalidate
  // on changes to `c`
  const z = [y];

  // return [x, z];
  return (
    <>
      <ValidateMemoization inputs={[a, b, c]} output={x} />
      <ValidateMemoization inputs={[a, b]} output={z} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: false, b: null, c: 0}],
  sequentialRenders: [
    {a: false, b: null, c: 0},
    {a: false, b: null, c: 1},
    {a: true, b: 0, c: 1},
    {a: true, b: 1, c: 1},
  ],
};
```

----------------------------------------

TITLE: Demonstrating Invalid Hook Usage in React Component
DESCRIPTION: This code snippet illustrates an incorrect implementation of hooks in a React component. It attempts to use a custom hook (useHookInsideCallback) within a useEffect callback, which violates the Rules of Hooks. This pattern is not supported and leads to a runtime error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.bail.rules-of-hooks-3d692676194b.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Unsupported input

// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
const ComponentWithHookInsideCallback = React.forwardRef((props, ref) => {
  useEffect(() => {
    useHookInsideCallback();
  });
  return <button {...props} ref={ref} />;
});
```

----------------------------------------

TITLE: Running Unit Tests for DevTools
DESCRIPTION: Execute the unit tests for the core functionalities of the React DevTools.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_8

LANGUAGE: sh
CODE:
```
yarn test-build-devtools
```

----------------------------------------

TITLE: Compiled React Component with Optimized Memoization (JavaScript)
DESCRIPTION: This snippet shows the compiled version of the React component with optimized memoization. It uses the _c function from react/compiler-runtime to create a memoization cache and implements efficient re-rendering logic for various computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-memoization-lack-of-phi-types-explicit-types.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { useFragment } from "shared-runtime";

function Component() {
  const $ = _c(11);
  const data = useFragment();
  let t0;
  if ($[0] !== data.nodes) {
    t0 = data.nodes ?? [];
    $[0] = data.nodes;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const nodes = t0;
  let t1;
  if ($[2] !== nodes) {
    t1 = nodes.flatMap(_temp);
    $[2] = nodes;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const flatMap = t1;
  let t2;
  if ($[4] !== flatMap) {
    t2 = flatMap.filter(_temp2);
    $[4] = flatMap;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const filtered = t2;
  let t3;
  let t4;
  if ($[6] !== filtered) {
    t4 = filtered.map();
    $[6] = filtered;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  t3 = t4;
  const map = t3;
  const index = filtered.findIndex(_temp3);
  let t5;
  if ($[8] !== index || $[9] !== map) {
    t5 = (
      <div>
        {map}
        {index}
      </div>
    );
    $[8] = index;
    $[9] = map;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  return t5;
}
function _temp3(x) {
  return x === null;
}
function _temp2(item) {
  return item != null;
}
function _temp(node) {
  return node.items;
}
```

----------------------------------------

TITLE: Implementing Conditional Reassignment in React Component (Input Version)
DESCRIPTION: A React component that conditionally reassigns a variable based on boolean props using a helper function called conditionalInvoke. The component includes a fixture entrypoint for testing sequential renders with different prop combinations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-two-lambdas.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {conditionalInvoke} from 'shared-runtime';

function Component({doReassign1, doReassign2}) {
  let x = {};
  const reassign1 = () => {
    x = 2;
  };
  const reassign2 = () => {
    x = 3;
  };
  conditionalInvoke(doReassign1, reassign1);
  conditionalInvoke(doReassign2, reassign2);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{doReassign1: true, doReassign2: true}],
  sequentialRenders: [
    {doReassign1: true, doReassign2: true},
    {doReassign1: true, doReassign2: false},
    {doReassign1: false, doReassign2: false},
  ],
};
```

----------------------------------------

TITLE: Original React Component Implementation with useMemo
DESCRIPTION: A React component that uses useMemo to optimize rendering. The component closes over an external global variable and updates it on click events. The implementation demonstrates a potential issue with memoization as the onClick handler references a prop but is not in the dependency array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-modify-global-in-callback-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';

const someGlobal = {value: 0};

function Component({value}) {
  const onClick = () => {
    someGlobal.value = value;
  };
  return useMemo(() => {
    return <div onClick={onClick}>{someGlobal.value}</div>;
  }, []);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 0}],
  sequentialRenders: [
    {value: 1},
    {value: 1},
    {value: 42},
    {value: 42},
    {value: 0},
  ],
};
```

----------------------------------------

TITLE: Initializing React Component with Global State Mutation
DESCRIPTION: Demonstrates problematic React component that modifies a global variable outside of state management, which can lead to unexpected rendering behaviors and React best practice violations
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-global-reassignment-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';

let someGlobal = false;

function Component() {
  const [state, setState] = useState(someGlobal);

  const setGlobal = () => {
    someGlobal = true;
  };
  const indirectSetGlobal = () => {
    setGlobal();
  };
  indirectSetGlobal();

  useEffect(() => {
    setState(someGlobal);
  }, [someGlobal]);

  return <div>{String(state)}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing Array Processing Component in JavaScript
DESCRIPTION: This snippet defines a React component that processes an array, removing zeros and halving other values. It demonstrates usage of array methods and a do-while loop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-continue.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const x = [0, 1, 2, 3];
  const ret = [];
  do {
    const item = x.pop();
    if (item === 0) {
      continue;
    }
    ret.push(item / 2);
  } while (x.length);

  return ret;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component Definition with Hook and JSX
DESCRIPTION: This code defines a React component that receives a `value` prop, renders it within nested `div` elements, and includes a `useHook` call. The component also creates an object `o` and assigns the `value` prop to it.  It exports the component as part of a `FIXTURE_ENTRYPOINT` object for testing or rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useHook} from 'shared-runtime';

function Component(props) {
  const o = {};
  const x = <div>{props.value}</div>; // create within the range of x to group with x
  useHook(); // intersperse a hook call to prevent memoization of x
  o.value = props.value;

  const y = <div>{x}</div>;

  return <div>{y}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'sathya'}],
};

```

----------------------------------------

TITLE: Defining React Component with FBT Internationalization Markup
DESCRIPTION: Original React component that uses the FBT internationalization library to create a text string with a parameter insertion. The component accepts a value prop that gets inserted between 'Before text' and 'After text'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-no-whitespace-btw-text-and-param.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

const _ = fbt;
function Component({value}: {value: string}) {
  return (
    <fbt desc="descdesc">
      Before text<fbt:param name="paramName">{value}</fbt:param>After text
    </fbt>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'hello world'}],
};
```

----------------------------------------

TITLE: Implementing useMakeCallback React Hook - Original Code
DESCRIPTION: Original implementation of a custom React hook that creates a callback function based on input object value. The hook uses useState and conditionally calls the callback during initial rendering when state is 0.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditional-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';
import {useIdentity} from 'shared-runtime';

/**
 * Assume that conditionally called functions can be invoked and that their
 * property loads are hoistable to the function declaration site.
 */
function useMakeCallback({obj}: {obj: {value: number}}) {
  const [state, setState] = useState(0);
  const cb = () => {
    if (obj.value !== 0) setState(obj.value);
  };
  useIdentity(null);
  if (state === 0) {
    cb();
  }
  return {cb};
}
export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{obj: {value: 1}}],
  sequentialRenders: [{obj: {value: 1}}, {obj: {value: 2}}],
};

```

----------------------------------------

TITLE: Input: React Component with Function Definition
DESCRIPTION: Original implementation of a React component with a nested function that returns an object based on a prop value
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-functiondecl-hoisting.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo({value}) {
  const result = bar();
  function bar() {
    return {value};
  }
  return <Stringify result={result} fn={bar} shouldInvokeFns={true} />;
}
```

----------------------------------------

TITLE: Implementing Custom Hook with React Setup - JavaScript
DESCRIPTION: This snippet shows the implementation of a custom React hook useFoo that manages an object based on null check conditions. Dependencies include the React compiler-runtime for the caching mechanism. The function takes an object with properties obj and objIsNull and pushes values into an array conditionally. It returns the array as its output. Key parameters obj and objIsNull determine behavior. Inputs are objects following the specified structure. Returns an array of managed states. Assumes a React environment for runtime aspect.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-break-in-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(t0) {
  const $ = _c(3);
  const { obj, objIsNull } = t0;
  let x;
  if ($[0] !== obj || $[1] !== objIsNull) {
    x = [];
    bb0: {
      if (objIsNull) {
        break bb0;
      } else {
        x.push(obj.a);
      }

      x.push(obj.b);
    }
    $[0] = obj;
    $[1] = objIsNull;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ obj: null, objIsNull: true }],
  sequentialRenders: [
    { obj: null, objIsNull: true },
    { obj: { a: 2 }, objIsNull: false },
  ],
};

```

----------------------------------------

TITLE: Implementing Router Component in JavaScript
DESCRIPTION: This code defines a Router function that takes a title and a mapping as parameters. It creates an array of [title, entry] pairs from the mapping values. The function is designed to be used with React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-iterator-of-immutable-collection.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Router({title, mapping}) {
  const array = [];
  for (let entry of mapping.values()) {
    array.push([title, entry]);
  }
  return array;
}

const routes = new Map([
  ['about', '/about'],
  ['contact', '/contact'],
]);

export const FIXTURE_ENTRYPOINT = {
  fn: Router,
  params: [],
  sequentialRenders: [
    {
      title: 'Foo',
      mapping: routes,
    },
    {
      title: 'Bar',
      mapping: routes,
    },
  ],
};
```

----------------------------------------

TITLE: Using Freeze Functionality in React Component - JavaScript
DESCRIPTION: This code snippet defines a React component that initializes an array 'a' and applies the 'useFreeze' function twice to ensure that 'a' behaves as a frozen and readonly state. The 'call' function is also invoked on 'a', demonstrating its usage with a frozen state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-freeze-arguments.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const a = [];
  useFreeze(a); // should freeze
  useFreeze(a); // should be readonly
  call(a); // should be readonly
  return a;
}

function useFreeze(x) {}
function call(x) {}
```

----------------------------------------

TITLE: Defining Original React Component Function
DESCRIPTION: This snippet defines a function 'foo' that creates a conditional JSX structure based on input parameters. It also exports a FIXTURE_ENTRY POINT object for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-jsx-child.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const x = [];
  if (a) {
    const y = [];
    if (b) {
      y.push(c);
    }
    x.push(<div>{y}</div>);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining React Components with Forget Optimization
DESCRIPTION: This snippet defines two React components (Component and Component2) with conditional implementations based on the Forget feature flag. It uses the isForgetEnabled_Fixtures() function to determine which implementation to use. The optimized version uses the _c function from react/compiler-runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-preserves-function-properties.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
const Component = isForgetEnabled_Fixtures()
  ? function Component() {
      const $ = _c(1);
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = <></>;
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : function Component() {
      return <></>;
    };
export default Component;

export const Component2 = isForgetEnabled_Fixtures()
  ? function Component2() {
      const $ = _c(1);
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = <></>;
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : function Component2() {
      return <></>;
    };

Component.displayName = "Component ONE";
Component2.displayName = "Component TWO";

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [{}],
};
```

----------------------------------------

TITLE: React Component with Default Arrow Function Parameter (JavaScript)
DESCRIPTION: This code defines a React component named `Component` using a JavaScript function. It takes two parameters: `x` and `y`. The `y` parameter has a default value, which is an arrow function that returns the value of `x`. The component then simply returns the result of calling the `y` function. The FIXTURE_ENTRYPOINT exports the component function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.default-param-accesses-local.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(
  x,
  y = () => {
    return x;
  }
) {
  return y();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: Original Component Function Implementation in JavaScript
DESCRIPTION: Defines a component function that creates an object with nested properties and a closure function. The FIXTURE_ENTRYPOINT exports configuration for testing with the 'TodoAdd' component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a: {a}};
  let x = function () {
    z.a.a();
  };
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Input Component Function with Simple Closure
DESCRIPTION: Original component function that creates a closure capturing a nested object. The component takes a parameter 'a', creates an object with a nested reference to that parameter, and returns a function that logs the nested value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a: {a}};
  let x = function () {
    console.log(z.a.a);
  };
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component with useIdentity and setPropertyByKey
DESCRIPTION: The 'Foo' component takes a 'count' prop and initializes an object 'x'. It then uses 'useIdentity' to create a memoized callback 'cb' that sets the 'value' property of 'x' to 'count' using 'setPropertyByKey'. The key functionality is demonstrated by the mutation of 'x' after the hook call which causes a React error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-call-freezes-captured-identifier.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableTransitivelyFreezeFunctionExpressions
import {setPropertyByKey, Stringify, useIdentity} from 'shared-runtime';

function Foo({count}) {
  const x = {value: 0};
  /**
   * After this custom hook call, it's no longer valid to mutate x.
   */
  const cb = useIdentity(() => {
    setPropertyByKey(x, 'value', count);
  });

  x.value += count;
  return <Stringify x={x} cb={cb} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{count: 1}],
};

```

----------------------------------------

TITLE: React Component with Optional Chaining (Code)
DESCRIPTION: This snippet defines a React component named `Component` that accepts `props`. It creates an object `obj` using `makeObject()` and then uses optional chaining `obj.a?.b?.(props.c)` to safely call a method `b` on potentially null or undefined properties `a` and `b` of the object. The `props.c` value is passed as an argument to the method `b`. The component returns null, indicating it doesn't render anything.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-optional-method-assigned-to-variable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const obj = makeObject();
  obj.a?.b?.(props.c);
  return null;
}
```

----------------------------------------

TITLE: Compiled React Component with Inferred Effect Dependencies
DESCRIPTION: The compiled version of the component showing how React's compiler-runtime transforms the code to correctly track the setState dependency. It uses memoization to avoid recreating the effect callback unnecessarily and explicitly adds setState to the dependency array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-setState.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect, useState } from "react";
import { print } from "shared-runtime";

/*
 * setState types are not enough to determine to omit from deps. Must also take reactivity into account.
 */
function ReactiveRefInEffect(props) {
  const $ = _c(2);
  const [, setState1] = useRef("initial value");
  const [, setState2] = useRef("initial value");
  let setState;
  if (props.foo) {
    setState = setState1;
  } else {
    setState = setState2;
  }
  let t0;
  if ($[0] !== setState) {
    t0 = () => print(setState);
    $[0] = setState;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  useEffect(t0, [setState]);
}
```

----------------------------------------

TITLE: JavaScript Error: Unhandled MetaProperty Expression
DESCRIPTION: This error message indicates that the JavaScript runtime encountered a `MetaProperty` expression (`new.target`) during the lowering of expressions that it cannot handle, specifically when not dealing with `import.meta`. It highlights the line of code where the error occurred: `const nt = new.target;`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-new-target-meta-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 |
  3 | function foo() {
> 4 |   const nt = new.target;
    |              ^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Handle MetaProperty expressions other than import.meta (4:4)
  5 |   return <Stringify value={nt} />;
  6 | }
  7 |

```

----------------------------------------

TITLE: Defining Conditional Function and Exporting Fixture in JavaScript
DESCRIPTION: This snippet defines a function 'foo' that returns null if the first parameter is null, otherwise returns the second parameter. It also exports a constant FIXTURE_ENTRYPOINT object that references the 'foo' function and specifies parameters for a 'TodoAdd' component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-conditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  if (a == null) {
    return null;
  } else {
    return b;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component with Compiler Runtime Optimization (Code)
DESCRIPTION: This is the compiled version of the React component, utilizing React's compiler runtime (`react/compiler-runtime`). It memoizes the result of the function calls and object creation to prevent re-computation if the props haven't changed. This optimization improves performance by avoiding unnecessary calculations and re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    const x = makeOptionalFunction(props);
    const y = makeObject(props);
    t0 = x?.(y.a, props.a, foo(y.b), bar(props.b));
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  return z;
}
```

----------------------------------------

TITLE: Compiled useFoo with React Compiler
DESCRIPTION: This snippet showcases the compiled version of the `useFoo` hook, likely after processing by a React compiler. It demonstrates how the `useMemo` hook is transformed to manage dependencies and memoize the result using the `_c` function (presumably from `react/compiler-runtime`). It also exports a `FIXTURE_ENTRYPOINT` to specify function and params.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-reordering-depslist-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";

function useFoo(arr1, arr2) {
  const $ = _c(5);
  let y;
  if ($[0] !== arr1 || $[1] !== arr2) {
    const x = [arr1];

    (y = x.concat(arr2)), y;
    $[0] = arr1;
    $[1] = arr2;
    $[2] = y;
  } else {
    y = $[2];
  }
  let t0;
  let t1;
  if ($[3] !== y) {
    t1 = { y };
    $[3] = y;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  t0 = t1;
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [
    [1, 2],
    [3, 4],
  ],
};

```

----------------------------------------

TITLE: Using Stringify for Conditional Rendering in React (JavaScript)
DESCRIPTION: This snippet defines the `useFoo` function, which takes an object as an argument and returns a Stringify component that conditionally renders properties from nested objects based on their state. It demonstrates how to handle potentially undefined values using optional chaining.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/todo-infer-function-uncond-optionals-hoisted.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function useFoo({a}) {
  return <Stringify fn={() => a.b?.c.d?.e} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: null}],
  sequentialRenders: [
    {a: null},
    {a: {b: null}},
    {a: {b: {c: {d: null}}}},
    {a: {b: {c: {d: {e: 4}}}}},
  ],
};

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(2);
  const { a } = t0;
  let t1;
  if ($[0] !== a.b?.c.d?.e) {
    t1 = <Stringify fn={() => a.b?.c.d?.e} shouldInvokeFns={true} />;
    $[0] = a.b?.c.d?.e;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: null }],
  sequentialRenders: [
    { a: null },
    { a: { b: null } },
    { a: { b: { c: { d: null } } } },
    { a: { b: { c: { d: { e: 4 } } } } },
  ],
};

```

----------------------------------------

TITLE: Defining React Component with FBT Internationalization
DESCRIPTION: This snippet defines a React component that uses FBT for internationalization. It demonstrates how to insert dynamic content into a translated string using FBT parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-whitespace-around-param-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

const _ = fbt;
function Component({value}: {value: string}) {
  return (
    <fbt desc="descdesc">
      Before text <fbt:param name="paramName"> {value} </fbt:param> after text
    </fbt>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'hello world'}],
};
```

----------------------------------------

TITLE: React Component with Array and Math.max
DESCRIPTION: This snippet defines a React component that uses the `makeArray` function to create an array, pushes a value onto it using `push`, and calculates the maximum value among several numbers, including elements from another array using the spread operator.  The component returns the calculated maximum value. It depends on the `makeArray` function and highlights an error during code generation related to the inline usage of `push` with `Math.max`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-nested-method-calls-lower-property-load-into-temporary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

const other = [0, 1];
function Component({}) {
  const items = makeArray(0, 1, 2, null, 4, false, 6);
  const max = Math.max(2, items.push(5), ...other);
  return max;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};
```

----------------------------------------

TITLE: Original Function Implementation in JavaScript
DESCRIPTION: A simple JavaScript function that creates an array and an object, assigns the array to a property of the object, and returns the object. The function is exported as part of a FIXTURE_ENTRYPOINT object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const x = [];
  const y = {};
  y.x = x;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining a React Component with 'use' Directives
DESCRIPTION: This snippet defines a simple React component named 'Component' that uses two 'use' directives and renders a div element. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multi-directive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  'use foo';
  'use bar';
  return <div>"foo"</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Defining Optimized React Component in JavaScript
DESCRIPTION: This code snippet demonstrates an optimized React component leveraging compiler runtime utilities. It avoids unnecessary recomputation by retaining previously computed values in a cache. The component directly manipulates internal state based on value comparison and sharing, optimizing performance for repeated renders. Dependencies include `react` and `react/compiler-runtime`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/drop-methodcall-usememo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as React from "react";

function Component(props) {
  const $ = _c(2);
  let t0;
  let x;
  if ($[0] !== props.value) {
    x = [];
    x.push(props.value);
    $[0] = props.value;
    $[1] = x;
  } else {
    x = $[1];
  }
  t0 = x;
  const x_0 = t0;
  return x_0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};

```

----------------------------------------

TITLE: Compiled React Component with Caching
DESCRIPTION: Compiled version of the component with added caching logic using React compiler runtime. Implements memoization for object creation and function references.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-variable-in-nested-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(4);
  let t0;
  if ($[0] !== a) {
    t0 = { a };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  let t1;
  if ($[2] !== z) {
    t1 = function () {
      console.log(z);
    };
    $[2] = z;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized React Component
DESCRIPTION: This JavaScript code represents the compiled and optimized version of the original React component. It uses a compiler runtime `_c` to memoize the results of calculations based on the component's props. This optimization avoids unnecessary re-renders and improves the component's performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-reactive-via-mutation-of-property-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(7);
  let items;
  if ($[0] !== props.a) {
    items = bar();
    mutate(items.a, props.a);
    $[0] = props.a;
    $[1] = items;
  } else {
    items = $[1];
  }

  const t0 = items.length + 1;
  let t1;
  if ($[2] !== t0) {
    t1 = foo(t0);
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const count = t1;
  let t2;
  if ($[4] !== count || $[5] !== items) {
    t2 = { items, count };
    $[4] = count;
    $[5] = items;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
```

----------------------------------------

TITLE: Advanced Component State Management with Compiler Runtime - JavaScript
DESCRIPTION: This snippet shows an advanced React component using a customized method with compiler runtime. It uses a memoization technique to cache and reuse the effect function, improving performance by avoiding unnecessary reconstructions. The snippet relies on 'react/compiler-runtime' along with useEffect and useState from React. Parameters involve initial state setup and effect function caching.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/valid-setState-in-useEffect-listener.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateNoSetStateInPassiveEffects
import { useEffect, useState } from "react";

function Component() {
  const $ = _c(1);
  const [state, setState] = useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setTimeout(setState, 10);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(t0);
  return state;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This snippet shows the compiled version of the `VideoTab` component using React's compiler runtime. It utilizes `_c` for memoization and stores the result in a cache. The `ref` is still created using `useRef`, and the function accessing `ref.current.x` is created only when the component is initially rendered and stored in the cache. The cached component is then returned on subsequent renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-field-not-added-to-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender false
function VideoTab() {
  const $ = _c(1);
  const ref = useRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = () => {
      console.log(ref.current.x);
    };

    t0 = <VideoList videos={x} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

```

----------------------------------------

TITLE: Compiled React Component with Caching
DESCRIPTION: Compiled version of the React component with memoization logic implemented through the Forget feature flag. Includes caching for both ErrorView and the main component using React compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-export-default-gating-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
import { Stringify } from "shared-runtime";

const ErrorView = isForgetEnabled_Fixtures()
  ? (error, _retry) => {
      const $ = _c(2);
      let t0;
      if ($[0] !== error) {
        t0 = <Stringify error={error} />;
        $[0] = error;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : (error, _retry) => <Stringify error={error}></Stringify>;

export default isForgetEnabled_Fixtures()
  ? (props) => {
      const $ = _c(1);
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = (
          <Foo>
            <Bar />
            <ErrorView />
          </Foo>
        );
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : (props) => (
      <Foo>
        <Bar></Bar>
        <ErrorView></ErrorView>
      </Foo>
    );
```

----------------------------------------

TITLE: Using React Compiler Runtime in Component
DESCRIPTION: This code uses a customized React setup with the "react/compiler-runtime" package for component creation. It manipulates component render state to handle memoized values and dependencies more efficiently. Prerequisites include a setup with the react/compiler-runtime and familiarity with its concepts. It takes initial component configurations and outputs a component that conditionally renders based on state changes. There are constraints regarding react memoization strategies and their interactions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-unused-callback-nested.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender
import { useEffect, useRef, useState } from "react";

function Component() {
  const $ = _c(5);
  const ref = useRef(null);
  const [state, setState] = useState(false);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(_temp, t0);
  let t1;
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      setState(true);
    };
    t2 = [];
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useEffect(t1, t2);

  const t3 = String(state);
  let t4;
  if ($[3] !== t3) {
    t4 = <Child key={t3} ref={ref} />;
    $[3] = t3;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  return t4;
}
function _temp() {}

function Child(t0) {
  const { ref } = t0;
  return ref.current;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: React Component with Event Firing
DESCRIPTION: This snippet shows a React component that imports a 'fire' function (presumably custom) and uses it within a useEffect hook to trigger a function ('foo') with the component's props. The 'foo' function simply logs the props to the console. The intent is to execute 'foo' as a side effect when the component mounts or when props change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/basic.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = props => {
    console.log(props);
  };
  useEffect(() => {
    fire(foo(props));
  });

  return null;
}

```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This JavaScript snippet defines a React component named `Foo`. The component includes a function `x` that attempts to modify the global `window.href` property.  The component then passes this function as a prop named `y` to another component called `Bar`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.object-capture-global-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {
  const x = () => {
    window.href = 'foo';
  };
  const y = {x};
  return <Bar y={y} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};

```

----------------------------------------

TITLE: React Component Definition with idx macro
DESCRIPTION: This code defines a React component that uses the `idx` macro to safely access nested properties within the `props` object. The `idx` macro is used with different variations (`idx`, `idx.a`, `idx.a.b`, `idx.hello_world.b`, `idx.hello_world.b.c`) to access the `group.label` property.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-method-no-outlining-wildcard.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
```javascript
// @customMacros(idx.*.b)

function Component(props) {
  // outlined
  const groupName1 = idx(props, _ => _.group.label);
  // outlined
  const groupName2 = idx.a(props, _ => _.group.label);
  // not outlined
  const groupName3 = idx.a.b(props, _ => _.group.label);
  // not outlined
  const groupName4 = idx.hello_world.b(props, _ => _.group.label);
  // outlined
  const groupName5 = idx.hello_world.b.c(props, _ => _.group.label);
  return (
    <div>
      {groupName1}
      {groupName2}
      {groupName3}
      {groupName4}
      {groupName5}
    </div>
  );
}

```
```

----------------------------------------

TITLE: Defining Function with Object Destructuring in JavaScript
DESCRIPTION: This snippet defines a function 'foo' that uses object destructuring in its parameter to extract the 'data' property and rename it to 'dataTestID'. It also exports a constant 'FIXTURE_ENTRYPOINT' with the function and its parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-param-string-literal-key.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo({data: dataTestID}) {
  return dataTestID;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{data: {}}],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component with useState Hook (Input)
DESCRIPTION: This React component utilizes the useState hook to initialize a state variable 'x' with the initial value of 1. The component's purpose is to return this initial value of 'x'. The component is exported via FIXTURE_ENTRYPOINT for testing and usage in other modules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-with-React-namespace.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const [x, setX] = React.useState(1);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Shows the initial implementation of a React component with nested functions and closure accessing a constant value. Contains a while loop with conditional logic and returns a function that accesses the closed-over variable.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rewrite-phis-in-lambda-capture-context.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const x = 4;

  const get4 = () => {
    while (bar()) {
      if (baz) {
        bar();
      }
    }
    return () => x;
  };

  return get4;
}
```

----------------------------------------

TITLE: Defining and Exporting a React Component with Sequenced Properties in JavaScript
DESCRIPTION: This code snippet defines a React function component named 'Component' that processes properties and stores calculated values based on conditions involving those properties. It exports an object 'FIXTURE_ENTRYPOINT' that associates the component with a set of parameters and predefined render sequences for testing purposes. Dependencies include basic JavaScript syntax and React environment setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-cascading-eliminated-phis.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function Component(props) {
  let x = 0;
  const values = [];
  const y = props.a || props.b;
  values.push(y);
  if (props.c) {
    x = 1;
  }
  values.push(x);
  if (props.d) {
    x = 2;
  }
  values.push(x);
  return values;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 0, b: 1, c: true, d: true}],
  sequentialRenders: [
    {a: 0, b: 1, c: true, d: true},
    {a: 4, b: 1, c: true, d: true},
    {a: 4, b: 1, c: false, d: true},
    {a: 4, b: 1, c: false, d: false},
  ],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Shows the original component implementation that creates nested objects with property dependencies on props.a. The component creates scoped objects x and y with properties derived from props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-nested-scopes-with-same-inputs.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {setProperty} from 'shared-runtime';

function Component(props) {
  // start of scope for y, depend on props.a
  let y = {};

  // nested scope for x, dependent on props.a
  const x = {};
  setProperty(x, props.a);
  // end of scope for x

  y.a = props.a;
  y.x = x;
  // end of scope for y

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 42}],
};
```

----------------------------------------

TITLE: Defining React Component Function with Closure
DESCRIPTION: This snippet defines a React component function 'f' that creates a closure and renders a div element. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutated-ref-non-reactive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function f(a) {
  let x;
  (() => {
    x = {};
  })();
  // this is not reactive on `x` as `x` is never reactive
  return <div x={x} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Async React Component with Data Population
DESCRIPTION: This JavaScript code defines an asynchronous React component named `Component` that takes `props` as an argument. It initializes an empty array `x`, populates it with data using `populateData(props.id, x)`, and returns the populated array. This component fetches data on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/await-side-effecting-promise.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
async function Component(props) {
  const x = [];
  await populateData(props.id, x);
  return x;
}
```

----------------------------------------

TITLE: Optimizing React Component with Const Variables
DESCRIPTION: This snippet demonstrates an optimized version of the React component using 'const' for variable declarations. It performs the same operations as the previous version but with improved variable declarations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-scopes-hook-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function component(props) {
  const x = [];
  const y = [];
  y.push(useHook(props.foo));
  x.push(y);
  return x;
}
```

----------------------------------------

TITLE: Initializing Invalid React Hook with Identity Function
DESCRIPTION: A function that attempts to use an identifier before it is defined, causing a hoisting error. The identity function is incorrectly applied to an undefined variable.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.dont-hoist-inline-reference.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';
function useInvalid() {
  const x = identity(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useInvalid,
  params: [],
};
```

----------------------------------------

TITLE: Defining a React Hook with Conditional Rendering
DESCRIPTION: This snippet defines a React hook named `useFoo` that takes `props` as an argument. Inside the hook, the value of `x` is conditionally set based on the `props.cond` property. The `mutate` function is called to update the state, and finally, `x` is returned.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function useFoo(props) {
  let x = [];
  x.push(props.bar);
  if (props.cond) {
    x = {};
    x = [];
    x.push(props.foo);
  } else {
    x = [];
    x = [];
    x.push(props.bar);
  }
  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{bar: 'bar', foo: 'foo', cond: true}],
  sequentialRenders: [
    {bar: 'bar', foo: 'foo', cond: true},
    {bar: 'bar', foo: 'foo', cond: true},
    {bar: 'bar', foo: 'foo', cond: false},
  ],
};

```

----------------------------------------

TITLE: Initializing React Component with Let Variables
DESCRIPTION: This snippet shows a React component function using 'let' for variable declarations. It creates nested arrays, uses a custom hook, and returns the outer array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-scopes-hook-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(props) {
  let x = [];
  let y = [];
  y.push(useHook(props.foo));
  x.push(y);
  return x;
}
```

----------------------------------------

TITLE: Implementing a JavaScript Function with a Loop Increment Bug
DESCRIPTION: A JavaScript function 'foo' containing a while loop with a potential infinite loop bug. The loop condition checks if x < 10, but inside the loop, the increment operation (x + 1) doesn't actually modify x since the result isn't assigned back to x.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-while-no-reassign.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  while (x < 10) {
    x + 1;
  }

  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with memoization implementation using Symbol.for('react.memo_cache_sentinel') for cache detection and optimization of renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/log-pruned-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger
import { createContext, use, useState } from "react";
import {
  Stringify,
  identity,
  makeObject_Primitives,
  useHook,
} from "shared-runtime";

function Component() {
  const $ = _c(6);
  const w = use(Context);

  const x = makeObject_Primitives();
  const x2 = makeObject_Primitives();
  useState(null);
  identity(x);
  identity(x2);

  const y = useHook();
  let z;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    z = [];
    for (let i = 0; i < 10; i++) {
      const obj = makeObject_Primitives();
      z.push(obj);
    }
    $[0] = z;
  } else {
    z = $[0];
  }
  let t0;
  if ($[1] !== w || $[2] !== x || $[3] !== x2 || $[4] !== y) {
    t0 = <Stringify items={[w, x, x2, y, z]} />;
    $[1] = w;
    $[2] = x;
    $[3] = x2;
    $[4] = y;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  return t0;
}

const Context = createContext();

function Wrapper() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <Context value={42}>
        <Component />
      </Context>
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Wrapper,
  params: [{}],
};
```

----------------------------------------

TITLE: Initializing React Component with Fire Method
DESCRIPTION: A React component that attempts to use the `fire()` method with an invalid method call, which triggers a compilation error. The code demonstrates an incorrect approach to invoking the `fire()` method.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.todo-method.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = () => {
    console.log(props);
  };
  useEffect(() => {
    fire(props.foo());
  });

  return null;
}
```

----------------------------------------

TITLE: Compiled Output of useFoo Function with Memoization
DESCRIPTION: The React compiler-optimized version of useFoo that implements memoization using a cache array with sentinel values. It caches both object creation and the resulting array, preventing unnecessary recalculations when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/todo-merge-ssa-phi-access-nodes.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import {
  identity,
  makeObject_Primitives,
  setPropertyByKey,
} from "shared-runtime";

/**
 * A bit of an edge case, but we could further optimize here by merging
 * re-orderability of nodes across phis.
 */
function useFoo(cond) {
  const $ = _c(5);
  let x;
  if (cond) {
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      x = {};
      setPropertyByKey(x, "a", { b: 2 });
      $[0] = x;
    } else {
      x = $[0];
    }

    Math.max(x.a.b, 0);
  } else {
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      x = makeObject_Primitives();
      setPropertyByKey(x, "a", { b: 3 });
      $[1] = x;
    } else {
      x = $[1];
    }

    Math.max(x.a.b, 0);
  }
  let y;
  if ($[2] !== cond || $[3] !== x) {
    y = [];
    if (identity(cond)) {
      y.push(x.a.b);
    }
    $[2] = cond;
    $[3] = x;
    $[4] = y;
  } else {
    y = $[4];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Initial implementation of a React component that uses the Stringify component to render values. The component takes an 'id' prop and renders two Stringify components with different title values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-instruction-from-merge-consecutive-scopes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component({id}) {
  const bar = (() => {})();

  return (
    <>
      <Stringify title={bar} />
      <Stringify title={id ? true : false} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Running the Test Shell
DESCRIPTION: Launch the test shell to see changes reflected in the DevTools test app.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_5

LANGUAGE: sh
CODE:
```
cd <react-repo>
cd packages/react-devtools-shell
yarn start
```

----------------------------------------

TITLE: Implementing React.memo Cache with React Components in JavaScript
DESCRIPTION: This snippet illustrates the usage of React.memo caching using a custom symbol technique. The 'Component' function checks a cache symbol to decide if it needs to render a new child component or return a cached one. It demonstrates performance optimization via memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-in-jsx-attribute.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
export function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Child text={'Some \"text\"'} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function Child(props) {
  return props.text;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Implementing Unoptimized React Component with Dynamic Item Rendering
DESCRIPTION: This snippet defines a React component that renders a list of items based on props. It includes a constant TOTAL and exports a FIXTURE_ENTRYPOINT for testing different render scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-with-value-block-initializer.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const TOTAL = 10;
function Component(props) {
  const items = [];
  for (let i = props.start ?? 0; i < props.items.length; i++) {
    const item = props.items[i];
    items.push(<div key={item.id}>{item.value}</div>);
  }
  return <div>{items}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      start: null,
      items: [
        {id: 0, value: 'zero'},
        {id: 1, value: 'one'},
      ],
    },
  ],
  sequentialRenders: [
    {
      start: 1,
      items: [
        {id: 0, value: 'zero'},
        {id: 1, value: 'one'},
      ],
    },
    {
      start: 2,
      items: [
        {id: 0, value: 'zero'},
        {id: 1, value: 'one'},
      ],
    },
    {
      start: 0,
      items: [
        {id: 0, value: 'zero'},
        {id: 1, value: 'one'},
        {id: 2, value: 'two'},
      ],
    },
    {
      start: 1,
      items: [
        {id: 0, value: 'zero'},
        {id: 1, value: 'one'},
        {id: 2, value: 'two'},
      ],
    },
  ],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component implementation that performs shallow copy operations with error handling. Uses shared runtime utilities and returns an array or null based on operation success.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-with-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {shallowCopy, throwInput} = require('shared-runtime');

function Component(props) {
  let x = [];
  try {
    const y = shallowCopy({});
    if (y == null) {
      return;
    }
    x.push(throwInput(y));
  } catch {
    return null;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing React Function with Infinite Loop and Variable Declaration
DESCRIPTION: This code snippet defines a React function 'useFoo' that contains an infinite while loop with a variable declaration inside. The function will never terminate due to the constant true condition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/loop-unused-let.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo() {
  while (1) {
    let foo;
  }
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that initializes an empty array and contains an unused break loop. Exports a fixture entry point for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const x = [];
  for (const item of [1, 2]) {
    break;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component with Switch Statement
DESCRIPTION: This React component takes props and uses a switch statement based on `props.p0` to manipulate an array `x`.  It conditionally pushes `props.p2` and `props.p3` into `x`. The component then renders a child component with modified array. It returns another component with `child` as children.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [];
  let y;
  switch (props.p0) {
    case true: {
      x.push(props.p2);
      x.push(props.p3);
      y = [];
    }
    case false: {
      y = x;
      break;
    }
  }
  const child = <Component data={x} />;
  y.push(props.p4);
  return <Component data={y}>{child}</Component>;
}
```

----------------------------------------

TITLE: Defining Function and Using Local State in React
DESCRIPTION: This code snippet defines a functional component 'Foo' that utilizes a closure to manage a variable 'x' and returns a 'Stringify' component with the 'getX' function passed as a prop. The purpose is to demonstrate how to capture local state and behavior in a React component. It showcases the importance of variable declarations before usage, as accessing 'x' before initialization can lead to exceptions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-invalid-tdz-let.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {
  const getX = () => x;
  console.log(getX());

  let x = 4;
  x += 5;

  return <Stringify getX={getX} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Implementing React Component with Destructuring in JavaScript
DESCRIPTION: This snippet defines a function 'foo' that takes props as an argument, uses object destructuring to extract values, and performs some operations. It also includes a FIXTURE_ENTRYPOINT export for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-direct-reassignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let x, y;
  ({x, y} = {x: props.a, y: props.b});
  console.log(x); // prevent DCE from eliminating `x` altogether
  x = props.c;
  return x + y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component Definition with Ref
DESCRIPTION: Defines a React component `Foo` that accepts `props` and a `ref`. It conditionally renders a `Stringify` component based on `CONST_TRUE` and attempts to access the `ref` within the render function.  The fixture entry point provides example parameters for the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.repro-ref-mutable-range.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify, identity, mutate, CONST_TRUE} from 'shared-runtime';

function Foo(props, ref) {
  const value = {};
  if (CONST_TRUE) {
    mutate(value);
    return <Stringify ref={ref} />;
  }
  mutate(value);
  if (CONST_TRUE) {
    return <Stringify ref={identity(ref)} />;
  }
  return value;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}, {current: 'fake-ref-object'}],
};

```

----------------------------------------

TITLE: React Flow Type Alias Input Code
DESCRIPTION: Original Flow-typed code showing type alias usage and function annotations. Defines a Bar type alias as string and demonstrates its usage in a function parameter annotation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-variable-annotation_.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
type Bar = string;
function TypeAliasUsedAsAnnotation() {
  type Foo = Bar;
  const fun = f => {
    let g: Foo = f;
    console.log(g);
  };
  fun('hello, world');
}

export const FIXTURE_ENTRYPOINT = {
  fn: TypeAliasUsedAsAnnotation,
  params: [],
};
```

----------------------------------------

TITLE: Flow-Typed React Component Input
DESCRIPTION: Original React component implementation using Flow type annotations. Defines a Component that takes props with an id number and returns a value from an array construction.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-var-array_.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableUseTypeAnnotations
import {identity} from 'shared-runtime';

function Component(props: {id: number}) {
  const x: Array<number> = makeArray(props.id);
  const y = x.at(0);
  return y;
}

function makeArray<T>(x: T): Array<T> {
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 42}],
};
```

----------------------------------------

TITLE: React Component Definition with useHook
DESCRIPTION: This React component utilizes the `useHook` function from the `shared-runtime` module.  The hook call is intentionally interspersed within the component's logic to prevent memoization of the 'x' variable. The component accepts 'props' as input, specifically expecting a 'value' property, and returns a nested array containing this value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useHook} from 'shared-runtime';

function Component(props) {
  const x = [];
  useHook(); // intersperse a hook call to prevent memoization of x
  x.push(props.value);

  const y = [x];

  return [y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'sathya'}],
};
```

----------------------------------------

TITLE: Implementing FBT Localization in React Component
DESCRIPTION: React component implementation showing FBT usage for text localization. The code demonstrates parameter interpolation for dynamic text but encounters an issue with local variable naming that conflicts with the FBT transform.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-fbt-as-local.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';
import {identity} from 'shared-runtime';

/**
 * Note that the fbt transform looks for callsites with a `fbt`-named callee.
 * This is incompatible with react-compiler as we rename local variables in
 * HIRBuilder + RenameVariables.
 *
 * See evaluator error:
 *   Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok) <div>Hello, Sathya!Goodbye, Sathya!</div>
 *   Forget:
 *   (kind: exception) fbt$0.param is not a function
 */

function Foo(props) {
  const getText1 = fbt =>
    fbt(
      `Hello, ${fbt.param('(key) name', identity(props.name))}!`,
      '(description) Greeting'
    );

  const getText2 = fbt =>
    fbt(
      `Goodbye, ${fbt.param('(key) name', identity(props.name))}!`,
      '(description) Greeting2'
    );

  return (
    <div>
      {getText1(fbt)}
      {getText2(fbt)}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{name: 'Sathya'}],
};
```

----------------------------------------

TITLE: Using Identity with Conditional Returns - JavaScript
DESCRIPTION: Defines a function 'useFoo' that processes an input with a conditional check, utilizing 'identity' from a shared runtime. The function constructs an array based on conditions, interacting with external identity functions. Dependencies include 'shared-runtime'. Takes an object with 'input' and 'cond'. Returns null if 'cond' is true or an array derived from 'input'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-poisons-outer-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import {identity} from 'shared-runtime';

function useFoo({input, cond}) {
  const x = [];
  if (cond) {
    return null;
  }
  x.push(identity(input.a.b));
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {a: {b: 2}}, cond: false}],
  sequentialRenders: [
    {input: {a: {b: 2}}, cond: false},
    // preserve nullthrows
    {input: null, cond: false},
    {input: null, cond: true},
    {input: {}, cond: false},
    {input: {a: {b: null}}, cond: false},
    {input: {a: null}, cond: false},
    {input: {a: {b: 3}}, cond: false},
  ],
};
```

----------------------------------------

TITLE: Implementing Color Selection Logic in React Hook
DESCRIPTION: This snippet defines a custom React hook 'useFoo' that selects colors based on global variables 'isSelected' and 'isCurrent'. It loops 6 times, logging the selected color each time. The hook is exported as part of a fixture for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-let-undefined-decl.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// These variables are unknown to useFoo, as they are
// defined at module scope or implicit globals
const isSelected = false;
const isCurrent = true;

function useFoo() {
  for (let i = 0; i <= 5; i++) {
    let color;
    if (isSelected) {
      color = isCurrent ? "#FFCC22" : "#FF5050";
    } else {
      color = isCurrent ? "#CCFF03" : "#CCCCCC";
    }

    console.log(color);
  }
}

export const FIXTURE_ENTRYPOINT = {
  params: [],
  fn: useFoo,
};
```

----------------------------------------

TITLE: Input React Component with Parameter Destructuring
DESCRIPTION: Original React component implementation showing parameter destructuring with rest parameters. The component takes a foo parameter and destructures a bar property from the rest parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-object-spread-pattern.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(foo, ...{bar}) {
  return [foo, bar];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['foo', {bar: 'bar'}],
};
```

----------------------------------------

TITLE: Initializing React Component with GraphQL Fragment
DESCRIPTION: Uses useFragment hook to extract user name from a GraphQL fragment, retrieving data from props and returning the user's name
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/tagged-template-in-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useFragment} from 'shared-runtime';

function Component(props) {
  const user = useFragment(
    graphql`
      fragment F on User {
        name
      }
    `,
    props.user
  );
  return user.name;
}
```

LANGUAGE: javascript
CODE:
```
import { useFragment } from "shared-runtime";

function Component(props) {
  const user = useFragment(
    graphql`
      fragment F on User {
        name
      }
    `,
    props.user,
  );
  return user.name;
}
```

----------------------------------------

TITLE: Switch Case for Value Assignment in React Component
DESCRIPTION: This snippet implements a React functional component that uses a switch case statement to determine the appropriate value to return based on a prop key. It illustrates an alternate approach without using hooks, relying on traditional variable assignment in a control structure to achieve similar functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-switch-no-fallthrough.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let t0;
  bb0: switch (props.key) {
    case "key": {
      t0 = props.value;
      break bb0;
    }
    default: {
      t0 = props.defaultValue;
    }
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Defining useFoo React Component with Mutate
DESCRIPTION: This code defines a React component `useFoo` that takes props as input and conditionally pushes values into an array named `x`. It utilizes a `mutate` function, presumably for state management or side effects. The `FIXTURE_ENTRYPOINT` provides configuration for testing, including initial parameters and sequential renders with different prop values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function useFoo(props) {
  let x = [];
  x.push(props.bar);
  if (props.cond) {
    x = {};
    x = [];
    x.push(props.foo);
  }
  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{bar: 'bar', foo: 'foo', cond: true}],
  sequentialRenders: [
    {bar: 'bar', foo: 'foo', cond: true},
    {bar: 'bar', foo: 'foo', cond: true},
    {bar: 'bar', foo: 'foo', cond: false},
  ],
};

```

----------------------------------------

TITLE: Using useRef and useEffect in React Component
DESCRIPTION: This snippet illustrates the use of React's useRef and useEffect hooks to manipulate a ref and state within a functional component. It forces a re-render to ensure the useEffect executes as expected. Dependencies include React and usage of hooks from React library. Inputs include initial component parameters, and it outputs the rendered component with potential ref updates visible in the child component. The primary constraint is violating React's rules by accessing a ref in a child component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-unused-callback-nested.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
import {useEffect, useRef, useState} from 'react';

function Component() {
  const ref = useRef(null);
  const [state, setState] = useState(false);
  useEffect(() => {
    const callback = () => {
      ref.current = 'Ok';
    };
  }, []);

  useEffect(() => {
    setState(true);
  }, []);

  // We use state to force a re-render and observe whether the
  // ref updated. This lets us check that the effect actually ran
  // and wasn't DCE'd
  return <Child key={String(state)} ref={ref} />;
}

function Child({ref}) {
  // This violates the rules of React, so we access the ref in a child
  // component
  return ref.current;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Defining React Component and Fixture Entrypoint - JavaScript
DESCRIPTION: Defines a React component that processes props and maps over an internal array. It exports a FIXTURE_ENTRYPOINT object which serves as the entry point for testing or execution. The component doesn't depend on props values and focuses on creating and returning a tuple of arrays.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-frozen-array.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
"function Component(props) {\n  const x = [];\n  <dif>{x}</dif>;\n  const y = x.map(item => item);\n  return [x, y];\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};"
```

----------------------------------------

TITLE: Optimizing HomeDiscoStoreItemTileRating Component with Compiler-Generated Code
DESCRIPTION: This snippet demonstrates the optimized version of the HomeDiscoStoreItemTileRating component. It uses compiler-generated code to implement memoization and conditional rendering, potentially improving performance by avoiding unnecessary recalculations and re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-scope-missing-mutable-range.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function HomeDiscoStoreItemTileRating(props) {
  const $ = _c(4);
  const item = useFragment();
  let count;
  if ($[0] !== item?.aggregates) {
    count = 0;
    const aggregates = item?.aggregates || [];
    aggregates.forEach((aggregate) => {
      count = count + (aggregate.count || 0);
      count;
    });
    $[0] = item?.aggregates;
    $[1] = count;
  } else {
    count = $[1];
  }
  let t0;
  if ($[2] !== count) {
    t0 = <Text>{count}</Text>;
    $[2] = count;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}
```

----------------------------------------

TITLE: Initial React Component Implementation in JavaScript
DESCRIPTION: This snippet shows the initial implementation of a React component with unnecessary operations. It takes a prop 'i', performs some redundant operations, and returns the value of 'i'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-prefix-update.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let i = 0;
  --i;
  i = props.i;
  return i;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{i: 42}],
};
```

----------------------------------------

TITLE: React Component with Compiler Optimization
DESCRIPTION: This code defines a React component named `Component` that conditionally returns an array, optimized using the React compiler. It uses `_c` from `react/compiler-runtime` for memoization. If the props `a`, `b`, or `cond` change, it re-computes the return value, otherwise using a cached version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

function Component(props) {
  const $ = _c(6);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const x = [];
      if (props.cond) {
        x.push(props.a);
        t0 = x;
        break bb0;
      } else {
        let t1;
        if ($[4] !== props.b) {
          t1 = makeArray(props.b);
          $[4] = props.b;
          $[5] = t1;
        } else {
          t1 = $[5];
        }
        t0 = t1;
        break bb0;
      }
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.cond;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    // pattern 1
    { cond: true, a: 42 },
    { cond: true, a: 42 },
    // pattern 2
    { cond: false, b: 3.14 },
    { cond: false, b: 3.14 },
    // pattern 1
    { cond: true, a: 42 },
    // pattern 2
    { cond: false, b: 3.14 },
    // pattern 1
    { cond: true, a: 42 },
    // pattern 2
    { cond: false, b: 3.14 },
  ],
};

```

----------------------------------------

TITLE: Using Memoization in React Component - JavaScript
DESCRIPTION: This snippet illustrates a React functional component that utilizes memoization to cache computation results. The component checks for a cached value and either returns it or creates a new object. It uses the 'react/compiler-runtime' for the memoization logic and exports a similar FIXTURE_ENTRYPOINT.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-objectexpression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { a: 1, b: 2 };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Accessing import.meta Properties in JavaScript Functions
DESCRIPTION: This code snippet defines four functions that demonstrate different ways of interacting with the import.meta object. Function 'a' returns the import.meta.url directly, while functions 'b', 'c', and 'd' use conditional statements to check various properties of import.meta.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function a() {
  return import.meta.url;
}

function b() {
  let a = 0;
  if (import.meta.url) {
    a = 1;
  }
  return a;
}

function c() {
  let a = 0;
  if (import.meta.foo) {
    a = 1;
  }
  return a;
}

function d() {
  let a = 0;
  if (import.meta) {
    a = 1;
  }
  return a;
}
```

----------------------------------------

TITLE: Input Example of React useEffect with Pruned Non-Reactive Values
DESCRIPTION: Example React component demonstrating a scenario where semantically non-reactive values have pruned scopes due to interleaving hook calls. The code shows how the React compiler needs to handle effect dependencies for such cases.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/pruned-nonreactive-obj.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useIdentity, mutate, makeObject} from 'shared-runtime';
import {useEffect} from 'react';

/**
 * When a semantically non-reactive value has a pruned scope (i.e. the object
 * identity becomes reactive, but the underlying value it represents should be
 * constant), the compiler can choose to either
 * - add it as a dependency (and rerun the effect)
 * - not add it as a dependency
 *
 * We keep semantically non-reactive values in both memo block and effect
 * dependency arrays to avoid versioning invariants e.g. `x !== y.aliasedX`.
 * ```js
 * function Component() {
 *   // obj is semantically non-reactive, but its memo scope is pruned due to
 *   // the interleaving hook call
 *   const obj = {};
 *   useHook();
 *   write(obj);
 *
 *   const ref = useRef();
 *
 *   // this effect needs to be rerun when obj's referential identity changes,
 *   // because it might alias obj to a useRef / mutable store.
 *   useEffect(() => ref.current = obj, ???);
 *
 *   // in a custom hook (or child component), the user might expect versioning
 *   // invariants to hold
 *   useHook(ref, obj);
 * }
 *
 * // defined elsewhere
 * function useHook(someRef, obj) {
 *   useEffect(
 *     () => assert(someRef.current === obj),
 *     [someRef, obj]
 *   );
 * }
 * ```
 */
function PrunedNonReactive() {
  const obj = makeObject();
  useIdentity(null);
  mutate(obj);

  useEffect(() => print(obj.value));
}
```

----------------------------------------

TITLE: Creating Component with Incorrect Hook Usage in React
DESCRIPTION: This JavaScript snippet demonstrates an improper use of the React Hook useState within a callback function. This is a common error as hooks must be called at the top level of a function component or a custom hook as per the Rules of Hooks. No specific dependencies are required, but it's assumed that React is being used. The intended input is a functional component, and the erroneous output is an InvalidReact error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-449a37146a83.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Invalid because it's a common misunderstanding.\n// We *could* make it valid but the runtime error could be confusing.\nfunction createComponent() {\n  return function ComponentWithHookInsideCallback() {\n    function handleClick() {\n      useState();\n    }\n  };\n}
```

----------------------------------------

TITLE: Input React Component with Conditionally Selected Ref in useEffect
DESCRIPTION: A React component that demonstrates a case where ref selection depends on props, making the ref reactive despite refs typically being stable. The component conditionally selects between two refs based on a prop value and uses the selected ref in an effect.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-ref.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect, useRef} from 'react';
import {print} from 'shared-runtime';

/*
 * Ref types are not enough to determine to omit from deps. Must also take reactivity into account.
 */
function ReactiveRefInEffect(props) {
  const ref1 = useRef('initial value');
  const ref2 = useRef('initial value');
  let ref;
  if (props.foo) {
    ref = ref1;
  } else {
    ref = ref2;
  }
  useEffect(() => print(ref));
}
```

----------------------------------------

TITLE: Defining React Hook with Dependency Tracking
DESCRIPTION: This snippet defines a React hook `useFoo` that takes props as input and returns an array. It utilizes conditional logic based on `props.cond` to push either `props.foo` or `props.bar` into the array. The hook is designed to showcase dependency propagation in HIR.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-ternary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond
    ? ((x = {}), (x = []), x.push(props.foo))
    : ((x = []), (x = []), x.push(props.bar));
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};

```

----------------------------------------

TITLE: Original React Component with Feature Flag Styling
DESCRIPTION: A React component that conditionally applies styles based on a feature flag. Uses stylex for styling and includes flow type checking. The component demonstrates conditional class name assignment using feature flags.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonreactive-noescaping-dependency-can-inline-into-consuming-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow
function Component() {
  return (
    <div
      className={stylex(
        // this value is a) in its own scope, b) non-reactive, and c) non-escaping
        // its scope gets pruned bc it's non-escaping, but this doesn't mean we need to
        // create a temporary for it
        flags.feature('feature-name') ? styles.featureNameStyle : null
      )}></div>
  );
}
```

----------------------------------------

TITLE: Compiled React Component using Compiler-Runtime
DESCRIPTION: This snippet shows the compiled version of the React component, making use of `react/compiler-runtime` for optimization.  The `_c` function seems to be used for memoization of the `Stringify` component's output, preventing unnecessary re-renders. It checks for a sentinel value in a cache and conditionally renders the component based on whether the output is cached.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-default-to-true.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Stringify truthyAttribute={true} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: Original React Component Implementation (JavaScript)
DESCRIPTION: This snippet shows the original implementation of the 'useFoo' component before compilation. It defines a function that returns a 'Stringify' component with a nested object containing a function accessing nested properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-object-method-uncond-access.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR

import {identity, Stringify} from 'shared-runtime';

function useFoo({a}) {
  const x = {
    fn() {
      return identity(a.b.c);
    },
  };
  return <Stringify x={x} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: null}],
  sequentialRenders: [{a: null}, {a: {b: {c: 4}}}],
};
```

----------------------------------------

TITLE: Initializing React Component with useMemo
DESCRIPTION: A React functional component using useMemo to memoize a mutation operation with empty dependency array
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-return-empty.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let x = useMemo(() => {
    mutate(a);
  }, []);
  return x;
}
```

----------------------------------------

TITLE: Original Input Function with Object and Array Manipulation
DESCRIPTION: A JavaScript function creating an object, array, and performing mutations with aliasing. Demonstrates basic object and array interactions before compiler transformation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const a = {};
  const y = a;
  const x = [];

  y.x = x;

  mutate(a); // y & x are aliased to a
  return y;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization - JavaScript
DESCRIPTION: This snippet shows a more complex React component that uses memoization for performance. It checks if the cached value corresponds to the previous props, updating the cache only when necessary, and utilizes a function `_c` from React's compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-call-as-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = makeObject();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  let t1;
  if ($[1] !== props) {
    t1 = x?.[foo(props.value)];
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows the optimized version of the Component function using React's compiler runtime. It implements memoization to cache the result of the 'foo' method call, potentially improving performance for repeated renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-object-method.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const object = {
      foo() {
        try {
          return [];
        } catch (t1) {
          return;
        }
      },
    };

    t0 = object.foo();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Hook Implementation With Compiler Memoization Applied
DESCRIPTION: The optimized version of useFoo hook with React Compiler's memoization. It uses the _c runtime function to create a cache array and only recalculates values when dependencies change, demonstrating React's optimization strategy for reducing redundant computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-destruction-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    x = [];
    x.push(props.bar);
    props.cond ? (([x] = [[]]), x.push(props.foo)) : null;
    mutate(x);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};
```

----------------------------------------

TITLE: Optimizing Component with Compiler Runtime - React JavaScript
DESCRIPTION: In this more optimized version, the 'Component' function utilizes 'react/compiler-runtime' to memoize and efficiently track changes in props and items across re-renders. It allows for reduced computational overhead, particularly beneficial for frequently updated React components. Dependencies include the 'react/compiler-runtime' library. Initial parameters involve an object with a nested 'id' property, ensuring component utility consistency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-captures-receiver-noAlias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(6);
  let t0;
  if ($[0] !== props.a) {
    t0 = { a: props.a };
    $[0] = props.a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const item = t0;
  let t1;
  if ($[2] !== item) {
    t1 = [item];
    $[2] = item;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const items = t1;
  let t2;
  if ($[4] !== items) {
    t2 = items.map(_temp);
    $[4] = items;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const mapped = t2;
  return mapped;
}
function _temp(item_0) {
  return item_0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: { id: 42 } }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized Component with Memoization
DESCRIPTION: This code snippet optimizes a React component by using memoization to avoid unnecessary calculations. It checks previous props and states, only updating when there's a change. It utilizes the internal state `$` to hold previous values, ensuring efficiency in rendering data and computing the count.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-reactive-via-mutation-of-computed-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(8);
  let items;
  if ($[0] !== props.a || $[1] !== props.key) {
    items = bar();
    mutate(items[props.key], props.a);
    $[0] = props.a;
    $[1] = props.key;
    $[2] = items;
  } else {
    items = $[2];
  }

  const t0 = items.length + 1;
  let t1;
  if ($[3] !== t0) {
    t1 = foo(t0);
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const count = t1;
  let t2;
  if ($[5] !== count || $[6] !== items) {
    t2 = { items, count };
    $[5] = count;
    $[6] = items;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  return t2;
}

```

----------------------------------------

TITLE: Managing Dependencies in a React Component - JavaScript
DESCRIPTION: This snippet defines a React component function 'Foo' that conditionally renders an element based on the input properties 'cond' and 'value'. It uses 'identity' and 'Stringify' from 'shared-runtime' for processing and rendering. The component tracks state to optimize re-renders by checking if the dependencies have changed. The entry point 'FIXTURE_ENTRYPOINT' specifies parameters for executing the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-component-props-non-null.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR\nimport {identity, Stringify} from 'shared-runtime';\n\nfunction Foo(props) {\n  /**\n   * props.value should be inferred as the dependency of this scope\n   * since we know that props is safe to read from (i.e. non-null)\n   * as it is arg[0] of a component function\n   */\n  const arr = [];\n  if (props.cond) {\n    arr.push(identity(props.value));\n  }\n  return <Stringify arr={arr} />;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{value: 2, cond: true}],\n};\n
```

----------------------------------------

TITLE: Optimized React Component with Memoization Using React Compiler Runtime
DESCRIPTION: The same component after being processed by the React compiler, implementing memoization to avoid redundant computations and renders. Uses an imported runtime helper _c to manage a cache array of previous values and dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/interdependent.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * Should produce 1 scope:
 *
 * return: inputs=props.a & props.b; outputs=return
 *   const a = compute(props.a);
 *   const b = compute(props.b);
 *   foo(a, b);
 *   return = <Foo a={a} b={b} />
 */
function Component(props) {
  const $ = _c(7);
  let a;
  let b;
  if ($[0] !== props.a || $[1] !== props.b) {
    a = compute(props.a);
    b = compute(props.b);
    foo(a, b);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = a;
    $[3] = b;
  } else {
    a = $[2];
    b = $[3];
  }
  let t0;
  if ($[4] !== a || $[5] !== b) {
    t0 = <Foo a={a} b={b} />;
    $[4] = a;
    $[5] = b;
    $[6] = t0;
  } else {
    t0 = $[6];
  }
  return t0;
}

function compute() {}
function foo() {}
function Foo() {}
```

----------------------------------------

TITLE: Defining React Component with Stringify
DESCRIPTION: This snippet defines a React function component 'useFoo' that takes an object with a property 'a'. It returns a Stringify component that attempts to render a nested property path. It ensures the function is invoked only when dependencies change, as managed by the imported compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/todo-infer-function-uncond-optionals-hoisted.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR

import {Stringify} from 'shared-runtime';

function useFoo({a}) {
  return <Stringify fn={() => a.b?.c.d?.e} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: null}],
  sequentialRenders: [
    {a: null},
    {a: {b: null}},
    {a: {b: {c: {d: null}}}},
    {a: {b: {c: {d: {e: 4}}}}},
  ],
};

```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This React component optimizes rendering performance by caching previous render states and minimizing calls to expensive operations. It uses a synthesized compiler_runtime mechanism provided by \\"react/compiler-runtime\\" to track and conditionally update parts of the component's logic based on changes to props. This approach efficiently manages state with array indexing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-prototype-call-mutating.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { ValidateMemoization } from "shared-runtime";

function Component(props) {
  const $ = _c(7);
  let t0;
  let a;
  if ($[0] !== props.name) {
    a = [];
    const f = function () {
      a.push(props.name);
    };

    f.call();
    $[0] = props.name;
    $[1] = a;
  } else {
    a = $[1];
  }
  t0 = a;
  const a_0 = t0;
  let t1;
  if ($[2] !== props.name) {
    t1 = [props.name];
    $[2] = props.name;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== a_0 || $[5] !== t1) {
    t2 = <ValidateMemoization inputs={t1} output={a_0} />;
    $[4] = a_0;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Jason" }],
  sequentialRenders: [
    { name: "Lauren" },
    { name: "Lauren" },
    { name: "Jason" },
  ],
};
```

----------------------------------------

TITLE: Implementing Original React Component Function in JavaScript
DESCRIPTION: This snippet defines a function 'foo' that manipulates arrays based on input parameters. It also exports a FIXTURE_ENTRYPOINT object for component testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dependencies.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(x, y, z) {
  const items = [z];
  items.push(x);

  const items2 = [];
  if (x) {
    items2.push(y);
  }

  if (y) {
    items.push(x);
  }

  return items2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Original React Component Definition
DESCRIPTION: A React component that manipulates arrays based on props and returns a recursive component call. It demonstrates mutation patterns that might require special handling during compilation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment-conditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [];
  x.push(props.p0);
  let y = x;

  if (props.p1) {
    x = [];
  }

  y.push(props.p2);

  return <Component x={x} y={y} />;
}
```

----------------------------------------

TITLE: Implementing a Component with Memoization in React
DESCRIPTION: This snippet implements a React component 'Component' that leverages a custom renderer for optimization using '_c' from 'react/compiler-runtime'. It optimizes rendering based on the props and internal state, which helps to avoid unnecessary updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-separate-nested.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableJsxOutlining
function Component(t0) {
  const $ = _c(7);
  const { arr } = t0;
  const x = useX();
  let t1;
  if ($[0] !== arr || $[1] !== x) {
    let t2;
    if ($[3] !== x) {
      t2 = (i, id) => {
        const T0 = _temp;
        return <T0 i={i} j={i} k={i} key={id} x={x} />;
      };
      $[3] = x;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    t1 = arr.map(t2);
    $[0] = arr;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = <>{t1}</>;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
function _temp(t0) {
  const $ = _c(11);
  const { i: i, j: j, k: k, x: x } = t0;
  let t1;
  if ($[0] !== i) {
    t1 = <Baz i={i} />;
    $[0] = i;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== j) {
    t2 = <Joe j={j} />;
    $[2] = j;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== k) {
    t3 = <Foo k={k} />;
    $[4] = k;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== t1 || $[7] !== t2 || $[8] !== t3 || $[9] !== x) {
    t4 = (
      <Bar x={x}>
        {t1}
        {t2}
        {t3}
      </Bar>
    );
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
    $[9] = x;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  return t4;
}

function Bar(t0) {
  const $ = _c(3);
  const { x, children } = t0;
  let t1;
  if ($[0] !== children || $[1] !== x) {
    t1 = (
      <>
        {x}
        {children}
      </>
    );
    $[0] = children;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Baz(t0) {
  const { i } = t0;
  return i;
}

function Joe(t0) {
  const { j } = t0;
  return j;
}

function Foo(t0) {
  const { k } = t0;
  return k;
}

function useX() {
  return "x";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arr: ["foo", "bar"] }],
};

```

----------------------------------------

TITLE: Using Simple Assignment in Custom React Hook
DESCRIPTION: This snippet shows an alternative implementation of the useFoo function without using useMemo. Instead, it performs a direct assignment of the identity result based on the input parameter x. This may not offer the same performance benefits as memoization, but serves as a baseline for understanding the function's behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";
import { identity } from "shared-runtime";

/**
 * This is technically a false positive, although it makes sense
 * to bailout as source code might be doing something sketchy.
 */
function useFoo(x) {
  let t0;
  t0 = identity(x);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [2],
};

```

----------------------------------------

TITLE: Implementing Increment/Decrement Operations with Flow in React
DESCRIPTION: This snippet defines a Foo component using Flow type annotations. It demonstrates pre-increment, post-increment, and decrement operations on an object property, logging the results at various stages. The code also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/member-inc.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
//@flow

component Foo() {
  let x = {a: 1};
  x.a++;
  x.a--;
  console.log(++x.a);
  console.log(x.a++);

  console.log(x.a);
  let y = x.a++;
  console.log(y);
  console.log(x.a);

  console.log((++x.a).toString(), (x.a++).toString(), x.a);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Using Compiler Runtime for State Management in Custom React Hook - JavaScript
DESCRIPTION: This snippet enhances the previous hook by incorporating a compiler runtime utility to manage state updates efficiently. It ensures that state is only updated when necessary by comparing previous values. This custom hook also requires React and shared runtime imports. The output behavior remains similar, where functions can be invoked to access current state values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-nested.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState } from "react";
import { createHookWrapper } from "shared-runtime";

function useHook(t0) {
  const $ = _c(3);
  const { value } = t0;
  const [state] = useState(false);
  let t1;
  if ($[0] !== state || $[1] !== value) {
    t1 = {
      getX() {
        return {
          a: [],
          getY() {
            return value;
          },
          state,
        };
      },
    };
    $[0] = state;
    $[1] = value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ value: 0 }],
};
```

----------------------------------------

TITLE: Implementing a Reactive Component with React Boilerplate
DESCRIPTION: This snippet builds upon the previous component, introducing a mechanism to store and compare state-like values using an array `$`. The goal is to optimize re-computation of rendered output. It showcases the integration of a React-like runtime to track changes and store computed outputs in `t0`. This requires a React environment or runtime support to execute.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  for (let i = 0; i < props.test; i++) {
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { test: 12 },
    { test: 12 },
    { test: 1 },
    { test: 1 },
    { test: 12 },
    { test: 1 },
    { test: 12 },
    { test: 1 },
  ],
};
```

----------------------------------------

TITLE: Original Function Implementation
DESCRIPTION: Original JavaScript function that conditionally creates and modifies objects based on input parameter 'a'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-if-else-with-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  let x = someObj();
  if (a) {
    const y = someObj();
    const z = y;
    x = z;
  } else {
    x = someObj();
  }

  x.f = 1;
  return x;
}
```

----------------------------------------

TITLE: React Component with fire function
DESCRIPTION: This code defines a React component that uses the `fire` function from 'react' within a `useEffect` hook. The `fire` function is called with the result of invoking `foo` with the component's props, effectively triggering a side effect when the props or `foo` function change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/rewrite-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = props => {
    console.log(props);
  };
  useEffect(() => {
    fire(foo(props));
  }, [foo, props]);

  return null;
}

```

----------------------------------------

TITLE: Defining a Basic React Component in JavaScript
DESCRIPTION: This snippet defines a simple React component function using JavaScript. It creates an object and applies a function on the same object, showcasing basic component structure. No special dependencies are required beyond standard JavaScript and React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-args-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Component(props) {
  let x = makeObject();
  x.foo((x = makeObject()));
  return x;
}

```

----------------------------------------

TITLE: Defining React Functional Component - Advanced Version with React Compiler Runtime
DESCRIPTION: This JavaScript snippet enhances the previous component by integrating the React/compiler-runtime. It introduces memoization logic to avoid recalculating the object unless its reference changes. It maintains the same export structure for testing with a sample 'foo' implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisted-function-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let t;
  if ($[0] !== a) {
    t = { a };
    x(t);
    function x(p) {
      p.a.foo();
    }
    $[0] = a;
    $[1] = t;
  } else {
    t = $[1];
  }
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [
    {
      foo: () => {
        console.log(42);
      },
    },
  ],
};
```

----------------------------------------

TITLE: Using Custom Hook with State Management in JavaScript
DESCRIPTION: This snippet defines a custom React hook that takes an object with a value, mutates it using shared runtime methods, and returns an object with a method to get the current value. It leverages the 'mutateAndReturn' function to manage state changes and stores the value in an internal state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-mutated-after.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper, mutate, mutateAndReturn} from 'shared-runtime';
function useHook({value}) {
  const x = mutateAndReturn({value});
  const obj = {
    getValue() {
      return x;
    },
  };
  mutate(obj);
  return obj;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{value: 0}],
};
```

----------------------------------------

TITLE: Using setProperty in Conditional State Management - JavaScript
DESCRIPTION: This snippet defines the useFoo function which takes an object containing 'o' (with a numeric value) and 'branchCheck' (a boolean) as arguments. It conditionally modifies an object 'x' based on the value of 'branchCheck' and returns 'x'. The dependency 'setProperty' is used to assign values to 'x'. Inputs include the object 'o' with its numeric value and 'branchCheck'. The output is the modified object 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-cfg-nested-testifelse.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {setProperty} from 'shared-runtime';

function useFoo({o, branchCheck}: {o: {value: number}; branchCheck: boolean}) {
  let x = {};
  if (branchCheck) {
    setProperty(x, o.value);
  } else {
    if (o.value) {
      setProperty(x, o.value);
    } else {
      setProperty(x, o.value);
    }
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{o: {value: 2}, branchCheck: false}],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { setProperty } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(3);
  const { o, branchCheck } = t0;
  let x;
  if ($[0] !== branchCheck || $[1] !== o.value) {
    x = {};
    if (branchCheck) {
      setProperty(x, o.value);
    } else {
      if (o.value) {
        setProperty(x, o.value);
      } else {
        setProperty(x, o.value);
      }
    }
    $[0] = branchCheck;
    $[1] = o.value;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ o: { value: 2 }, branchCheck: false }],
};
```

----------------------------------------

TITLE: React Compiler Error Message
DESCRIPTION: An error message from React Compiler showing that it skipped optimizing the component because it couldn't preserve the existing manual memoization. The error points to line 18 where useMemo is used to memoize a potentially mutable value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-missed-memoization-from-capture-in-invoked-function-inferred-as-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  16 |   // We infer that getIsEnabled returns a mutable value, such that
  17 |   // isEnabled is mutable
> 18 |   const isEnabled = useMemo(() => getIsEnabled(), [getIsEnabled]);
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (18:18)
  19 |
  20 |   // We then infer getLoggingData as capturing that mutable value,
  21 |   // so any calls to this function are then inferred as extending
```

----------------------------------------

TITLE: Defining React Component with Mutation Function
DESCRIPTION: This snippet shows a React component that creates an object from props and mutates it. It defines a mutate function that adds an 'updated' flag and sets a key-value pair on the object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-with-store-to-parameter.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const mutate = (object, key, value) => {
    object.updated = true;
    object[key] = value;
  };
  const x = makeObject(props);
  mutate(x);
  return x;
}
```

----------------------------------------

TITLE: React Component with Error Handling and Constant Propagation
DESCRIPTION: Implementation of a React component that demonstrates constant value propagation through try-catch blocks. The component accepts props with a default value but always returns a constant value of 42.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-immediately-throws-after-constant-propagation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = props.default;
  const y = 42;
  try {
    // note: this constant propagates so that we know
    // the handler is unreachable
    return y;
  } catch (e) {
    x = e;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{default: 42}],
};
```

----------------------------------------

TITLE: Improved useFoo Hook with Dependency Management - JavaScript
DESCRIPTION: This snippet improves upon the earlier 'useFoo' implementation by adding state management based on dependencies using an array '$'. The hook checks for changes in the props and either initializes a new state or uses the previous one, improving efficiency. The integration of a conditional state update mechanism ensures that unnecessary updates are minimized, making this version more performant.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-destruction-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { mutate } from "shared-runtime";

function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    x = [];
    x.push(props.bar);
    props.cond ? (([x] = [[]]), x.push(props.foo)) : null;
    mutate(x);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};
```

----------------------------------------

TITLE: Initializing React DevTools Backend with Node.js and Socket.io
DESCRIPTION: This snippet sets up a Node.js server with Socket.io to create a backend for React DevTools. It initializes the DevTools bridge and handles client connections and disconnections.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_8

LANGUAGE: javascript
CODE:
```
const {
  activate,
  createBridge,
  initialize,
} = require('react-devtools-inline/backend');
const { createServer } = require('http');
const SocketIO = require('socket.io');

const server = createServer();
const socket = SocketIO(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"],
    allowedHeaders: [],
    credentials: true
  }
});
socket.on('connection', client => {
  const wall = {
    listen(listener) {
      client.on('message', data => {
        if (data.uid === UID) {
          listener(data);
        }
      });
    },
    send(event, payload) {
      const data = {event, payload, uid: UID};
      client.emit('message', data);
    },
  };

  const bridge = createBridge(global, wall);

  client.on('disconnect', () => {
    bridge.shutdown();
  });

  activate(global, { bridge });
});
socket.listen(PORT);
```

----------------------------------------

TITLE: Defining React Hook useFoo with Aliasing and Mutation
DESCRIPTION: This code defines a React hook named `useFoo` that accepts an object with properties `a` and `b`. Inside the hook, an array `arr` and an object `obj` are created. The array is assigned to a property of the object using `setPropertyByKey`. An alias `obj_alias` is created for `obj`. A callback function `cb` is defined which accesses the length of the array through the alias. The code then pushes elements into the array inside a loop. Finally, it returns a `Stringify` component with the callback and a boolean prop.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-aliased-capture-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableTransitivelyFreezeFunctionExpressions:false
import {setPropertyByKey, Stringify} from 'shared-runtime';

/**
 * Variation of bug in `bug-aliased-capture-aliased-mutate`
 * Found differences in evaluator results
 * Non-forget (expected):
 *   (kind: ok)
 *   <div>{"cb":{"kind":"Function","result":2},"shouldInvokeFns":true}</div>
 *   <div>{"cb":{"kind":"Function","result":3},"shouldInvokeFns":true}</div>
 * Forget:
 *   (kind: ok)
 *   <div>{"cb":{"kind":"Function","result":2},"shouldInvokeFns":true}</div>
 *   <div>{"cb":{"kind":"Function","result":2},"shouldInvokeFns":true}</div>
 */

function useFoo({a}: {a: number, b: number}) {
  const arr = [];
  const obj = {value: a};

  setPropertyByKey(obj, 'arr', arr);
  const obj_alias = obj;
  const cb = () => obj_alias.arr.length;
  for (let i = 0; i < a; i++) {
    arr.push(i);
  }
  return <Stringify cb={cb} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: 2}],
  sequentialRenders: [{a: 2}, {a: 3}],
};

```

----------------------------------------

TITLE: React Component with Pre/Post Increment Operations (Compiled Code)
DESCRIPTION: This code represents a compiled version of the React component from the 'Input' section, likely generated by 'react/compiler-runtime'. The component performs similar pre-increment and post-increment operations on its props. The compiled version includes optimizations and memoization using the `_c` function from 'react/compiler-runtime'. The FIXTURE_ENTRYPOINT object provides the component, test parameters, and specifies that it is not a React Component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0) {
  const $ = _c(10);
  let { a, b: t1, c: t2 } = t0;
  let [b] = t1;
  let { c } = t2;
  const d = a++;
  const e = ++a;
  const f = b--;
  const g = --b;
  const h = c++;
  const i = --c;
  let t3;
  if (
    $[0] !== a ||
    $[1] !== b ||
    $[2] !== c ||
    $[3] !== d ||
    $[4] !== e ||
    $[5] !== f ||
    $[6] !== g ||
    $[7] !== h ||
    $[8] !== i
  ) {
    t3 = [a, b, c, d, e, f, g, h, i];
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = d;
    $[4] = e;
    $[5] = f;
    $[6] = g;
    $[7] = h;
    $[8] = i;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 2, b: [3], c: { c: 4 } }],
  isComponent: false,
};

```

----------------------------------------

TITLE: Input Implementation of useRelayData Hook
DESCRIPTION: Original implementation of useRelayData hook that uses useFragment to process query data. The function takes query and idx parameters and returns a string representation of data at the specified index.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/relay-transitive-mixeddata.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useFragment} from 'shared-runtime';

/**
 * React compiler should infer that the returned value is a primitive and avoid
 * memoizing it.
 */
function useRelayData({query, idx}) {
  'use memo';
  const data = useFragment('', query);
  return data.a[idx].toString();
}

export const FIXTURE_ENTRYPOINT = {
  fn: useRelayData,
  params: [{query: '', idx: 0}],
  sequentialRenders: [
    {query: '', idx: 0},
    {query: '', idx: 0},
    {query: '', idx: 1},
  ],
};
```

----------------------------------------

TITLE: Initializing Component with JavaScript
DESCRIPTION: This snippet defines a simple JavaScript function named 'component' which initializes and manipulates an object. The function exports 'FIXTURE_ENTRYPOINT', indicating its use in a React context. The code requires no external dependencies, focusing solely on object manipulation. Input 'a' is expected, modifying the component's state internally.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-indirect-mutate-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let x = {a};
  const f0 = function () {
    let q = x;
    const f1 = function () {
      q.b = 1;
    };
    f1();
  };
  f0();

  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining a React Hook with Conditional Dependencies
DESCRIPTION: This code defines a React hook `useJoinCondDepsInUncondScopes` that conditionally sets properties of objects `x` and `y` based on the value of `props.a.b`. The purpose is to test how React Forget handles conditional dependencies in inner scopes and whether it propagates them correctly to parent scopes. The hook takes `props` as input, where `props.a.b` is expected to be a value used in the conditional logic and property setting.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/join-uncond-scopes-cond-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// This tests an optimization, NOT a correctness property.
// When propagating reactive dependencies of an inner scope up to its parent,
// we prefer to retain granularity.
//
// In this test, we check that Forget propagates the inner scope's conditional
// dependencies (e.g. props.a.b) instead of only its derived minimal
// unconditional dependencies (e.g. props).
// ```javascript
//  scope @0 (deps=[???] decls=[x, y]) {
//    let y = {};
//    scope @1 (deps=[props] decls=[x]) {
//      let x = {};
//      if (foo) mutate1(x, props.a.b);
//    }
//    mutate2(y, props.a.b);
//  }

import {CONST_TRUE, setProperty} from 'shared-runtime';

function useJoinCondDepsInUncondScopes(props) {
  let y = {};
  let x = {};
  if (CONST_TRUE) {
    setProperty(x, props.a.b);
  }
  setProperty(y, props.a.b);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useJoinCondDepsInUncondScopes,
  params: [{a: {b: 3}}],
};

```

----------------------------------------

TITLE: Defining Basic React Hook using Shared Runtime
DESCRIPTION: This snippet defines a simple React hook, 'useFoo', that imports from 'shared-runtime'. It creates a text element using the value '4' and returns it. No additional parameters are utilized, making it a straightforward implementation of a functional component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-memberexpr-tag.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as SharedRuntime from 'shared-runtime';
function useFoo() {
  const MyLocal = SharedRuntime;
  return <MyLocal.Text value={4} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: Defining a Component with Dependency Extraction - JavaScript
DESCRIPTION: This snippet defines a React component named 'Component' which utilizes functions to mutate props and handle reactive dependencies. It includes important comments about potential pitfalls with state management and optimizations. The dependencies involve several functions from shared-runtime to ensure proper handling of props and state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/aliased-nested-scope-truncated-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import { Stringify, mutate, identity, shallowCopy, setPropertyByKey } from 'shared-runtime';

/**
 * This fixture is similar to `bug-aliased-capture-aliased-mutate` and
 * `nonmutating-capture-in-unsplittable-memo-block`, but with a focus on
 * dependency extraction.
 *
 * NOTE: this fixture is currently valid, but will break with optimizations:
 * - Scope and mutable-range based reordering may move the array creation
 *     *after* the `mutate(aliasedObj)` call. This is invalid if mutate
 *     reassigns inner properties.
 * - RecycleInto or other deeper-equality optimizations may produce invalid
 *     output -- it may compare the array's contents / dependencies too early.
 * - Runtime validation for immutable values will break if `mutate` does
 *     interior mutation of the value captured into the array.
 *
 * Before scope block creation, HIR looks like this:
 *  //
 *  // $1 is unscoped as obj's mutable range will be
 *  // extended in a later pass
 *  //
 *  $1    = LoadLocal obj@0[0:12]
 *  $2    = PropertyLoad $1.id
 *  //
 *  // $3 gets assigned a scope as Array is an allocating
 *  // instruction, but this does *not* get extended or
 *  // merged into the later mutation site.
 *  // (explained in `bug-aliased-capture-aliased-mutate`)
 *  //
 *  $3@1  = Array[$2]
 *  ...
 *  $10@0 = LoadLocal shallowCopy@0[0, 12]
 *  $11   = LoadGlobal mutate
 *  $12   = $11($10@0[0, 12])
 *
 * When filling in scope dependencies, we find that it's incorrect to depend on
 * PropertyLoads from obj as it hasn't completed its mutable range. Following
 * the immutable / mutable-new typing system, we check the identity of obj to
 * detect whether it was newly created (and thus mutable) in this render pass.
 *
 * HIR with scopes looks like this.
 * bb0:
 *  $1    = LoadLocal obj@0[0:12]
 *  $2    = PropertyLoad $1.id
 *  scopeTerminal deps=[obj@0] block=bb1 fallt=bb2
 * bb1:
 *  $3@1  = Array[$2]
 *  goto bb2
 * bb2:
 *  ...
 *
 * This is surprising as deps now is entirely decoupled from temporaries used
 * by the block itself. scope @1's instructions now reference a value (1)
 * produced outside its scope range and (2) not represented in its dependencies
 *
 * The right thing to do is to ensure that all Loads from a value get assigned
 * the value's reactive scope. This also requires track mutating and aliasing
 * separately from scope range. In this example, that would correctly merge
 * the scopes of $3 with obj.
 * Runtime validation and optimizations such as ReactiveGraph-based reordering
 * require this as well.
 *
 * A tempting fix is to instead extend $3's ReactiveScope range up to include
 * $2 (the PropertyLoad). This fixes dependency deduping but not reordering
 * and mutability.
 */
function Component({prop}) {
  let obj = shallowCopy(prop);
  const aliasedObj = identity(obj);

  // [obj.id] currently is assigned its own reactive scope
  const id = [obj.id];

  // Writing to the alias may reassign to previously captured references.
  // The compiler currently produces valid output, but this breaks with
  // reordering, recycleInto, and other potential optimizations.
  mutate(aliasedObj);
  setPropertyByKey(aliasedObj, 'id', prop.id + 1);

  return <Stringify id={id} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{prop: {id: 1}}],
  sequentialRenders: [{prop: {id: 1}}, {prop: {id: 1}}, {prop: {id: 2}}],
};

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import {
  Stringify,
  mutate,
  identity,
  shallowCopy,
  setPropertyByKey,
} from "shared-runtime";

/**
 * This fixture is similar to `bug-aliased-capture-aliased-mutate` and
 * `nonmutating-capture-in-unsplittable-memo-block`, but with a focus on
 * dependency extraction.
 *
 * NOTE: this fixture is currently valid, but will break with optimizations:
 * - Scope and mutable-range based reordering may move the array creation
 *     *after* the `mutate(aliasedObj)` call. This is invalid if mutate
 *     reassigns inner properties.
 * - RecycleInto or other deeper-equality optimizations may produce invalid
 *     output -- it may compare the array's contents / dependencies too early.
 * - Runtime validation for immutable values will break if `mutate` does
 *     interior mutation of the value captured into the array.
 *
 * Before scope block creation, HIR looks like this:
 *  //
 *  // $1 is unscoped as obj's mutable range will be
 *  // extended in a later pass
 *  //
 *  $1    = LoadLocal obj@0[0:12]
 *  $2    = PropertyLoad $1.id
 *  //
 *  // $3 gets assigned a scope as Array is an allocating
 *  // instruction, but this does *not* get extended or
 *  // merged into the later mutation site.
 *  // (explained in `bug-aliased-capture-aliased-mutate`)
 *  //
 *  $3@1  = Array[$2]
 *  ...
 *  $10@0 = LoadLocal shallowCopy@0[0, 12]
 *  $11   = LoadGlobal mutate
 *  $12   = $11($10@0[0, 12])
 *
 * When filling in scope dependencies, we find that it's incorrect to depend on
 * PropertyLoads from obj as it hasn't completed its mutable range. Following
 * the immutable / mutable-new typing system, we check the identity of obj to
 * detect whether it was newly created (and thus mutable) in this render pass.
 *
 * HIR with scopes looks like this.
 * bb0:
 *  $1    = LoadLocal obj@0[0:12]
 *  $2    = PropertyLoad $1.id
 *  scopeTerminal deps=[obj@0] block=bb1 fallt=bb2
 * bb1:
 *  $3@1  = Array[$2]
 *  goto bb2
 * bb2:
 *  ...
 *
 * This is surprising as deps now is entirely decoupled from temporaries used
 * by the block itself. scope @1's instructions now reference a value (1)
 * produced outside its scope range and (2) not represented in its dependencies
 *
 * The right thing to do is to ensure that all Loads from a value get assigned
 * the value's reactive scope. This also requires track mutating and aliasing
 * separately from scope range. In this example, that would correctly merge
 * the scopes of $3 with obj.
 * Runtime validation and optimizations such as ReactiveGraph-based reordering
 * require this as well.
 *
 * A tempting fix is to instead extend $3's ReactiveScope range up to include
 * $2 (the PropertyLoad). This fixes dependency deduping but not reordering
 * and mutability.
 */
function Component(t0) {
  const $ = _c(4);
  const { prop } = t0;
  let t1;
  if ($[0] !== prop) {
    const obj = shallowCopy(prop);
    const aliasedObj = identity(obj);
    let t2;
    if ($[2] !== obj) {
      t2 = [obj.id];
      $[2] = obj;
      $[3] = t2;
    } else {
      t2 = $[3];
    }
    const id = t2;

    mutate(aliasedObj);
    setPropertyByKey(aliasedObj, "id", prop.id + 1);

    t1 = <Stringify id={id} />;
    $[0] = prop;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ prop: { id: 1 } }],
  sequentialRenders: [
    { prop: { id: 1 } },
    { prop: { id: 1 } },
    { prop: { id: 2 } },
  ],
};

```

----------------------------------------

TITLE: Optimized React Component with Context Selectors
DESCRIPTION: Compiled version of the component that uses context selectors for performance optimization. Implements memoization to prevent unnecessary re-renders and includes selector functions for individual context values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-acess-multiple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useContext_withSelector } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @lowerContextAccess
function App() {
  const $ = _c(3);
  const { foo } = useContext_withSelector(MyContext, _temp);
  const { bar } = useContext_withSelector(MyContext, _temp2);
  let t0;
  if ($[0] !== bar || $[1] !== foo) {
    t0 = <Bar foo={foo} bar={bar} />;
    $[0] = bar;
    $[1] = foo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
function _temp2(t0) {
  return [t0.bar];
}
function _temp(t0) {
  return [t0.foo];
}
```

----------------------------------------

TITLE: Running Fizz Fixtures in Production Mode
DESCRIPTION: Command to start Fizz Fixtures in production mode, which pre-builds all static resources and starts a server-side rendering HTTP server without hot reloading.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/fizz/README.md#2025-04-21_snippet_2

LANGUAGE: bash
CODE:
```
yarn start:prod
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This JavaScript code defines an optimized asynchronous React component named `Component` that uses the React compiler runtime (`_c`) to memoize the data fetched based on `props.id`. It checks if the `props.id` has changed since the last render. If it has, it fetches the data, updates the memoized value, and returns the data. Otherwise, it returns the memoized data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/await-side-effecting-promise.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
async function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.id) {
    x = [];
    await populateData(props.id, x);
    $[0] = props.id;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: Defining Original React Component in JavaScript
DESCRIPTION: This snippet defines a React component named 'Component' that returns the result of calling a method 'foo' on an object. The 'foo' method returns an empty array or undefined if an error occurs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-object-method.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const object = {
    foo() {
      try {
        return [];
      } catch (e) {
        return;
      }
    },
  };
  return object.foo();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiler-Optimized Version of the Callback Hook
DESCRIPTION: The compiled version of the useMakeCallback hook, which includes automatic memoization using React's compiler runtime. It caches the callback based on dependencies (obj.value and setState) to avoid unnecessary rerenders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/hook-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper, useIdentity } from "shared-runtime";

/**
 * Assume that functions passed hook arguments are invoked and that their
 * property loads are hoistable.
 */
function useMakeCallback(t0) {
  const $ = _c(3);
  const { obj, setState } = t0;
  let t1;
  if ($[0] !== obj.value || $[1] !== setState) {
    t1 = () => setState(obj.value);
    $[0] = obj.value;
    $[1] = setState;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const cb = useIdentity(t1);
  return cb;
}

const setState = (arg: number) => {
  "use no memo";
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useMakeCallback),
  params: [{ obj: { value: 1 }, setState }],
  sequentialRenders: [
    { obj: { value: 1 }, setState },
    { obj: { value: 2 }, setState },
  ],
};
```

----------------------------------------

TITLE: Initializing JavaScript Objects with Conditional Properties
DESCRIPTION: This function demonstrates object property assignment based on a conditional parameter. It initializes objects and uses conditional statements to assign properties, showing how aliasing works. Dependencies include a 'mutate' function that modifies the objects. The function takes an argument 'a', initializes 'x', and conditionally assigns 'y' or 'z' before returning 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate-inside-if.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function foo(a) {
  const x = {};
  if (a) {
    let y = {};
    x.y = y;
    mutate(y); // aliases x & y, but not z
  } else {
    let z = {};
    x.z = z;
  }
  return x;
}

```

----------------------------------------

TITLE: Enhanced React Component with Compiler Runtime - JavaScript
DESCRIPTION: This snippet showcases an enhanced version of the React component that integrates React's compiler runtime. It optimizes the item handling by leveraging internal state comparisons to minimize re-calculations. The conditionally generated items are either initialized or fetched from a cached state based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/iife-return-modified-later-phi.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(3);
  let items;
  if ($[0] !== props.a || $[1] !== props.cond) {
    let t0;
    if (props.cond) {
      t0 = [];
    } else {
      t0 = null;
    }
    items = t0;

    items?.push(props.a);
    $[0] = props.a;
    $[1] = props.cond;
    $[2] = items;
  } else {
    items = $[2];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: {} }],
};
```

----------------------------------------

TITLE: Basic GraphQL Fragment Component
DESCRIPTION: Simple React component defining a GraphQL fragment with an ID field, without memoization
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/tagged-template-literal.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let t = graphql`
    fragment F on T {
      id
    }
  `;

  return t;
}
```

----------------------------------------

TITLE: Original React Component with Error Handling
DESCRIPTION: Basic React component that attempts to throw an error using throwErrorWithMessage and catches it to return null. Includes a fixture export for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {throwErrorWithMessage} = require('shared-runtime');

function Component(props) {
  let x;
  try {
    x = throwErrorWithMessage('oops');
  } catch {
    x = null;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Compiler Error with Fire Usage
DESCRIPTION: This error message indicates that the `fire` function call was not transformed by the compiler, likely because it's a compiler-required feature and the transformation process failed. The error message suggests either removing the `fire` call or ensuring successful transformation by the compiler. This typically involves configuring the build process to correctly handle the `fire` function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.use-no-memo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  13 |   };
  14 |   useEffect(() => {
> 15 |     fire(foo(props));
     |     ^^^^ InvalidReact: [Fire] Untransformed reference to compiler-required feature. Either remove this `fire` call or ensure it is successfully transformed by the compiler (15:15)
  16 |     fire(foo());
  17 |     fire(bar());
  18 |   });

```

----------------------------------------

TITLE: React Component with Optional Function Call (Input)
DESCRIPTION: This React component demonstrates calling an optional function (`x`) with arguments derived from props and the result of other function calls (`foo`, `bar`). The optional chaining operator (`?.`) ensures that the function is only called if it exists.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeOptionalFunction(props);
  const y = makeObject(props);
  const z = x?.(y.a, props.a, foo(y.b), bar(props.b));
  return z;
}
```

----------------------------------------

TITLE: Compiled Output of React Component with FBT Internationalization
DESCRIPTION: This snippet shows the compiled output of the FBT-enabled React component. It includes performance optimizations such as caching the translated string when the input value doesn't change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-whitespace-around-param-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

const _ = fbt;
function Component(t0) {
  const $ = _c(2);
  const { value } = t0;
  let t1;
  if ($[0] !== value) {
    t1 = fbt._(
      "Before text {paramName} after text",
      [fbt._param("paramName", value)],
      { hk: "26pxNm" },
    );
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "hello world" }],
};
```

----------------------------------------

TITLE: Input FBT Implementation for Pluralization
DESCRIPTION: Original source code showing FBT usage for pluralization and parameter interpolation. Uses the useIdentity hook and handles plural forms of 'is/are' based on item count.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/repro-macro-property-not-handled.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';
import {useIdentity} from 'shared-runtime';

/**
 * MemoizeFbtAndMacroOperandsInSameScope should also track PropertyLoads (e.g. fbt.plural).
 * This doesn't seem to be an issue for fbt, but affects other internal macros invoked as
 * `importSpecifier.funcName` (see https://fburl.com/code/72icxwmn)
 */
function useFoo({items}: {items: Array<number>}) {
  return fbt(
    'There ' +
      fbt.plural('is', useIdentity([...items]).length, {many: 'are'}) +
      ' ' +
      fbt.param('number of items', items.length) +
      ' items',
    'Error content when there are unsupported locales.',
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{items: [2, 3]}],
};
```

----------------------------------------

TITLE: Defining a Custom Hook in React JavaScript
DESCRIPTION: This code snippet defines a custom hook named 'useHook' in a React application. It imports constants and a 'Stringify' component, uses a conditional to modify a number, and outputs a JSX component. A fixture entry point is defined for test purposes. Dependencies include React, 'shared-runtime', and 'compiler-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-reassigned-let-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_NUMBER0, CONST_NUMBER1, Stringify} from 'shared-runtime';

function useHook({cond}) {
  'use memo';
  const getX = () => x;

  let x = CONST_NUMBER0;
  if (cond) {
    x += CONST_NUMBER1;
  }
  return <Stringify getX={getX} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{cond: true}],
  sequentialRenders: [{cond: true}, {cond: true}, {cond: false}],
};

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_NUMBER0, CONST_NUMBER1, Stringify } from "shared-runtime";

function useHook(t0) {
  "use memo";
  const $ = _c(2);
  const { cond } = t0;
  let t1;
  if ($[0] !== cond) {
    const getX = () => x;

    let x;
    x = CONST_NUMBER0;
    if (cond) {
      x = x + CONST_NUMBER1;
      x;
    }

    t1 = <Stringify getX={getX} shouldInvokeFns={true} />;
    $[0] = cond;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ cond: true }],
  sequentialRenders: [{ cond: true }, { cond: true }, { cond: false }],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that creates an array and pushes a prop value into it. Contains a debugger statement and exports a fixture configuration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/debugger-memoized.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [];
  debugger;
  x.push(props.value);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization
DESCRIPTION: Optimized version of the hook using React compiler runtime, implementing memoization and conditional re-computation strategy
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-3.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper, mutate } from "shared-runtime";

function useHook(a) {
  const $ = _c(2);
  let t0;
  if ($[0] !== a) {
    const x = { a };
    const obj = {
      method() {
        mutate(x);
        return x;
      },
    };

    t0 = obj.method();
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ x: 1 }],
};
```

----------------------------------------

TITLE: Defining Unreachable Function with Unconditional Return
DESCRIPTION: A JavaScript function that includes an unconditional return statement preventing subsequent code execution. This example demonstrates a hook function with an unreachable code block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-4f6c78a14bf7.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useUnreachable() {
  return;
  useHook();
}
```

----------------------------------------

TITLE: Compiled React Component with FBT String Optimization
DESCRIPTION: Compiled output of the React component that transforms the JSX-based FBT markup into optimized function calls. It includes memoization logic to prevent unnecessary re-rendering when the input value hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-no-whitespace-btw-text-and-param.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

const _ = fbt;
function Component(t0) {
  const $ = _c(2);
  const { value } = t0;
  let t1;
  if ($[0] !== value) {
    t1 = fbt._(
      "Before text{paramName}After text",
      [fbt._param("paramName", value)],
      { hk: "aKEGX" },
    );
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "hello world" }],
};
```

----------------------------------------

TITLE: Mutating Data with Conditions in JavaScript
DESCRIPTION: This snippet defines a function called useFoo, which uses conditionals to determine how to manipulate an array before calling a mutate function. It requires the "shared-runtime" module, and the expected input includes an object with properties "bar", "foo", and "cond". The output is an array that has been mutated based on the provided conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @enablePropagateDepsInHIR\nimport {mutate} from 'shared-runtime';\n\nfunction useFoo(props) {\n  let x = [];\n  x.push(props.bar);\n  if (props.cond) {\n    x = {};\n    x = [];\n    x.push(props.foo);\n  }\n  mutate(x);\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{bar: 'bar', foo: 'foo', cond: true}],\n  sequentialRenders: [\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: true},\n    {bar: 'bar', foo: 'foo', cond: false},\n  ],\n};\n
```

----------------------------------------

TITLE: Implementing React Component with Console Logging and Object Mutation (Input Version)
DESCRIPTION: This code snippet defines a React component that demonstrates console logging, object mutation, and function invocation patterns. It creates an object with a method, mutates it, and invokes the method while logging various steps.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-call-evaluation-order.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Should print A, B, arg, original
function Component() {
  const changeF = o => {
    o.f = () => console.log('new');
  };
  const x = {
    f: () => console.log('original'),
  };

  (console.log('A'), x)[(console.log('B'), 'f')](
    (changeF(x), console.log('arg'), 1)
  );
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Unreachable Code Error in Function Declaration
DESCRIPTION: An error highlighting issues with function declaration placement and potential hoisting challenges in the code snippet
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoist-function-decls.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
1 | function Component() {
2 |   return get2();
> 3 |   function get2() {
    |   ^^^^^^^^^^^^^^^^^^
> 4 |     return 2;
    | ^^^^^^^^^^^^^
> 5 |   }
    | ^^^^ Todo: Support functions with unreachable code that may contain hoisted declarations (3:5)
6 | }
7 |
```

----------------------------------------

TITLE: Defining Component with Inner Function
DESCRIPTION: A JavaScript function component that contains an inner function get2() which returns a constant value of 2
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoist-function-decls.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  return get2();
  function get2() {
    return 2;
  }
}
```

----------------------------------------

TITLE: Managing Errors and State in React Component
DESCRIPTION: This snippet defines a React functional component that uses functions 'shallowCopy' and 'throwErrorWithMessage' from 'shared-runtime' to manage component state and error handling. The 'Component' function pushes an error message onto an array and uses a shallow copy of an object to handle exceptions. It then exports an object 'FIXTURE_ENTRYPOINT' containing 'Component' as function and parameters for testing. The component expects a 'props' object and outputs an array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-mutate-outer-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
const {shallowCopy, throwErrorWithMessage} = require('shared-runtime');

function Component(props) {
  const x = [];
  try {
    x.push(throwErrorWithMessage('oops'));
  } catch {
    x.push(shallowCopy({a: props.a}));
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1}],
};

```

----------------------------------------

TITLE: React Component Input Implementation
DESCRIPTION: Original React component implementation showing key mutation pattern. The component creates a mutable key object used in a div element's key prop, with mutations happening before and after element creation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-during-jsx-construction.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate, mutateAndReturnNewValue} from 'shared-runtime';

function Component(props) {
  const key = {};
  // Key is modified by the function, but key itself is not frozen
  const element = <div key={mutateAndReturnNewValue(key)}>{props.value}</div>;
  // Key is later mutated here: this mutation must be grouped with the
  // jsx construction above
  mutate(key);
  return element;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Defining React Components with use no memo Directive
DESCRIPTION: Two React functional components demonstrating different syntax styles (function expression and arrow function) that both use the 'use no memo' directive to opt out of memoization. Both components render a Button component with a dynamic value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/use-no-memo-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
const TestComponent = function () {
  "use no memo";
  return <Button>{x}</Button>;
};
const TestComponent2 = ({ x }) => {
  "use no memo";
  return <Button>{x}</Button>;
};
```

----------------------------------------

TITLE: React Component Definition and Export
DESCRIPTION: This code defines a functional React component named `Component` that accepts `props` as input. The component returns an object containing `props` passed into a function `f`. The result is assigned to the `foo` property. The component and its default parameters are exported as `FIXTURE_ENTRYPOINT`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-no-component-obj-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function Component(props) {
  const ignore = <foo />;
  return { foo: f(props) };
}

function f(props) {
  return props;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: Testing React StrictMode with react-is
DESCRIPTION: Shows how to identify React StrictMode components using isStrictMode and typeOf functions.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_6

LANGUAGE: javascript
CODE:
```
import React from "react";
import * as ReactIs from 'react-is';

ReactIs.isStrictMode(<React.StrictMode />); // true
ReactIs.typeOf(<React.StrictMode />) === ReactIs.StrictMode; // true
```

----------------------------------------

TITLE: Input: FBT Pluralization with Parameterized Counts
DESCRIPTION: A React component that uses FBT to display pluralized text based on count parameters. It takes object parameters for apple and banana counts and returns a formatted text string with proper pluralization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/bug-fbt-plural-multiple-function-calls.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

/**
 * Similar to error.todo-multiple-fbt-plural
 *
 * Evaluator error:
 *   Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok) <div>1 apple and 2 bananas</div>
 *   Forget:
 *   (kind: ok) <div>1 apples and 2 bananas</div>
 */

function useFoo({apples, bananas}) {
  return fbt(
    `${fbt.param('number of apples', apples)} ` +
      fbt.plural('apple', apples) +
      ` and ${fbt.param('number of bananas', bananas)} ` +
      fbt.plural('banana', bananas),
    'TestDescription',
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{apples: 1, bananas: 2}],
};
```

----------------------------------------

TITLE: Compiled React Output for useFoo Custom Hook
DESCRIPTION: This snippet shows the React compiler output for the useFoo custom hook. It includes memoization logic using the _c function and optimizes re-renders based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-copy-constructor-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray, mutate } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(6);
  const { propArr } = t0;
  let s1;
  let s2;
  if ($[0] !== propArr[0]) {
    s1 = new Set([1, 2, 3]);
    s1.add(makeArray(propArr[0]));

    s2 = new Set(s1);

    mutate(s2);
    $[0] = propArr[0];
    $[1] = s1;
    $[2] = s2;
  } else {
    s1 = $[1];
    s2 = $[2];
  }
  let t1;
  if ($[3] !== s1 || $[4] !== s2) {
    t1 = [s1, s2];
    $[3] = s1;
    $[4] = s2;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ propArr: [7, 8, 9] }],
  sequentialRenders: [
    { propArr: [7, 8, 9] },
    { propArr: [7, 8, 9] },
    { propArr: [7, 8, 10] },
  ],
};
```

----------------------------------------

TITLE: Error Output from Optional Chaining Usage
DESCRIPTION: This is the error output showing an unexpected terminal kind error with the optional chaining operator in the logical test block. The error specifically points to the 'value?.y' expression on line 5.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-logical-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  3 | function useFoo(props: {value: {x: string; y: string} | null}) {
  4 |   const value = props.value;
> 5 |   return useNoAlias(value?.x, value?.y) ?? {};
    |                               ^^^^^^^^ Todo: Unexpected terminal kind `optional` for logical test block (5:5)
  6 | }
  7 |
  8 | export const FIXTURE_ENTRYPONT = {
```

----------------------------------------

TITLE: Flow-typed React Component Input
DESCRIPTION: Original React component implementation with Flow type annotations. Takes a props object with numeric id, processes it through makeArray utility, and returns the first element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-array_.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableUseTypeAnnotations
import {identity, makeArray} from 'shared-runtime';

function Component(props: {id: number}) {
  const x = (makeArray(props.id): Array<number>);
  const y = x.at(0);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 42}],
};
```

----------------------------------------

TITLE: Implementing React Component with Global State and Effects
DESCRIPTION: This snippet defines a React component that uses useState and useEffect hooks to manage state based on a global variable. It includes functionality to update the global variable and synchronize the component state with it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-reassignment-in-effect-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';

let someGlobal = false;

function Component() {
  const [state, setState] = useState(someGlobal);

  const setGlobal = () => {
    someGlobal = true;
  };
  useEffect(() => {
    setGlobal();
  }, []);

  useEffect(() => {
    setState(someGlobal);
  }, [someGlobal]);

  return <div>{String(state)}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining Component and Exporting Fixture Entry Point - JavaScript
DESCRIPTION: This snippet defines a React component named 'Component' that retrieves a number from a shared runtime module and returns it. It also exports a constant 'FIXTURE_ENTRYPOINT' that holds the component along with parameters for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-types-through-type-cast.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow
import {getNumber} from 'shared-runtime';

function Component(props) {
  // We can infer that `x` is a primitive bc it is aliased to `y`,
  // which is used in a binary expression
  const x = getNumber();
  const y = (x: any);
  y + 1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};

```

----------------------------------------

TITLE: Using Memoization in a Functional Component - JavaScript
DESCRIPTION: This snippet demonstrates a React component utilizing memoization for performance optimization. It initializes arrays conditionally based on a cache sentinel and returns the processed arrays. This showcases advanced React features.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-frozen-array-noAlias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    const y = x.map(_temp);
    t1 = [x, y];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
function _temp(item) {
  return item;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Transpiled React Component Implementation
DESCRIPTION: This snippet shows the transpiled version of the React component function. It handles the array destructuring and default parameter logic explicitly, making it compatible with environments that don't support these ES6 features natively.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-array-param-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(t0) {
  const [t1] = t0;
  const a = t1 === undefined ? 2 : t1;
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Managing Input with Identity Function in JavaScript
DESCRIPTION: This snippet defines the function useFoo, which processes an input object to produce an array based on certain conditions and using an identity function. It checks for the presence of properties inputHasAB and inputHasABC, processes the input accordingly, and either returns null or an array constructed using the identity function. It requires 'shared-runtime' package for the identity function and inputs with specific properties to operate correctly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/reduce-if-exhaustive-poisoned-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function useFoo({input, inputHasAB, inputHasABC}) {
  const x = [];
  if (!inputHasABC) {
    x.push(identity(input.a));
    if (!inputHasAB) {
      return null;
    }
    x.push(identity(input.a.b));
  } else {
    x.push(identity(input.a.b.c));
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {b: 1}, inputHasAB: false, inputHasABC: false}],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that creates an array of primitive objects and modifies the last item's 'a' property. Includes a test fixture for sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-capture-item-of-local-collection-mutate-later-value-initially-null.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives} from 'shared-runtime';

function Component(props) {
  let lastItem = null;
  const items = [makeObject_Primitives(), makeObject_Primitives()];
  for (const x of items) {
    lastItem = x;
  }
  if (lastItem != null) {
    lastItem.a += 1;
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}, {}],
};
```

----------------------------------------

TITLE: Optimized React Component with FBT and Memoization
DESCRIPTION: This snippet shows an optimized version of the React component, likely produced by a compiler. It implements the same functionality as the original component but with additional optimizations for memoization and rendering efficiency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-repro-invalid-mutable-range-destructured-prop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { fbt } from "fbt";
import { useMemo } from "react";
import { ValidateMemoization } from "shared-runtime";

function Component(t0) {
  const $ = _c(7);
  const { data } = t0;
  let t1;
  let t2;
  if ($[0] !== data.name) {
    t2 = fbt._("{'name'}", [fbt._param("name", data.name ?? "")], {
      hk: "csQUH",
    });
    $[0] = data.name;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const el = t1;
  let t3;
  if ($[2] !== data.name) {
    t3 = [data.name];
    $[2] = data.name;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== el || $[5] !== t3) {
    t4 = <ValidateMemoization inputs={t3} output={el} />;
    $[4] = el;
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  return t4;
}

const props1 = { data: { name: "Mike" } };
const props2 = { data: { name: "Mofei" } };
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [props1],
  sequentialRenders: [props1, props2, props2, props1, { ...props1 }],
};
```

----------------------------------------

TITLE: Implementing React Component with Conditional Assignment and Destructuring
DESCRIPTION: This snippet defines a React component that conditionally assigns a value to 'x' based on props. It uses destructuring assignment and provides a fallback option.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-assignment-array-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  if (props.cond) {
    [[x] = ['default']] = props.y;
  } else {
    x = props.fallback;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Compiled React Component with FBT Optimization
DESCRIPTION: This snippet shows the compiled and optimized version of the React component using FBT. It includes memoization for performance improvement and demonstrates how FBT transforms the internationalized strings into an optimized format for runtime execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-single-space-btw-param-and-text.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

const _ = fbt;
function Component(t0) {
  const $ = _c(2);
  const { value } = t0;
  let t1;
  if ($[0] !== value) {
    t1 = fbt._(
      "Before text {paramName} after text",
      [fbt._param("paramName", value)],
      { hk: "26pxNm" },
    );
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "hello world" }],
};
```

----------------------------------------

TITLE: Defining Non-Fire Component in React - JavaScript
DESCRIPTION: This snippet defines a React functional component named NonFireComponent that accepts a prop and logs it. The component utilizes the useEffect hook to invoke a local function foo, which logs the prop and a static string. Dependencies include React and its hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/no-fire-todo-syntax-shouldnt-throw.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire @panicThreshold(none)
import {fire} from 'react';

/**
 * Compilation of this file should succeed.
 */
function NonFireComponent({prop1}) {
  /**
   * This component bails out but does not use fire
   */
  const foo = () => {
    try {
      console.log(prop1);
    } finally {
      console.log('jbrown215');
    }
  };
  useEffect(() => {
    foo();
  });
}

```

----------------------------------------

TITLE: Advanced React Component Logic with Early Return - JavaScript
DESCRIPTION: This snippet implements a more complex version of the component function which utilizes a symbol as an early return sentinel. It checks previous property values before executing its logic and handles errors by pushing properties into an error array. The component exports a fixed entry point for use in external contexts.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-try-value-modified-in-catch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
const { throwInput } = require("shared-runtime");

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.e || $[1] !== props.y) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      try {
        const y = [];
        y.push(props.y);
        throwInput(y);
      } catch (t1) {
        const e = t1;
        e.push(props.e);
        t0 = e;
        break bb0;
      }
    }
    $[0] = props.e;
    $[1] = props.y;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ y: "foo", e: "bar" }],
};

```

----------------------------------------

TITLE: Defining Fire Component in React - JavaScript
DESCRIPTION: This snippet illustrates a React functional component called FireComponent. It employs fire to handle its properties through a defined foo function that logs its received props. The component uses the useEffect hook, which calls fire with the function wrapped in a conditional check based on props. Required dependencies include React and fire.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/no-fire-todo-syntax-shouldnt-throw.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c, useFire } from "react/compiler-runtime"; // @enableFire @panicThreshold(none)
import { fire } from "react";

/**
 * Compilation of this file should succeed.
 */
function FireComponent(props) {
  const $ = _c(3);

  const foo = _temp;
  const t0 = useFire(foo);
  let t1;
  if ($[0] !== props || $[1] !== t0) {
    t1 = () => {
      t0(props);
    };
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  useEffect(t1);
  return null;
}
function _temp(props_0) {
  console.log(props_0);
}

```

----------------------------------------

TITLE: Enhanced Component Function with Conditional State Mutation - JavaScript
DESCRIPTION: This snippet showcases an enhanced version of the 'component' function that includes conditional invocation of state mutation based on previous state. It utilizes the mutable state from a cache-like structure and mutates only if the current parameters differ from the last. This structure improves efficiency. The expected input parameters are 'foo' and 'bar', while the output is a mutated object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-arr-2-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { mutate } = require("shared-runtime");

function component(foo, bar) {
  const $ = _c(3);
  let x;
  if ($[0] !== bar || $[1] !== foo) {
    x = { foo };
    const y = { bar };

    const a = [y];
    const b = x;
    a.x = b;

    mutate(y);
    $[0] = bar;
    $[1] = foo;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["foo", "bar"],
};
```

----------------------------------------

TITLE: Configuring Jest Timers for Testing
DESCRIPTION: Sets up Jest timer mocking and restoration for consistent test environments. Uses useFakeTimers() to simulate timer behavior and useRealTimers() to reset to standard timer implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-279ac76f53af.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
jest.useFakeTimers();
beforeEach(() => {
  jest.useRealTimers();
});
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component that demonstrates exception handling and potential array mutation. Uses a throwInput function that may throw the input array, which is then caught and modified.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-with-catch-param.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {throwInput} = require('shared-runtime');

function Component(props) {
  let x = [];
  try {
    // foo could throw its argument...
    throwInput(x);
  } catch (e) {
    // ... in which case this could be mutating `x`!
    e.push(null);
    return e;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining Component Function with Shared Runtime - JavaScript
DESCRIPTION: This code snippet defines a React component named 'Component' that utilizes the 'makeArray' function from 'shared-runtime' to create an array based on a numeric input. It also uses 'SharedRuntime.Stringify' to render the result. Required dependencies include 'shared-runtime'. The component accepts a single parameter 'num' and returns JSX that incorporates the generated array. It includes a note regarding global property loading.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-global-property-load-cached.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as SharedRuntime from 'shared-runtime';
import {makeArray} from 'shared-runtime';

/**
 * Here, we don't need to memoize SharedRuntime.Stringify as it is a PropertyLoad
 * off of a global.
 * TODO: in PropagateScopeDeps (hir), we should produce a sidemap of global rvals
 * and avoid adding them to `temporariesUsedOutsideDefiningScope`.
 */
function Component({num}: {num: number}) {
  const arr = makeArray(num);
  return (
    <SharedRuntime.Stringify value={arr.push(num)}></SharedRuntime.Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{num: 2}],
};
```

----------------------------------------

TITLE: Original React Component with useEffect
DESCRIPTION: A React function component that creates an object with nested properties and uses useEffect to print a value. The @inferEffectDependencies directive indicates that effect dependencies should be automatically inferred.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-memberexpr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect} from 'react';
import {print} from 'shared-runtime';

function ReactiveMemberExpr({propVal}) {
  const obj = {a: {b: propVal}};
  useEffect(() => print(obj.a.b));
}
```

----------------------------------------

TITLE: Setting up and running React View Transition test in development mode
DESCRIPTION: Commands to build React locally, install dependencies, and start a development server with hot reloading for testing View Transitions.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/view-transition/README.md#2025-04-21_snippet_0

LANGUAGE: bash
CODE:
```
cd fixtures/view-transition
yarn
yarn start
```

----------------------------------------

TITLE: Defining React useFoo Function and Fixture
DESCRIPTION: This code defines a React function named `useFoo` which takes an object with `input` and `cond` properties. Based on the `cond` parameter, it either skips processing or pushes a value derived from `input.a.b` (using `identity` function) into an array.  The `FIXTURE_ENTRYPOINT` constant defines test scenarios for the `useFoo` function including different input values and conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/else-branch-scope-unpoisoned.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function useFoo({input, cond}) {
  const x = [];
  label: {
    if (cond) {
      break label;
    } else {
      x.push(identity(input.a.b));
    }
  }
  return x[0];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {a: {b: 2}}, cond: false}],
  sequentialRenders: [
    {input: null, cond: true},
    {input: {a: {b: 2}}, cond: false},
    {input: null, cond: true},
    // preserve nullthrows
    {input: {}, cond: false},
    {input: {a: {b: null}}, cond: false},
    {input: {a: null}, cond: false},
    {input: {a: {b: 3}}, cond: false},
  ],
};

```

----------------------------------------

TITLE: Inefficient Function Implementation in JavaScript
DESCRIPTION: Original implementation of 'foo' function with redundant variable assignments. The function takes three parameters but only returns the last one after multiple reassignments.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-reassign.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let x = 0;
  x = a;
  x = b;
  x = c;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: JavaScript Hoisting Example
DESCRIPTION: This code snippet demonstrates variable hoisting in JavaScript. The function `hoisting` attempts to use `bar` and `baz` within the function `foo` before they are declared. Due to hoisting, this code will run without errors, but might exhibit unexpected behaviour if `bar` and `baz` are not initialized before `foo` is called.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-const-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
```javascript
function hoisting() {
  const foo = () => {
    return bar + baz;
  };
  const bar = 3;
  const baz = 2;
  return foo(); // OK: called outside of TDZ for bar/baz
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```
```

----------------------------------------

TITLE: Implementing Mutation and Component Logic in JavaScript
DESCRIPTION: This snippet defines a mutate function for array manipulation and a Component function that demonstrates various object and array operations. It also includes a FIXTURE_ENTRYPOINT export for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-lifetime-with-aliasing.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function mutate(x, y) {
  'use no forget';
  if (!Array.isArray(x.value)) {
    x.value = [];
  }
  x.value.push(y);
  if (y != null) {
    y.value = x;
  }
}

function Component(props) {
  const a = {};
  const b = [a]; // array elements alias
  const c = {};
  const d = {c}; // object values alias

  // capture all the values into this object
  const x = {};
  x.b = b;
  const y = mutate(x, d); // mutation aliases the arg and return value

  // all of these tests are seemingly readonly, since the values are never directly
  // mutated again. but they are all aliased by `x`, which is later modified, and
  // these are therefore mutable references:
  if (a) {
  }
  if (b) {
  }
  if (c) {
  }
  if (d) {
  }
  if (y) {
  }

  // could in theory mutate any of a/b/c/x/z, so the above should be inferred as mutable
  mutate(x, null);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining Custom Hook with Attached Method
DESCRIPTION: Creates a custom hook function with an additional static method, showing an incorrect way of referencing hooks
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hook-property-load-local-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo() {}
useFoo.useBar = function () {
  return 'foo';
};

function Foo() {
  let bar = useFoo.useBar;
  return bar();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Input React Component With Primitive Objects
DESCRIPTION: Original React component implementation that uses makeObject_Primitives and handles primitive object operations within JSX.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/allow-locals-named-like-hooks.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives, Stringify} from 'shared-runtime';

function Component(props) {
  let useFeature = makeObject_Primitives();
  let x;
  if (useFeature) {
    x = [useFeature + useFeature].push(-useFeature);
  }
  let y = useFeature;
  let z = useFeature.useProperty;
  return (
    <Stringify val={useFeature}>
      {x}
      {y}
      {z}
    </Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Enhanced Iterator Semantics with Memoization in React using JavaScript
DESCRIPTION: This snippet extends the previous implementation by including a compiler-runtime cache mechanism, enhancing the memoization process. It optimizes iterator handling by caching React.memo cache sentinels and input states to improve performance. The useFoo function now manages cached state changes to ensure efficient rendering, powered by React and shared-runtime dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-granular-iterator-semantics.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useIdentity, ValidateMemoization } from "shared-runtime";

/**
 * Fixture for granular iterator semantics:
 * 1. ConditionallyMutate the iterator itself, depending on whether the iterator
 *    is a mutable iterator.
 * 2. Capture effect on elements within the iterator.
 */
function Validate({ x, input }) {
  "use no memo";
  return (
    <>
      <ValidateMemoization inputs={[]} output={x[0]} onlyCheckCompiled={true} />
      <ValidateMemoization
        inputs={[input]}
        output={x[1]}
        onlyCheckCompiled={true}
      />
    </>
  );
}
function useFoo(input) {
  "use memo";
  const $ = _c(6);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [{}];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = Array.from(t0);
  useIdentity();
  let t1;
  if ($[1] !== input) {
    t1 = [input];
    $[1] = input;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  x.push(t1);
  let t2;
  if ($[3] !== input || $[4] !== x) {
    t2 = <Validate x={x} input={input} />;
    $[3] = input;
    $[4] = x;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [1],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Original implementation of a React component that creates an object with two properties, performs a comparison, and returns a value. Shows basic object property access patterns.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-field-load-binary-op.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let x = {u: makeSomePrimitive(), v: makeSomePrimitive()};
  let u = x.u;
  let v = x.v;
  if (u > v) {
  }

  let y = x.u;
  let z = x.v;
  return z;
}
```

----------------------------------------

TITLE: React Component with useFire Hook
DESCRIPTION: This snippet shows a React component that utilizes the `useFire` hook and `_c` from `react/compiler-runtime` to optimize the execution of the `foo` function within a `useEffect` hook.  `useFire` memoizes the function, and `_c` is used for conditional updates to reduce unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/multiple-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c, useFire } from "react/compiler-runtime"; // @enableFire
import { fire } from "react";

function Component(props) {
  const $ = _c(3);
  const foo = _temp;
  const t0 = useFire(foo);
  let t1;
  if ($[0] !== props || $[1] !== t0) {
    t1 = () => {
      t0(props);
      const nested = function nested() {
        t0(props);
      };

      nested();
    };
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  useEffect(t1);
  return null;
}
function _temp(props_0) {
  console.log(props_0);
}

```

----------------------------------------

TITLE: Input React Component with FBT Internationalization
DESCRIPTION: A React component using FBT for internationalization with enumeration and parameter components. The component conditionally renders 'hello' or 'goodbye' based on the props.value, and includes the value as a parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-jsxtext.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Foo(props) {
  return (
    <fbt desc="Some text to be translated">
      <fbt:enum
        enum-range={{'0': 'hello', '1': 'goodbye'}}
        value={props.value ? '0' : '1'}
      />{' '}
      <fbt:param name="value">{props.value}</fbt:param>
      {', '}
    </fbt>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{value: 1}],
  sequentialRenders: [{value: 1}, {value: 0}],
};
```

----------------------------------------

TITLE: Original JavaScript Switch Statement with Fallthrough Cases
DESCRIPTION: A JavaScript function that demonstrates a switch statement with fallthrough cases. The function assigns values to variable y based on the input parameter x, with some cases containing explicit breaks and others falling through to the next case.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-with-fallthrough.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(x) {
  let y;
  switch (x) {
    case 0: {
      y = 0;
    }
    case 1: {
      y = 1;
    }
    case 2: {
      break;
    }
    case 3: {
      y = 3;
      break;
    }
    case 4: {
      y = 4;
    }
    case 5: {
      y = 5;
    }
    default: {
      y = 0;
    }
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Original React Component with Global Object Type Resolution
DESCRIPTION: A React function component that demonstrates how type and effect lookups are resolved on JavaScript global objects. It uses imported utility functions and accesses global properties like Math.max, Infinity, and NaN.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-global-object.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, sum} from 'shared-runtime';

// Check that we correctly resolve type and effect lookups on the javascript
// global object.
function Component(props) {
  let neverAliasedOrMutated = identity(props.b);
  let primitiveVal1 = Math.max(props.a, neverAliasedOrMutated);
  let primitiveVal2 = Infinity;
  let primitiveVal3 = globalThis.globalThis.NaN;

  // Even though we don't know the function signature of sum,
  // we should be able to infer that it does not mutate its inputs.
  sum(primitiveVal1, primitiveVal2, primitiveVal3);
  return {primitiveVal1, primitiveVal2, primitiveVal3};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1, b: 2}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Initializing Nullable Object Processing with Error Handling
DESCRIPTION: Function that safely extracts and pushes values from potentially null objects using try-catch and identity function. Handles scenarios with null or partially defined objects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-maybe-null-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo(maybeNullObject: {value: {inner: number}} | null) {
  const y = [];
  try {
    y.push(identity(maybeNullObject.value.inner));
  } catch {
    y.push('null');
  }

  return y;
}
```

----------------------------------------

TITLE: Defining React Component with Complex Logic (Simplified)
DESCRIPTION: This code defines a React functional component named `MyComponent` with complex conditional statements and hooks. It aims to illustrate scenarios that can be computationally expensive to analyze, potentially related to memoization or other performance optimizations. The conditional logic and hooks contribute to the component's overall complexity.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-c1e8c7f4c191.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// Is valid but hard to compute by brute-forcing
function MyComponent() {
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }
  if (c) {
  }

  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
  useHook();
}

```

----------------------------------------

TITLE: Rendering Components with Prop-based Conditional Logic in React JavaScript
DESCRIPTION: The code defines two components, ComponentA and ComponentB, using JavaScript within a React framework to manage conditional rendering based on props. Both components utilize arrays and a conditional logic via a comparison array `_c` to optimize re-renders when specific props change. ComponentA and ComponentB share similar logic, with ComponentB further allowing mutation checks via `mayMutate()` for more granular control.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-on-mutable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function ComponentA(props) {
  const a = [];
  const b = [];
  if (b) {
    a.push(props.p0);
  }
  if (props.p1) {
    b.push(props.p2);
  }
  return <Foo a={a} b={b} />;
}

function ComponentB(props) {
  const a = [];
  const b = [];
  if (mayMutate(b)) {
    a.push(props.p0);
  }
  if (props.p1) {
    b.push(props.p2);
  }
  return <Foo a={a} b={b} />;
}

function Foo() {}
function mayMutate() {}
```

----------------------------------------

TITLE: Original Component Function with Nested Objects and Mutation
DESCRIPTION: A React component function that creates nested objects and arrays, then mutates the deeply nested array before returning the outermost object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-nested-member-path-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let z = [];
  let y = {};
  y.z = z;
  let x = {};
  x.y = y;
  mutate(x.y.z);
  return x;
}
```

----------------------------------------

TITLE: Validating Component Naming in JavaScript
DESCRIPTION: This JavaScript function validates that a capitalized function is treated as a React component. It checks the invocation of `someGlobal.SomeFunc()`, which, if capitalized incorrectly, may raise an error indicating a misuse of component naming conventions. It provides insights into handling JSX rendering appropriately.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capitalized-method-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoCapitalizedCalls
function Component() {
  const x = someGlobal.SomeFunc();

  return x;
}

```

----------------------------------------

TITLE: Creating an FBT Component with Parameter Substitution in React
DESCRIPTION: This snippet shows a React component using the FBT library to create an internationalized greeting with a dynamic parameter. The component takes a name prop and inserts it into the greeting text, then converts the result to a string.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-unicode.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component(props) {
  const element = (
    <fbt desc={'Dialog to show to user'}>
      Hello <fbt:param name="user name ">{props.name}</fbt:param>
    </fbt>
  );
  return element.toString();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Jason'}],
};
```

----------------------------------------

TITLE: Original Component Implementation
DESCRIPTION: Simple React component that creates an object with a property and returns its value. This represents the code before compiler optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-field-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let x = {t: 1};
  let p = x.t;
  return p;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Hook Definition: useFoo with Emit Freeze and Forget Instrumentation
DESCRIPTION: This JavaScript code defines a React hook named `useFoo` that takes `props` as an argument and returns the result of calling the `foo` function with `props.x` and `__DEV__`. It is annotated with `@enableEmitFreeze` and `@instrumentForget`, suggesting it's part of a memoization or optimization process within a React component, likely using React's compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/emit-freeze-nonconflicting-global-reference.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableEmitFreeze @instrumentForget
function useFoo(props) {
  return foo(props.x, __DEV__);
}
```

----------------------------------------

TITLE: Defining a Component in JavaScript
DESCRIPTION: This snippet defines a React component function that creates an object and assigns properties using a function call. It highlights basic React component initialization. makeObject() is assumed to generate necessary object attributes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-args-destructuring-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = makeObject();
  x.foo(([x] = makeObject()));
  return x;
}

```

----------------------------------------

TITLE: React Component with idx macro usage
DESCRIPTION: This code defines a React component that uses a custom `idx` macro to access nested properties within the `props` object. It demonstrates both outlined and not outlined usages of the `idx` macro. The purpose is to show the original component structure before the transformation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-method-no-outlining.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
```javascript
// @customMacros(idx.a)

function Component(props) {
  // outlined
  const groupName1 = idx(props, _ => _.group.label);
  // not outlined
  const groupName2 = idx.a(props, _ => _.group.label);
  // outlined
  const groupName3 = idx.a.b(props, _ => _.group.label);
  return (
    <div>
      {groupName1}
      {groupName2}
      {groupName3}
    </div>
  );
}

```
```

----------------------------------------

TITLE: FBT Component Input Source
DESCRIPTION: Original React component using FBT for text translation. Demonstrates basic FBT syntax with parameter interpolation using fbt:param.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

const _ = fbt;
function Component({value}: {value: string}) {
  return (
    <fbt desc="descdesc">
      Before text
      <fbt:param name="paramName">{value}</fbt:param>
    </fbt>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'hello world'}],
};
```

----------------------------------------

TITLE: Defining and Exporting a React Component - JavaScript
DESCRIPTION: This snippet defines a React functional component with an embedded function for rendering. It includes an exported object for the entry point with a function and parameter specification. The component uses an inner function to return a constant value as part of the rendering process. No external dependencies are required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-within-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({}) {
  const outer = () => {
    const inner = () => {
      return x;
    };
    const x = 3;
    return inner();
  };
  return <div>{outer()}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Using Conditional Dependencies in JavaScript
DESCRIPTION: The function `useCondDepInConditionalExpr` takes in props and a condition to return a computed value based on the condition's outcome. It ensures that `props.a.b` is appropriately used as an unconditional dependency, impacting the reactive scope's output. Requirements include `identity` and `addOne` from 'shared-runtime' for functionality, while inputs are `props` and `cond`, with outputs returning the computed value `x`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-condexpr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths

import {identity, addOne} from 'shared-runtime';

function useCondDepInConditionalExpr(props, cond) {
  const x = identity(cond) ? addOne(props.a.b) : identity(props.a.b);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInConditionalExpr,
  params: [{a: {b: 2}}, true],
};

```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths

import { identity, addOne } from "shared-runtime";

function useCondDepInConditionalExpr(props, cond) {
  const $ = _c(3);
  let t0;
  if ($[0] !== cond || $[1] !== props.a.b) {
    t0 = identity(cond) ? addOne(props.a.b) : identity(props.a.b);
    $[0] = cond;
    $[1] = props.a.b;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInConditionalExpr,
  params: [{ a: { b: 2 } }, true],
};

```

----------------------------------------

TITLE: Simplified React Component Handler
DESCRIPTION: Shows a simplified version of the handler function with minimal conditional logic. Exports the same fixture configuration structure but with a more straightforward implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-phi.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  if (a) {
  }
  return b;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Input: React Hook with Conditional Dependency Superpath
DESCRIPTION: A React hook function that demonstrates dependency tracking when an unconditional dependency (props.a) is the superpath of a conditional dependency (props.a.b). It includes test cases for various input scenarios including null and undefined values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// When an unconditional dependency `props.a` is the subpath of a conditional
// dependency `props.a.b`, we can safely overestimate and only track `props.a`
// as a dependency

import {identity} from 'shared-runtime';

// ordering of accesses should not matter
function useConditionalSuperpath2({props, cond}) {
  const x = {};
  if (identity(cond)) {
    x.b = props.a.b;
  }
  x.a = props.a;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useConditionalSuperpath2,
  params: [{props: {a: null}, cond: false}],
  sequentialRenders: [
    {props: {a: null}, cond: false},
    {props: {a: {}}, cond: true},
    {props: {a: {b: 3}}, cond: true},
    {props: {}, cond: false},
    // test that we preserve nullthrows
    {props: {a: {b: undefined}}, cond: true},
    {props: {a: undefined}, cond: true},
  ],
};
```

----------------------------------------

TITLE: Building and Testing React DevTools Extensions for Different Browsers
DESCRIPTION: Commands to build and test the React DevTools extension for Chrome, Firefox, and Edge browsers after dependencies have been installed.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/README.md#2025-04-21_snippet_3

LANGUAGE: sh
CODE:
```
cd packages/react-devtools-extensions/

yarn build:chrome # => packages/react-devtools-extensions/chrome/build
yarn run test:chrome # Test Chrome extension

yarn build:firefox # => packages/react-devtools-extensions/firefox/build
yarn run test:firefox # Test Firefox extension

yarn build:edge # => packages/react-devtools-extensions/edge/build
yarn run test:edge # Test Edge extension
```

----------------------------------------

TITLE: Original React Hook Implementation
DESCRIPTION: A React hook that creates a Map containing arrays from two input elements. Returns the size of the Map. Uses shared runtime utility makeArray.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/map-constructor.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

function useHook({el1, el2}) {
  const s = new Map();
  s.set(el1, makeArray(el1));
  s.set(el2, makeArray(el2));
  return s.size;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{el1: 1, el2: 'foo'}],
  sequentialRenders: [
    {el1: 1, el2: 'foo'},
    {el1: 2, el2: 'foo'},
  ],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that creates an array with fixed and dynamic values, uses identity hook, and filters the array before rendering with Stringify component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-filter-known-nonmutate-Boolean.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify, useIdentity} from 'shared-runtime';

/**
 * Also see repro-array-map-known-mutate-shape, which calls a global function
 * that mutates its operands.
 */
function Component({value}) {
  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];
  useIdentity(null);
  const derived = arr.filter(Boolean);
  return (
    <Stringify>
      {derived.at(0)}
      {derived.at(-1)}
    </Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 5}],
  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],
};
```

----------------------------------------

TITLE: Initializing Map and Set Polyfills for React 16
DESCRIPTION: Example code demonstrating the new JS environment requirements for React 16, including Map, Set, and requestAnimationFrame polyfills for older browser support.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_20

LANGUAGE: javascript
CODE:
```
Map && Set && requestAnimationFrame
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that creates and modifies an array of objects using makeObject_Primitives helper. Includes test fixture configuration for multiple renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-mutate-item-of-local-collection.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives} from 'shared-runtime';

function Component(props) {
  const items = [makeObject_Primitives(), makeObject_Primitives()];
  for (const x of items) {
    x.a += 1;
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}, {}],
};
```

----------------------------------------

TITLE: Implementing React Component with Plain Objects
DESCRIPTION: This snippet defines a React component using plain objects instead of JSX. It creates a counter with a button to increment the count, using the useState hook for state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-objects.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useState} from 'react';
import {Stringify} from 'shared-runtime';

function Component(props) {
  let [state, setState] = useState(0);
  return [
    {component: Stringify, props: {text: 'Counter'}},
    {component: 'span', props: {children: [state]}},
    {
      component: 'button',
      props: {
        'data-testid': 'button',
        onClick: () => setState(state + 1),
        children: ['increment'],
      },
    },
  ];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing useTest Function with Builder Pattern in JavaScript
DESCRIPTION: This snippet defines a 'useTest' function that uses the Builder pattern to construct a complex data structure. It takes an object with 'isNull' and 'data' properties as input and returns a nested array-like structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-slow-validate-preserve-memo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {Builder} from 'shared-runtime';
function useTest({isNull, data}: {isNull: boolean; data: string}) {
  const result = Builder.makeBuilder(isNull, 'hello world')
    ?.push('1', 2)
    ?.push(3, {
      a: 4,
      b: 5,
      c: data,
    })
    ?.push(6, data)
    ?.push(7, '8')
    ?.push('8', Builder.makeBuilder(!isNull)?.push(9).vals)?.vals;
  return result;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [{isNull: false, data: 'param'}],
};
```

----------------------------------------

TITLE: Installing Project Dependencies
DESCRIPTION: Install the necessary dependencies for the React project using Yarn.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_1

LANGUAGE: sh
CODE:
```
cd <react-repo>
yarn install
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the component function 'f' using React's compiler runtime. It implements memoization for the 'x' object and the rendered div element to improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutated-ref-non-reactive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function f(a) {
  const $ = _c(2);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = {};
    $[0] = x;
  } else {
    x = $[0];
  }
  let t0;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div x={x} />;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Initializing Nested Object Dependency Tracking in React
DESCRIPTION: Function that creates a new object by accessing nested properties from input props, showcasing React compiler's ability to track object dependencies efficiently
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function TestDepsSubpathOrder2(props) {
  let x = {};
  x.a = props.a;
  x.b = props.a.b;
  x.c = props.a.b.c;
  return x;
}
```

----------------------------------------

TITLE: React Compiler Output for Invalid Component
DESCRIPTION: The compiled version of the invalid component using React's compiler-runtime. It shows how React attempts to memoize the inner component through a sentinel value check, but this pattern is still invalid for component definitions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger @validateStaticComponents
function Example(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const Component = function Component() {
      return <div />;
    };

    t0 = <Component />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Using useFire in a Conditional Component - JavaScript
DESCRIPTION: This snippet demonstrates an alternative implementation of a React component that uses the useFire hook along with useEffect to manage side effects based on props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-validate-conditional-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useFire } from "react/compiler-runtime"; // @enableFire @panicThreshold(none)
import { fire, useEffect } from "react";
import { Stringify } from "shared-runtime";

/**
 * When @enableFire is specified, retry compilation with validation passes (e.g.
 * hook usage) disabled
 */
function Component(props) {
  const foo = _temp;
  if (props.cond) {
    const t0 = useFire(foo);
    useEffect(() => {
      t0(props);
    });
  }
  return <Stringify />;
}
function _temp(props_0) {
  console.log(props_0);
}

```

----------------------------------------

TITLE: Original React Component with useFragment and useFreeze Hooks
DESCRIPTION: A React component that uses useFragment and useFreeze hooks to manage data. It creates a MaybeMutable instance and renders nested Views with text content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-memo-value-not-promoted-to-outer-scope-dynamic.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const item = useFragment(FRAGMENT, props.item);
  useFreeze(item);

  const count = new MaybeMutable(item);
  return (
    <View>
      <View>
        {<span>Text</span>}
        {<span>{maybeMutate(count)}</span>}
      </View>
    </View>
  );
}
```

----------------------------------------

TITLE: Creating and Returning React Component with Validation - JavaScript
DESCRIPTION: This snippet illustrates creating and returning a React component within a function using annotations for logging and validation. It serves as an example of a typical but incorrect pattern of creating components within the render method. There are no explicit dependencies declared in this snippet, but it implies React as a dependency. The function takes `props` as parameters and returns a React component instance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-construct-component-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger @validateStaticComponents
function Example(props) {
  const Component = createComponent();
  return <Component />;
}

```

----------------------------------------

TITLE: Input Hook Function with useState in React
DESCRIPTION: The original React hook function that uses useState and returns an array containing just the state value. Note that the update function from useState is ignored with an underscore.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-hook-with-hook-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function useStateValue(props) {
  const [state, _] = useState(null);
  return [state];
}
```

----------------------------------------

TITLE: React Component with Initial Fire and Effect Implementation
DESCRIPTION: Initial implementation of a React component using fire events and useEffect with memoization and prop interactions
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-preserve-memo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees @enableFire @panicThreshold(none)
import {fire} from 'react';
import {sum} from 'shared-runtime';

function Component({prop1, bar}) {
  const foo = () => {
    console.log(prop1);
  };
  useEffect(() => {
    fire(foo(prop1));
    fire(foo());
    fire(bar());
  });

  return useMemo(() => sum(bar), []);
}
```

----------------------------------------

TITLE: Initializing React Component with idx in JavaScript
DESCRIPTION: This snippet showcases a basic React component that uses the `idx` library to safely access deeply nested properties. It uses a lambda function to avoid outlining. The component displays a group label if available. Dependencies include React and the `idx` package.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-no-outlining.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @customMacros(idx)
import idx from 'idx';

function Component(props) {
  // the lambda should not be outlined
  const groupName = idx(props, _ => _.group.label);
  return <div>{groupName}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Mutating Component State - JavaScript
DESCRIPTION: This snippet defines a component function that receives an argument, constructs an object, and mutates it before returning. It leverages the `mutate` function from 'shared-runtime' for state modification, which is useful in managing shared application state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-computed-mutate-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {mutate} = require('shared-runtime');

function component(a) {
  let x = {a};
  let y = {};
  (function () {
    y['x'] = x;
  })();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['foo'],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the component using memoization. It imports a compiler runtime function and uses it to cache the component's state, reducing unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/delete-computed-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let x;
  if ($[0] !== props.a || $[1] !== props.b) {
    x = { a: props.a, b: props.b };
    delete x["b"];
    $[0] = props.a;
    $[1] = props.b;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component with ESLint Rule Disabling (JavaScript)
DESCRIPTION: This code defines a React component (`lowercasecomponent`) that disables a custom ESLint rule (`my-app/react-rule`) using `eslint-disable` and `eslint-disable-next-line`. The purpose is to demonstrate how disabling such rules can prevent React Compiler from optimizing the component. The component returns a simple `div` containing a variable `x`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.bailout-on-suppression-of-custom-rule.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @eslintSuppressionRules(my-app/react-rule)

/* eslint-disable my-app/react-rule */
function lowercasecomponent() {
  'use forget';
  const x = [];
  // eslint-disable-next-line my-app/react-rule
  return <div>{x}</div>;
}
/* eslint-enable my-app/react-rule */
```

----------------------------------------

TITLE: Implementing State Management in React Component - JavaScript
DESCRIPTION: This snippet enhances the 'Foo' component by integrating state management using a custom Hook '_c' from 'react/compiler-runtime'. It checks for changes in props and re-renders the component accordingly, employing a cached mechanism to optimize performance. Dependencies include 'react/compiler-runtime' and 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/repro-invariant.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { Stringify } from "shared-runtime";

function Foo(t0) {
  const $ = _c(5);
  const { data } = t0;
  let t1;
  if ($[0] !== data.a.d) {
    t1 = () => data.a.d;
    $[0] = data.a.d;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const t2 = data.a?.b.c;
  let t3;
  if ($[2] !== t1 || $[3] !== t2) {
    t3 = <Stringify foo={t1} bar={t2} shouldInvokeFns={true} />;
    $[2] = t1;
    $[3] = t2;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ data: { a: null } }],
  sequentialRenders: [{ data: { a: { b: { c: 4 } } } }],
};
```

----------------------------------------

TITLE: Defining React Component with Object Manipulation
DESCRIPTION: This snippet defines a React component that creates an object from props, deletes a specific key, and returns the modified object. It also exports a constant for component testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/delete-computed-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {a: props.a, b: props.b};
  const key = 'b';
  delete x[key];
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining a Conditional Component with Memoization in React - JavaScript
DESCRIPTION: This snippet enhances the previous implementation by using a caching mechanism through the React compiler. It introduces a memoization pattern with 'Symbol.for("react.memo_cache_sentinel")' to optimize performance when rendering the component. The returned value depends on the condition and also references 'useFreeze' and 'call' to ensure immutability as required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-freeze-possibly-mutable-arguments.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  const cond = props.cond;
  const x = props.x;
  let a;
  if (cond) {
    a = x;
  } else {
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = [];
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    a = t0;
  }

  useFreeze(a);
  useFreeze(a);
  call(a);
  return a;
}

function useFreeze(x) {}
function call(x) {}
```

----------------------------------------

TITLE: Building the Extension Using Yarn
DESCRIPTION: This snippet outlines the command to build the extension using Yarn from the root directory. Dependencies include Yarn package manager and the appropriate build script setup.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/edge/README.md#2025-04-21_snippet_1

LANGUAGE: bash
CODE:
```
yarn run build:extension:edge
```

----------------------------------------

TITLE: React Hook Definition: useFoo (Transpiled)
DESCRIPTION: This is a transpiled version of the `useFoo` React hook. It destructures the `onClose` prop from the input object `t0`. Functionally, it's equivalent to the original, initializing a button with primary and secondary actions via `Stringify` and depending on a `dispatcher` obtained using `useHook`. The code demonstrates potential dependency injection or hoisting patterns since `dispatcher` is used before being defined.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisted-declaration-with-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { StaticText1, Stringify, identity, useHook } from "shared-runtime";

/**
 * `button` and `dispatcher` must end up in the same memo block. It would be
 * invalid for `button` to take a dependency on `dispatcher` as dispatcher
 * is created later.
 */
function useFoo(t0) {
  const { onClose } = t0;
  const button = StaticText1 ?? (
    <Stringify
      primary={{ label: identity("label"), onPress: onClose }}
      secondary={{
        onPress: () => {
          dispatcher.go("route2");
        },
      }}
    />
  );

  const dispatcher = useHook();
  return button;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ onClose: identity() }],
};

```

----------------------------------------

TITLE: Original Component with Console Logging
DESCRIPTION: The original component implementation that shallow copies props and logs them using various console methods. This code demonstrates how React's compiler will handle console logging operations outside of reactive scopes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/console-readonly.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {shallowCopy} from 'shared-runtime';

function Component(props) {
  const x = shallowCopy(props);
  // These calls should view x as readonly and be grouped outside of the reactive scope for x:
  console.log(x);
  console.info(x);
  console.warn(x);
  console.error(x);
  console.trace(x);
  console.table(x);
  global.console.log(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1, b: 2}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Using React Hook in JavaScript
DESCRIPTION: This JavaScript snippet demonstrates a function `useFoo` that utilizes a custom hook from React, `useVideoPlayer`. The hook is called inside the function and its result is returned. However, there is an error related to the dynamic use of hooks, which violates React's rules. Refer to the provided documentation link for more details. The snippet requires React as a dependency and does not handle cases of dynamic changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-from-hook-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({data}) {
  const useMedia = useVideoPlayer();
  const foo = useMedia();
  return foo;
}
```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React Component
DESCRIPTION: Example showing an incorrect implementation of a React hook that uses optional chaining (?.), which violates the Rules of Hooks by making the hook call conditional. This pattern is not allowed as hooks must be called in the same order on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-optional-methodcall.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const {result} = Module.useConditionalHook?.() ?? {};
  return result;
}
```

LANGUAGE: plaintext
CODE:
```
  1 | function Component() {
> 2 |   const {result} = Module.useConditionalHook?.() ?? {};
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (2:2)
  3 |   return result;
  4 | }
  5 |
```

----------------------------------------

TITLE: Demonstrating Invalid React Hook Usage in JavaScript
DESCRIPTION: This snippet illustrates an invalid JavaScript function where a React Hook is conditionally called within a 'normal' function, which is against React's Hook rules. The function does not execute without warnings, emphasizing the need to adhere to consistent hook usage patterns. The example does not depend on external libraries but requires an understanding of React Hooks. It announces conditional variables like 'cond'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-d740d54e9c21.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function normalFunctionWithConditionalHook() {
  if (cond) {
    useHookInsideNormalFunction();
  }
}

```

----------------------------------------

TITLE: Invalid Conditional Hook Usage in React Component
DESCRIPTION: Demonstrates a component that incorrectly uses a Hook within a ternary operator. This pattern violates React's Rules of Hooks by making the Hook call conditional, which is explicitly forbidden.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-b4dcda3d60ed.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Expected to fail

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function ComponentWithTernaryHook() {
  cond ? useTernaryHook() : null;
}
```

LANGUAGE: plaintext
CODE:
```
  4 | // This *must* be invalid.
  5 | function ComponentWithTernaryHook() {
> 6 |   cond ? useTernaryHook() : null;
    |          ^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (6:6)
  7 | }
  8 |

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Transformed version of the component with compiler-runtime imports and memoization logic implemented through Symbol sentinel checking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-type-import.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import type { ReactElement } from "react";

function Component(_props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div>hello world</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with Destructuring Parameter
DESCRIPTION: A React component that destructures the 'foo' parameter, accesses its 'bar' property, and renders a Stringify component with a handler that modifies 'foo'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-reassign-const.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Component({foo}) {
  let bar = foo.bar;
  return (
    <Stringify
      handler={() => {
        foo = true;
      }}
    />
  );
}

```

----------------------------------------

TITLE: Initializing Component with Shared Runtime and Conditional Logic in JavaScript
DESCRIPTION: The snippet initializes a React component, 'Component', that checks a condition (props.cond) to assign a value to an 'object'. It depends on the 'makeObject_Primitives' from 'shared-runtime' to construct the object. The component returns an object with the value altered based on props.cond. The input includes component props and outputs an object with 'value' property set.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-mutated-in-consequent-alternate-both-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives} from 'shared-runtime';

function Component(props) {
  const object = makeObject_Primitives();
  if (props.cond) {
    object.value = 1;
    return object;
  } else {
    object.value = props.value;
    return object;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: false, value: [0, 1, 2]}],
};
```

----------------------------------------

TITLE: Defining React Component with Memoization-Ready Structure
DESCRIPTION: This snippet defines a React component that returns an object with a session_id. The component is structured to allow for easy memoization by the React compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-no-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {getNumber} = require('shared-runtime');

function Component(props) {
  // Two scopes: one for `getNumber()`, one for the object literal.
  // Neither has dependencies so they should merge
  return {session_id: getNumber()};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing CaptureNotMutate Component in React
DESCRIPTION: This code defines a React component named CaptureNotMutate that demonstrates challenges with memoization when dealing with captured variables. It processes props, creates a function that captures a local variable, and mutates the result.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-capture-returned-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function CaptureNotMutate(props) {
  const idx = foo(props.x);
  const element = bar(props.el);

  const fn = function () {
    const arr = {element};
    return arr[idx];
  };
  const aliasedElement = fn();
  mutate(aliasedElement);
  return aliasedElement;
}
```

----------------------------------------

TITLE: Defining React Component with Identity Function in JavaScript
DESCRIPTION: This snippet defines a React component 'Test' that uses an 'identity' function from 'shared-runtime'. It also exports a 'FIXTURE_ENTRYPOINT' object with the component function and empty params.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ts-instantiation-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, invoke} from 'shared-runtime';

function Test() {
  const str = invoke(identity<string>, 'test');
  return str;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [],
};
```

----------------------------------------

TITLE: Defining a React Component
DESCRIPTION: This snippet defines a simple React component that receives props and returns an array containing an empty object and a prop value. The component is then exported as part of the FIXTURE_ENTRYPOINT object, which also includes sample parameter values. It demonstrates a basic component structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-nonreactive-captured-with-reactive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {};
  const y = props.y;
  return [x, y]; // x is captured here along with a reactive value. this shouldn't make `x` reactive!
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{y: 42}],
};

```

----------------------------------------

TITLE: Defining React Component with External Function Invocation (Input)
DESCRIPTION: A React component that initializes a null variable, reassigns it through a closure function invoked externally, and returns the updated value. Includes test fixture configuration for sequential renders with different prop values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-reactive-capture.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {invoke} from 'shared-runtime';

function Component({value}) {
  let x = null;
  const reassign = () => {
    x = value;
  };
  invoke(reassign);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 2}],
  sequentialRenders: [{value: 2}, {value: 4}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that creates an array from props, performs multiplication and addition operations on array elements. Shows unoptimized array manipulation logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-expression-computed.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [props.x];
  const index = 0;
  x[index] *= 2;
  x['0'] += 3;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: 2}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing React Component with Object Manipulation
DESCRIPTION: This snippet defines a React component that creates an array of objects, iterates over them, and modifies the last item. It also exports a fixture for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-capture-item-of-local-collection-mutate-later.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives} from 'shared-runtime';

function Component(props) {
  let lastItem = {};
  const items = [makeObject_Primitives(), makeObject_Primitives()];
  for (const x of items) {
    lastItem = x;
  }
  if (lastItem != null) {
    lastItem.a += 1;
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Defining Component with Optimized Context Variable Handling in JavaScript
DESCRIPTION: This snippet presents an alternative implementation of the Component function that optimizes for context variable management and state mutation. It captures inputs using a closure defined by the compiler runtime and manages shared state effectively. The function returns an object composed of the bar value and modified x property. This implementation showcases subtle differences in capturing context variables compared to the previous snippet. Dependencies include 'react/compiler-runtime' and 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-capturing-func-maybealias-captured-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray, mutate } from "shared-runtime";

/**
 * Bug repro:
 * Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok)
 *   {"bar":4,"x":{"foo":3,"wat0":"joe"}}
 *   {"bar":5,"x":{"foo":3,"wat0":"joe"}}
 *   Forget:
 *   (kind: ok)
 *   {"bar":4,"x":{"foo":3,"wat0":"joe"}}
 *   {"bar":5,"x":{"foo":3,"wat0":"joe","wat1":"joe"}}
 *
 * Fork of `capturing-func-alias-captured-mutate`, but instead of directly
 * aliasing `y` via `[y]`, we make an opaque call.
 *
 * Note that the bug here is that we don't infer that `a = makeArray(y)`
 * potentially captures a context variable into a local variable. As a result,
 * we don't understand that `a[0].x = b` captures `x` into `y` -- instead, we're
 * currently inferring that this lambda captures `y` (for a potential later
 * mutation) and simply reads `x`.
 *
 * Concretely `InferReferenceEffects.hasContextRefOperand` is incorrectly not
 * used when we analyze CallExpressions.
 */
function Component(t0) {
  const $ = _c(5);
  const { foo, bar } = t0;
  let t1;
  if ($[0] !== foo) {
    t1 = { foo };
    $[0] = foo;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  let y;
  if ($[2] !== bar || $[3] !== x) {
    y = { bar };
    const f0 = function () {
      const a = makeArray(y);
      const b = x;

      a[0].x = b;
    };

    f0();
    mutate(y.x);
    $[2] = bar;
    $[3] = x;
    $[4] = y;
  } else {
    y = $[4];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ foo: 3, bar: 4 }],
  sequentialRenders: [
    { foo: 3, bar: 4 },
    { foo: 3, bar: 5 },
  ],
};
```

----------------------------------------

TITLE: Basic Flow-typed React Component with Hook
DESCRIPTION: Initial version of a React component using Flow annotations and a dynamic hook. Includes special Flow directives for hook guards and other configurations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-add-hook-guards-on-retry.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableEmitHookGuards @panicThreshold(none) @enableFire

component Foo(useDynamicHook) {
  useDynamicHook();
  return <div>hello world</div>;
}
```

----------------------------------------

TITLE: React Component with Continue Statement
DESCRIPTION: Original implementation of a React component that calculates a sum using a for loop with continue statement and compound operators (+=). Takes props.count as input and returns accumulated sum.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-empty-update-with-continue.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  for (let i = 0; i < props.count; ) {
    x += i;
    i += 1;
    continue;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Original implementation of a React component that creates a context object based on props and performs mutation. Uses dynamic key assignment and the identity function from shared runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-member.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate, mutateAndReturn} from 'shared-runtime';

function Component(props) {
  const key = {a: 'key'};
  const context = {
    [key.a]: identity([props.value]),
  };
  mutate(key);
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that creates an object from props, deletes a property, and returns the modified object. Includes a fixture entrypoint configuration for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/delete-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {a: props.a, b: props.b};
  delete x.b;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component Rendering with Memo and Static Text in JavaScript
DESCRIPTION: This snippet demonstrates a memoized approach to rendering a React component named `Component` using static text elements. It imports a custom React compiler-runtime function (`_c`) to optimize rendering by maintaining a cache for memoization. The component uses shared runtime dependencies (`StaticText1` and `StaticText2`) and evaluates prop values to update the component only when necessary, thus optimizing performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-tag-evaluation-order.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { StaticText1, StaticText2 } from "shared-runtime";

function Component(props) {
  const $ = _c(3);

  const t0 = props.value;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <StaticText2 />;
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== t0) {
    t2 = (
      <StaticText1>
        {t0}
        {t1}
      </StaticText1>
    );
    $[1] = t0;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "string value 1" }],
  isComponent: true,
};

```

----------------------------------------

TITLE: Chaining Frontend API Methods
DESCRIPTION: Example showing how to chain Frontend API methods for convenience in initializing DevTools UI.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-core/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
const DevtoolsUI = require("react-devtools-core/standalone");
DevtoolsUI.setContentDOMNode(element).startServer();
```

----------------------------------------

TITLE: React Component with try/catch
DESCRIPTION: This React component attempts to access `props.cond` and `props.foo` within a try/catch block. The intention is to catch any errors that might occur during property access. The error message indicates an unsupported feature.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-logical-expression-within-try-catch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let result;
  try {
    result = props.cond && props.foo;
  } catch (e) {
    console.log(e);
  }
  return result;
}

```

----------------------------------------

TITLE: Defining a React Component with Conditional Logic and Array Manipulation
DESCRIPTION: A React component that conditionally creates an array based on props and manipulates it. It demonstrates a pattern where an object is created and later pushed into a conditionally created array, then both are returned.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-array-push.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {};
  let y;
  if (props.cond) {
    y = [props.value];
  } else {
    y = [];
  }
  // This should be inferred as `<store> y` s.t. `x` can still
  // be independently memoized. *But* this also must properly
  // extend the mutable range of the array literals in the
  // if/else branches
  y.push(x);

  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, value: 42}],
  sequentialRenders: [
    {cond: true, value: 3.14},
    {cond: false, value: 3.14},
    {cond: true, value: 42},
  ],
};
```

----------------------------------------

TITLE: Compiled React Hook with Explicit Memoization Logic
DESCRIPTION: Shows the compiled version of the useMakeCallback hook with React compiler transformations. The compiler adds explicit memoization logic using an array for caching dependencies and the callback function, reusing the cached version when dependencies haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/return-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper } from "shared-runtime";

/**
 * Assume that directly returned functions are invoked and that their property
 * loads are hoistable.
 */
function useMakeCallback(t0) {
  const $ = _c(3);
  const { obj, setState } = t0;
  let t1;
  if ($[0] !== obj.value || $[1] !== setState) {
    t1 = () => setState(obj.value);
    $[0] = obj.value;
    $[1] = setState;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

const setState = (arg: number) => {
  "use no memo";
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useMakeCallback),
  params: [{ obj: { value: 1 }, setState }],
  sequentialRenders: [
    { obj: { value: 1 }, setState },
    { obj: { value: 2 }, setState },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Transformed version of the component with added memoization logic using Symbol.for('react.memo_cache_sentinel'). Includes caching mechanism to prevent unnecessary recreations of mutable objects and arrays.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-capture-in-method-receiver-and-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeObject_Primitives, mutate } from "shared-runtime";

function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = makeObject_Primitives();

    const x = [];
    x.push(a);

    mutate(x);
    t0 = [x, a];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Creating an Optimized Custom Hook in React
DESCRIPTION: Implements an optimized version of the 'useFoo' hook that utilizes reference tracking to minimize re-renders and improve performance. It makes use of a compiler runtime and maintains state through a cached array. This version is more efficient but requires the 'react/compiler-runtime' package.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-hook-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper } from "shared-runtime";
import { useState } from "react";
function useFoo() {
  const $ = _c(2);
  const [state] = useState(false);
  let t0;
  if ($[0] !== state) {
    t0 = {
      func() {
        return state;
      },
    };
    $[0] = state;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useFoo),
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized Conditional Render Component in React
DESCRIPTION: This snippet enhances the previous component with optimizations using a 'compiler-runtime' to manage render states. It conditionally renders static text and employs memoization to reduce rendering overhead. It also exports the component with defined parameters for consistency in testing and usage across the application.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-ternary-local-variable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { RenderPropAsChild, StaticText1, StaticText2 } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  const Foo = props.showText1 ? StaticText1 : StaticText2;
  let t0;
  if ($[0] !== Foo) {
    t0 = <RenderPropAsChild items={[() => <Foo key="0" />]} />;
    $[0] = Foo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ showText1: false }],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime in JavaScript
DESCRIPTION: This snippet shows the optimized version of the React component after compilation. It uses the React compiler runtime for performance improvements, including memoization of the Stringify component rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component-inner-function-with-many-args.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";
function Component(props) {
  const $ = _c(2);
  const cb = _temp;
  let t0;
  if ($[0] !== props.id) {
    t0 = <Stringify cb={cb} id={props.id} />;
    $[0] = props.id;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function _temp(x, y, z) {
  return x + y + z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 0 }],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Original implementation of a React component that uses conditional logic to modify a variable based on props. Uses the 'invoke' utility from shared-runtime to call a method.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-objectmethod.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {invoke} from 'shared-runtime';

function Component({cond}) {
  let x = 2;
  const obj = {
    method(cond) {
      if (cond) {
        x = 4;
      }
    },
  };
  invoke(obj.method, cond);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};
```

----------------------------------------

TITLE: Optimized Router Component with React Compiler Runtime
DESCRIPTION: This is an optimized version of the Router component using React's compiler runtime. It includes memoization to prevent unnecessary re-renders when the inputs haven't changed. The code also defines the routes and FIXTURE_ENTRYPOINT for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-iterator-of-immutable-collection.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Router(t0) {
  const $ = _c(3);
  const { title, mapping } = t0;
  let array;
  if ($[0] !== mapping || $[1] !== title) {
    array = [];
    for (const entry of mapping.values()) {
      array.push([title, entry]);
    }
    $[0] = mapping;
    $[1] = title;
    $[2] = array;
  } else {
    array = $[2];
  }
  return array;
}

const routes = new Map([
  ["about", "/about"],
  ["contact", "/contact"],
]);

export const FIXTURE_ENTRYPOINT = {
  fn: Router,
  params: [],
  sequentialRenders: [
    {
      title: "Foo",
      mapping: routes,
    },
    {
      title: "Bar",
      mapping: routes,
    },
  ],
};
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This code defines a React functional component named `foo`. The component takes `props` as input, initializes a variable `x` to 0, and enters a while loop that continues as long as `x` is greater than `props.min` and less than `props.max`. Inside the loop, `x` is multiplied by 2. Finally, the component returns the final value of `x`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-logical.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let x = 0;
  while (x > props.min && x < props.max) {
    x *= 2;
  }
  return x;
}
```

----------------------------------------

TITLE: Exporting React Component Fixture in JavaScript
DESCRIPTION: This snippet defines a simple React component and exports it as a fixture entry point. It includes the component function and parameters necessary for its initialization. The expected input is a function that acts as a React component, and it exports an object containing the component function and its parameters as an array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.handle-unexpected-exception-pipeline.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @throwUnknownException__testonly:true

function Component() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Compiled React Component with Memo Cache
DESCRIPTION: The transformed version of the component after compilation, using React's memo cache system. It introduces a cache sentinel check to avoid redundant computation on re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-object-in-context.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = [];
    const foo = () => {
      x = {};
    };

    foo();
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Compiler Transformed Component with Memoization
DESCRIPTION: The compiler-transformed version of the same component that automatically implements memoization. It imports a runtime helper and uses an array to cache the props and result, recalculating only when props change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-receiver-method-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    const x = makeOptionalObject(props);
    const y = makeObject(props);
    t0 = x?.method(y.a, props.a, foo(y.b), bar(props.b));
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  return z;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization Implementation
DESCRIPTION: Compiled version of the component showing how React implements memoization using a compiler runtime. The code includes caching logic to prevent unnecessary recomputation of values and function references.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-noAlias-escaping-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  const f = _temp;
  let t0;
  if ($[0] !== props.items) {
    t0 = [...props.items].map(f);
    $[0] = props.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  let t1;
  if ($[2] !== x) {
    t1 = [x, f];
    $[2] = x;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
function _temp(item) {
  return item;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ items: [{ id: 1 }] }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Components with Memoization
DESCRIPTION: Compiled version of the React components with added memoization logic. Shows how the forget directive is transformed into conditional rendering with value caching using the compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating @compilationMode(annotation)
export const Bar = isForgetEnabled_Fixtures()
  ? function Bar(props) {
      "use forget";
      const $ = _c(2);
      let t0;
      if ($[0] !== props.bar) {
        t0 = <div>{props.bar}</div>;
        $[0] = props.bar;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : function Bar(props) {
      "use forget";
      return <div>{props.bar}</div>;
    };

export function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}

export const Foo = isForgetEnabled_Fixtures()
  ? function Foo(props) {
      "use forget";
      const $ = _c(2);
      let t0;
      if ($[0] !== props.bar) {
        t0 = <Foo>{props.bar}</Foo>;
        $[0] = props.bar;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : function Foo(props) {
      "use forget";
      return <Foo>{props.bar}</Foo>;
    };

export const FIXTURE_ENTRYPOINT = {
  fn: eval("Bar"),
  params: [{ bar: 2 }],
};
```

----------------------------------------

TITLE: Transformed React Hook with Compiler Optimizations
DESCRIPTION: This code shows the compiled version of the `useFoo` hook, demonstrating the React compiler's optimizations for state updates and memoization. It uses `react/compiler-runtime` for efficient memoization and avoids unnecessary re-renders by caching the results of the `handleLogout` and `getComponent` functions. The compiler also ensures that the `onClick` handler and the component returned by `getComponent` are memoized correctly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-setstate-captured-indirectly-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
function useFoo() {
  const $ = _c(9);
  const onClick = (response) => {
    setState(DISABLED_FORM);
  };

  const [, t0] = useState();
  const setState = t0;
  let t1;
  if ($[0] !== setState) {
    t1 = () => {
      setState(DISABLED_FORM);
    };
    $[0] = setState;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  setState;
  const handleLogout = t1;
  let t2;
  if ($[2] !== handleLogout) {
    t2 = () => <ColumnItem onPress={() => handleLogout()} />;
    $[2] = handleLogout;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const getComponent = t2;
  let t3;
  if ($[4] !== getComponent) {
    t3 = getComponent();
    $[4] = getComponent;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== onClick || $[7] !== t3) {
    t4 = [t3, onClick];
    $[6] = onClick;
    $[7] = t3;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  return t4;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This JavaScript code shows the compiled version of the React component, leveraging React's compiler runtime. The `_c` function is used for memoization, caching the result of the array construction based on the values of `props.foo` and `props.bar`. This avoids unnecessary re-renders if the props haven't changed, optimizing performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-expression-spread.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.bar || $[1] !== props.foo) {
    t0 = [0, ...props.foo, null, ...props.bar, "z"];
    $[0] = props.bar;
    $[1] = props.foo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ foo: [1, 2, 3], bar: [4, 5, 6] }],
  isComponent: false,
};

```

----------------------------------------

TITLE: Implementing React Component with Stringify and User IDs
DESCRIPTION: This snippet defines a React component 'Foo' that renders a Stringify component. It takes an array of user IDs as input and creates a new array from them. The FIXTURE_ENTRYPOINT is defined for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-backedge-reference-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Foo({userIds}) {
  return (
    <Stringify
      fn={() => {
        const arr = [];

        for (const selectedUser of userIds) {
          arr.push(selectedUser);
        }
        return arr;
      }}
      shouldInvokeFns={true}
    />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{userIds: [1, 2, 3]}],
  sequentialRenders: [{userIds: [1, 2, 4]}],
};
```

----------------------------------------

TITLE: React Component Definition with Fixture Export
DESCRIPTION: Defines a React functional component that renders 'Hello World' and exports it as a fixture with metadata. The component uses a custom directive 'use no forget' and is configured with an empty params array and isComponent flag.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-forget-with-no-errors.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  'use no forget';
  return <div>Hello World</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};
```

LANGUAGE: javascript
CODE:
```
function Component() {
  "use no forget";
  return <div>Hello World</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Advanced Function Component with Runtime Cache in React
DESCRIPTION: This snippet demonstrates a more complex version of the 'Foo' component that utilizes the 'react/compiler-runtime' for caching and memoization. It checks if the cached value is available, and if not, it creates a new instance of 'Stringify'. The function manages render counting via a separate '_temp' function, enhancing performance through memoization strategies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-global-in-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

let renderCount = 0;
function Foo() {
  const $ = _c(1);
  const cb = _temp;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Stringify cb={cb} shouldInvokeFns={true} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  renderCount = renderCount + 1;
  return renderCount;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized useState in JavaScript
DESCRIPTION: This snippet shows the compiled version of the React component. It uses an optimized version of useState, employing a caching mechanism to avoid unnecessary re-renders. The component structure and FIXTURE_ENTRYPOINT export remain the same.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-import-specifier.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import type { SetStateAction, Dispatch } from "react";
import { useState } from "react";

function Component(_props) {
  const $ = _c(2);
  const [x] = useState(0);
  let t0;
  if ($[0] !== x) {
    t0 = { x };
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component and Fixture Definition
DESCRIPTION: Defines a React component function `t` that destructures the `props` array and returns the second element (indexed as `foo`). It also defines a constant `FIXTURE_ENTRYPOINT` that serves as a fixture configuration.  This configuration specifies the component function (`fn`), the expected parameters (`params`), and the component name (`isComponent`).
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-pattern-dce.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function t(props) {
  const [, foo] = props;
  return foo;
}

export const FIXTURE_ENTRYPOINT = {
  fn: t,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: React Compiler Runtime Component with Caching
DESCRIPTION: An optimized version of the component using React compiler runtime for memoization, with conditional rendering and state preservation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-2-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function component(foo, bar) {
  const $ = _c(3);
  let x;
  if ($[0] !== bar || $[1] !== foo) {
    x = { foo };
    const y = { bar };

    const a = { y };
    const b = x;
    a.x = b;

    mutate(y);
    $[0] = bar;
    $[1] = foo;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["foo", "bar"],
};
```

----------------------------------------

TITLE: Compiler-Transformed Implementation with Memoization
DESCRIPTION: The React compiler's transformed version of the useMakeCallback hook with automatic memoization. It uses a cache array to store dependencies (obj.value and setState) and the memoized result to prevent unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/jsx-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function useMakeCallback(t0) {
  const $ = _c(3);
  const { obj, setState } = t0;
  let t1;
  if ($[0] !== obj.value || $[1] !== setState) {
    t1 = <Stringify cb={() => setState(obj.value)} shouldInvokeFns={true} />;
    $[0] = obj.value;
    $[1] = setState;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

const setState = (arg: number) => {
  "use no memo";
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{ obj: { value: 1 }, setState }],
  sequentialRenders: [
    { obj: { value: 1 }, setState },
    { obj: { value: 2 }, setState },
  ],
};
```

----------------------------------------

TITLE: Memoized React Hook: useFoo with React Compiler Runtime
DESCRIPTION: This JavaScript code defines a memoized React hook `useFoo` leveraging React's compiler runtime. It imports `makeReadOnly` and `_c` from `react-compiler-runtime` and `react/compiler-runtime` respectively. The hook uses `_c` to memoize the result of `foo(props.x, __DEV__)`, updating the memoized value only when `props.x` changes. In development, `makeReadOnly` is used to ensure immutability of the returned value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/emit-freeze-nonconflicting-global-reference.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { makeReadOnly } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @enableEmitFreeze @instrumentForget
function useFoo(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.x) {
    t0 = foo(props.x, __DEV__);
    $[0] = props.x;
    $[1] = __DEV__ ? makeReadOnly(t0, "useFoo") : t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Using Memoization and Conditional Rendering in a React Component - JavaScript
DESCRIPTION: This snippet showcases an advanced implementation of a React functional component using memoization. The component, 'Component', incorporates the 'react/compiler-runtime' for memoization of the component's output based on props. It initializes a memoized value and leverages optional function calls to decide how to render JSX based on the props received.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-with-independently-memoizable-arg.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    const x = makeOptionalFunction(props);

    t0 = x?.(
      <div>
        <span>{props.text}</span>
      </div>,
    );
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const y = t0;
  return y;
}

```

----------------------------------------

TITLE: Optimized State Management React JavaScript
DESCRIPTION: This snippet shows an optimized state management approach using React's component for improved performance. The 'Component' function uses a compiler-runtime related import to optimize conditional updates of component states, minimizing re-computation and unnecessary renders. This requires installing the react/compiler-runtime package.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independent-across-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function compute() {}
function mutate() {}
function foo() {}
function Foo() {}

/**
 * Should produce 3 scopes:
 *
 * a: inputs=props.a & props.c; outputs=a
 *   a = compute(props.a);
 *   if (props.c)
 *     mutate(a)
 * b: inputs=props.b & props.c; outputs=b
 *   b = compute(props.b);
 *   if (props.c)
 *     mutate(b)
 * return: inputs=a, b outputs=return
 *   return = <Foo a={a} b={b} />
 */
function Component(props) {
  const $ = _c(8);
  let a;
  let b;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.c) {
    a = compute(props.a);
    b = compute(props.b);
    if (props.c) {
      mutate(a);
      mutate(b);
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = a;
    $[4] = b;
  } else {
    a = $[3];
    b = $[4];
  }
  let t0;
  if ($[5] !== a || $[6] !== b) {
    t0 = <Foo a={a} b={b} />;
    $[5] = a;
    $[6] = b;
    $[7] = t0;
  } else {
    t0 = $[7];
  }
  return t0;
}

```

----------------------------------------

TITLE: Compiled Output with Inferred Dependencies
DESCRIPTION: The compiled version of the component with automatically inferred dependencies for the useEffect hook. The compiler creates a cache array and tracks changes to objects and their properties to properly determine when effects should re-run.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-memberexpr-merge.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect } from "react";
import { print } from "shared-runtime";

function ReactiveMemberExprMerge(t0) {
  const $ = _c(4);
  const { propVal } = t0;
  let t1;
  if ($[0] !== propVal) {
    t1 = { a: { b: propVal } };
    $[0] = propVal;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const obj = t1;
  let t2;
  if ($[2] !== obj.a) {
    t2 = () => print(obj.a, obj.a.b);
    $[2] = obj.a;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  useEffect(t2, [obj.a]);
}
```

----------------------------------------

TITLE: React Compiler Runtime Optimized Component
DESCRIPTION: Advanced implementation of React component using compiler runtime memoization. Implements caching mechanism to optimize repeated renders and minimize unnecessary data fetching.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/await.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
async function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.id) {
    t0 = await load(props.id);
    $[0] = props.id;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const user = t0;
  let t1;
  if ($[2] !== user.name) {
    t1 = <div>{user.name}</div>;
    $[2] = user.name;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
```

----------------------------------------

TITLE: Optimized Custom Hook and Component with React Compiler - JavaScript
DESCRIPTION: This snippet showcases a similar component but uses a compiler runtime optimization, with react's memos and caching. The custom hook and component Foo are enhanced to cache objects and reuse them to leverage memoization for optimized re-renders. It requires that the react/compiler-runtime is available for _c function used in memoization. This snippet is intended to demonstrate advanced optimization using compiler-level hooks in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-useCallback-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableTreatRefLikeIdentifiersAsRefs @validatePreserveExistingMemoizationGuarantees\nimport { useRef, useCallback } from "react";\n\nfunction useCustomRef() {\n  const $ = _c(1);\n  let t0;\n  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {\n    t0 = { click: _temp };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  return useRef(t0);\n}\nfunction _temp() {}\n\nfunction Foo() {\n  const $ = _c(2);\n  const ref = useCustomRef();\n  let t0;\n  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {\n    t0 = () => {\n      ref.current?.click();\n    };\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const onClick = t0;\n  let t1;\n  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {\n    t1 = <button onClick={onClick} />;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [],\n  isComponent: true,\n};
```

----------------------------------------

TITLE: Optimizing Component with Compiler Runtime in React - JavaScript
DESCRIPTION: This snippet showcases an optimized React component using 'react/compiler-runtime'. It employs caching for performance, ensuring object properties are updated only when necessary. The component function interacts with the FIXTURE_ENTRYPOINT to define its behavior and identify it as 'TodoAdd'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-pattern-params.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(t0) {
  const $ = _c(7);
  const { a, b } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = { a };
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const y = t1;
  let t2;
  if ($[2] !== b) {
    t2 = { b };
    $[2] = b;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const z = t2;
  let t3;
  if ($[4] !== y || $[5] !== z) {
    t3 = { y, z };
    $[4] = y;
    $[5] = z;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Compiled Output of Conditional Subpath Optimization in React
DESCRIPTION: Compiled version of the function showing how the React Compiler has transformed it to include memoization. The compiler has optimized the dependency tracking to just track 'props.a' rather than both 'props.a' and 'props.a.b'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/subpath-order1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // When a conditional dependency `props.a` is a subpath of an unconditional
// dependency `props.a.b`, we can access `props.a` while preserving program
// semantics (with respect to nullthrows).
// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`

import { identity } from "shared-runtime";

// ordering of accesses should not matter
function useConditionalSubpath1(props, cond) {
  const $ = _c(3);
  let x;
  if ($[0] !== cond || $[1] !== props.a) {
    x = {};
    x.b = props.a.b;
    if (identity(cond)) {
      x.a = props.a;
    }
    $[0] = cond;
    $[1] = props.a;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Shows the compiler-transformed version of the Foo component with added memoization. The React compiler has added a cache array (_c) to store previous prop values and output, optimizing rendering by skipping computation when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-within-nested-valueblock-in-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify, identity, makeArray, mutate } from "shared-runtime";

/**
 * Here, identity('foo') is an immutable allocating instruction.
 * `arr` is a mutable value whose mutable range ends at `arr.map`.
 *
 * The previous (reactive function) version of alignScopesToBlocks set the range of
 * both scopes to end at value blocks within the <></> expression.
 * However, both scope ranges should be aligned to the outer value block
 * (e.g. `cond1 ? <>: null`). The HIR version of alignScopesToBlocks
 * handles this correctly.
 */
function Foo(t0) {
  const $ = _c(3);
  const { cond1, cond2 } = t0;
  let t1;
  if ($[0] !== cond1 || $[1] !== cond2) {
    const arr = makeArray({ a: 2 }, 2, []);

    t1 = cond1 ? (
      <>
        <div>{identity("foo")}</div>
        <Stringify value={cond2 ? arr.map(mutate) : null} />
      </>
    ) : null;
    $[0] = cond1;
    $[1] = cond2;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ cond1: true, cond2: true }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Transformed version of the component with added memoization using Symbol.for checks. Includes compiler runtime imports and caching mechanism for object and JSX elements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/numeric-literal-as-object-property-key.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Test() {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { 21: "dimaMachina" };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const obj = t0;

  const { 21: myVar } = obj;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (
      <div>
        {obj[21]}
        {myVar}
      </div>
    );
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Feature Flag Logic
DESCRIPTION: Transformed version of the React component with compiled forget functionality. Includes conditional rendering based on feature flag and caching mechanism for optimized rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/conflicting-gating-fn.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures as _isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating

export const isForgetEnabled_Fixtures = () => {
  "use no forget";
  return false;
};

export const Bar = _isForgetEnabled_Fixtures()
  ? function Bar(props) {
      "use forget";
      const $ = _c(2);
      let t0;
      if ($[0] !== props.bar) {
        t0 = <div>{props.bar}</div>;
        $[0] = props.bar;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : function Bar(props) {
      "use forget";
      return <div>{props.bar}</div>;
    };

export const FIXTURE_ENTRYPOINT = {
  fn: eval("Bar"),
  params: [{ bar: 2 }],
};
```

----------------------------------------

TITLE: Defining a Simple Component in JavaScript
DESCRIPTION: This function defines a simple React component that receives an object with properties 'a' and 'b' and returns an object containing 'y' and 'z'. It is used in conjunction with the FIXTURE_ENTRYPOINT object to specify parameters and component identity for 'TodoAdd'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-pattern-params.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function component({a, b}) {
  let y = {a};
  let z = {b};
  return {y, z};
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Input Component Definition with Arrow Function Default
DESCRIPTION: Original React component definition using an arrow function as a default parameter value for x. Exports a fixture entrypoint for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-with-empty-callback.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(x = () => {}) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Original React Component with Function Dependencies
DESCRIPTION: Initial implementation of a React component that checks a property length with a nested function. Uses the @enableTreatFunctionDepsAsConditional directive for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/functionexprconditional-access.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableTreatFunctionDepsAsConditional
function Component(props) {
  function getLength() {
    return props.bar.length;
  }

  return props.bar && getLength();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{bar: null}],
};
```

----------------------------------------

TITLE: Defining a Reactive Component in React (JavaScript)
DESCRIPTION: This snippet defines a React functional component, implementing non-reactive state variables that depend on a reactive prop. The component computes the value of `x` based on a loop relative to the `props.init` value, returning it in an array. The snippet also discusses the reactive nature of `x` due to its dependence on the `props.init` control variable.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-init.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  for (let i = props.init; i < 10; i++) {
    if (i === 0) {
      x = 0;
      break;
    } else {
      x = 1;
      break;
    }
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" variable `i`, whose initial value `props.init` is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {init: 0},
    {init: 0},
    {init: 10},
    {init: 10},
    {init: 0},
    {init: 10},
    {init: 0},
    {init: 10},
  ],
};
```

----------------------------------------

TITLE: Defining a Component with Non-Reactive State - JavaScript
DESCRIPTION: This snippet defines a React component named `Component` that determines the value of `x` based on the input props. The logic sets `x` to 10 if the input value is greater than 10, or to 1 otherwise. The component returns an array containing the value of `x`, which is commented to indicate that while `x` is non-reactive, it depends on the reactive control variable `i`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-forof-collection.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  for (const i of props.values) {
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" variable `i`, whose value is derived from
  // `props.values` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {values: [12]},
    {values: [12]},
    {values: [1]},
    {values: [1]},
    {values: [12]},
    {values: [1]},
    {values: [12]},
    {values: [1]},
  ],
};
```

----------------------------------------

TITLE: Original React Component with Dynamic Component Creation
DESCRIPTION: A React functional component that dynamically creates a component during render by calling a method on a prop. This pattern can cause state reset issues and is flagged by React's validation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-method-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger @validateStaticComponents
function Example(props) {
  const Component = props.foo.bar();
  return <Component />;
}
```

----------------------------------------

TITLE: Defining React Component with Nested Scopes
DESCRIPTION: This snippet defines a React component with nested scopes and potential variable shadowing. It demonstrates a function that mutates a local array and returns an object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutate-shadowed-object.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const x = {};
  {
    const x = [];
    const fn = function () {
      mutate(x);
    };
    fn();
  }
  return x; // should return {}
}
```

----------------------------------------

TITLE: Defining React Component with Array Props
DESCRIPTION: This snippet defines a React component that creates arrays from props and returns a logical expression. It also exports a fixture entrypoint for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-logical.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const a = [props.a];
  const b = [props.b];
  const c = [props.c];
  // We don't do constant folding for non-primitive values (yet) so we consider
  // that any of a, b, or c could return here
  return (a && b) || c;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Implementing FBT in a React Component
DESCRIPTION: This snippet shows a React component using FBT for internationalization. It demonstrates how to use fbt tags and parameters within JSX to create localizable content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-text-must-use-expression-container.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component(props) {
  return (
    <Foo
      value={
        <fbt desc="Description of the parameter">
          <fbt:param name="value">{'0'}</fbt:param>%
        </fbt>
      }
    />
  );
}
```

----------------------------------------

TITLE: React Compiler Error Message for Memoization Issues
DESCRIPTION: The error message from React Compiler indicating that it skipped optimizing the component due to memoization preservation issues. It highlights three specific locations where memoization could not be preserved, primarily due to potential mutations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-missed-memoization-from-inferred-mutation-in-logger.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
   9 |   const [index, setIndex] = useState(0);
  10 |
> 11 |   const logData = useMemo(() => {
     |                   ^^^^^^^^^^^^^^^
> 12 |     const item = items[index];
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 13 |     return {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 14 |       key: item.key,
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 15 |     };
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 16 |   }, [index, items]);
     | ^^^^^^^^^^^^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (11:16)

CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly (28:28)

CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (19:27)
  17 |
  18 |   const setCurrentIndex = useCallback(
  19 |     (index: number) => {
```

----------------------------------------

TITLE: React Component with Array Destructuring
DESCRIPTION: Defines a React component `foo` that receives props and uses array destructuring to extract the first two elements into variables x and y. The function returns the sum of x and y. It also exports FIXTURE_ENTRYPOINT, which configures the component for a test environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-array-rest-element.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(props) {
  const [x, y] = props.a;
  return x + y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component with React compiler runtime optimizations. Includes memoization for props.value spreading and maintains the same functionality as the input version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-continue.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  let t0;
  if ($[0] !== props.value) {
    t0 = { ...props.value };
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const object = t0;
  for (const y in object) {
    if (y === "continue") {
      continue;
    }

    x = object[y];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: { a: "a", continue: "skip", b: "hello!" } }],
  sequentialRenders: [
    { value: { a: "a", continue: "skip", b: "hello!" } },
    { value: { a: "a", continue: "skip", b: "hello!" } },
    { value: { a: "skip!", continue: true } },
    { value: { a: "a", continue: "skip", b: "hello!" } },
    { value: { a: "skip!", continue: true } },
    { value: { a: "a", continue: "skip", b: "hello!" } },
    { value: { a: "skip!", continue: true } },
    { value: { a: "skip!", continue: true } },
  ],
};
```

----------------------------------------

TITLE: Creating an Array with Optional Chaining from Nullable Values in React
DESCRIPTION: This code defines a 'useFoo' function that handles a prop containing a nullable nested object, attempts to create an array from its properties using optional chaining, and then tries to join the array elements. It also includes a helper 'createArray' function and exports a test fixture. The code generates a type error for the optional chaining usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-optional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo(props: {value: {x: string; y: string} | null}) {
  const value = props.value;
  return createArray(value?.x, value?.y)?.join(', ');
}

function createArray<T>(...args: Array<T>): Array<T> {
  return args;
}

export const FIXTURE_ENTRYPONT = {
  fn: useFoo,
  props: [{value: null}],
};
```

----------------------------------------

TITLE: Creating Custom Hook Wrapper in React - JavaScript
DESCRIPTION: This snippet demonstrates how to define a custom hook in React using JavaScript. It uses the 'createHookWrapper' from a shared runtime to wrap the 'useHook' function, which manages values 'a' and 'b'. It returns an object with methods 'x' and 'y' that encapsulate these values. The FIXTURE_ENTRYPOINT establishes how the hook will be used, defining 'params' with initial values for 'a' and 'b'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper} from 'shared-runtime';
function useHook({a, b}) {
  return {
    x: function () {
      return [a];
    },
    y() {
      return [b];
    },
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{a: 1, b: 2}],
};

```

----------------------------------------

TITLE: Using Special Effect in React
DESCRIPTION: This snippet defines a React functional component that uses a special effect for managing side effects tied to props. It logs the prop value and captures any exceptions during the execution. The useSpecialEffect function is imported from 'shared-runtime', which handles the lifecycle of side effects. The expected input is a prop object with 'prop1', and the output is rendered JSX containing the prop value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.todo-syntax.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import {useSpecialEffect} from 'shared-runtime';

/**
 * Note that a react compiler-based transform still has limitations on JS syntax.
 * We should surface these as actionable lint / build errors to devs.
 */
function Component({prop1}) {
  'use memo';
  useSpecialEffect(() => {
    try {
      console.log(prop1);
    } finally {
      console.log('exiting');
    }
  }, [prop1]);
  return <div>{prop1}</div>;
}

```

----------------------------------------

TITLE: Initializing Object References with 'let' in React Component
DESCRIPTION: This snippet demonstrates object reference assignment using 'let' variable declarations in a React component function. It creates multiple objects and assigns references between them before calling a 'mutate' function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-alias-fields.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let x = {};
  let p = {};
  let q = {};
  let y = {};

  x.y = y;
  p.y = x.y;
  q.y = p.y;

  mutate(q);
}
```

----------------------------------------

TITLE: Calculating Factorial using JavaScript in React
DESCRIPTION: This snippet demonstrates a React functional component that calculates the factorial of a number using a slightly optimized closure for caching results. It utilizes the React 'c' function from the compiler-runtime for optimization. The input is an object containing a numeric value, with the output being the factorial of that value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-recursive-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(t0) {
  const $ = _c(2);
  const { value } = t0;
  let t1;
  if ($[0] !== value) {
    const factorial = (x) => {
      if (x <= 1) {
        return 1;
      } else {
        return x * factorial(x - 1);
      }
    };

    t1 = factorial(value);
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ value: 3 }],
};
```

----------------------------------------

TITLE: Compiled Version of 'useFoo' React Hook in JavaScript
DESCRIPTION: This snippet shows the compiled version of the 'useFoo' React hook. It includes optimizations for memoization and early returns. The code uses a compiler runtime and maintains the same functionality as the original implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-in-nested-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate, setProperty, throwErrorWithMessageIf } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(6);
  const { value, cond } = t0;
  let t1;
  let y;
  if ($[0] !== cond || $[1] !== value) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      y = [value];
      let x;
      if ($[4] !== cond) {
        x = { cond };
        try {
          mutate(x);
          throwErrorWithMessageIf(x.cond, "error");
        } catch {
          setProperty(x, "henderson");
          t1 = x;
          break bb0;
        }

        setProperty(x, "nevada");
        $[4] = cond;
        $[5] = x;
      } else {
        x = $[5];
      }
      y.push(x);
    }
    $[0] = cond;
    $[1] = value;
    $[2] = t1;
    $[3] = y;
  } else {
    t1 = $[2];
    y = $[3];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ value: 4, cond: true }],
  sequentialRenders: [
    { value: 4, cond: true },
    { value: 5, cond: true },
    { value: 5, cond: false },
  ],
};
```

----------------------------------------

TITLE: Defining Component with Conditional Logic in React - JavaScript
DESCRIPTION: This snippet defines a functional React component 'Component' that performs conditional logic based on 'props.cond'. It initializes a variable 't0' and evaluates the condition without utilizing hooks. The fixture entry point is exported for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-nested-ifs.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let t0;
  if (props.cond) {
    if (props.cond) {
    }
  }
  t0 = undefined;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Initializing React Dependency Tracking Function
DESCRIPTION: A function demonstrating React compiler's ability to track nested object dependencies without order-sensitive access
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function TestDepsSubpathOrder1(props) {
  let x = {};
  x.b = props.a.b;
  x.a = props.a;
  x.c = props.a.b.c;
  return x;
}
```

----------------------------------------

TITLE: React Component with Multiple Parameters
DESCRIPTION: Defines a React component named `Component` that accepts two parameters, `foo` and `bar`. The component returns a simple `div` element. It also defines and exports a constant `FIXTURE_ENTRYPOINT` which is an object containing the component function and a `params` array to be passed to the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-dont-compile-components-with-multiple-params.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
// Takes multiple parameters - not a component!
function Component(foo, bar) {
  return <div />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [null, null],
};

```

----------------------------------------

TITLE: Implementing a React Test Fixture with Conditional Logic
DESCRIPTION: A JavaScript function 'foo' with conditional logic that modifies a variable based on a condition, followed by a FIXTURE_ENTRYPOINT export that exposes the function for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-simple-phi.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let y = 2;

  if (y > 1) {
    y = 1;
  } else {
    y = 2;
  }

  let x = y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Exporting Fixture Entrypoint for React Component Testing
DESCRIPTION: This snippet exports a constant FIXTURE_ENTRYPOINT object that contains metadata about the Component function. It specifies the function, parameters, and component name, likely used for testing or integration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-set-state-in-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining React Fixture Entrypoint in JavaScript
DESCRIPTION: This code defines a simple function 'foo' and exports a constant FIXTURE_ENTRYPOINT. The FIXTURE_ENTRYPOINT object specifies the function to be used, the parameters, and the name of the React component (TodoAdd) for fixture testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/trivial.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(x) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Direct Implementation of Custom Hook - JavaScript
DESCRIPTION: The snippet provides a basic implementation of the custom hook useFoo without React-specific optimizations, focusing on managing object properties based on a null check. It does not require additional dependencies besides JavaScript execution environment. The hook logic involves conditionally populating an array with object properties. Expected input is an object with obj and objIsNull properties. The function outputs an array. This version directly highlights the functional behavior without external optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-break-in-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useFoo({obj, objIsNull}) {
  const x = [];
  b0: {
    if (objIsNull) {
      break b0;
    } else {
      x.push(obj.a);
    }
    x.push(obj.b);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{obj: null, objIsNull: true}],
  sequentialRenders: [
    {obj: null, objIsNull: true},
    {obj: {a: 2}, objIsNull: false},
  ],
};

```

----------------------------------------

TITLE: Advanced Component Logic with Compiler Runtime
DESCRIPTION: This snippet shows a React functional component with more complex handling of memoization and runtime cache. It leverages a utility from 'react/compiler-runtime' to memoize values based on runtime conditions. The component works by checking specific conditions in an internal cache, defaulting values as necessary, and keeping track of state changes to determine return values. The key dependencies are compiler-runtime utilities and React hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/immutable-hooks.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableAssumeHooksFollowRulesOfReact true
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  const y = useFoo(x);
  bar(x, y);
  let t1;
  if ($[1] !== y) {
    t1 = [x, y];
    $[1] = y;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
```

----------------------------------------

TITLE: React Component Destructuring Error
DESCRIPTION: An error output showing that destructuring of context variables is not supported. The error points to the 'foo' parameter in the component definition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-reassign-const.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  1 | import {Stringify} from 'shared-runtime';
  2 |
> 3 | function Component({foo}) {
    |                     ^^^ Todo: Support destructuring of context variables (3:3)
  4 |   let bar = foo.bar;
  5 |   return (
  6 |     <Stringify
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component function that creates an object with a property and returns a closure function that logs it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-variable-in-nested-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a};
  let x = function () {
    {
      console.log(z);
    }
  };
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Calculating Sum within a React Component (JavaScript)
DESCRIPTION: This snippet defines a React component that calculates a sum starting from a base value, incrementing the loop index by a specified increment until a test condition is met. The results are rendered in a React div. No external dependencies are required beyond the usual React setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-reassigned-loop-force-scopes-enabled.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @enableForest\nfunction Component({base, start, increment, test}) {\n  let value = base;\n  for (let i = start; i < test; i += increment) {\n    value += i;\n  }\n  return <div>{value}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{base: 0, start: 0, test: 10, increment: 1}],\n  sequentialRenders: [\n    {base: 0, start: 1, test: 10, increment: 1},\n    {base: 0, start: 0, test: 10, increment: 2},\n    {base: 2, start: 0, test: 10, increment: 2},\n    {base: 0, start: 0, test: 11, increment: 2},\n  ],\n};\n
```

----------------------------------------

TITLE: Original JavaScript Function with Loop and Conditional Logic
DESCRIPTION: The input JavaScript function that initializes an empty array, iterates through it, and conditionally assigns a value based on a condition parameter. This represents code before React compiler transformation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for-of.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(cond) {
  let items = [];
  for (const item of items) {
    let y = 0;
    if (cond) {
      y = 1;
    }
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Initializing Basic React Component
DESCRIPTION: A simple React functional component that creates a MaybeMutable instance and renders a component with dynamic content
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-member-expression-tag-grouping.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const maybeMutable = new MaybeMutable();
  return <Foo.Bar>{maybeMutate(maybeMutable)}</Foo.Bar>;
}
```

----------------------------------------

TITLE: Testing React Portals with react-is
DESCRIPTION: Demonstrates checking if an element is a React Portal using isPortal and typeOf functions. Requires ReactDOM for portal creation.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_5

LANGUAGE: javascript
CODE:
```
import React from "react";
import ReactDOM from "react-dom";
import * as ReactIs from 'react-is';

const div = document.createElement("div");
const portal = ReactDOM.createPortal(<div />, div);

ReactIs.isPortal(portal); // true
ReactIs.typeOf(portal) === ReactIs.Portal; // true
```

----------------------------------------

TITLE: Defining Simple React Component with Object References
DESCRIPTION: This snippet defines a simple React component that creates and manipulates object references. It also exports a FIXTURE_ENTRYPOINT object for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-field-store.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let x = {};
  let q = {};
  x.t = q;
  let z = x.t;
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining Type Alias and Function with Flow Annotations in React
DESCRIPTION: This snippet demonstrates the use of Flow annotations, type aliases, and function declarations in a React context. It defines a 'Bar' type alias, a 'TypeAliasUsedAsAnnotation' function, and exports a 'FIXTURE_ENTRYPOINT' object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-annotation_.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
type Bar = string;
function TypeAliasUsedAsAnnotation() {
  type Foo = Bar;
  const fun = (f: Foo) => {
    console.log(f);
  };
  fun('hello, world');
}

export const FIXTURE_ENTRYPOINT = {
  fn: TypeAliasUsedAsAnnotation,
  params: [],
};
```

----------------------------------------

TITLE: Using Hooks in React Enabling AssumeHooksFollowRulesOfReact
DESCRIPTION: This code snippet demonstrates a React component implementing hooks while assuming that hooks follow certain React rules. It imports a compiler-runtime function and handles input freezing and memoization through conditional logic. The main dependencies for this snippet include React and React hooks, specifically the "useFoo" hook. Inputs involve props supplied to the component, and outputs are frozen objects returned from the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/immutable-hooks.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact true
function Component(props) {
  const x = {};
  // In enableAssumeHooksFollowRulesOfReact mode hooks freeze their inputs and return frozen values
  const y = useFoo(x);
  // Thus both x and y are frozen here, and x can be independently memoized
  bar(x, y);
  return [x, y];
}
```

----------------------------------------

TITLE: Original React Hook Implementation
DESCRIPTION: Input version of a React hook that implements conditional logging based on a constant string comparison and boolean parameter. Uses a labeled block with switch statement for flow control.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unlabeled-break-within-label-switch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_STRING0} from 'shared-runtime';

function useHook(cond) {
  const log = [];
  switch (CONST_STRING0) {
    case CONST_STRING0:
      log.push(`@A`);
      bb0: {
        if (cond) {
          break;
        }
        log.push(`@B`);
      }
      log.push(`@C`);
  }
  return log;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [true],
};
```

----------------------------------------

TITLE: Original React Component with Class Instantiation and Array Creation
DESCRIPTION: The input code defines a simple React component that creates a class instance, an array, and returns them. It imports an identity function and defines a Foo class that gets wrapped by the identity function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/new-does-not-mutate-class.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

class Foo {}
function Component({val}) {
  const MyClass = identity(Foo);
  const x = [val];
  const y = new MyClass();

  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{val: 0}],
};
```

----------------------------------------

TITLE: Original React Hook Implementation with Label Break Pattern
DESCRIPTION: A custom React hook that conditionally adds data to an array. It uses a labeled block with a conditional break to control execution flow, and processes nested object properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-poisons-outer-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function useFoo({input, cond}) {
  const x = [];
  label: {
    if (cond) {
      break label;
    }
    x.push(identity(input.a.b));
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {a: {b: 2}}, cond: false}],
  sequentialRenders: [
    {input: {a: {b: 2}}, cond: false},
    // preserve nullthrows
    {input: null, cond: false},
    {input: null, cond: true},
    {input: {}, cond: false},
    {input: {a: {b: null}}, cond: false},
    {input: {a: null}, cond: false},
    {input: {a: {b: 3}}, cond: false},
  ],
};
```

----------------------------------------

TITLE: Sequence Component Definition (Input)
DESCRIPTION: Defines a simple JavaScript function component named `sequence` that utilizes the comma operator within expressions and a `while` loop. The function `foo` is also defined, though it does nothing.  The function returns a value that is computed using the comma operator. It shows the original component before any transformation or optimization is applied.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequence-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function sequence(props) {
  let x = (null, Math.max(1, 2), foo());
  while ((foo(), true)) {
    x = (foo(), 2);
  }
  return x;
}

function foo() {}

```

----------------------------------------

TITLE: Original React Component with Identity Function
DESCRIPTION: A React component that imports an identity function, uses it to create jQuery reference and wraps it in an array. The component returns this wrapped value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conflicting-dollar-sign-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(props) {
  const $ = identity('jQuery');
  const t0 = identity([$]);
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining React Test Fixture Input (JavaScript)
DESCRIPTION: Input version of a sample function and test fixture setup for a React component. The function 'foo' creates arrays and populates them in a loop, while FIXTURE_ENTRYPOINT exports configuration for a 'TodoAdd' component test.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-while.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let x = [];
  let y = [];
  while (c) {
    y.push(b);
    x.push(a);
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining a React Component Functionality - JavaScript
DESCRIPTION: This snippet defines a React functional component named 'Component' that processes props. It creates an object using 'makeObject' and uses a ternary operator to determine which prop to utilize based on the object's property 'a'. It is important to note that the first snippet contains an unused variable declaration for a cleaner implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-ternary-assigned-to-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // unused!
  const obj = makeObject();
  const _ = obj.a ? props.b : props.c;
  return null;
}

```

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const obj = makeObject();
  obj.a ? props.b : props.c;
  return null;
}

```

----------------------------------------

TITLE: Calculating Factorial using TypeScript
DESCRIPTION: This snippet defines a recursive function to calculate the factorial of a given number using TypeScript. The function takes an object with a 'value' property as input. The expected input is a numeric value, and the output is the computed factorial of that value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-recursive-call.expect.md#2025-04-21_snippet_0

LANGUAGE: typescript
CODE:
```
function Foo({value}: {value: number}) {
  const factorial = (x: number) => {
    if (x <= 1) {
      return 1;
    } else {
      return x * factorial(x - 1);
    }
  };

  return factorial(value);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{value: 3}],
};
```

----------------------------------------

TITLE: Implementing Original React Component with Dynamic Context
DESCRIPTION: This snippet defines a React component that creates a dynamic context object using a computed property key. It imports an 'identity' function and exports a fixture for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-constant-number.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Component(props) {
  const key = 42;
  const context = {
    [key]: identity([props.value]),
  };
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'hello!'}],
};
```

----------------------------------------

TITLE: React Component with Const Declarations
DESCRIPTION: Modified version of the component using const declarations instead of let. While the variables cannot be reassigned, their properties can still be mutated as they are objects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-liverange-loop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function mutate() {}
function cond() {}

function Component(props) {
  const a = {};
  const b = {};
  const c = {};
  const d = {};
  while (true) {
    mutate(a, b);
    if (cond(a)) {
      break;
    }
  }
  if (a) {
  }
  if (b) {
  }
  if (c) {
  }
  if (d) {
  }

  mutate(d, null);
}
```

----------------------------------------

TITLE: Creating Memoized Component Function with Original Implementation
DESCRIPTION: A basic function component that creates an object and returns a closure function. Shows the initial implementation before compiler optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prop-capturing-function-1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  let z = {a, b};
  let x = function () {
    console.log(z);
  };
  return x;
}
```

----------------------------------------

TITLE: Implementing React Component with FBT and Memoization
DESCRIPTION: This snippet defines a React component that uses FBT for internationalization and useMemo for performance optimization. It renders a user's name and validates the memoization using a ValidateMemoization component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-repro-invalid-mutable-range-destructured-prop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {fbt} from 'fbt';
import {useMemo} from 'react';
import {ValidateMemoization} from 'shared-runtime';

function Component({data}) {
  const el = useMemo(
    () => (
      <fbt desc="user name">
        <fbt:param name="name">{data.name ?? ''}</fbt:param>
      </fbt>
    ),
    [data.name]
  );
  return <ValidateMemoization inputs={[data.name]} output={el} />;
}

const props1 = {data: {name: 'Mike'}};
const props2 = {data: {name: 'Mofei'}};
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [props1],
  sequentialRenders: [props1, props2, props2, props1, {...props1}],
};
```

----------------------------------------

TITLE: Input React Component with FBT Translation
DESCRIPTION: Original source code showing a React component that uses FBT for internationalization. The component takes an items prop and displays a translated string with the count of items.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-template-string-same-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';
import {Stringify} from 'shared-runtime';

export function Component(props) {
  let count = 0;
  if (props.items) {
    count = props.items.length;
  }
  return (
    <Stringify>
      {fbt(
        `for ${fbt.param('count', count)} experiences`,
        `Label for the number of items`,
        {project: 'public'}
      )}
    </Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{items: [1, 2, 3]}],
};
```

----------------------------------------

TITLE: Input React Component with FBT
DESCRIPTION: Source code showing a React component that uses FBT for internationalization. The component takes a name prop and renders a greeting message using FBT's parameter substitution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-newline.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component(props) {
  const element = (
    <fbt desc={'Dialog to show to user'}>
      Hello{' '}
      <fbt:param
        name="a really long description
      that got split into multiple lines">
        {props.name}
      </fbt:param>
    </fbt>
  );
  return element.toString();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Jason'}],
};
```

----------------------------------------

TITLE: Initializing Loop-Based Function with Fixture
DESCRIPTION: Defines a function that performs iteration based on a nested object condition, with an exported fixture configuration for potential component testing
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  let x = 0;
  while (a.b.c) {
    x += b;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  let x = 0;
  while (a.b.c) {
    x = x + b;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component Rendering with Shallow Copy (Input)
DESCRIPTION: This code defines a React component that renders a div element with specified child properties based on the `width` prop. It utilizes `react/jsx-runtime` for JSX transformation and `shared-runtime` for a shallow copy operation. The component creates a `childprops` object containing a style with the provided width, assigns it to the div, performs a shallow copy, and then returns the created element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-freeze.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {jsx as _jsx} from 'react/jsx-runtime';
import {shallowCopy} from 'shared-runtime';

function Component(props) {
  const childprops = {style: {width: props.width}};
  const element = _jsx('div', {
    childprops: childprops,
    children: '"hello world"',
  });
  shallowCopy(childprops); // function that in theory could mutate, we assume not bc createElement freezes
  return element;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: Compiled useFoo function with memoization
DESCRIPTION: This code snippet represents the compiled version of the `useFoo` function. It leverages the `_c` function (presumably from `react/compiler-runtime`) for memoization. The compiled code checks if the input arrays and lambda functions have changed before recomputing the map operations, optimizing for performance by reusing previously computed values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * Forked from array-map-simple.js
 * 
 * Whether lambdas are named or passed inline shouldn't affect whether we expect
 * it to be called.
 */
function useFoo(t0) {
  const $ = _c(13);
  const { arr1, arr2 } = t0;
  let t1;
  if ($[0] !== arr1[0]) {
    t1 = (e) => arr1[0].value + e.value;
    $[0] = arr1[0];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const cb1 = t1;
  let t2;
  if ($[2] !== arr1 || $[3] !== cb1) {
    t2 = arr1.map(cb1);
    $[2] = arr1;
    $[3] = cb1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const x = t2;
  let t3;
  if ($[5] !== arr2) {
    t3 = (e_0) => arr2[0].value + e_0.value;
    $[5] = arr2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const cb2 = t3;
  let t4;
  if ($[7] !== arr1 || $[8] !== cb2) {
    t4 = arr1.map(cb2);
    $[7] = arr1;
    $[8] = cb2;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  const y = t4;
  let t5;
  if ($[10] !== x || $[11] !== y) {
    t5 = [x, y];
    $[10] = x;
    $[11] = y;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  return t5;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ arr1: [], arr2: [] }],
  sequentialRenders: [
    { arr1: [], arr2: [] },
    { arr1: [], arr2: null },
    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },
  ],
};

```

----------------------------------------

TITLE: Defining a Custom Hook with useCallback in React
DESCRIPTION: This snippet defines a custom React hook, useHook, that memoizes a function using useCallback. It checks a condition based on the props and mutates an object if the condition is met, returning a specific value from the props. Dependencies for memoization are specified in the useCallback hook to optimize re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.hoist-useCallback-infer-conditional-value-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useCallback} from 'react';
import {identity, mutate} from 'shared-runtime';

function useHook(propA, propB) {
  return useCallback(() => {
    const x = {};
    if (identity(null) ?? propA.a) {
      mutate(x);
      return {
        value: propB.x.y,
      };
    }
  }, [propA.a, propB.x.y]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{a: 1}, {x: {y: 3}}],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: Compiler-optimized version of the component that implements memoization using React's compiler runtime. Uses array-based caching to store and compare previous props and computed values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-object-assignment-to-context-var.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props) {
    const { x: t0 } = props;
    x = t0;
    const foo = () => {
      x = identity(props.x);
    };

    foo();
    $[0] = props;
    $[1] = x;
  } else {
    x = $[1];
  }
  let t0;
  if ($[2] !== x) {
    t0 = { x };
    $[2] = x;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime in JavaScript
DESCRIPTION: This snippet shows the compiled and optimized version of the React component using the React compiler runtime. It includes memoization techniques to avoid unnecessary re-renders and optimizes the rendering of the Stringify component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-filter-capture-mutate-bug.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutateAndReturn, Stringify, useIdentity } from "shared-runtime";

/**
 * Repro for bug with `mutableOnlyIfOperandsAreMutable` flag
 * Found differences in evaluator results
  * Non-forget (expected):
  * (kind: ok)
  * <div>{"children":[{"value":"foo","wat0":"joe"},{"value":5,"wat0":"joe"}]}</div>
  * <div>{"children":[{"value":"foo","wat0":"joe"},{"value":6,"wat0":"joe"}]}</div>
  * <div>{"children":[{"value":"foo","wat0":"joe"},{"value":6,"wat0":"joe"}]}</div>
  * Forget:
  * (kind: ok)
  * <div>{"children":[{"value":"foo","wat0":"joe"},{"value":5,"wat0":"joe"}]}</div>
  * <div>{"children":[{"value":"foo","wat0":"joe","wat1":"joe"},{"value":6,"wat0":"joe"}]}</div>
  * <div>{"children":[{"value":"foo","wat0":"joe","wat1":"joe"},{"value":6,"wat0":"joe"}]}</div>

 */
function Component(t0) {
  const $ = _c(7);
  const { value } = t0;
  const arr = [{ value: "foo" }, { value: "bar" }, { value }];
  useIdentity(null);
  const derived = arr.filter(mutateAndReturn);
  let t1;
  if ($[0] !== derived) {
    t1 = derived.at(0);
    $[0] = derived;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== derived) {
    t2 = derived.at(-1);
    $[2] = derived;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1 || $[5] !== t2) {
    t3 = (
      <Stringify>
        {t1}
        {t2}
      </Stringify>
    );
    $[4] = t1;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 5 }],
  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component with automatic memoization implementation using a cache array. Includes checks to prevent unnecessary recalculations of destructured objects and arrays.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-destructured-rest-element.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(7);
  let b;
  if ($[0] !== props.a) {
    const { a, ...t0 } = props.a;
    b = t0;
    $[0] = props.a;
    $[1] = b;
  } else {
    b = $[1];
  }
  let d;
  if ($[2] !== props.c) {
    [, ...d] = props.c;
    $[2] = props.c;
    $[3] = d;
  } else {
    d = $[3];
  }
  let t0;
  if ($[4] !== b || $[5] !== d) {
    t0 = <div b={b} d={d} />;
    $[4] = b;
    $[5] = d;
    $[6] = t0;
  } else {
    t0 = $[6];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component with Compiler Runtime Integration in JavaScript
DESCRIPTION: This snippet showcases a React component that utilizes the react/compiler-runtime to achieve memoization. It imports a specific part of the compiler-runtime and utilizes symbols to cache frequently used values. It effectively optimizes state management by introducing memo cache sentinels and maintains it within the scope of the React component. This advanced implementation requires understanding of React\'s memoization mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-Boolean.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  const y = Boolean(x);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [x, y];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This is the compiled version of the `Component` using React's compiler. It utilizes `react/compiler-runtime` and memoization techniques to optimize rendering performance. The compiled code caches intermediate values and component instances to avoid unnecessary re-renders, demonstrating how the compiler enhances efficiency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dupe-key-dupe-component.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableJsxOutlining
function Component(t0) {
  const $ = _c(7);
  const { arr } = t0;
  const x = useX();
  let t1;
  if ($[0] !== arr || $[1] !== x) {
    let t2;
    if ($[3] !== x) {
      t2 = (i, id) => {
        const T0 = _temp;
        return <T0 k={i + "i"} k1={i + "j"} key={id} x={x} />;
      };
      $[3] = x;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    t1 = arr.map(t2);
    $[0] = arr;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = <>{t1}</>;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
function _temp(t0) {
  const $ = _c(8);
  const { k: k, k1: k1, x: x } = t0;
  let t1;
  if ($[0] !== k) {
    t1 = <Foo k={k} />;
    $[0] = k;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== k1) {
    t2 = <Foo k={k1} />;
    $[2] = k1;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1 || $[5] !== t2 || $[6] !== x) {
    t3 = (
      <Bar x={x}>
        {t1}
        {t2}
      </Bar>
    );
    $[4] = t1;
    $[5] = t2;
    $[6] = x;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
}

function Bar(t0) {
  const $ = _c(3);
  const { x, children } = t0;
  let t1;
  if ($[0] !== children || $[1] !== x) {
    t1 = (
      <>
        {x}
        {children}
      </>
    );
    $[0] = children;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Foo(t0) {
  const { k } = t0;
  return k;
}

function useX() {
  return "x";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arr: ["foo", "bar"] }],
};
```

----------------------------------------

TITLE: Implementing Optimized React Component with Compiler Runtime
DESCRIPTION: A React component that uses compiler runtime for performance optimization. It conditionally renders a Button component based on changes to the 'x' prop, using array-based memoization through the compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/01-user-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
export default function TestComponent(t0) {
  const $ = _c(2);
  const { x } = t0;
  let t1;
  if ($[0] !== x) {
    t1 = <Button>{x}</Button>;
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the React component using memoization. It uses a compiler-generated array to cache previous prop values and results, improving performance by avoiding unnecessary re-computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-break-labeled.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * props.b *does* influence `a`
 */
function Component(props) {
  const $ = _c(5);
  let a;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d
  ) {
    a = [];
    a.push(props.a);
    bb0: {
      if (props.b) {
        break bb0;
      }

      a.push(props.c);
    }

    a.push(props.d);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = a;
  } else {
    a = $[4];
  }
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized Component with Caching - React - JavaScript
DESCRIPTION: This snippet enhances the previous component by introducing caching to optimize performance. It checks if the input arrays have changed and only recalculates the output if they have. This is done through a use of an internal cache array. It also uses 'makeArray' to adapt the input into the desired output structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-spread.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b) {
    t0 = makeArray(...props.a, null, ...props.b);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: [1, 2], b: [2, 3, 4] }],
};
```

----------------------------------------

TITLE: Compiled: Optimized React Component with Compiler Runtime
DESCRIPTION: Compiler-transformed version of the React component using React compiler runtime. Implements memoization and optimized event handling with conditional state tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/repeated-calls.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c, useFire } from "react/compiler-runtime"; // @enableFire
import { fire } from "react";

function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props) {
    t0 = () => {
      console.log(props);
    };
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const foo = t0;
  const t1 = useFire(foo);
  let t2;
  if ($[2] !== props || $[3] !== t1) {
    t2 = () => {
      t1(props);
      t1(props);
    };
    $[2] = props;
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  useEffect(t2);
  return null;
}
```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: Transformed component using React compiler runtime with memoization and cache handling for JSX element creation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-try-with-catch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger @validateNoJSXInTryStatements
function Component(props) {
  const $ = _c(1);
  let el;
  try {
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = <div />;
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    el = t0;
  } catch {
    return null;
  }
  return el;
}
```

----------------------------------------

TITLE: Optimized React Component using Compiler-Runtime
DESCRIPTION: This snippet shows an optimized version of the React component using React's compiler-runtime. It includes memoization and conditional rendering for improved performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-instruction-part-of-already-closed-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableAssumeHooksFollowRulesOfReact
import { Stringify, identity, useHook } from "shared-runtime";

function Component(t0) {
  const $ = _c(17);
  const { index } = t0;
  const data = useHook();
  let T0;
  let t1;
  let t2;
  let t3;
  if ($[0] !== data || $[1] !== index) {
    const a = identity(data, index);
    const b = identity(data, index);
    const c = identity(data, index);

    const t4 = identity(b);
    if ($[6] !== t4) {
      t2 = <Stringify value={t4} />;
      $[6] = t4;
      $[7] = t2;
    } else {
      t2 = $[7];
    }
    const t5 = identity(a);
    if ($[8] !== t5) {
      t3 = <Stringify value={t5} />;
      $[8] = t5;
      $[9] = t3;
    } else {
      t3 = $[9];
    }
    T0 = Stringify;
    t1 = identity(c);
    $[0] = data;
    $[1] = index;
    $[2] = T0;
    $[3] = t1;
    $[4] = t2;
    $[5] = t3;
  } else {
    T0 = $[2];
    t1 = $[3];
    t2 = $[4];
    t3 = $[5];
  }
  let t4;
  if ($[10] !== T0 || $[11] !== t1) {
    t4 = <T0 value={t1} />;
    $[10] = T0;
    $[11] = t1;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  let t5;
  if ($[13] !== t2 || $[14] !== t3 || $[15] !== t4) {
    t5 = (
      <div>
        {t2}
        {t3}
        {t4}
      </div>
    );
    $[13] = t2;
    $[14] = t3;
    $[15] = t4;
    $[16] = t5;
  } else {
    t5 = $[16];
  }
  return t5;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ index: 0 }],
};
```

----------------------------------------

TITLE: Conditional Rendering with Memoization in React
DESCRIPTION: This JavaScript snippet extends the use of memoization in a React component by importing compiler-runtime for internal React operations. It memoizes a functional component and conditionally updates a button element when props change, utilizing an array to store the props and element. Dependencies include React and react/compiler-runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-eacfcaa6ef89.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Valid because hooks can be used in anonymous function arguments to
// memo.
const MemoizedFunction = memo(function (props) {
  const $ = _c(2);
  useHook();
  let t0;
  if ($[0] !== props) {
    t0 = <button {...props} />;
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
});
```

----------------------------------------

TITLE: Defining and Exporting a Component in JavaScript
DESCRIPTION: This snippet demonstrates the creation of a component, its initialization, and export as a fixture entry point. It uses a function to define a component and assigns parameters for its export. The `component` function module provides a mock component structure with a local function invoking a method on the object `t`. The export constant `FIXTURE_ENTRYPOINT` specifies the component as 'TodoAdd'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-decl.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let t = {a};
  function x() {
    t.foo();
  }
  x(t);
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Input: Lambda Functions with Array Mapping in React
DESCRIPTION: Original React code that demonstrates how lambdas are handled when passed to array.map. It shows a scenario where getVal1 has a known callsite in cb1, but cb1 is only passed to array.map rather than being directly called.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-chained-callbacks.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * Forked from array-map-simple.js
 *
 * Here, getVal1 has a known callsite in `cb1`, but `cb1` isn't known to be
 * called (it's only passed to array.map). In this case, we should be
 * conservative and assume that all named lambdas are conditionally called.
 */
function useFoo({arr1, arr2}) {
  const getVal1 = () => arr1[0].value;
  const cb1 = e => getVal1() + e.value;
  const x = arr1.map(cb1);
  const getVal2 = () => arr2[0].value;
  const cb2 = e => getVal2() + e.value;
  const y = arr1.map(cb2);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{arr1: [], arr2: []}],
  sequentialRenders: [
    {arr1: [], arr2: []},
    {arr1: [], arr2: null},
    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},
  ],
};
```

----------------------------------------

TITLE: React Compiler-Optimized useFoo Hook with Automatic Memoization
DESCRIPTION: The transformed version of the useFoo hook after React Compiler processing. It adds automatic memoization to cache the callback function and results when inputs haven't changed, using an array $ for storing memoized values and dependency tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/bug-invalid-array-map-manual.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(t0) {
  const $ = _c(5);
  const { arr1, arr2 } = t0;
  let t1;
  if ($[0] !== arr2[0].value) {
    t1 = (e) => arr2[0].value + e.value;
    $[0] = arr2[0].value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const cb = t1;
  let y;
  if ($[2] !== arr1 || $[3] !== cb) {
    y = [];
    for (let i = 0; i < arr1.length; i++) {
      y.push(cb(arr1[i]));
    }
    $[2] = arr1;
    $[3] = cb;
    $[4] = y;
  } else {
    y = $[4];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ arr1: [], arr2: [] }],
  sequentialRenders: [
    { arr1: [], arr2: [] },
    { arr1: [], arr2: null },
    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },
  ],
};
```

----------------------------------------

TITLE: Original React Component
DESCRIPTION: This snippet shows the original React component definition. It takes props as input, creates a MaybeMutable object, retrieves a value from props, and returns an array containing the prop value and the result of calling maybeMutate with the MaybeMutable object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-property-load-accessed-outside-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const maybeMutable = new MaybeMutable();
  let x = props.value;
  return [x, maybeMutate(maybeMutable)];
}
```

----------------------------------------

TITLE: Initializing Reactive Component in React - JavaScript
DESCRIPTION: The function 'Component' uses arrays to demonstrate how variable reactivity can be interleaved based on their mutations in a React component. Dependencies include a props object with a 'cond' property. The function initializes arrays 'a' and 'b', modifies them based on props, and introduces reactivity by grouping and controlling values. It returns 'x', showing conditional reactivity.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-while.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a and b are independent but their mutations are interleaved, so
  // they get grouped in a reactive scope. this means that a becomes
  // reactive since it will effectively re-evaluate based on a reactive
  // input
  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(null);

  // Downstream consumer of a, which initially seems non-reactive except
  // that a becomes reactive, per above
  const c = [a];

  let x;
  while (c[0][0]) {
    x = 1;
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `c[0]` which becomes reactive via
  // being interleaved with `b`.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};

```

----------------------------------------

TITLE: React Component Input Code with Mutable State
DESCRIPTION: Original React component code showing a component with mutable state handling. Uses MaybeMutable class and JSX with View component. Includes detailed HIR (High-level Intermediate Representation) comments explaining the compilation process.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-jsx-tag-lowered-between-mutations.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const maybeMutable = new MaybeMutable();
  // NOTE: this will produce invalid output.
  // The HIR is roughly:
  //                                    mutable range of `maybeMutable`
  // StoreLocal maybeMutable = ...     
  // t0 = LoadGlobal View               <-- View is lowered inside this mutable range
  //                                         and thus gets becomes an output of this scope,
  //                                         gets promoted to temporary
  // t1 = LoadGlobal maybeMutate       
  // t2 = LoadLocal maybeMutable       
  // t3 = Call t1(t2)                  
  // t4 = Jsx tag=t0 props=[] children=[t3] <-- `t0` is an invalid tag
  return <View>{maybeMutate(maybeMutable)}</View>;
}
```

----------------------------------------

TITLE: Defining and Exporting a React Component - JavaScript
DESCRIPTION: This snippet defines a React component named 'Component' that takes a numerical prop, applies the 'useIdentity' hook to it, and returns the result of the 'identity' function. It exports a constant 'FIXTURE_ENTRYPOINT' which includes the Component and a set of parameters for testing the functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-no-component-annot.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @compilationMode(infer)
import {useIdentity, identity} from 'shared-runtime';

function Component(fakeProps: number) {
  const x = useIdentity(fakeProps);
  return identity(x);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [42],
};
```

LANGUAGE: JavaScript
CODE:
```
// @compilationMode(infer)
import { useIdentity, identity } from "shared-runtime";

function Component(fakeProps: number) {
  const x = useIdentity(fakeProps);
  return identity(x);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [42],
};
```

----------------------------------------

TITLE: Optimized useFoo Hook with React Compiler Memoization
DESCRIPTION: Compiler-optimized version of the useFoo hook that implements memoization using React's compiler runtime. It uses an array to track props dependencies and only recreates the array when the relevant props change, improving performance across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-ternary-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { arrayPush } from "shared-runtime";
function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    x = [];
    x.push(props.bar);
    props.cond ? ((x = []), x.push(props.foo)) : ((x = []), x.push(props.bar));
    arrayPush(x, 4);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};
```

----------------------------------------

TITLE: React Component with Memoization Preservation Errors
DESCRIPTION: This React component uses hooks like useFragment, useState, useMemo, and useCallback. The React Compiler fails to optimize it because it cannot preserve the existing manual memoization guarantees, likely due to potential mutations of memoized data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-missed-memoization-from-inferred-mutation-in-logger.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @validatePreserveExistingMemoizationGuarantees
import {useFragment} from 'react-relay';
import LogEvent from 'LogEvent';
import {useCallback, useMemo} from 'react';

component Component(id) {
  const items = useFragment();

  const [index, setIndex] = useState(0);

  const logData = useMemo(() => {
    const item = items[index];
    return {
      key: item.key,
    };
  }, [index, items]);

  const setCurrentIndex = useCallback(
    (index: number) => {
      const object = {
        tracking: logData.key,
      };
      // We infer that this may mutate `object`, which in turn aliases
      // data from `logData`, such that `logData` may be mutated.
      LogEvent.log(() => object);
      setIndex(index);
    },
    [index, logData, items]
  );

  if (prevId !== id) {
    setCurrentIndex(0);
  }

  return (
    <Foo
      index={index}
      items={items}
      current={mediaList[index]}
      setCurrentIndex={setCurrentIndex}
    />
  );
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component showing how React transforms the code to implement memoization using compiler runtime. It caches previous parameter values and return results to avoid unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-object-spread-pattern.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(foo, ...t0) {
  const $ = _c(3);
  const { bar } = t0;
  let t1;
  if ($[0] !== bar || $[1] !== foo) {
    t1 = [foo, bar];
    $[0] = bar;
    $[1] = foo;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["foo", { bar: "bar" }],
};
```

----------------------------------------

TITLE: Compiled Component with Automatic Dependency Tracking
DESCRIPTION: The compiled output of the React component after transformation by React's compiler. It implements a caching mechanism using an array for tracking changes to variables and memoizing computed values, while automatically adding the correct dependency (obj.a) to the useEffect hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-optional-chain.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect } from "react";
import { print } from "shared-runtime";

// TODO: take optional chains as dependencies
function ReactiveMemberExpr(t0) {
  const $ = _c(7);
  const { cond, propVal } = t0;
  let t1;
  if ($[0] !== cond || $[1] !== propVal) {
    t1 = cond ? { b: propVal } : null;
    $[0] = cond;
    $[1] = propVal;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t1) {
    t2 = { a: t1 };
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const obj = t2;
  let t3;
  if ($[5] !== obj.a?.b) {
    t3 = () => print(obj.a?.b);
    $[5] = obj.a?.b;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  useEffect(t3, [obj.a]);
}
```

----------------------------------------

TITLE: Optimized React Component Implementation with Memoization
DESCRIPTION: This snippet shows an optimized version of the Component function, likely generated by a React compiler. It uses memoization techniques to avoid unnecessary re-renders and computations, storing intermediate results in an array for reuse across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR
import { identity, ValidateMemoization } from "shared-runtime";
import { useMemo } from "react";

function Component(t0) {
  const $ = _c(7);
  const { arg } = t0;

  arg?.items.edges?.nodes;
  let t1;
  let t2;
  if ($[0] !== arg?.items.edges?.nodes) {
    t2 = arg?.items.edges?.nodes.map(identity);
    $[0] = arg?.items.edges?.nodes;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const data = t1;

  const t3 = arg?.items.edges?.nodes;
  let t4;
  if ($[2] !== t3) {
    t4 = [t3];
    $[2] = t3;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] !== data || $[5] !== t4) {
    t5 = <ValidateMemoization inputs={t4} output={data} />;
    $[4] = data;
    $[5] = t4;
    $[6] = t5;
  } else {
    t5 = $[6];
  }
  return t5;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiler-transformed version of the component using memoization cache sentinel to optimize repeated renders. Uses react/compiler-runtime for caching mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-mutate-item-of-local-collection.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeObject_Primitives } from "shared-runtime";

function Component(props) {
  const $ = _c(1);
  let items;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    items = [makeObject_Primitives(), makeObject_Primitives()];
    for (const x of items) {
      x.a = x.a + 1;
    }
    $[0] = items;
  } else {
    items = $[0];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}, {}],
};
```

----------------------------------------

TITLE: Utilizing useMemo with ValidateMemoization in React JavaScript
DESCRIPTION: Demonstrates a React component using the useMemo hook from the 'shared-runtime' package for memoization. It constructs a data array based on the props, which is passed to the ValidateMemoization component to validate the memoization logic. The snippet requires 'shared-runtime' as a dependency, with 'props.items' being the crucial parameter monitored for changes. The output is a React element rendered conditionally based on memoized data. This approach limits unnecessary renderings in React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-single-with-unconditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
  const data = useMemo(() => {
    const x = [];
    x.push(props?.items);
    x.push(props.items);
    return x;
  }, [props.items]);
  return <ValidateMemoization inputs={[props.items]} output={data} />;
}
```

----------------------------------------

TITLE: Implementing React Component with Complex Control Flow
DESCRIPTION: This code snippet defines a React component function that uses labeled statements, if-else conditions, and switch cases to set the value of 'x' based on different props. It handles various edge cases and includes intentional fallthroughs in the switch statement.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dominator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  label: if (props.a) {
    x = 1;
  } else {
    if (props.b) {
      x = 2;
    } else {
      break label;
    }
    x = 3;
  }
  label2: switch (props.c) {
    case 'a': {
      x = 4;
      break;
    }
    case 'b': {
      break label2;
    }
    case 'c': {
      x = 5;
      // intentional fallthrough
    }
    default: {
      x = 6;
    }
  }
  if (props.d) {
    return null;
  }
  return x;
}
```

----------------------------------------

TITLE: React Component with Fire Function
DESCRIPTION: This snippet demonstrates a React component using the `fire` function from the 'react' library to execute a function `foo` within a `useEffect` hook. The function `foo` logs the component's props to the console.  The snippet also includes nested functions that also utilize `fire` to invoke `foo`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/multiple-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = props => {
    console.log(props);
  };
  useEffect(() => {
    fire(foo(props));
    function nested() {
      fire(foo(props));
      function innerNested() {
        fire(foo(props));
      }
    }

    nested();
  });

  return null;
}

```

----------------------------------------

TITLE: Creating Components Conditionally with React
DESCRIPTION: This snippet defines a React functional component that conditionally assigns a component type based on the 'cond' prop. It showcases a basic implementation without optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-conditionally-assigned-dynamically-constructed-component-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @logger @validateStaticComponents
function Example(props) {
  let Component;
  if (props.cond) {
    Component = createComponent();
  } else {
    Component = DefaultComponent;
  }
  return <Component />;
}

```

----------------------------------------

TITLE: Defining a Function with Hoisting in JavaScript
DESCRIPTION: This snippet defines a function `hoisting` that demonstrates variable hoisting in JavaScript. The function defines a closure `foo` that references `bar` and `baz` before they are declared. This code shows how hoisting works in JS and affects the function's behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-let-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function hoisting() {
  let foo = () => {
    return bar + baz;
  };
  let bar = 3;
  let baz = 2;
  return foo(); // OK: called outside of TDZ for bar/baz
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the React component using compiler runtime functions. It implements memoization to avoid unnecessary re-renders and object creations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression-object.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(props) {
  const $ = _c(3);

  const a = props.a || (props.b && props.c && props.d);
  const b = (props.a && props.b && props.c) || props.d;
  let t0;
  if ($[0] !== a || $[1] !== b) {
    t0 = { a, b };
    $[0] = a;
    $[1] = b;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining Component Logic in React - JavaScript
DESCRIPTION: Defines a React component `Component` that uses properties to manipulate its state. It initializes an object and an array, pushes the input prop to the array, and updates a boolean `z` based on the input. It returns the component's state, with `FIXTURE_ENTRYPOINT` defined for sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-through-property-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {};
  const y = [];
  x.y = y;
  x.y.push(props.input);

  let z = 0;
  if (x.y[0]) {
    z = 1;
  }

  return [z];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {input: true},
    {input: true},
    {input: false},
    {input: false},
    {input: true},
    {input: false},
    {input: true},
    {input: false},
  ],
};
```

----------------------------------------

TITLE: Compiled JavaScript Function with Memoization
DESCRIPTION: This snippet shows the compiled version of the `foo` function using `react/compiler-runtime`. It utilizes `_c(1)` to memoize the result of the function. If the memoized value is not available (first execution), it creates the data structure as in the original function. Subsequent calls will directly return the memoized value from the cache, thus avoiding redundant calculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scope-grouping.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = {};
    const y = [];
    const z = {};
    y.push(z);
    x.y = y;
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Conditional Execution Example in Foo Function - JavaScript
DESCRIPTION: This snippet demonstrates a function 'Foo' that takes a boolean parameter 'cond'. Depending on the value of 'cond', it either logs 'other test' or 'fallthrough test'. It showcases variable scoping and conditional logic in JavaScript. Requires the 'log' function defined previously.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-shadowing.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Foo(cond) {
  let str = '';
  if (cond) {
    let str = 'other test';
    log(str);
  } else {
    str = 'fallthrough test';
  }
  log(str);
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiler-transformed version of the component that implements memoization for the object spread operation. Uses React compiler runtime utilities to cache and reuse spread results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-spread-element.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.foo) {
    t0 = { ...props.foo };
    $[0] = props.foo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Enhanced Custom Hook with React Compiler Runtime in JavaScript
DESCRIPTION: This snippet is an enhanced version of the previous hook, adding state checks and utilizing the React compiler runtime for more efficient state management. It encapsulates value mutation and retrieval, checking if the current value has changed before reassigning the internal state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-mutated-after.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper, mutate, mutateAndReturn } from "shared-runtime";
function useHook(t0) {
  const $ = _c(2);
  const { value } = t0;
  let obj;
  if ($[0] !== value) {
    const x = mutateAndReturn({ value });
    obj = {
      getValue() {
        return x;
      },
    };

    mutate(obj);
    $[0] = value;
    $[1] = obj;
  } else {
    obj = $[1];
  }
  return obj;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ value: 0 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiler-optimized version of the component that includes memoization using React's compiler runtime. It caches computed values and implements checks to avoid unnecessary recomputation while maintaining the same functionality as the original component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-mutable-range.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { throwErrorWithMessage, shallowCopy } = require("shared-runtime");

function Component(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.value) {
    x = [];
    try {
      let t0;
      if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = throwErrorWithMessage("oops");
        $[2] = t0;
      } else {
        t0 = $[2];
      }
      x.push(t0);
    } catch {
      let t0;
      if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = shallowCopy({});
        $[3] = t0;
      } else {
        t0 = $[3];
      }
      x.push(t0);
    }

    x.push(props.value);
    $[0] = props.value;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization (JavaScript)
DESCRIPTION: This snippet shows an optimized version of the React component using memoization. It caches computed values to avoid unnecessary recalculations, potentially improving performance in scenarios with frequent re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

const SCALE = 2;

function Component(props) {
  const $ = _c(5);
  const { key } = props;
  let t0;
  if ($[0] !== props.value) {
    t0 = identity([props.value, SCALE]);
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== key || $[3] !== t0) {
    t1 = { [key]: t0 };
    $[2] = key;
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const context = t1;
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ key: "Sathya", value: "Compiler" }],
};
```

----------------------------------------

TITLE: Generated React Component with Optimization
DESCRIPTION: This JavaScript code represents the compiled version of the `Component` using `react/compiler-runtime`. It caches previous prop values and compares them with current ones, updating only when they differ.  It uses `_c(3)` to create a cache array with a size of 3. The component aims to minimize re-renders by only updating the returned array if the props have changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/option-enable-change-variable-codegen.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableChangeVariableCodegen
function Component(props) {
  const $ = _c(3);
  const c_00 = $[0] !== props.a;
  const c_1 = $[1] !== props.b.c;
  let t0;
  if (c_00 || c_1) {
    t0 = [props.a, props.b.c];
    $[0] = props.a;
    $[1] = props.b.c;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const c_0 = t0;
  return c_0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 3.14, b: { c: true } }],
};

```

----------------------------------------

TITLE: Optimizing Component State with React Compiler Runtime - JavaScript
DESCRIPTION: This snippet involves the use of the React 'compiler-runtime' to optimize component state by caching and tracking changes to inputs. It illustrates how conditionally updated objects are used to minimize computations and maintain consistent outputs. This is implemented in a JavaScript environment within React and requires the 'react/compiler-runtime' package.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-pattern-params.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(t0) {
  const $ = _c(7);
  const [a, b] = t0;
  let t1;
  if ($[0] !== a) {
    t1 = { a };
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const y = t1;
  let t2;
  if ($[2] !== b) {
    t2 = { b };
    $[2] = b;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const z = t2;
  let t3;
  if ($[4] !== y || $[5] !== z) {
    t3 = [y, z];
    $[4] = y;
    $[5] = z;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [["val1", "val2"]],
  isComponent: false,
};

```

----------------------------------------

TITLE: JavaScript Function with Block-Scoped Variables
DESCRIPTION: A JavaScript function demonstrating variable scoping with let declarations inside if/else blocks. The function creates variables x and y in the function scope, then declares a variable z in either the if or else block scope, making z inaccessible outside its respective block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-if-else.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  let y = 2;

  if (y) {
    let z = x + y;
  } else {
    let z = x;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Using Compiler Runtime for Enhanced Logging Hook in JavaScript
DESCRIPTION: This snippet builds upon the previous implementation by integrating React's compiler runtime. It optimizes the 'useHook' function to retrieve stateful logs efficiently, showing a structure that allows for conditionally resetting state based on the passed parameter 'end'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/labeled-break-within-label-loop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useHook(end) {
  const $ = _c(2);
  let log;
  if ($[0] !== end) {
    log = [];
    for (let i = 0; i < end + 1; i++) {
      log.push(`${i} @A`);
      bb0: {
        if (i === end) {
          break bb0;
        }
        log.push(`${i} @B`);
      }
      log.push(`${i} @C`);
    }
    $[0] = end;
    $[1] = log;
  } else {
    log = $[1];
  }
  return log;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [1],
};
```

----------------------------------------

TITLE: Compiled React Component with FBT
DESCRIPTION: Compiled output of the FBT component showing runtime optimizations including memoization using the compiler runtime. Implements the same functionality with additional performance improvements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.count) {
    t0 = fbt._(
      "{(key) count} items",
      [fbt._param("(key) count", props.count)],
      { hk: "3yW91j" },
    );
    $[0] = props.count;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const text = t0;
  let t1;
  if ($[2] !== text) {
    t1 = <div>{text}</div>;
    $[2] = text;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
```

----------------------------------------

TITLE: Original JavaScript Function with Object References
DESCRIPTION: A JavaScript function that creates objects with references to each other and mutates one of the objects before returning another. This demonstrates object aliasing and mutation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const a = {};
  const x = a;

  const y = {};
  y.x = x;

  mutate(a); // y & x are aliased to a
  return y;
}
```

----------------------------------------

TITLE: React Compiler-Transformed Memoization Code in JavaScript
DESCRIPTION: Compiler-transformed output that adds memoization to avoid redundant computations on re-renders. It uses React's compiler runtime to track the condition state and reuse the previously computed array when the condition hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-reference-effects.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { arrayPush } from "shared-runtime";

function Foo(cond) {
  const $ = _c(2);
  let x;
  if ($[0] !== cond) {
    x = null;
    if (cond) {
      x = [];
    }

    arrayPush(x, 2);
    $[0] = cond;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ cond: true }],
  sequentialRenders: [{ cond: true }, { cond: true }],
};
```

----------------------------------------

TITLE: Compiled React Component Output
DESCRIPTION: Optimized and compiled version of the component with memoization logic. Uses Symbol.for('react.memo_cache_sentinel') for caching and includes compiler runtime optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-duplicate-instruction-from-merge-consecutive-scopes.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Component(t0) {
  const $ = _c(3);
  const { id } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <Stringify title={undefined} />;
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const t2 = id ? true : false;
  let t3;
  if ($[1] !== t2) {
    t3 = (
      <>
        {t1}
        <Stringify title={t2} />
      </>
    );
    $[1] = t2;
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Understanding Dependency Propagation in React Scopes - JavaScript
DESCRIPTION: This JavaScript function handles dependencies by conditioning propagation based on an inner scope's granularity. Using constants and helper functions from a shared runtime, it ensures that only necessary changes trigger updates. The function `useJoinCondDepsInUncondScopes` leverages prop values and checks against constants for conditional dependency management. Dependencies include `shared-runtime` and expected inputs as object parameters with nested properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/join-uncond-scopes-cond-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_TRUE, setProperty} from 'shared-runtime';

function useJoinCondDepsInUncondScopes(props) {
  let y = {};
  let x = {};
  if (CONST_TRUE) {
    setProperty(x, props.a.b);
  }
  setProperty(y, props.a.b);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useJoinCondDepsInUncondScopes,
  params: [{a: {b: 3}}],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { CONST_TRUE, setProperty } from "shared-runtime";

function useJoinCondDepsInUncondScopes(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.a.b) {
    const y = {};
    const x = {};
    if (CONST_TRUE) {
      setProperty(x, props.a.b);
    }
    setProperty(y, props.a.b);
    t0 = [x, y];
    $[0] = props.a.b;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useJoinCondDepsInUncondScopes,
  params: [{ a: { b: 3 } }],
};
```

----------------------------------------

TITLE: Compiled React Component with FBT Optimization
DESCRIPTION: This snippet shows the compiled and optimized version of the React component using FBT. It includes performance optimizations such as caching and conditional rendering based on prop changes. The compiled code demonstrates how FBT translates the internationalization markup into efficient JavaScript.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbs-params.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { fbs } from "fbt";

function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.name) {
    t0 = (
      <div
        title={fbs._(
          "Hello {user name}",
          [fbs._param("user name", props.name)],
          { hk: "2zEDKF" },
        )}
      >
        Hover me
      </div>
    );
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Sathya" }],
};
```

----------------------------------------

TITLE: Original JavaScript Function Definition
DESCRIPTION: This snippet defines a JavaScript function `foo` that creates an object `x`, an array `y`, and an object `z`. It then pushes `z` into `y` and assigns `y` to `x.y`. Finally, it returns `x`. This represents a simple data structure creation and manipulation logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scope-grouping.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = {};
  let y = [];
  let z = {};
  y.push(z);
  x.y = y;

  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: React Component with Compiler Runtime
DESCRIPTION: The `ValidComponent` utilizes the `react/compiler-runtime`'s `_c` function to memoize the rendered JSX based on the `greeting` prop. This optimization avoids unnecessary re-renders when the `greeting` prop remains the same. It imports `_c` from `react/compiler-runtime` and stores the previous greeting and rendered element for comparison.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multiple-components-first-is-invalid.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @panicThreshold(none)
import { useHook } from "shared-runtime";

function InvalidComponent(props) {
  if (props.cond) {
    useHook();
  }
  return <div>Hello World!</div>;
}

function ValidComponent(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.greeting) {
    t0 = <div>{props.greeting}</div>;
    $[0] = props.greeting;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

```

----------------------------------------

TITLE: React Component with useNoAlias and Caching - JavaScript
DESCRIPTION: In this code snippet, a React component is optimized with internal caching using the '_c' function from 'react/compiler-runtime'. The component tracks several state variables to avoid unnecessary computations and updates. It empowers the 'useNoAlias' function for efficient runtime behavior based on 'props.a'. Dependencies include 'react/compiler-runtime' and 'shared-runtime', and it requires understanding of React's reconciliation and caching mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-noAlias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useNoAlias } from "shared-runtime";

function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.a) {
    t0 = { a: props.a };
    $[0] = props.a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const item = t0;
  const x = useNoAlias(item, () => {
    console.log(props);
  }, [props.a]);
  let t1;
  if ($[2] !== item || $[3] !== x) {
    t1 = [x, item];
    $[2] = item;
    $[3] = x;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: { id: 42 } }],
  isComponent: true,
};

```

----------------------------------------

TITLE: Compiled React Component with Dependency Tracking
DESCRIPTION: This is the compiled version of the `Foo` component, utilizing `react/compiler-runtime` for optimized rendering. It uses a dependency tracking array `$` to store previous prop values and the rendered result. This allows the component to skip re-renders if the props haven't changed, improving performance. The compiled code mirrors the logic of the original component, conditionally accessing the nested property and rendering the result with `Stringify`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-objectmethod-cond-access.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { Stringify } from "shared-runtime";

function Foo(t0) {
  const $ = _c(3);
  const { a, shouldReadA } = t0;
  let t1;
  if ($[0] !== a || $[1] !== shouldReadA) {
    t1 = (
      <Stringify
        objectMethod={{
          method() {
            if (shouldReadA) {
              return a.b.c;
            }
            return null;
          },
        }}
        shouldInvokeFns={true}
      />
    );
    $[0] = a;
    $[1] = shouldReadA;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ a: null, shouldReadA: true }],
  sequentialRenders: [
    { a: null, shouldReadA: true },
    { a: null, shouldReadA: false },
    { a: { b: { c: 4 } }, shouldReadA: true },
  ],
};

```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet demonstrates the optimized version of the component using React's compiler runtime for memoization. It caches the result of the computation to avoid unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let ret;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [1, 2, 3];
    ret = [];
    do {
      const item = x.pop();
      ret.push(item * 2);
    } while (x.length);
    $[0] = ret;
  } else {
    ret = $[0];
  }
  return ret;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: Compiler-optimized version of the component that includes memoization checks and caching using React's compiler runtime. Implements efficient prop comparison and object caching.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-push-effect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // arrayInstance.push should have the following effects:\n//  - read on all args (rest parameter)\n//  - mutate on receiver\nfunction Component(props) {\n  const $ = _c(8);\n  let t0;\n  if ($[0] !== props.x) {\n    t0 = foo(props.x);\n    $[0] = props.x;\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  const x = t0;\n  let t1;\n  if ($[2] !== props.y) {\n    t1 = { y: props.y };\n    $[2] = props.y;\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  const y = t1;\n  let arr;\n  if ($[4] !== x || $[5] !== y) {\n    arr = [];\n    let t2;\n    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {\n      t2 = {};\n      $[7] = t2;\n    } else {\n      t2 = $[7];\n    }\n    arr.push(t2);\n    arr.push(x, y);\n    $[4] = x;\n    $[5] = y;\n    $[6] = arr;\n  } else {\n    arr = $[6];\n  }\n  return arr;\n}
```

----------------------------------------

TITLE: Compiled React Component with Dependency Tracking
DESCRIPTION: The compiled version of the component with added dependency tracking and caching logic. Uses compiler-runtime utilities to optimize re-renders based on props changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reactive-dependencies-non-optional-properties-inside-optional-chain.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.post.feedback.comments?.edges) {
    t0 = props.post.feedback.comments?.edges?.map(render);
    $[0] = props.post.feedback.comments?.edges;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This snippet shows the compiled version of the React component, optimized using `react/compiler-runtime`. It uses a caching mechanism (`_c`) to avoid re-rendering the component if the `name` prop hasn't changed.  It utilizes `SharedRuntime.Stringify` to format the output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-localvar-memberexpr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as SharedRuntime from "shared-runtime";
function Component(t0) {
  const $ = _c(2);
  const { name } = t0;
  let t1;
  if ($[0] !== name) {
    t1 = <SharedRuntime.Stringify>hello world {name}</SharedRuntime.Stringify>;
    $[0] = name;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "sathya" }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The transformed code after React's compiler processing, implementing memoization with Symbol.for("react.memo_cache_sentinel") to optimize rendering. The compiler adds runtime helpers to manage component state and caching of function references.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-in-callback-passed-to-jsx-indirect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender
import { useRef } from "react";

function Component() {
  const $ = _c(2);
  const ref = useRef(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const setRef = () => {
      if (ref.current !== null) {
        ref.current = "";
      }
    };

    t0 = () => {
      setRef();
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onClick = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (
      <>
        <input ref={ref} />
        <button onClick={onClick} />
      </>
    );
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows the optimized version of the component using React's compiler-runtime functions. It implements memoization to cache values and limit the mutable range of variables, potentially improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-capture-in-method-receiver.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = someObj();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const a = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [];
    x.push(a);

    t1 = [x, a];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with memoization logic using Symbol.for() and compiler runtime utilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-function-with-implicit-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
const Test = () => {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
};

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimizations
DESCRIPTION: The compiled version of the component using React compiler runtime (_c). Implements caching mechanism to avoid recreating objects when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-string-literal-key.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.foo) {
    t0 = { foo: props.foo };
    $[0] = props.foo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimizing React Component with Compiler-Runtime and Memoization
DESCRIPTION: This snippet shows an optimized version of the component using React's compiler-runtime. It implements memoization to avoid unnecessary recalculations and object creations, potentially improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-constant-number.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.value) {
    t0 = identity([props.value]);
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = { [42]: t0 };
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const context = t1;
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "hello!" }],
};
```

----------------------------------------

TITLE: Input: Function Component with Closure Variable Modification
DESCRIPTION: Demonstrates a React functional component that modifies an external variable through a nested function, using useFoo higher-order function
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-global-hook-arg.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
let b = 1;

export default function MyApp() {
  const fn = () => {
    b = 2;
  };
  return useFoo(fn);
}

function useFoo(fn) {}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [],
};
```

----------------------------------------

TITLE: React Component Definition and Export
DESCRIPTION: This code defines a functional React component named `Component` that accepts `props` as input. The component returns an object containing `props` passed into a function `f`. The result is assigned to the `foo` property. The component and its default parameters are exported as `FIXTURE_ENTRYPOINT`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-no-component-obj-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function Component(props) {
  const ignore = <foo />;
  return { foo: f(props) };
}

function f(props) {
  return props;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization (Output Version)
DESCRIPTION: The React Compiler transformed version of the component with memoization. It uses the _c runtime function to create a persistent array that stores values between renders, only recalculating when props change. This optimizes performance by avoiding unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-two-lambdas.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { conditionalInvoke } from "shared-runtime";

function Component(t0) {
  const $ = _c(3);
  const { doReassign1, doReassign2 } = t0;
  let x;
  if ($[0] !== doReassign1 || $[1] !== doReassign2) {
    x = {};
    const reassign1 = () => {
      x = 2;
    };

    const reassign2 = () => {
      x = 3;
    };

    conditionalInvoke(doReassign1, reassign1);
    conditionalInvoke(doReassign2, reassign2);
    $[0] = doReassign1;
    $[1] = doReassign2;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ doReassign1: true, doReassign2: true }],
  sequentialRenders: [
    { doReassign1: true, doReassign2: true },
    { doReassign1: true, doReassign2: false },
    { doReassign1: false, doReassign2: false },
  ],
};
```

----------------------------------------

TITLE: Implementing React Component with Reactive Scope Behavior in JavaScript
DESCRIPTION: This code defines a React component that demonstrates reactive scope behavior. It creates objects, uses hooks, and manipulates values to test how React assigns and merges scopes during reconciliation. The component is designed to show how value mutations are handled within the same reactive scope.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-scope-merging-value-blocks.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  CONST_TRUE,
  identity,
  makeObject_Primitives,
  mutateAndReturn,
  useHook,
} from "shared-runtime";

/**
 * value and `mutateAndReturn(value)` should end up in the same reactive scope.
 * (1) `value = makeObject` and `(temporary) = mutateAndReturn(value)` should be assigned
 * the same scope id (on their identifiers)
 * (2) alignScopesToBlockScopes should expand the scopes of both `(temporary) = identity(1)`
 * and `(temporary) = mutateAndReturn(value)` to the outermost value block boundaries
 * (3) mergeOverlappingScopes should merge the scopes of the above two instructions
 */
function Component(t0) {
  const value = makeObject_Primitives();
  useHook();
  const mutatedValue =
    identity(1) && CONST_TRUE ? mutateAndReturn(value) : null;
  const result = [];
  useHook();
  result.push(value, mutatedValue);
  return result;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}, {}],
};
```

----------------------------------------

TITLE: Rendering Component with Feature Flag Check - React - JavaScript
DESCRIPTION: This code defines a React component named 'Foo' which extends from React's Component class. Within the render method, it conditionally calls 'useFeatureFlag' from 'FooStore' based on a condition variable. The use of 'use' in the method name led to a false positive warning which indicates a potential design issue with naming conventions in React hooks. This snippet requires React and FooStore to function correctly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-206e2811c87c.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

// This is a false positive (it's valid) that unfortunately
// we cannot avoid. Prefer to rename it to not start with "use"
class Foo extends Component {
  render() {
    if (cond) {
      FooStore.useFeatureFlag();
    }
  }
}

```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This code defines a simple React component that takes `props` as input, calls the `bar()` and `foo()` functions, and returns an object containing `items` and `count`. It represents the initial state of the component before any compiler optimizations are applied.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-reactive-via-mutation-of-property-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const items = bar();
  mutate(items.a, props.a);

  const count = foo(items.length + 1);

  return {items, count};
}
```

----------------------------------------

TITLE: Defining Original React Component in JavaScript
DESCRIPTION: This snippet shows the original React component function before compilation. It declares variables, performs comparisons, and returns a value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-return-type-inference.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let x = foo();
  let y = foo();
  if (x > y) {
    let z = {};
  }

  let z = foo();
  return z;
}
```

----------------------------------------

TITLE: Defining React Component with Mutable Range Example
DESCRIPTION: This snippet defines a React component function that handles props and returns an object. It includes comments about mutable range issues and potential aliasing problems.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression-object.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(props) {
  // The mutable range for a extens the entire body.
  // commenting out the last line of InferMutableRanges fixes it.
  // my guess of what's going on is that a is aliased into the return value object literal,
  // and that alias makes it look like the range of a needs to be extended to that point.
  // but what's weird is that the end of a's range doesn't quite extend to the object.
  let a = props.a || (props.b && props.c && props.d);
  let b = (props.a && props.b && props.c) || props.d;
  return {a, b};
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component Definition with Mutation
DESCRIPTION: Defines a React component that accepts props 'a' and 'b', initializes local variables 'z' and 'y', and defines a function 'x' that mutates 'z' and calls 'mutate' on 'y.b'. The component returns an array containing 'y' and 'z'.  It's designed to test how mutation affects rendering and to be used with a fixture entrypoint.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function Component({a, b}) {
  let z = {a};
  let y = {b: {b}};
  let x = function () {
    z.a = 2;
    mutate(y.b);
  };
  x();
  return [y, z];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 2, b: 3}],
  sequentialRenders: [
    {a: 2, b: 3},
    {a: 2, b: 3},
    {a: 4, b: 3},
    {a: 4, b: 5},
  ],
};

```

----------------------------------------

TITLE: Implementing Reactive State Management in a React Component
DESCRIPTION: This snippet enhances the previous component by incorporating a reactive state management approach using `react/compiler-runtime`. It rerenders the component based on the condition of `$[0]` and updates it accordingly. The logic within the loop remains similar, but now includes state validation and updates for reactive usage, allowing the output array `t0` to either hold the new value of `x` or the previous state depending on the condition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-do-while-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  let i = 0;
  do {
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }

    i++;
  } while (i < props.test);
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { test: 12 },
    { test: 12 },
    { test: 1 },
    { test: 1 },
    { test: 12 },
    { test: 1 },
    { test: 12 },
    { test: 1 },
  ],
};
```

----------------------------------------

TITLE: Original React Hook Implementation with Set Spread Operation
DESCRIPTION: Defines a custom hook 'useFoo' that creates a Set and uses spread operator with Math.max(). Includes test fixture configuration for sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/call-spread-argument-set.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useIdentity} from 'shared-runtime';

/**
 * Forked version of call-spread-argument-mutable-iterator that is known to not mutate
 * the spread argument since it is a Set
 */
function useFoo() {
  const s = new Set([1, 2]);
  useIdentity(null);
  return [Math.max(...s), s];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Memoized React Component with React Compiler Runtime
DESCRIPTION: This React component uses `react/compiler-runtime` to optimize rendering.  It memoizes the result of mapping over `props.post.feedback.comments?.edges` using the `render` function. It conditionally renders the comments only if the `props.post.feedback.comments?.edges` has changed, preventing unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependencies-non-optional-properties-inside-optional-chain.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.post.feedback.comments?.edges) {
    t0 = props.post.feedback.comments?.edges?.map(render);
    $[0] = props.post.feedback.comments?.edges;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Handling Reactive State in React Component - JavaScript
DESCRIPTION: This JavaScript code extends the reactive component handling by incorporating the React compiler-runtime. It uses the _c function to manage reactive updates within the component. The function keeps track of reactivity changes and updates the component output accordingly. React compiler runtime is a prerequisite for this snippet. Like the first snippet, it expects a props object as input and returns an array with a boolean value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-via-mutation-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);

  const x = [];
  if (props.cond) {
    x.push(1);
  }

  let y = false;
  if (x[0]) {
    y = true;
  }
  let t0;
  if ($[0] !== y) {
    t0 = [y];
    $[0] = y;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { cond: true },
    { cond: true },
    { cond: false },
    { cond: false },
    { cond: true },
    { cond: false },
    { cond: true },
    { cond: false },
  ],
};

```

----------------------------------------

TITLE: Transformed JavaScript Function in React
DESCRIPTION: This snippet shows the JavaScript output after transforming the TypeScript code. Type annotations are removed, and the inner function is hoisted and named. The overall structure and functionality remain the same.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-variable-annotation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
type Bar = string;
function TypeAliasUsedAsVariableAnnotation() {
  const fun = _temp;

  fun("hello, world");
}
function _temp(f) {
  const g = f;
  console.log(g);
}

export const FIXTURE_ENTRYPOINT = {
  fn: TypeAliasUsedAsVariableAnnotation,
  params: [],
};
```

----------------------------------------

TITLE: Implementing a Minimal JavaScript Function with Fixture in React
DESCRIPTION: Defines an empty function 'foo' and exports a fixture entrypoint object that references the function. This minimal implementation serves as a testing template.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-complex-single-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimizing React Component without Destructuring
DESCRIPTION: This snippet shows an optimized version of the Component function. It achieves the same result as the previous version but without using destructuring. It directly accesses the first element of props.value and uses a ternary operator for the default value assignment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-explicit-undefined.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [t0] = props.value;
  const x = t0 === undefined ? 42 : t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: [undefined] }],
};
```

----------------------------------------

TITLE: Defining a React Component with Function Returning Arrow Function (Input)
DESCRIPTION: Original React component that creates a context object with a testFn method returning an arrow function. The component renders a Stringify component to display the context object with function invocation enabled.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-nested-object-method.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)

import {Stringify} from 'shared-runtime';

function Test() {
  const context = {
    testFn() {
      // if it is an arrow function its work
      return () => 'test'; // it will break compile if returns an arrow fn
    },
  };

  return <Stringify value={context} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This snippet defines a React component `useFoo` that utilizes a `Stringify` component from `shared-runtime`. The component returns the result of invoking a callback function that renders the `Stringify` component with a value of 4. The component is then exported as `FIXTURE_ENTRYPOINT` for testing or usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-tag-in-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';
function useFoo() {
  const MyLocal = Stringify;
  const callback = () => {
    return <MyLocal value={4} />;
  };
  return callback();
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Memoized React Component with Compiler Runtime
DESCRIPTION: This code defines a memoized React component, `Component2`, using `react/compiler-runtime`. It memoizes the results of mapping the `items` prop and the rendered `<ul>` element.  This optimization prevents unnecessary re-renders when the `items` prop remains unchanged. It also includes the FIXTURE_ENTRYPOINT.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-func-expr.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const Component2 = (props) => {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.items) {
    t0 = props.items.map(_temp);
    $[0] = props.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = <ul>{t0}</ul>;
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
};

export const FIXTURE_ENTRYPOINT = {
  fn: Component2,
  params: [
    {
      items: [
        { id: 2, name: "foo" },
        { id: 3, name: "bar" },
      ],
    },
  ],
};
function _temp(item) {
  return <li key={item.id}>{item.name}</li>;
}
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the React component, likely produced by a compiler. It uses memoization techniques and a custom compiler runtime to improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/resolve-react-hooks-based-on-import-name.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState as useReactState } from "react";

function Component() {
  const $ = _c(4);
  const [state, setState] = useReactState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setState(_temp);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onClick = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <button onClick={onClick}>Increment</button>;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== state) {
    t2 = (
      <>
        Count {state}
        {t1}
      </>
    );
    $[2] = state;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}
function _temp(s) {
  return s + 1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Initial React Component with Mutable State
DESCRIPTION: A basic React component showing initial implementation with MaybeMutable and nested rendering
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-memo-value-not-promoted-to-outer-scope-static.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const count = new MaybeMutable();
  return (
    <View>
      <View>
        {<span>Text</span>}
        {<span>{maybeMutate(count)}</span>}
      </View>
    </View>
  );
}
```

----------------------------------------

TITLE: Compiled React Component with Caching Optimizations (JavaScript)
DESCRIPTION: This snippet shows the compiled version of the React component with added caching optimizations. It includes memoization of derived values and conditional rendering based on changed inputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-map-capture-mutate-bug.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutateAndReturn, Stringify, useIdentity } from "shared-runtime";

/**
 * Copy of repro-array-map-capture-mutate-bug, showing that the same issue applies to any
 * function call which captures its callee when applying an operand.
 */
function Component(t0) {
  const $ = _c(7);
  const { value } = t0;
  const arr = [{ value: "foo" }, { value: "bar" }, { value }];
  useIdentity(null);
  const derived = arr.map(mutateAndReturn);
  let t1;
  if ($[0] !== derived) {
    t1 = derived.at(0);
    $[0] = derived;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== derived) {
    t2 = derived.at(-1);
    $[2] = derived;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1 || $[5] !== t2) {
    t3 = (
      <Stringify>
        {t1}
        {t2}
      </Stringify>
    );
    $[4] = t1;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 5 }],
  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],
};
```

----------------------------------------

TITLE: Calculating Sum from Queue - JavaScript (Alternative)
DESCRIPTION: This snippet is an alternative implementation of the same Component function that also calculates the sum of an array. It uses a different way to add the popped values to the sum, illustrating minor variations in syntax.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-with-assignment-in-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component() {
  const queue = [1, 2, 3];
  let value;
  let sum = 0;
  while ((value = queue.pop()) != null) {
    sum = sum + value;
  }
  return sum;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Compiled React Components with useMemo - JavaScript
DESCRIPTION: Illustrates optimized React components using a compiler runtime alias `_c` to minimize recomputation. It uses a caching technique where computations and outputs are cached, reducing the need to recalculate when dependencies do not change. Requires `react/compiler-runtime`, `useState`, and `useMemo` dependencies. It functions similarly to the uncompiled version but is optimized for better performance through direct memory cache access.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-import.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState, useMemo } from "react";

function Component(props) {
  const $ = _c(4);
  const [x] = useState(0);
  let t0;
  let t1;
  if ($[0] !== x) {
    t1 = calculateExpensiveNumber(x);
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const expensiveNumber = t0;
  let t2;
  if ($[2] !== expensiveNumber) {
    t2 = <div>{expensiveNumber}</div>;
    $[2] = expensiveNumber;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

function Component2(props) {
  const $ = _c(4);
  const [x] = useState(0);
  let t0;
  let t1;
  if ($[0] !== x) {
    t1 = calculateExpensiveNumber(x);
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const expensiveNumber = t0;
  let t2;
  if ($[2] !== expensiveNumber) {
    t2 = <div>{expensiveNumber}</div>;
    $[2] = expensiveNumber;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}
```

----------------------------------------

TITLE: Optimizing Component Logic in JavaScript
DESCRIPTION: This snippet redefines the 'Component' function by introducing an optimization check via the '_c' function. This version utilizes a caching mechanism to avoid re-computing the component's output when the input props remain unchanged, enhancing performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-leave-case.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from 'react/compiler-runtime';
import { Stringify } from 'shared-runtime';

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.p0 || $[1] !== props.p1) {
    const x = [];
    let y;
    if (props.p0) {
      x.push(props.p1);
      y = x;
    }

    t0 = (
      <Stringify>
        {x}
        {y}
      </Stringify>
    );
    $[0] = props.p0;
    $[1] = props.p1;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ p0: false, p1: 2 }],
  sequentialRenders: [
    { p0: false, p1: 2 },
    { p0: false, p1: 2 },
    { p0: true, p1: 2 },
    { p0: true, p1: 3 },
  ],
};
```

----------------------------------------

TITLE: Optimized App Component with Compiler-Generated Code
DESCRIPTION: This snippet presents an optimized version of the App component, likely generated by a React compiler. It uses specialized hooks and guards to improve context access performance and includes memoization logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-access-hook-guard.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import {
  $dispatcherGuard,
  useContext_withSelector,
} from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @lowerContextAccess @enableEmitHookGuards
function App() {
  const $ = _c(3);
  try {
    $dispatcherGuard(0);
    const { foo } = (function () {
      try {
        $dispatcherGuard(2);
        return useContext_withSelector(MyContext, _temp);
      } finally {
        $dispatcherGuard(3);
      }
    })();
    const { bar } = (function () {
      try {
        $dispatcherGuard(2);
        return useContext_withSelector(MyContext, _temp2);
      } finally {
        $dispatcherGuard(3);
      }
    })();
    let t0;
    if ($[0] !== bar || $[1] !== foo) {
      t0 = <Bar foo={foo} bar={bar} />;
      $[0] = bar;
      $[1] = foo;
      $[2] = t0;
    } else {
      t0 = $[2];
    }
    return t0;
  } finally {
    $dispatcherGuard(1);
  }
}
function _temp2(t0) {
  return [t0.bar];
}
function _temp(t0) {
  return [t0.foo];
}
```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: This snippet shows the compiled version of the React component, leveraging the `react/compiler-runtime` for memoization. It initializes a cache using `_c` and conditionally updates the returned array based on changes in props. This optimizes re-renders by caching previous results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-nonreactive-captured-with-reactive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  const y = props.y;
  let t1;
  if ($[1] !== y) {
    t1 = [x, y];
    $[1] = y;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ y: 42 }],
};

```

----------------------------------------

TITLE: Compiled React Hook with Dependency Tracking
DESCRIPTION: Compiled version of the React hook with added dependency tracking and caching mechanism. Includes compiler-runtime utilities and optimized conditional checks for performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-non-null-destructure.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { identity, useIdentity } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(10);
  const { arg, cond } = t0;
  let t1;
  if ($[0] !== arg) {
    t1 = { value: arg };
    $[0] = arg;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const maybeObj = useIdentity(t1);
  const { value } = maybeObj;
  useIdentity(null);
  let arr;
  if ($[2] !== cond || $[3] !== maybeObj.value) {
    arr = [];
    if (cond) {
      let t2;
      if ($[5] !== maybeObj.value) {
        t2 = identity(maybeObj.value);
        $[5] = maybeObj.value;
        $[6] = t2;
      } else {
        t2 = $[6];
      }
      arr.push(t2);
    }
    $[2] = cond;
    $[3] = maybeObj.value;
    $[4] = arr;
  } else {
    arr = $[4];
  }
  let t2;
  if ($[7] !== arr || $[8] !== value) {
    t2 = { arr, value };
    $[7] = arr;
    $[8] = value;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ arg: 2, cond: false }],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: Advanced implementation using React compiler runtime for performance optimization, with explicit memoization and state tracking
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-runtime-import.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import * as React from "react";
import { someImport, c as _c } from "react/compiler-runtime";
import { calculateExpensiveNumber } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  const [x] = React.useState(0);
  let t0;
  let t1;
  if ($[0] !== x) {
    t1 = calculateExpensiveNumber(x);
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const expensiveNumber = t0;
  let t2;
  if ($[2] !== expensiveNumber) {
    t2 = (
      <div>
        {expensiveNumber}
        {`${someImport}`}
      </div>
    );
    $[2] = expensiveNumber;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimizations
DESCRIPTION: Compiled version of the React component using compiler runtime optimizations. Includes caching mechanism using the _c compiler runtime function to optimize repeated operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-cast-expression.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
type Foo = { bar: string };
function Component(props) {
  const $ = _c(2);
  let y;
  if ($[0] !== props.bar) {
    const x = { bar: props.bar };
    y = (x: Foo);
    y.bar = "hello";
    $[0] = props.bar;
    $[1] = y;
  } else {
    y = $[1];
  }
  const z = (y: Foo);
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet demonstrates the optimized version of the component using React's compiler-runtime. It implements memoization and efficient updates based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-join.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(7);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  let t2;
  if ($[2] !== props.value) {
    t2 = [t0, t1, props.value];
    $[2] = props.value;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const x = t2;
  const y = x.join(_temp);
  foo(y);
  let t3;
  if ($[4] !== x || $[5] !== y) {
    t3 = [x, y];
    $[4] = x;
    $[5] = y;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}
function _temp() {
  return "this closure gets stringified, not called";
}
```

----------------------------------------

TITLE: State Management with React's Compiler Runtime in JavaScript
DESCRIPTION: This snippet extends the `component` function from React using the `compiler-runtime`. It introduces caching with the use of special react compiler variables to store and update the state object `z` based on the input `a`. This approach helps in optimizing component re-rendering by checking if the state has changed before executing state updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture_mutate-across-fns.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let z;
  if ($[0] !== a) {
    z = { a };
    const f0 = function () {
      const f1 = function () {
        z.b = 1;
      };

      f1();
    };

    f0();
    $[0] = a;
    $[1] = z;
  } else {
    z = $[1];
  }
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Running DevTools in DEV Mode
DESCRIPTION: Start the DevTools in development mode to test changes interactively.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_4

LANGUAGE: sh
CODE:
```
cd <react-repo>
cd packages/react-devtools-inline
yarn start
```

----------------------------------------

TITLE: Transformed React Hook with Compiler Runtime
DESCRIPTION: This code shows the transformed version of the `useJoinCondDepsInUncondScopes` hook, likely after being processed by the React compiler (Forget). It introduces the `_c` function from `react/compiler-runtime` for memoization and dependency tracking. The transformed code uses a conditional check based on `props.a.b` to determine whether to re-execute the hook's logic, aiming to optimize re-renders based on changes to `props.a.b`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/join-uncond-scopes-cond-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // This tests an optimization, NOT a correctness property.
// When propagating reactive dependencies of an inner scope up to its parent,
// we prefer to retain granularity.
//
// In this test, we check that Forget propagates the inner scope's conditional
// dependencies (e.g. props.a.b) instead of only its derived minimal
// unconditional dependencies (e.g. props).
// ```javascript
//  scope @0 (deps=[???] decls=[x, y]) {
//    let y = {};
//    scope @1 (deps=[props] decls=[x]) {
//      let x = {};
//      if (foo) mutate1(x, props.a.b);
//    }
//    mutate2(y, props.a.b);
//  }

import { CONST_TRUE, setProperty } from "shared-runtime";

function useJoinCondDepsInUncondScopes(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.a.b) {
    const y = {};
    const x = {};
    if (CONST_TRUE) {
      setProperty(x, props.a.b);
    }

    setProperty(y, props.a.b);
    t0 = [x, y];
    $[0] = props.a.b;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useJoinCondDepsInUncondScopes,
  params: [{ a: { b: 3 } }],
};

```

----------------------------------------

TITLE: Compiled React Component Definition
DESCRIPTION: This code represents the transformed React component function after compilation. It utilizes `react/compiler-runtime` for optimization. It introduces memoization logic using the `_c` function to store and reuse previous calculations, avoiding redundant operations when the input `a` remains the same. The component now only re-computes the variable `z` if the input `a` has changed, otherwise it reuses the stored value from the `$`` cache.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a, b) {
  const $ = _c(2);
  let z;
  if ($[0] !== a) {
    z = { a };
    const x = function () {
      z.a = 2;
    };

    x();
    $[0] = a;
    $[1] = z;
  } else {
    z = $[1];
  }
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [{ a: "val1", b: "val2" }],
  isComponent: false,
};

```

----------------------------------------

TITLE: Compiled Component with React Compiler Runtime Memoization
DESCRIPTION: The transformed component after processing by React's compiler. It introduces memoization via a compiler runtime array ($) to track dependencies and prevent unnecessary recalculations. The array stores previous values and only recalculates when dependencies change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(4);
  let t0;
  if ($[0] !== a) {
    t0 = { a: { a } };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  let t1;
  if ($[2] !== z.a.a) {
    t1 = function () {
      console.log(z.a.a);
    };
    $[2] = z.a.a;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Compiler output with memoization
DESCRIPTION: This JavaScript code shows the compiled output of the `useFoo` function, utilizing memoization provided by `react/compiler-runtime`. The compiler generates code to check for changes in `cond` and `input.a.b` before re-executing the function's logic. The `_c` function manages the memoized state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-label.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(t0) {
  const $ = _c(3);
  const { input, cond } = t0;
  let x;
  if ($[0] !== cond || $[1] !== input.a.b) {
    x = [];
    bb0: if (cond) {
      break bb0;
    }

    x.push(input.a.b);
    $[0] = cond;
    $[1] = input.a.b;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}
```

----------------------------------------

TITLE: Compiler-Optimized Output Implementation
DESCRIPTION: Optimized version with React compiler runtime integration, implementing memoization using array-based caching for improved performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-expression-nested-path.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function g(props) {
  const $ = _c(2);
  let a;
  if ($[0] !== props.c) {
    a = { b: { c: props.c } };
    a.b.c = a.b.c + 1;
    a.b.c = a.b.c * 2;
    $[0] = props.c;
    $[1] = a;
  } else {
    a = $[1];
  }
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: g,
  params: [{ c: 2 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component Compiled Implementation
DESCRIPTION: Compiler-optimized version of the component with memoization using Symbol.for() and Unicode escape sequences for non-ASCII characters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-string-attribute-expression-container.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <div>
        <Text value={"\n"} />
        <Text value={"A\tE"} />
        <Text value={"\uB098\uC740"} />
        <Text value="Lauren" />
        <Text value={"\u0B9A\u0BA4\u0BCD\u0BAF\u0BBE"} />
        <Text value="Sathya" />
      </div>
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function Text(t0) {
  const $ = _c(2);
  const { value } = t0;
  let t1;
  if ($[0] !== value) {
    t1 = <span>{value}</span>;
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization - JavaScript
DESCRIPTION: This snippet shows the compiled version of the React component. It introduces optimizations such as memoization checks and caching of computed values. The component logic remains the same, but with added performance enhancements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-object-mutated-later.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, mutate } from "shared-runtime";

function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const key = t0;
  let t1;
  if ($[1] !== props.value) {
    t1 = identity([props.value]);
    $[1] = props.value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t1) {
    t2 = { [key]: t1 };
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const context = t2;

  mutate(key);
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization for Invalid Tag Test
DESCRIPTION: This is the compiled version of the test fixture with React compiler-runtime features. It demonstrates how the code is transformed to include memoization using a Symbol.for cache sentinel pattern, while preserving the invalid tag test case.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-lowercase-localvar.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Throw } from "shared-runtime";

/**
 * Note: this is disabled in the evaluator due to different devmode errors.
 * Found differences in evaluator results
 *  Non-forget (expected):
 *  (kind: ok) <invalidtag val="[object Object]"></invalidtag>
 *  logs: ['Warning: <%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.%s','invalidTag']
 *
 *  Forget:
 *  (kind: ok) <invalidtag val="[object Object]"></invalidtag>
 *  logs: [
 *   'Warning: <%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.%s','invalidTag',
 *   'Warning: The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.%s','invalidTag',
 *  ]
 */
function useFoo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <invalidTag val={{ val: 2 }} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: Component with Memoization - JavaScript
DESCRIPTION: This snippet illustrates the use of memoization within a React functional component. It employs the 'react/compiler-runtime' to access a caching mechanism. The component checks if the cache for a specific key is available; if not, it renders the JSX and stores it in the cache. This approach optimizes re-renders by avoiding unnecessary computations. Outputs a cached component or fresh JSX when required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-member-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <Sathya.Codes.Forget>
        <Foo.Bar.Baz />
      </Sathya.Codes.Forget>
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

```

----------------------------------------

TITLE: Compiler-Optimized React Component
DESCRIPTION: Compiler-transformed version of the component with optimized memoization logic. Uses compiler-runtime helpers to implement caching and dependency tracking for better performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(7);
  const item = props.item;
  let baseVideos;
  let t0;
  let thumbnails;
  if ($[0] !== item) {
    thumbnails = [];
    baseVideos = getBaseVideos(item);

    baseVideos.forEach((video) => {
      const baseVideo = video.hasBaseVideo;
      if (Boolean(baseVideo)) {
        thumbnails.push({ extraVideo: true });
      }
    });
    $[0] = item;
    $[1] = baseVideos;
    $[2] = t0;
    $[3] = thumbnails;
  } else {
    baseVideos = $[1];
    t0 = $[2];
    thumbnails = $[3];
  }
  t0 = undefined;
  let t1;
  if ($[4] !== baseVideos || $[5] !== thumbnails) {
    t1 = <FlatList baseVideos={baseVideos} items={thumbnails} />;
    $[4] = baseVideos;
    $[5] = thumbnails;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  return t1;
}
```

----------------------------------------

TITLE: Original React Component with Context Variable Test
DESCRIPTION: A React component that tests forget's ability to handle context variables. It creates a context variable with a mutable range and then references it after that range, checking if proper memoization occurs based on the component's inputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/context-var-granular-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {throwErrorWithMessage, ValidateMemoization} from 'shared-runtime';

/**
 * Context variables are local variables that (1) have at least one reassignment
 * and (2) are captured into a function expression. These have a known mutable
 * range: from first declaration / assignment to the last direct or aliased,
 * mutable reference.
 *
 * This fixture validates that forget can take granular dependencies on context
 * variables when the reference to a context var happens *after* the end of its
 * mutable range.
 */
function Component({cond, a}) {
  let contextVar;
  if (cond) {
    contextVar = {val: a};
  } else {
    contextVar = {};
    throwErrorWithMessage('');
  }
  const cb = {cb: () => contextVar.val * 4};

  /**
   * manually specify input to avoid adding a `PropertyLoad` from contextVar,
   * which might affect hoistable-objects analysis.
   */
  return (
    <ValidateMemoization
      inputs={[cond ? a : undefined]}
      output={cb}
      onlyCheckCompiled={true}
    />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: false, a: undefined}],
  sequentialRenders: [
    {cond: true, a: 2},
    {cond: true, a: 2},
  ],
};
```

----------------------------------------

TITLE: Using React Compiler Runtime for Component Definition in JavaScript
DESCRIPTION: This snippet shows a more complex version of the `component` function that integrates React's `compiler-runtime` for JSX transformation. It sets up several temporary variables (t0, t1) to handle state management, updating them based on the state of the component. The `FIXTURE_ENTRYPOINT` is exported, orchestrating function execution with specific initialization parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-arrow-function-1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(4);
  let t0;
  if ($[0] !== a) {
    t0 = { a };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  let t1;
  if ($[2] !== z) {
    t1 = () => {
      console.log(z);
    };
    $[2] = z;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Initializing Conditional Dependency Tracking Function
DESCRIPTION: Function demonstrating conditional object property access and reactive scope management in React Compiler. Handles different execution paths while tracking dependencies on props.a.b.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-ifelse.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function useCondDepInDirectIfElse(props, cond) {
  const x = {};
  if (identity(cond)) {
    x.b = props.a.b;
  } else {
    x.c = props.a.b;
  }
  return x;
}
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";

function useCondDepInDirectIfElse(props, cond) {
  const $ = _c(3);
  let x;
  if ($[0] !== cond || $[1] !== props.a.b) {
    x = {};
    if (identity(cond)) {
      x.b = props.a.b;
    } else {
      x.c = props.a.b;
    }
    $[0] = cond;
    $[1] = props.a.b;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}
```

----------------------------------------

TITLE: React Compiler Runtime Optimized Component Function
DESCRIPTION: An optimized version of the component function using React's compiler runtime. Implements memoization and prevents unnecessary re-renders by tracking state changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prop-capturing-function-1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a, b) {
  const $ = _c(5);
  let t0;
  if ($[0] !== a || $[1] !== b) {
    t0 = { a, b };
    $[0] = a;
    $[1] = b;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const z = t0;
  let t1;
  if ($[3] !== z) {
    t1 = function () {
      console.log(z);
    };
    $[3] = z;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const x = t1;
  return x;
}
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the React component, likely generated by a compiler. It includes memoization and conditional rendering optimizations while maintaining the same functionality as the original component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/controlled-input.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState } from "react";
function component() {
  const $ = _c(3);
  const [x, setX] = useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (event) => setX(event.target.value);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const handler = t0;
  let t1;
  if ($[1] !== x) {
    t1 = <input onChange={handler} value={x} />;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Optimized VideoTab with React Compiler Runtime Memoization
DESCRIPTION: An enhanced version of the VideoTab component using React's compiler runtime for memoization, with cached rendering and Symbol-based memo sentinel
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-write-not-added-to-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function VideoTab() {
  const $ = _c(1);
  const ref = useRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = () => {
      ref.current = 1;
    };

    t0 = <VideoList videos={x} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled Function with Memoization
DESCRIPTION: Optimized version of the function using React's compiler runtime. Implements memoization using a cache array to avoid redundant computations when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { addOne, shallowCopy } from "shared-runtime";

function foo(a, b, c) {
  const $ = _c(5);
  let t0;
  if ($[0] !== a) {
    t0 = shallowCopy(a);
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  let t1;
  if ($[2] !== b || $[3] !== x) {
    t1 = x.foo(b);
    $[2] = b;
    $[3] = x;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const y = t1;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{ foo: addOne }, 3],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining a Basic React Component in JavaScript
DESCRIPTION: This snippet defines a simple React component that calculates a value based on the prop 'test'. The component uses a while loop to assign values to 'x' based on the index 'i' and the 'test' prop. It illustrates basic state management without any hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-while-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  let i = 0;
  while (i < props.test) {
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }
    i++;
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" variable `i`, whose value is affected by
  // `props.test` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {test: 12},
    {test: 12},
    {test: 1},
    {test: 1},
    {test: 12},
    {test: 1},
    {test: 12},
    {test: 1},
  ],
};
```

----------------------------------------

TITLE: Defining Component and Exporting Fixture Entry Point - JavaScript
DESCRIPTION: This snippet defines a React component named 'Component' that retrieves a number from a shared runtime module and returns it. It also exports a constant 'FIXTURE_ENTRYPOINT' that holds the component along with parameters for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-types-through-type-cast.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { getNumber } from "shared-runtime";

function Component(props) {
  const x = getNumber();
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};

```

----------------------------------------

TITLE: Error Handling in Component Function - JavaScript
DESCRIPTION: This snippet defines a React component function that processes input properties, pushes one of the properties to an array, and uses a shared runtime function 'throwInput' to manage exceptions. It captures errors and outputs an error array when exceptions occur.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-try-value-modified-in-catch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
const {throwInput} = require('shared-runtime');

function Component(props) {
  try {
    const y = [];
    y.push(props.y);
    throwInput(y);
  } catch (e) {
    e.push(props.e);
    return e;
  }
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{y: 'foo', e: 'bar'}],
};

```

----------------------------------------

TITLE: Implementing useFoo Function with Shallow Copy and Conditional Logic in JavaScript
DESCRIPTION: This snippet defines the useFoo function that demonstrates scope management and conditional logic. It uses shallowCopy for input, creates a condition, and returns either a constant object or the result of a mutation based on the condition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutate-outer-scope-within-value-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_TRUE, identity, shallowCopy} from 'shared-runtime';

function mutate(_: unknown) {}

/**
 * There are three values with their own scopes in this fixture.
 * - arr, whose mutable range extends to the `mutate(...)` call
 * - cond, which has a mutable range of exactly 1 (e.g. created but not
 *   mutated)
 * - { val: CONST_TRUE }, which is also not mutated after creation. However,
 *   its scope range becomes extended to the value block.
 *
 * After AlignScopesToBlockScopes, our scopes look roughly like this
 * ```js
 *  [1] arr = shallowCopy()            @0
 *  [2] cond = identity()        <- @1 |
 *  [3] $0 = Ternary test=cond     @2 |
 *  [4]        {val : CONST_TRUE}  |   |
 *  [5]        mutate(arr)         |   |
 *  [6] return $0                     
 * ```
 *
 * Observe that instruction 5 mutates scope 0, which means that scopes 0 and 2
 * should be merged.
 */
function useFoo({input}) {
  const arr = shallowCopy(input);

  const cond = identity(false);
  return cond ? {val: CONST_TRUE} : mutate(arr);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: 3}],
};
```

----------------------------------------

TITLE: Hoisting Function Definition in JavaScript
DESCRIPTION: This JavaScript function `hoisting` demonstrates variable hoisting. It conditionally defines functions `foo` and `bar` and calls them. The function returns an array of boolean values based on the execution of `foo` and `bar` within the conditional block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-let-declaration-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function hoisting(cond) {
  let items = [];
  if (cond) {
    let foo = () => {
      items.push(bar());
    };
    let bar = () => true;
    foo();
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [true],
  isComponent: false,
};
```

----------------------------------------

TITLE: Closure Capture in JavaScript
DESCRIPTION: This JavaScript code defines a function `get2` that captures the variable `x` in a closure using a callback function. The callback function `callbk` returns a copy of `x`. The function then defines `x` and immediately calls `callbk`, returning the captured value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-repro-variable-used-in-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function get2() {
  const callbk = () => {
    const copy = x;
    return copy;
  };
  const x = 2;
  return callbk();
}

export const FIXTURE_ENTRYPOINT = {
  fn: get2,
  params: [],
};

```

----------------------------------------

TITLE: Component Definition
DESCRIPTION: This snippet defines a simple React component that takes a parameter 'a', creates an object 'z' with 'a' as a property, and then adds a property 'b' to 'z' within nested immediately invoked function expressions (IIFEs). Finally, it returns the object 'z'. This demonstrates a basic component structure with side effects within the function body.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture_mutate-across-fns-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a};
  (function () {
    (function () {
      z.b = 1;
    })();
  })();
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [2],
};

```

----------------------------------------

TITLE: TypeScript Optional Property Error in React Function
DESCRIPTION: This snippet captures an error related to the handling of optional properties in TypeScript within the `useFoo` function. It highlights how TypeScript's handling of optional chaining can cause unexpected issues, specifically when using optional properties that may fall through.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/error.todo-optional-call-chain-in-optional.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 | function useFoo(props: {value: {x: string; y: string} | null}) {
  3 |   const value = props.value;
> 4 |   return createArray(value?.x, value?.y)?.join(', ');
    |                      ^^^^^^^^ Todo: Unexpected terminal kind `optional` for optional fallthrough block (4:4)
  5 | }
  6 |
  7 | function createArray<T>(...args: Array<T>): Array<T> {

```

----------------------------------------

TITLE: Defining a Component Function - JavaScript
DESCRIPTION: This snippet defines a simple React component function that contains another function 'x' which calls a method 'foo' on the passed argument 'a'. Although the inner function 'x' is redefined as an empty function, it is still returned as the final output of the enclosing function. No external dependencies are required for this snippet.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-redeclare.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  function x(a) {
    a.foo();
  }
  function x() {}
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Transforming React Component without Destructuring in JavaScript
DESCRIPTION: This snippet shows the same React component rewritten without using array destructuring. It manually checks for undefined values and assigns the default. The fixture remains the same for testing consistency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-array-hole.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [t0] = props.value;
  const x = t0 === undefined ? 42 : t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: [, /* hole! */ 3.14] }],
};
```

----------------------------------------

TITLE: Simplified React Component
DESCRIPTION: Simplified version of the component that directly returns a constant value 42. Includes the same test fixture export but without error handling logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-immediately-returns.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  return 42;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ default: 42 }],
};
```

----------------------------------------

TITLE: Implementing React Component with Fragment and Memoization (Input)
DESCRIPTION: This snippet shows the original implementation of a React component using fragments and manual memoization. It includes a custom hook 'useFragment' and demonstrates destructuring with default values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-mixed-scope-and-local-variables-with-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify, graphql} from 'shared-runtime';

function useFragment(_arg1, _arg2) {
  'use no forget';
  return {
    urls: ['url1', 'url2', 'url3'],
    comments: ['comment1'],
  };
}

function Component(props) {
  const post = useFragment(
    graphql`
      fragment F on T {
        id
      }
    `,
    props.post
  );
  const allUrls = [];
  // `media` and `urls` are exported from the scope that will wrap this code,
  // but `comments` is not (it doesn't need to be memoized, bc the callback
  // only checks `comments.length`)
  // because of the scope, the let declaration for media and urls are lifted
  // out of the scope, and the destructure statement ends up turning into
  // a reassignment, instead of a const declaration. this means we try to
  // reassign `comments` when there's no declaration for it.
  const {media = null, comments = [], urls = []} = post;
  const onClick = e => {
    if (!comments.length) {
      return;
    }
    console.log(comments.length);
  };
  allUrls.push(...urls);
  return <Stringify media={media} allUrls={allUrls} onClick={onClick} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{post: {}}],
  isComponent: true,
};
```

----------------------------------------

TITLE: Compiled React Memo Code with Feature Flag
DESCRIPTION: Compiled version with React compiler runtime and feature flag integration, including memo cache sentinel logic
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/invalid-fnexpr-reference.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
import * as React from "react";

let Foo;
const MemoFoo = React.memo(Foo);
Foo = isForgetEnabled_Fixtures()
  ? () => {
      const $ = _c(1);
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = <div>hello world!</div>;
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : () => <div>hello world!</div>;

/**
 * Evaluate this fixture module to assert that compiler + original have the same
 * runtime error message.
 */
export const FIXTURE_ENTRYPOINT = {
  fn: isForgetEnabled_Fixtures() ? () => {} : () => {},
  params: [],
};
```

----------------------------------------

TITLE: FBT Implementation Error Output
DESCRIPTION: Error output showing the issue with using 'fbt' as a local variable name, which conflicts with the FBT transform's expectations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-fbt-as-local.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  16 |
  17 | function Foo(props) {
> 18 |   const getText1 = fbt =>
     |                    ^^^ Todo: Support local variables named "fbt" (18:18)
  19 |     fbt(
  20 |       `Hello, ${fbt.param('(key) name', identity(props.name))}!`,
  21 |       '(description) Greeting'
```

----------------------------------------

TITLE: Defining React Component and Fixture Entrypoint in JavaScript
DESCRIPTION: This snippet defines a React component function that iterates over props.value without performing any operations, and exports a fixture entrypoint for testing. The component takes props as an argument and returns an undefined variable x. The fixture specifies the component function and test parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-empty-body.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  for (const y in props.value) {
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: { a: "a", b: "B", c: "C!" } }],
};
```

----------------------------------------

TITLE: React Component with Explicit Undefined Check
DESCRIPTION: Alternative implementation that explicitly checks for undefined using a ternary operator instead of destructuring defaults. Assigns 42 if the value is undefined, otherwise uses the provided value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-default-at-explicit-null.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [t0] = props.value;
  const x = t0 === undefined ? 42 : t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: [null] }],
};
```

----------------------------------------

TITLE: React Component with Delete Operation (JavaScript)
DESCRIPTION: Defines a React component that creates an object, attempts to delete a property based on the `props.value`, and returns the result of the delete operation (which will be a boolean). Assumes `makeObject()` is a globally available function that returns an object.  Note that deleting a non-existent property results in `true`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-computed-delete.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @debug
function Component(props) {
  const x = makeObject();
  const y = delete x[props.value];
  return y;
}
```

----------------------------------------

TITLE: React Component with Computed Property Names
DESCRIPTION: A React component function using computed property names in an object literal, which imports utility functions from 'shared-runtime'. It creates an object with a dynamically computed property key based on function calls.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-member-expr-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate, mutateAndReturn} from 'shared-runtime';

function Component(props) {
  const obj = {mutateAndReturn};
  const key = {};
  const context = {
    [obj.mutateAndReturn(key)]: identity([props.value]),
  };
  mutate(key);
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Implementing React Component with Memoization and Mutation (Input)
DESCRIPTION: This code snippet defines a React component that creates objects, manipulates an array, and uses mutation. It demonstrates the use of the 'enablePreserveExistingMemoizationGuarantees' directive and the 'mutate' function from a shared runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-freeze-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePreserveExistingMemoizationGuarantees
const {mutate} = require('shared-runtime');

function Component(props) {
  const x = {};
  const y = {};
  const items = [x, y];
  items.pop();
  <div>{items}</div>; // note: enablePreserveExistingMemoizationGuarantees only visits function expressions, not arrays, so this doesn't freeze x/y
  mutate(y); // ok! not part of `items` anymore bc of items.pop()
  return [x, y, items];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Component with fbt Internationalization
DESCRIPTION: This snippet shows an optimized version of the React component using fbt. It includes memoization for better performance and uses the compiled format of fbt calls.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-leading-whitespace.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.count || $[1] !== props.option) {
    t0 = (
      <span>
        {fbt._(
          { "*": "{count} votes for {option}", _1: "1 vote for {option}" },
          [
            fbt._plural(identity(props.count), "count"),
            fbt._param(
              "option",

              props.option,
            ),
          ],
          { hk: "3Bg20a" },
        )}
        !
      </span>
    );
    $[0] = props.count;
    $[1] = props.option;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ count: 42, option: "thing" }],
  sequentialRenders: [
    { count: 42, option: "thing" },
    { count: 42, option: "thing" },
    { count: 1, option: "other" },
    { count: 1, option: "other" },
    { count: 42, option: "thing" },
    { count: 1, option: "other" },
    { count: 42, option: "thing" },
    { count: 1, option: "other" },
  ],
};
```

----------------------------------------

TITLE: Defining a React Component with Fire Usage - JavaScript
DESCRIPTION: This snippet defines a React functional component that imports the 'fire' function and logs a property to the console. It demonstrates error handling with try-finally and attempts to invoke the 'fire' function within a useEffect hook, noting potential limitations regarding React's compiler transformation of the 'fire' function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.todo-syntax.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire @panicThreshold(none)
import {fire} from 'react';

/**
 * Note that a react compiler-based transform still has limitations on JS syntax.
 * In practice, we expect to surface these as actionable errors to the user, in
 * the same way that invalid `fire` calls error.
 */
function Component({prop1}) {
  const foo = () => {
    try {
      console.log(prop1);
    } finally {
      console.log('jbrown215');
    }
  };
  useEffect(() => {
    fire(foo());
  });
}
```

----------------------------------------

TITLE: Defining and Exporting React Component as Fixture Entrypoint (Input)
DESCRIPTION: This snippet defines a simple component function that returns a value and exports it as a fixture entrypoint. The component initializes two variables but only returns one of them.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-primitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let x = 1;
  let y = 2;

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled FBT Component with React Compiler Runtime Optimization
DESCRIPTION: This is the compiled output of the FBT component showing how React's compiler optimizes internationalization. It uses memoization via the compiler runtime to avoid recreating the FBT instance on re-renders when props haven't changed, improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-unicode.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.name) {
    t0 = fbt._(
      "Hello {user name }",
      [fbt._param("user name \u263A", props.name)],
      { hk: "1En1lp" },
    );
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const element = t0;
  let t1;
  if ($[2] !== element) {
    t1 = element.toString();
    $[2] = element;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Jason" }],
};
```

----------------------------------------

TITLE: Defining React Component Input
DESCRIPTION: This snippet defines a simple React component function with a nested function that gets overwritten. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-reassign.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  function x(a) {
    a.foo();
  }
  x = {};
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Original React Component with Inferred Effect Dependencies
DESCRIPTION: A React component demonstrating how the compiler handles setState as a stable reference in useEffect. This example shows the input code before compilation, where the effect dependency array is intentionally omitted.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-setState.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect, useState} from 'react';
import {print} from 'shared-runtime';

/**
 * Special case of `infer-effect-deps/nonreactive-dep`.
 *
 * We know that local `useRef` return values are stable, regardless of
 * inferred memoization.
 */
function NonReactiveSetStateInEffect() {
  const [_, setState] = useState('initial value');
  useEffect(() => print(setState));
}
```

----------------------------------------

TITLE: Integrating React Compiler Runtime in Hoisting Implementation
DESCRIPTION: This snippet modifies the previous 'hoisting' function to utilize React's compiler runtime. It tracks state using arrays and conditional logic, allowing for optimized component behavior with React's state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-const-declaration-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function hoisting(cond) {
  const $ = _c(2);
  let items;
  if ($[0] !== cond) {
    items = [];
    if (cond) {
      const foo = () => {
        items.push(bar());
      };

      const bar = _temp;
      foo();
    }
    $[0] = cond;
    $[1] = items;
  } else {
    items = $[1];
  }
  return items;
}
function _temp() {
  return true;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [true],
  isComponent: false,
};
```

----------------------------------------

TITLE: Original Conditional Object Creation in React
DESCRIPTION: Input code showing a function that conditionally creates objects based on a condition. The function takes multiple parameters and returns an object containing either parameter b or c.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-literal-cached-in-if-else.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  let x = {};
  if (someVal) {
    x = {b};
  } else {
    x = {c};
  }

  return x;
}
```

----------------------------------------

TITLE: Defining a React Component with Stringify in JavaScript
DESCRIPTION: This code snippet defines a simple React component using the 'Stringify' component from 'shared-runtime'. It accepts an object with properties 'a' and 'b', then renders the property 'a' using 'Stringify'. The component is part of a fixture that tests its rendering behavior with sequential inputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-runs-inference.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';
function Component({a, b}) {
  let z = {a};
  let p = () => <Stringify>{z}</Stringify>;
  return p();
}
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1}],
  sequentialRenders: [{a: 1}, {a: 1}, {a: 2}],
};
```

----------------------------------------

TITLE: Building Dependencies from Source for React DevTools
DESCRIPTION: Command to build the required dependencies from source for React DevTools development, executed from the repository root.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/README.md#2025-04-21_snippet_1

LANGUAGE: sh
CODE:
```
yarn build-for-devtools
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component implementation that demonstrates error handling with try/catch blocks and array manipulation. The component attempts to push an error message to an array, catches any errors, and falls back to pushing a shallow copy of an empty object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-mutable-range.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {throwErrorWithMessage, shallowCopy} = require('shared-runtime');

function Component(props) {
  const x = [];
  try {
    x.push(throwErrorWithMessage('oops'));
  } catch {
    x.push(shallowCopy({}));
  }
  x.push(props.value); // extend the mutable range to include the try/catch
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiler-Transformed React Component with Memoization
DESCRIPTION: The same React component after being processed by the React compiler. It uses the memo cache system to optimize rendering by memoizing the component's state values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-primitive-in-context.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = 5;
    const foo = () => {
      x = {};
    };

    foo();
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Defining React Component with Conditional Property Access (Input)
DESCRIPTION: This code defines a React component `Foo` that takes an object `a` and a boolean `shouldReadA` as props. Based on `shouldReadA`, it either attempts to access `a.b.c` or returns null.  The result is then stringified using the `Stringify` component for rendering. The `FIXTURE_ENTRYPOINT` provides different input values for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/infer-function-cond-access-not-hoisted.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function Foo({a, shouldReadA}) {
  return (
    <Stringify
      fn={() => {
        if (shouldReadA) return a.b.c;
        return null;
      }}
      shouldInvokeFns={true}
    />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{a: null, shouldReadA: true}],
  sequentialRenders: [
    {a: null, shouldReadA: true},
    {a: null, shouldReadA: false},
    {a: {b: {c: 4}}, shouldReadA: true},
  ],
};
```

----------------------------------------

TITLE: React Compilation Error for Fire Method
DESCRIPTION: Error message indicating an invalid usage of the `fire()` method in a React component. The error specifies that `fire()` can only receive a function call, not direct method or expression invocations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-not-call.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   7 |   };
   8 |   useEffect(() => {
>  9 |     fire(props);
     |     ^^^^^^^^^^^ InvalidReact: Cannot compile `fire`. `fire()` can only receive a function call such as `fire(fn(a,b)). Method calls and other expressions are not allowed (9:9)
  10 |   });
  11 |
  12 |   return null;
```

----------------------------------------

TITLE: Defining Component Functionality in JavaScript
DESCRIPTION: This snippet defines a simple function 'component' that creates a closure and logs a parameter 'a' when invoked. It captures the input into an object and returns a new function that logs this object's property. It serves as a basic demonstration of how to create and export a React component entry point.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-member-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a};
  let x = function () {
    console.log(z.a);
  };
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Alternative React Component with Labeled Break Blocks
DESCRIPTION: A React functional component using labeled break blocks and explicit variable assignment to achieve similar conditional logic as the previous implementation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-switch-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let t0;
  bb0: {
    let y;
    bb1: switch (props.switch) {
      case "foo": {
        t0 = "foo";
        break bb0;
      }
      case "bar": {
        y = "bar";
        break bb1;
      }
      default: {
        y = props.y;
      }
    }

    t0 = y;
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Function Definition for Component in JavaScript
DESCRIPTION: This JavaScript function, Component, initializes a local object using the input parameter and modifies it with an external mutate function. It highlights basic object manipulation. The function takes one parameter, c, and depends on an external mutate method for modification.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue852.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(c) {
  let x = {c};
  mutate(x);
  let a = x;
  let b = a;
}

```

----------------------------------------

TITLE: Defining Simple Input Handler in JavaScript
DESCRIPTION: This snippet defines a basic React component that takes input from props and stores it in an array. The component returns the first item of the array after adding the input value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [];
  const y = x;
  y.push(props.input);

  return [x[0]];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {input: 42},
    {input: 42},
    {input: 'sathya'},
    {input: 'sathya'},
    {input: 42},
    {input: 'sathya'},
    {input: 42},
    {input: 'sathya'},
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Using Compiler Runtime
DESCRIPTION: The compiled version of the component using React's compiler-runtime for memoization. It implements a caching mechanism that tracks prop dependencies (cond and value) to avoid unnecessary recalculations and renders when the inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-array-push.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  let t1;
  if ($[1] !== props.cond || $[2] !== props.value) {
    let y;
    if (props.cond) {
      y = [props.value];
    } else {
      y = [];
    }

    y.push(x);

    t1 = [x, y];
    $[1] = props.cond;
    $[2] = props.value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, value: 42 }],
  sequentialRenders: [
    { cond: true, value: 3.14 },
    { cond: false, value: 3.14 },
    { cond: true, value: 42 },
  ],
};
```

----------------------------------------

TITLE: Compiled React Optimization Code
DESCRIPTION: The React compiler-optimized version of the code that implements caching using an array to store condition and object references. It reduces object allocations by reusing previously created objects when the condition hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-while.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(cond) {
  const $ = _c(2);
  let a;
  if ($[0] !== cond) {
    a = {};
    let b = {};
    let c = {};
    while (cond) {
      const z = a;
      a = b;
      b = c;
      c = z;
      mutate(a, b);
    }
    $[0] = cond;
    $[1] = a;
  } else {
    a = $[1];
  }
  return a;
}

function mutate(x, y) {}
```

----------------------------------------

TITLE: React Component with compiler runtime and memoization
DESCRIPTION: This snippet shows a react component, optimized using the react compiler. The component uses the `_c` function from `react/compiler-runtime` to manage memoization. It checks if a memoized value exists and reuses it, otherwise creates a new object using `makeObject_Primitives` and memoizes it for future use. The result of the object will only recompute if the dependencies of the compiler function change. `FIXTURE_ENTRYPOINT` is defined as an exported object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-maybe-modified-later-dont-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees:false
import { useMemo } from "react";
import { identity, makeObject_Primitives, mutate } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  let t0;
  let object;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = makeObject_Primitives();
    object = t0;
    identity(object);
    $[0] = object;
    $[1] = t0;
  } else {
    object = $[0];
    t0 = $[1];
  }
  return object;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: React Component Compilation with Memoization
DESCRIPTION: This snippet shows the compiled code for a React component (TestComponent) that uses a compiler runtime function (`_c`) for memoization. It checks if the input prop `x` has changed and only re-renders the `<Button>` component if necessary, storing the result in a cache.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/use-memo-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function TestComponent(t0) {
  "usememo";
  const $ = _c(2);
  const { x } = t0;
  let t1;
  if ($[0] !== x) {
    t1 = <Button>{x}</Button>;
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the React component using memoization. It uses a compiler-specific function _c for caching and implements the same functionality as the original component but with improved performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multiple-calls-to-hoisted-callback-from-other-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState } from "react";

function Component(props) {
  const $ = _c(1);
  const [, setState] = useState();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = () => b();

    const b = () => (
      <>
        <div onClick={() => onClick(true)}>a</div>
        <div onClick={() => onClick(false)}>b</div>
      </>
    );

    const onClick = (value) => {
      setState(value);
    };

    t0 = <div>{a()}</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized Component with Compiler Runtime Memoization
DESCRIPTION: An enhanced version of the previous component using React compiler runtime for memoization. Implements caching of component state and optimizes re-rendering by tracking changes in input parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-try-value-modified-in-catch-escaping.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
const { throwInput } = require("shared-runtime");

function Component(props) {
  const $ = _c(3);
  let x;
  if ($[0] !== props.e || $[1] !== props.y) {
    try {
      const y = [];
      y.push(props.y);
      throwInput(y);
    } catch (t0) {
      const e = t0;
      e.push(props.e);
      x = e;
    }
    $[0] = props.e;
    $[1] = props.y;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ y: "foo", e: "bar" }],
};
```

----------------------------------------

TITLE: Initializing React Component with Props in JavaScript
DESCRIPTION: This snippet defines two functions: `foo`, which appears to be a placeholder, and `Component`, a React component function. The component initializes an array and an object, passes them to the `foo` function, and returns a JSX element using them as props. There are no specific dependencies listed, although React and JSX syntax are used. This exercise primarily involves state creation and JSX return.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {}

function Component(props) {
  const a = [];
  const b = {};
  foo(a, b);
  let _ = <div a={a} />;
  foo(b);
  return <div a={a} b={b} />;
}

```

----------------------------------------

TITLE: Expanded Flow-typed React Component with Detailed Type Annotations
DESCRIPTION: Enhanced version of the same component with explicit Flow type annotations, including ReadOnly type and React.Node return type specification.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-add-hook-guards-on-retry.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Foo({
  useDynamicHook,
}: $ReadOnly<{ useDynamicHook: any }>): React.Node {
  useDynamicHook();
  return <div>hello world</div>;
}
```

----------------------------------------

TITLE: Defining React Component and Test Fixture
DESCRIPTION: This snippet defines a React component that renders a list of prop keys, and exports a fixture for testing the component with various prop combinations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let items = [];
  for (const key in props) {
    items.push(<div key={key}>{key}</div>);
  }
  return <div>{items}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{hello: null, world: undefined, '!': true}],
  sequentialRenders: [
    {a: null, b: null, c: null},
    {lauren: true, mofei: true, sathya: true, jason: true},
  ],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that calls a mutation function and returns an array of values. Shows the pre-compilation version of the component code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/uninitialized-declaration-in-reactive-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = mutate();
  let y;
  foo(x);
  return [y, x];
}
```

----------------------------------------

TITLE: Defining React Component with FBT Internationalization
DESCRIPTION: This snippet shows a React component using FBT for internationalization. It renders a text component with parameterized content for easy translation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-with-jsx-element-content.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function Component({name, data, icon}) {
  return (
    <Text type="body4">
      <fbt desc="Lorem ipsum">
        <fbt:param name="item author">
          <Text type="h4">{name}</Text>
        </fbt:param>
        <fbt:param name="icon">{icon}</fbt:param>
        <Text type="h4">
          <fbt:param name="item details">{data}</fbt:param>
        </Text>
      </fbt>
    </Text>
  );
}
```

----------------------------------------

TITLE: Implementing Array Manipulation Function in JavaScript
DESCRIPTION: This function creates an array by spreading a source array into a predefined array, then returns the length of the resulting array and the result of pushing a new element. It's designed to test order of evaluation in React compilation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/evaluation-order-mutate-call-after-dependency-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * Test that we preserve order of evaluation on the following case scope@0
 * ```js
 * // simplified HIR
 * scope@0
 *    ...
 *    $0 = arr.length
 *    $1 = arr.push(...)
 *
 * scope@1 <-- here we should depend on $0 (the value of the property load before the
 *             mutable call)
 *   [$0, $1]
 * ```
 */
function useFoo(source: Array<number>): [number, number] {
  const arr = [1, 2, 3, ...source];
  return [arr.length, arr.push(0)];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [[5, 6]],
};
```

----------------------------------------

TITLE: Initializing a Custom React Renderer with react-reconciler
DESCRIPTION: Basic example showing how to create a custom React renderer using the react-reconciler package. This demonstrates the main structure of using Reconciler with a HostConfig and exposing a public API.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const Reconciler = require('react-reconciler');

const HostConfig = {
  // You'll need to implement some methods here.
  // See below for more information and examples.
};

const MyRenderer = Reconciler(HostConfig);

const RendererPublicAPI = {
  render(element, container, callback) {
    // Call MyRenderer.updateContainer() to schedule changes on the roots.
    // See ReactDOM, React Native, or React ART for practical examples.
  }
};

module.exports = RendererPublicAPI;
```

----------------------------------------

TITLE: Defining Fixture for React Hook Testing
DESCRIPTION: This snippet exports a fixture object 'FIXTURE_ENTRYPOINT' for testing the 'useFoo' hook. It includes the hook function, initial parameters, and a sequence of renders with different prop values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-for-of-iterate-values.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{propArr: [7, 8, 9]}],
  sequentialRenders: [
    {propArr: [7, 8, 9]},
    {propArr: [7, 8, 9]},
    {propArr: [7, 8, 10]},
  ],
};
```

----------------------------------------

TITLE: Defining a test fixture for React component in JavaScript
DESCRIPTION: This JavaScript code defines a `FIXTURE_ENTRYPOINT` object. It contains the `useFoo` function, an array of `params` with sample inputs, and a `sequentialRenders` array for testing different scenarios with varying input values and conditions, including null and empty objects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-label.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {a: {b: 2}}, cond: false}],
  sequentialRenders: [
    {input: {a: {b: 2}}, cond: false},
    // preserve nullthrows
    {input: null, cond: false},
    {input: null, cond: true},
    {input: { }, cond: false},
    {input: {a: {b: null}}, cond: false},
    {input: {a: null}, cond: false},
    {input: {a: {b: 3}}, cond: false},
  ],
};
```

----------------------------------------

TITLE: Defining and Exporting Function in JavaScript
DESCRIPTION: This snippet defines a JavaScript function, Foo, which appears to demonstrate function typing with a TypeScript type declaration (type X) and an interface (Bar). It also shows how to export this function in React as FIXTURE_ENTRYPOINT with empty parameters. The interface and type are not actually used in the function return and the snippet relies on the standard JavaScript and TypeScript setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ignore-inner-interface-types.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {
  type X = number;
  interface Bar {
    baz: number;
  }
  return 0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};

```

----------------------------------------

TITLE: React Component Compiled Output with Memoization
DESCRIPTION: Compiled version of the component implementing memoization pattern. Uses compiler runtime utilities and Symbol.for() to implement caching. Shows how the mutable state and JSX are transformed into optimized code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-jsx-tag-lowered-between-mutations.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const maybeMutable = new MaybeMutable();

    t0 = <View>{maybeMutate(maybeMutable)}</View>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Defining a React Hook with Flow and Compilation Mode
DESCRIPTION: This snippet defines a React hook called `useFoo` that takes a number as input (`bar`) and returns an array containing that number. It uses Flow for type checking and specifies the compilation mode as `infer`.  This seems to be the hook definition before any compilation or transformation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-declaration-basic.flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @compilationMode(infer)
export default hook useFoo(bar: number) {
  return [bar];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [42],
};

```

----------------------------------------

TITLE: Using React and Custom Hooks with Memoization - JavaScript
DESCRIPTION: This snippet expands on the previous one by importing React runtime features. It demonstrates memoization for optimizing rendering with caching. The 'Component' utilizes the custom hook 'useFreeze' and stores component state within a variable '$' that checks and assigns a cache based on the memoization strategy. The memoization patterns help to avoid unnecessary re-renders unless the dependencies change, improving the performance of the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFreeze() {}
function foo() {}

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  const y = useFreeze(x);
  foo(y, x);
  let t1;
  if ($[1] !== y) {
    t1 = (
      <Component>
        {x}
        {y}
      </Component>
    );
    $[1] = y;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet shows the compiled version of the React component, utilizing React's compiler runtime (likely prepack or similar). It memoizes the rendered element based on the `props.version` to avoid unnecessary re-renders. The component leverages the `_c` function from `react/compiler-runtime` for memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-namespaced-name.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.version) {
    t0 = <xml:http protocol:version={props.version} />;
    $[0] = props.version;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: React Component with Object Property Iteration
DESCRIPTION: A React component that takes a props object, uses a for...in loop to iterate over props.value properties, and returns the first property key encountered. If no properties exist, returns null. Includes test fixture setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-body-always-returns.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  for (const x in props.value) {
    return x;
  }
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: {a: 'A!'}}],
};
```

----------------------------------------

TITLE: Building React DevTools Dependencies from Source
DESCRIPTION: This command builds the required dependencies for React DevTools from source. It should be run from the root of the repository.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_10

LANGUAGE: sh
CODE:
```
yarn build-for-devtools
```

----------------------------------------

TITLE: Original JavaScript Function Implementation
DESCRIPTION: This snippet shows the original implementation of a function 'foo' with conditional logic and object creation. It takes four parameters and returns an object with a modified property.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-nested-if-else-with-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  let x = someObj();
  if (a) {
    let z;
    if (b) {
      const w = someObj();
      z = w;
    } else {
      z = someObj();
    }
    const y = z;
    x = z;
  } else {
    x = someObj();
  }

  x.f = 1;
  return x;
}
```

----------------------------------------

TITLE: Simplified Component Logic - JavaScript
DESCRIPTION: This snippet shows a version of the React component with a simpler structure, focusing on a switch-case implementation that manages breaking out of the switch using labels. It also exports the FIXTURE_ENTRYPOINT similarly as the first snippet.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reverse-postorder.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  if (props.cond) {
    bb0: switch (props.test) {
      case 0: {
        break bb0;
      }
      case 1: {
        break bb0;
      }
      case 2: {
      }
      default: {
      }
    }
  } else {
    if (props.cond2) {
    }
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Implementing a conditional function with React test fixture (Input version)
DESCRIPTION: A simple JavaScript function that sets a variable based on a condition and returns it. Includes an export of FIXTURE_ENTRYPOINT that specifies test parameters for this function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-phi-primitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  let x;
  if (a) {
    x = 1;
  } else {
    x = 2;
  }

  let y = x;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [true, false],
  isComponent: false,
};
```

----------------------------------------

TITLE: Input: Allocating Primitive Expression as Dependency in React Component
DESCRIPTION: Original React component function that uses an allocating expression (bar(props).b) that produces a primitive value. This is a candidate for memoization by the React compiler to improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allocating-primitive-as-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// bar(props.b) is an allocating expression that produces a primitive, which means
// that Forget should memoize it.
// Correctness:
//   - y depends on either bar(props.b) or bar(props.b) + 1
function AllocatingPrimitiveAsDep(props) {
  let y = foo(bar(props).b + 1);
  return y;
}
```

----------------------------------------

TITLE: Implementing Error Handling in React Component
DESCRIPTION: This snippet shows a React component that attempts to push a prop value into an array, throws an input, and catches the error. It demonstrates basic error handling in React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-value-modified-in-catch-escaping.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {throwInput} = require('shared-runtime');

function Component(props) {
  let x;
  try {
    const y = [];
    y.push(props.y);
    throwInput(y);
  } catch (e) {
    e.push(props.e);
    x = e;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{y: 'foo', e: 'bar'}],
};
```

----------------------------------------

TITLE: Defining a Simple Component Structure in JavaScript
DESCRIPTION: This snippet defines a simple component function that takes an argument 'a', manipulates it, and returns a structured object. It also exports an entry point for use in a React application. The function modifies a property of the returned object based on an inner function call. Key parameters include 'a' which is the input to the component, and the structure returned contains nested properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-nested.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let y = {b: {a}};
  let x = function () {
    y.b.a = 2;
  };
  x();
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Defining React Component with Local State
DESCRIPTION: This snippet defines a React component that initializes a local variable 'x' through a function call. It demonstrates basic component structure and local state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/declare-reassign-variable-in-closure.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(p) {
  let x;
  const foo = () => {
    x = {};
  };
  foo();

  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Input React Component with Primitive Dependencies
DESCRIPTION: Original React component implementation showing how primitive values and expressions are handled as dependencies. Demonstrates usage of non-allocating expressions and property mutations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-as-dep-nested-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// props.b + 1 is an non-allocating expression, which means Forget can
// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1
// separately from props.b)
// Correctness:

import {identity, mutate, setProperty} from 'shared-runtime';

//   y depends on either props.b or props.b + 1
function PrimitiveAsDepNested(props) {
  let x = {};
  mutate(x);
  let y = identity(props.b + 1);
  setProperty(x, props.a);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: PrimitiveAsDepNested,
  params: [{a: 1, b: 2}],
  sequentialRenders: [
    // change b
    {a: 1, b: 3},
    // change b
    {a: 1, b: 4},
    // change a
    {a: 2, b: 4},
    // change a
    {a: 3, b: 4},
  ],
};
```

----------------------------------------

TITLE: Configuring ESLint 8+ with react-compiler plugin
DESCRIPTION: Configuration instructions for integrating eslint-plugin-react-compiler into ESLint 8+ using flat configuration method. This involves modifying the `eslint.config.mjs` file to include recommended settings.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_2

LANGUAGE: diff
CODE:
```
+ import reactCompiler from "eslint-plugin-react-compiler"
import react from "eslint-plugin-react"

export default [
    // Your existing config
    { ...pluginReact.configs.flat.recommended, settings: { react: { version: "detect" } } },
+   reactCompiler.configs.recommended    
]
```

----------------------------------------

TITLE: Legacy ESLint Configuration for react-compiler Plugin
DESCRIPTION: Instructions to add the react-compiler plugin to a legacy `.eslintrc` configuration file. It also shows how to set a rule using react-compiler in the rules section.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_3

LANGUAGE: json
CODE:
```
{
    "plugins": [
        "react-compiler"
    ]
}
```

----------------------------------------

TITLE: Compiled React Function with Memoization
DESCRIPTION: Compiler-optimized version of the function that implements caching logic to avoid redundant computations. Uses an array $ to store previous values and their computed results for memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call-fn-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(6);
  let t0;
  if ($[0] !== a) {
    t0 = makeObject(a);
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;

  const method = x.method;
  let t1;
  if ($[2] !== b || $[3] !== method || $[4] !== x) {
    t1 = method.call(x, b);
    $[2] = b;
    $[3] = method;
    $[4] = x;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const y = t1;
  return y;
}
```

----------------------------------------

TITLE: Testing useState Hook in a Class Component - JavaScript
DESCRIPTION: This snippet defines a class component that includes a method which calls the useState hook. The purpose is to demonstrate testing scenarios where the expectation is that the tests should fail, highlighting potential issues in the testing setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-ddeca9708b63.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed
(class {
  i() {
    useState();
  }
});

```

----------------------------------------

TITLE: Compiler-Optimized React Component Implementation
DESCRIPTION: The React compiler's optimized version of the component that uses caching to prevent unnecessary re-renders. It extracts the map callback to a separate function and uses the compiler-runtime to track dependencies and memoize intermediate values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlined-destructured-params.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.items) {
    t0 = props.items.map(_temp);
    $[0] = props.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = <>{t0}</>;
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
function _temp(t0) {
  const { id, name } = t0;
  return <Stringify key={id} name={name} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ items: [{ id: 1, name: "one" }] }],
};
```

----------------------------------------

TITLE: Defining React Component with Hoisted Function - JavaScript
DESCRIPTION: This snippet defines a React component 'Component' that attempts to render a nested function 'Foo'. The nested function is hoisted, which makes it available before its declaration in the code, but it remains unreachable from a control-flow standpoint. It highlights JavaScript's hoisting behavior in the context of function declarations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoisted-function-in-unreachable-code.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
function Component() {
  return <Foo />;

  // This is unreachable from a control-flow perspective, but it gets hoisted
  function Foo() {}
}

```

----------------------------------------

TITLE: Optimizing React Function with Compiler Runtime in JavaScript
DESCRIPTION: This snippet is an optimized variant of the useFoo function that uses react/compiler-runtime for performance improvements. It leverages caching and early returns to minimize repeated calculations when input data remains unchanged. Dependencies include 'react' and 'shared-runtime' packages. It operates on inputs with specific structure, using conditions to return early or construct arrays based on nested object properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/reduce-if-exhaustive-poisoned-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(11);
  const { input, inputHasAB, inputHasABC } = t0;
  let t1;
  let x;
  if ($[0] !== input.a || $[1] !== inputHasAB || $[2] !== inputHasABC) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      if (!inputHasABC) {
        let t2;
        if ($[5] !== input.a) {
          t2 = identity(input.a);
          $[5] = input.a;
          $[6] = t2;
        } else {
          t2 = $[6];
        }
        x.push(t2);
        if (!inputHasAB) {
          t1 = null;
          break bb0;
        }
        let t3;
        if ($[7] !== input.a.b) {
          t3 = identity(input.a.b);
          $[7] = input.a.b;
          $[8] = t3;
        } else {
          t3 = $[8];
        }
        x.push(t3);
      } else {
        let t2;
        if ($[9] !== input.a.b.c) {
          t2 = identity(input.a.b.c);
          $[9] = input.a.b.c;
          $[10] = t2;
        } else {
          t2 = $[10];
        }
        x.push(t2);
      }
    }
    $[0] = input.a;
    $[1] = inputHasAB;
    $[2] = inputHasABC;
    $[3] = t1;
    $[4] = x;
  } else {
    t1 = $[3];
    x = $[4];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { b: 1 }, inputHasAB: false, inputHasABC: false }],
};

```

----------------------------------------

TITLE: Component State Management with Shared Runtime and JavaScript
DESCRIPTION: Defines and executes a function `Component` that utilizes shared runtime for state mutation. Dependencies include `mutate` from 'shared-runtime'. It initializes component state, applies mutations, and exports an entry point with function parameters for testing. The function manipulates objects and tracks state changes based on `a`. Input is a parameter object. Output is a mutated state object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-computed-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function Component({a}) {
  let x = {a};
  let y = {};
  const f0 = function () {
    let a = y;
    a['x'] = x;
  };
  f0();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 2}],
  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],
};

```

----------------------------------------

TITLE: Rendering Component in React with Function Invocation
DESCRIPTION: This JavaScript snippet defines a React functional component that attempts to render the output of a function called 'notAhookTypedAsHook'. The component returns a JSX element containing the function's invocation result. Dependencies include the React library and a module named 'ReactCompilerTest'. Key input is the invocation of the function 'notAhookTypedAsHook', and output is its returned value inside a div element. The snippet's primary constraint is the expectation for 'notAhookTypedAsHook' to be a hook due to its naming convention, despite it not being one, causing a type configuration error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-nonhook-name-typed-as-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import {notAhookTypedAsHook} from 'ReactCompilerTest';

function Component() {
  return <div>{notAhookTypedAsHook()}</div>;
}
```

----------------------------------------

TITLE: Compiled React Component with react/compiler-runtime
DESCRIPTION: This snippet shows the compiled output of the React component using `react/compiler-runtime`. It imports `_c` from `react/compiler-runtime` and uses it to memoize the component's rendering. The `onClick` handler, named `_temp`, still modifies the global variables.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-reassignment-to-global-function-jsx-prop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  const onClick = _temp;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div onClick={onClick} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  someUnknownGlobal = true;
  moduleLocal = true;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: Validating Component Property in React
DESCRIPTION: A functional component that uses a switch statement to compare a prop value against a global property. Returns true if the value matches Global.Property, otherwise returns false.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-global-propertyload-case-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  switch (props.value) {
    case Global.Property: {
      return true;
    }
    default: {
      return false;
    }
  }
}
```

----------------------------------------

TITLE: Input React Component Definition
DESCRIPTION: Simple React functional component definition with a single div element and export configuration for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-function-with-implicit-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
const Test = () => <div />;

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [{}],
};
```

----------------------------------------

TITLE: Input React Component with Unary Operators
DESCRIPTION: Original React component implementation that tests various unary operators (+, -, void, delete, !, ~, typeof) on an object property. Returns an object containing the results of these operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unary-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let t = {t: a};
  let z = +t.t;
  let q = -t.t;
  let p = void t.t;
  let n = delete t.t;
  let m = !t.t;
  let e = ~t.t;
  let f = typeof t.t;
  return {z, p, q, n, m, e, f};
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Transformed JavaScript Component
DESCRIPTION: Transformed JavaScript code without Flow types, showing the compiled version with explicit parameter destructuring and value checking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-reorder.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
const foo = undefined;

function C(t0) {
  const { scope: t1 } = t0;
  const scope = t1 === undefined ? (foo ?? null) : t1;
  return scope;
}

export const FIXTURE_ENTRYPOINT = {
  fn: C,
  params: [{ scope: undefined }],
};
```

----------------------------------------

TITLE: Defining a Basic React Component Logic with Loop
DESCRIPTION: This snippet defines a basic React component that initializes a variable `x` based on the iteration count controlled by the `props.test` value. The component returns a reactive array containing `x`. The logic inside the loop decides the value of `x` based on the index `i`, capped at 10. The `props.test` value influences the loop execution, making `x` effectively reactive.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-do-while-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  let i = 0;
  do {
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }
    i++;
  } while (i < props.test);
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" variable `i`, whose value is affected by
  // `props.test` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {test: 12},
    {test: 12},
    {test: 1},
    {test: 1},
    {test: 12},
    {test: 1},
    {test: 12},
    {test: 1},
  ],
};
```

----------------------------------------

TITLE: React Compiler Optimized Implementation
DESCRIPTION: The React compiler-transformed version of the function that implements memoization using a cache array. It checks if the dependencies have changed before creating new objects, improving performance by reusing previous results when possible.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-literal-mutated-after-if-else.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c, d) {
  const $ = _c(3);
  let x;
  if ($[0] !== b || $[1] !== c) {
    if (someVal) {
      x = { b };
    } else {
      x = { c };
    }

    x.f = 1;
    $[0] = b;
    $[1] = c;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}
```

----------------------------------------

TITLE: Define React Component with Compiler Runtime
DESCRIPTION: This code defines a React component function `foo` that uses `react/compiler-runtime`. It initializes a variable `x` using a memoized value from `_c`. It includes a conditional statement that modifies `x` based on input `a`. The function then assigns `x` to `y` and returns `y`. The function is exported as part of `FIXTURE_ENTRYPOINT` with component metadata.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-non-empty-initializer.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let x = t0;
  if (a) {
    x = 1;
  }

  const y = x;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the React component with added memoization logic. It uses React's compiler runtime to optimize performance by caching computed values and only recalculating when dependencies change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-constant-string.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.value) {
    t0 = identity([props.value]);
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = { ["KeyName"]: t0 };
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const context = t1;
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Defining React Hook useFoo for State Management
DESCRIPTION: This code defines a React hook `useFoo` that utilizes `makeObject_Primitives` and `setPropertyByKey` to manage state based on input `value` and `cond`. It initializes an object `x`, conditionally sets the property 'a' on it, and creates an array `y` that may depend on `x.a.b`. Finally, it returns an array containing `y` and `x.a.b`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/hoist-deps-diff-ssa-instance.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeObject_Primitives, setPropertyByKey} from 'shared-runtime';

function useFoo({value, cond}) {
  let x: any = makeObject_Primitives();
  if (cond) {
    setPropertyByKey(x, 'a', null);
  } else {
    setPropertyByKey(x, 'a', {b: 2});
  }

  /**
   * y should take a dependency on `x`, not `x.a.b` here
   */
  const y = [];
  if (!cond) {
    y.push(x.a.b);
  }

  x = makeObject_Primitives();
  setPropertyByKey(x, 'a', {b: value});

  return [y, x.a.b];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{value: 3, cond: true}],
  sequentialRenders: [
    {value: 3, cond: true},
    {value: 3, cond: false},
  ],
};

```

----------------------------------------

TITLE: Implementing useMemo and useEffect in React Component - JavaScript
DESCRIPTION: This snippet defines a React component utilizing the `useMemo` hook to memoize a function that calls `someGlobal`, and the `useEffect` hook to invoke the memoized function. The component is designed to serve as a fixture entry point. It requires React's `useEffect` and custom `useMemo` implementation, and returns null indicating it's a non-visual component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-global-pruned.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect} from 'react';

function someGlobal() {}
function useFoo() {
  const fn = React.useMemo(
    () =>
      function () {
        someGlobal();
      },
    []
  );
  useEffect(() => {
    fn();
  }, [fn]);

  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Compiled Animated SVG Component with Reanimated
DESCRIPTION: This code represents the compiled version of the React component with Reanimated integration. It utilizes React's compiler runtime (`_c`) for optimization. The component memoizes the `animatedProps` and the resulting SVG element to prevent unnecessary re-renders. It relies on the `useAnimatedProps` hook for updating the SVG path.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reanimated-no-memo-arg.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableCustomTypeDefinitionForReanimated
import { useAnimatedProps } from "react-native-reanimated";
function Component() {
  const $ = _c(2);
  const radius = useSharedValue(50);

  const animatedProps = useAnimatedProps(() => {
    const path = `
    M 100, 100
    m -${radius.value}, 0
    a ${radius.value},${radius.value} 0 1,0 ${radius.value * 2},0
    a ${radius.value},${radius.value} 0 1,0 ${-radius.value * 2},0
    `;
    return { d: path };
  });
  let t0;
  if ($[0] !== animatedProps) {
    t0 = (
      <Svg>
        <AnimatedPath animatedProps={animatedProps} fill="black" />
      </Svg>
    );
    $[0] = animatedProps;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: React Component with Unmemoized Effect Dependencies
DESCRIPTION: A React component that demonstrates an issue with unmemoized effect dependencies. The component creates arrays that cannot be memoized properly and passes them to useEffect, which causes the React Compiler to reject optimizing the component to prevent infinite loops.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-memoized-effect-deps-invalidated-dep-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateMemoizedEffectDependencies
import {useHook} from 'shared-runtime';

function Component(props) {
  const x = [];
  useHook(); // intersperse a hook call to prevent memoization of x
  x.push(props.value);

  const y = [x];

  useEffect(() => {
    console.log(y);
  }, [y]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'sathya'}],
};
```

----------------------------------------

TITLE: Error Message from Blocklisted Import Validation
DESCRIPTION: This shows the error output that occurs when attempting to import from a blocklisted module. The validation tool catches the blocklisted import from 'DangerousImport' and provides a detailed error message pointing to the exact line and issue.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-blocklisted-imports.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  1 | // @validateBlocklistedImports(DangerousImport)
> 2 | import {foo} from 'DangerousImport';
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Todo: Bailing out due to blocklisted import. Import from module DangerousImport (2:2)
  3 | import {useIdentity} from 'shared-runtime';
  4 |
  5 | function useHook() {
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that renders a button with a deeplink ID. Takes props containing 'wat' path and 'itemID', with a nested function that creates an unused pathname variable.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-hoisting.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const wat = () => {
    const pathname = 'wat';
    pathname;
  };

  const pathname = props.wat;
  const deeplinkItemId = pathname ? props.itemID : null;

  return <button onClick={() => wat()}>{deeplinkItemId}</button>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{wat: '/dev/null', itemID: 42}],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the component using React's compiler-runtime. It implements memoization to cache object references and improve performance. The optimization is achieved through the use of Symbol.for('react.memo_cache_sentinel') for cache checking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-field-store.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = {};
    const q = {};
    x.t = q;
    $[0] = x;
  } else {
    x = $[0];
  }
  const z = x.t;
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime - JavaScript
DESCRIPTION: This snippet showcases a more optimized version of the React components using a custom compiler runtime to enhance performance. It manages state and memoization through an internal array, significantly improving the efficiency of rendering by reducing unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-kitchensink-import.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as React from "react";
import { useState, useMemo } from "react";

function Component(props) {
  const $ = _c(4);
  const [x] = useState(0);
  let t0;
  let t1;
  if ($[0] !== x) {
    t1 = calculateExpensiveNumber(x);
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const expensiveNumber = t0;
  let t2;
  if ($[2] !== expensiveNumber) {
    t2 = <div>{expensiveNumber}</div>;
    $[2] = expensiveNumber;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

function Component2(props) {
  const $ = _c(4);
  const [x] = useState(0);
  let t0;
  let t1;
  if ($[0] !== x) {
    t1 = calculateExpensiveNumber(x);
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const expensiveNumber = t0;
  let t2;
  if ($[2] !== expensiveNumber) {
    t2 = <div>{expensiveNumber}</div>;
    $[2] = expensiveNumber;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows the compiled version of the Component using React's compiler runtime. It includes memoization logic to optimize performance by caching the result of the default parameter check.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-array-with-unary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0) {
  const $ = _c(2);
  let t1;
  if ($[0] !== t0) {
    t1 = t0 === undefined ? [-1, 1] : t0;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Using Compiler Runtime in React Component (JavaScript)
DESCRIPTION: This snippet extends the previous component definition by incorporating the react/compiler-runtime for optimized rendering. It utilizes a signal-based state management approach to track state changes more efficiently and return the appropriate value based on the input prop. The code structure facilitates easy testing through the defined FIXTURE_ENTRYPOINT.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-init.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  for (const i = props.init; i < 10; ) {
    if (i === 0) {
      x = 0;
      break;
    } else {
      x = 1;
      break;
    }
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { init: 0 },
    { init: 0 },
    { init: 10 },
    { init: 10 },
    { init: 0 },
    { init: 10 },
    { init: 0 },
    { init: 10 },
  ],
};
```

----------------------------------------

TITLE: Defining React Test Fixture with Variables and Logic in JavaScript
DESCRIPTION: A JavaScript function 'foo' with variable declarations and conditional logic, along with a FIXTURE_ENTRYPOINT export for React testing. This fixture defines a function that is not a component and requires no parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-single-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  let y = 2;

  if (y) {
    let z = x + y;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Function Implementation: useFoo with Dynamic Lambda Optimization
DESCRIPTION: A React compiler runtime function that demonstrates safe array mapping with memoized lambda functions, preventing unnecessary property reads and maintaining performance
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo(t0) {
  const $ = _c(12);
  const { arr1, arr2 } = t0;
  let t1;
  if ($[0] !== arr1) {
    let t2;
    if ($[2] !== arr1[0]) {
      t2 = (e) => arr1[0].value + e.value;
      $[2] = arr1[0];
      $[3] = t2;
    } else {
      t2 = $[3];
    }
    t1 = arr1.map(t2);
    $[0] = arr1;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  let t2;
  if ($[4] !== arr1 || $[5] !== arr2) {
    let t3;
    if ($[7] !== arr2) {
      t3 = (e_0) => arr2[0].value + e_0.value;
      $[7] = arr2;
      $[8] = t3;
    } else {
      t3 = $[8];
    }
    t2 = arr1.map(t3);
    $[4] = arr1;
    $[5] = arr2;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const y = t2;
  let t3;
  if ($[9] !== x || $[10] !== y) {
    t3 = [x, y];
    $[9] = x;
    $[10] = y;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
}
```

----------------------------------------

TITLE: React Component Definition with SharedRuntime
DESCRIPTION: This code defines a React component `useFoo` that conditionally renders a `SharedRuntime.Text` component based on the `cond` prop.  It imports `SharedRuntime` and utilizes it within the component's logic. The `FIXTURE_ENTRYPOINT` object defines the component's entry point with predefined parameters for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-memberexpr-tag-conditional.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as SharedRuntime from 'shared-runtime';
function useFoo({cond}) {
  const MyLocal = SharedRuntime;
  if (cond) {
    return <MyLocal.Text value={4} />;
  } else {
    return null;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: true}],
};

```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiled version of the component showing both optimized and unoptimized paths, using React.forwardRef and implementing caching logic for optimized rendering based on the Forget feature flag.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/component-syntax-ref-gating.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag";
import { Stringify } from "shared-runtime";
import * as React from "react";

const Foo = React.forwardRef(Foo_withRef);
const isForgetEnabled_Fixtures_result = isForgetEnabled_Fixtures();
function Foo_withRef_optimized(_$$empty_props_placeholder$$, ref) {
  const $ = _c(2);
  let t0;
  if ($[0] !== ref) {
    t0 = <Stringify ref={ref} />;
    $[0] = ref;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function Foo_withRef_unoptimized(
  _$$empty_props_placeholder$$: $ReadOnly<{}>,
  ref: React.RefSetter<Controls>,
): React.Node {
  return <Stringify ref={ref} />;
}
function Foo_withRef(arg0, arg1) {
  if (isForgetEnabled_Fixtures_result) return Foo_withRef_optimized(arg0, arg1);
  else return Foo_withRef_unoptimized(arg0, arg1);
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval("(...args) => React.createElement(Foo, args)"),
  params: [{ ref: React.createRef() }],
};
```

----------------------------------------

TITLE: Optimized React Component after Compilation
DESCRIPTION: This snippet shows the optimized version of the Component after being processed by React's compiler. It includes memoization and conditional rendering optimizations to improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-param-assignment-pattern.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0, t1) {
  const $ = _c(5);
  const x = t0 === undefined ? "default" : t0;
  let t2;
  if ($[0] !== t1) {
    t2 = t1 === undefined ? [{}] : t1;
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const y = t2;
  let t3;
  if ($[2] !== x || $[3] !== y) {
    t3 = [x, y];
    $[2] = x;
    $[3] = y;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component and Fixture Definition
DESCRIPTION: Defines a React component function `t` that destructures the `props` array and returns the second element (indexed as `foo`). It also defines a constant `FIXTURE_ENTRYPOINT` that serves as a fixture configuration.  This configuration specifies the component function (`fn`), the expected parameters (`params`), and the component name (`isComponent`).
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-pattern-dce.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function t(props) {
  let [, foo, bar] = props;
  return foo;
}

export const FIXTURE_ENTRYPOINT = {
  fn: t,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the React component with memoization. It uses a cache to store computed values and avoids unnecessary re-computations. The code includes checks for a special Symbol to determine if cached values should be used.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/regexp-literal.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  let t0;
  let value;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const pattern = /foo/g;
    value = makeValue();

    t0 = pattern.test(value);
    $[0] = t0;
    $[1] = value;
  } else {
    t0 = $[0];
    value = $[1];
  }
  if (t0) {
    let t1;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = <div>{value}</div>;
      $[2] = t1;
    } else {
      t1 = $[2];
    }
    return t1;
  }
  let t1;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <div>Default</div>;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the 'Foo' component using memoization techniques. It uses a Symbol-based caching mechanism to store and reuse function and object references, potentially improving performance in subsequent renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-ref-callback-structure.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";

import { useRef } from "react";

function Foo(t0) {
  const $ = _c(4);
  const { cond, cond2 } = t0;
  const ref = useRef();
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => ref.current;
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const s = t1;
  if (cond) {
    let t2;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = [s];
      $[1] = t2;
    } else {
      t2 = $[1];
    }
    return t2;
  } else {
    if (cond2) {
      let t2;
      if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = { s };
        $[2] = t2;
      } else {
        t2 = $[2];
      }
      return t2;
    } else {
      let t2;
      if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = { s: [s] };
        $[3] = t2;
      } else {
        t2 = $[3];
      }
      return t2;
    }
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ cond: false, cond2: false }],
};
```

----------------------------------------

TITLE: Optimizing Rendering with State Management in React
DESCRIPTION: This code snippet enhances the previous `Foo` component by implementing state management for optimizing renders using React's compiler runtime. It utilizes a custom state array to track previous values of `a` and `x`, ensuring that the component re-renders only when necessary, which improves performance. The method checks if the new props or calculated values differ from the previous ones, facilitating targeted updates to the video list component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-aliased-not-added-to-dep-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender:false
function Foo(t0) {
  const $ = _c(4);
  const { a } = t0;
  const ref = useRef();
  const val = ref.current;
  let t1;
  if ($[0] !== a) {
    t1 = { a, val };
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  let t2;
  if ($[2] !== x) {
    t2 = <VideoList videos={x} />;
    $[2] = x;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: This code snippet represents the compiled version of the `List` component using React's compiler runtime (`_c`).  It demonstrates how the React compiler handles the rendering of list items, including memoization of the rendered items. The `_c` function likely handles memoization, preventing re-renders when the `items` prop hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-e675f0a672d8.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @skip
// Passed but should have failed

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function renderItem() {
  useState();
}

function List(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.items) {
    t0 = props.items.map(renderItem);
    $[0] = props.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

```

----------------------------------------

TITLE: Compiled React Memoization Test Implementation
DESCRIPTION: Shows the compiled version of the memoization test code with optimized caching logic. Implements memoization checks using Symbol.for('react.memo_cache_sentinel') and maintains cache references for props and rendered elements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-operator-method-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { ValidateMemoization } from "shared-runtime";
import { useMemo } from "react";
import * as React from "react";

const FooContext = React.createContext(null);
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Inner />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props.value) {
    t1 = <FooContext.Provider value={props.value}>{t0}</FooContext.Provider>;
    $[1] = props.value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Inner(props) {
  const $ = _c(7);
  const input = React.use(FooContext);
  let t0;
  let t1;
  if ($[0] !== input) {
    t1 = [input];
    $[0] = input;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const output = t0;
  let t2;
  if ($[2] !== input) {
    t2 = [input];
    $[2] = input;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== output || $[5] !== t2) {
    t3 = <ValidateMemoization inputs={t2} output={output} />;
    $[4] = output;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
  sequentialRenders: [
    { value: null },
    { value: 42 },
    { value: 42 },
    { value: null },
    { value: null },
    { value: 42 },
    { value: null },
    { value: 42 },
    { value: null },
  ],
};
```

----------------------------------------

TITLE: Defining a React function with conditional break and property access in JavaScript
DESCRIPTION: This JavaScript code defines a function `useFoo` that takes an `input` object and a `cond` boolean as parameters. It conditionally pushes a value `input.a.b` into an array `x`. A label and break statement are used for the conditional logic. It returns the array x.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-label.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({input, cond}) {
  const x = [];
  label: {
    if (cond) {
      break label;
    }
  }
  x.push(input.a.b); // unconditional
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component with Hook and Memoization
DESCRIPTION: This is the compiled version of the React component `SomeName`. It uses `react/compiler-runtime` and attempts to memoize the rendered fragment using a Symbol as a cache sentinel. The component also calls the custom hook `useSomeHook` and conditionally returns `null` if `anyConditionCanEvenBeFalse` is true.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-6949b255e7eb.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @skip
// Unsupported input

// Valid because the neither the conditions before or after the hook affect the hook call
// Failed prior to implementing BigInt because pathsFromStartToEnd and allPathsFromStartToEnd were too big and had rounding errors
const useSomeHook = () => {};

const SomeName = () => {
  const $ = _c(1);
  (FILLER ?? FILLER, FILLER) ?? FILLER;
  (FILLER ?? FILLER, FILLER) ?? FILLER;
  (FILLER ?? FILLER, FILLER) ?? FILLER;
  (FILLER ?? FILLER, FILLER) ?? FILLER;
  (FILLER ?? FILLER, FILLER) ?? FILLER;
  (FILLER ?? FILLER, FILLER) ?? FILLER;
  (FILLER ?? FILLER, FILLER) ?? FILLER;
  (FILLER ?? FILLER, FILLER) ?? FILLER;

  useSomeHook();
  if (anyConditionCanEvenBeFalse) {
    return null;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <React.Fragment>
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
        {FILLER ? FILLER : FILLER}
      </React.Fragment>
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
};

```

----------------------------------------

TITLE: Alternative Component Structure - JavaScript
DESCRIPTION: This snippet provides an alternative structure for the same component function. It replaces the inner function declaration with a named function '_temp' for better readability. The function assignment to 'x' and export of FIXTURE_ENTRYPOINT remain consistent.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-function-1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function component() {
  const x = _temp;
  return x;
}
function _temp(a) {
  a.foo();
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component with Interleaved Mutations
DESCRIPTION: This code defines a React component `Component` that initializes two arrays, `a` and `b`. The component then pushes `props.cond` into `b` and `false` into `a`. This interleaving causes `a` to become reactive. The code then demonstrates how the reactive nature of `a` affects downstream consumers, specifically how it influences the `do...while` loop and ultimately impacts the component's output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-do-while.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a and b are independent but their mutations are interleaved, so
  // they get grouped in a reactive scope. this means that a becomes
  // reactive since it will effectively re-evaluate based on a reactive
  // input
  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(false);

  // Downstream consumer of a, which initially seems non-reactive except
  // that a becomes reactive, per above
  const c = [a];

  let x = 0;
  do {
    x += 1;
  } while (c[0][0]);
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `c[0]` which becomes reactive via
  // being interleaved with `b`.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};

```

----------------------------------------

TITLE: Implementing useFoo with React Compiler Runtime
DESCRIPTION: This snippet implements the useFoo function utilizing React's compiler runtime for optimized evaluation. Similar to the previous snippet, it deals with handling conditional dependencies and optional chains. It imports identity from shared-runtime and utilizes a caching mechanism to avoid redundant calculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/edge-case-merge-uncond-optional-chain-and-cond.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

/**
 * Evaluator failure:
 * Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok) {}
 *   [[ (exception in render) TypeError: Cannot read properties of null (reading 'title_text') ]]
 *   Forget:
 *   (kind: ok) {}
 *   {}
 */
/**
 * Very contrived text fixture showing that it's technically incorrect to merge
 * a conditional dependency (e.g. dep.path in `cond ? dep.path : ...`) and an
 * unconditionally evaluated optional chain (`dep?.path`).
 *
 *
 * when screen is non-null, useFoo returns { title: null } or "(not null)"
 * when screen is null, useFoo throws
 */
function useFoo(t0) {
  const $ = _c(2);
  const { screen } = t0;
  let t1;
  if ($[0] !== screen) {
    t1 =
      screen?.title_text != null
        ? "(not null)"
        : identity({ title: screen.title_text });
    $[0] = screen;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ screen: null }],
  sequentialRenders: [{ screen: { title_bar: undefined } }, { screen: null }],
};
```

----------------------------------------

TITLE: Original React Component with Conditionals (Input)
DESCRIPTION: This code snippet shows the original React component before constant propagation.  It defines a series of variables (a, b, c, d, e) assigned values based on conditional checks. The component returns the final value of 'e', which is determined by the initial value of 'a'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequentially-constant-progagatable-if-test-conditions.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let a = 1;

  let b;
  if (a === 1) {
    b = true;
  } else {
    b = false;
  }

  let c;
  if (b) {
    c = 'hello';
  } else {
    c = null;
  }

  let d;
  if (c === 'hello') {
    d = 42.0;
  } else {
    d = 42.001;
  }

  let e;
  if (d === 42.0) {
    e = 'ok';
  } else {
    e = 'nope';
  }

  // should constant-propagate to "ok"
  return e;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the component function 'f' using React's compiler-runtime. It implements memoization to avoid unnecessary re-renders and computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutated-non-reactive-to-reactive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function f(a) {
  const $ = _c(4);
  let x;
  if ($[0] !== a) {
    x = { a };
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  let t0;
  if ($[2] !== x) {
    t0 = <div x={x} />;
    $[2] = x;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Transformed Increment/Decrement Operations in React
DESCRIPTION: This snippet shows the transformed version of the Foo component without Flow annotations. It replaces the increment and decrement operators with explicit addition and subtraction operations. The code maintains the same functionality as the input version but with more verbose and explicit operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/member-inc.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Foo() {
  const x = { a: 1 };
  x.a = x.a + 1;
  x.a = x.a - 1;
  console.log((x.a = x.a + 1));
  const t0 = x.a;
  x.a = t0 + 1;
  console.log(t0);

  console.log(x.a);
  const t1 = x.a;
  x.a = t1 + 1;
  const y = t1;
  console.log(y);
  console.log(x.a);

  const t2 = (x.a = x.a + 1).toString();
  const t3 = x.a;
  x.a = t3 + 1;
  console.log(t2, t3.toString(), x.a);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Implementing React Component with Conditional State Updates
DESCRIPTION: This snippet defines a React functional component that uses the useState hook to manage state. It includes a conditional state update based on props and a nested function that modifies state. The component returns the current state value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-set-state-in-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [x, setX] = useState(0);

  const foo = () => {
    setX(1);
  };

  if (props.cond) {
    setX(2);
    foo();
  }

  return x;
}
```

----------------------------------------

TITLE: Defining Function Foo with Conditionals and Object Mutation - JavaScript
DESCRIPTION: This snippet defines a function named 'Foo'. The function initializes a variable 'thing' and conditionally assigns it a value based on 'cond'. If 'CONST_TRUE' is true, it mutates 'thing' before returning. The function is designed to handle exceptions silently. Required dependencies include 'CONST_TRUE' and 'makeObject_Primitives' from 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-trycatch-nested-overlapping-range.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_TRUE, makeObject_Primitives} from 'shared-runtime';

function Foo() {
  try {
    let thing = null;
    if (cond) {
      thing = makeObject_Primitives();
    }
    if (CONST_TRUE) {
      mutate(thing);
    }
    return thing;
  } catch {}
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Enhancing useEffect with Custom Cache Logic - JavaScript
DESCRIPTION: This snippet enhances the earlier implementation by integrating a custom caching mechanism using `Symbol.for` to determine if a React memo cache sentinel is present. It substitutes the useMemo implementation with custom logic that assigns memoized functions and dependencies, further showcasing internal runtime operations. It maintains dependencies on React's `useEffect` and a runtime compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-global-pruned.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect } from "react";

function someGlobal() {}
function useFoo() {
  const $ = _c(2);
  let t0;
  t0 = _temp;
  const fn = t0;
  let t1;
  let t2;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      fn();
    };
    t2 = [fn];
    $[0] = t1;
    $[1] = t2;
  } else {
    t1 = $[0];
    t2 = $[1];
  }
  useEffect(t1, t2);
  return null;
}
function _temp() {
  someGlobal();
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: React Compiler Runtime Optimized Function
DESCRIPTION: Compiler-transformed version of the function with explicit memoization and dependency tracking using React compiler runtime
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar) {
    x = [];
    x.push(props.bar);
    $[0] = props.bar;
    $[1] = x;
  } else {
    x = $[1];
  }
  if (props.cond) {
    if ($[2] !== props.foo) {
      x = [];
      x.push(props.foo);
      $[2] = props.foo;
      $[3] = x;
    } else {
      x = $[3];
    }
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Flow Type Alias Compiled Code
DESCRIPTION: Compiled JavaScript output after Flow type stripping. Shows how type annotations are removed and the function is transformed into a more standard JavaScript format.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-variable-annotation_.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
type Bar = string;
function TypeAliasUsedAsAnnotation() {
  const fun = _temp;

  fun("hello, world");
}
function _temp(f) {
  const g = f;
  console.log(g);
}

export const FIXTURE_ENTRYPOINT = {
  fn: TypeAliasUsedAsAnnotation,
  params: [],
};
```

----------------------------------------

TITLE: Testing Changes with Browser Extension
DESCRIPTION: Build and test the React DevTools within a Chrome browser extension.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_6

LANGUAGE: sh
CODE:
```
cd <react-repo>
cd packages/react-devtools-extensions
yarn build:chrome:local && yarn test:chrome
```

----------------------------------------

TITLE: Defining a React Component in JavaScript
DESCRIPTION: This JavaScript snippet demonstrates a React component function that creates an object using the makeObject() function, deletes a value from the object using 'delete', and returns the result. Dependencies include React framework and the presence of a makeObject function. No inputs other than the use of props are specifically described, and the output is the result of the delete operation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-property-delete.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = makeObject();
  const y = delete x.value;
  return y;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiler-transformed version of the React component with explicit memoization cache handling using Symbol.for('react.memo_cache_sentinel'). Shows how the compiler implements memoization guarantees.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-call-second-function-which-captures-maybe-mutable-value-preserve-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees
import { useCallback } from "react";
import {
  identity,
  logValue,
  makeObject_Primitives,
  useHook,
} from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = makeObject_Primitives();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const object = t0;

  useHook();
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      logValue(object);
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const log = t1;
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      log();
    };
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const onClick = t2;

  identity(object);
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = <div onClick={onClick} />;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Fixture Entrypoint with Sequential Rendering Test Cases
DESCRIPTION: Defines a test fixture for the useFoo hook with multiple sequential render scenarios to validate behavior under different prop configurations, including null, undefined, and populated object scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/nested-optional-chains.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{
    prop1: null,
    prop2: null,
    prop3: null,
    prop4: null,
    prop5: null,
    prop6: null,
  }],
  sequentialRenders: [
    // Multiple test cases with different prop configurations
  ]
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Original implementation of a React component that performs a cumulative sum operation starting from an initial value and returns the result in an array. Includes a test fixture for component execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-with-assignment-as-update.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = props.init;
  for (let i = 0; i < 100; i = i + 1) {
    x += i;
  }
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{init: 0}],
};
```

----------------------------------------

TITLE: React Component Definition with Conditional Logic
DESCRIPTION: This snippet defines a React component named `Component` that conditionally returns an array based on the `props.cond` value. If `props.cond` is true, it returns an array containing `props.a`. Otherwise, it uses `makeArray` to create an array from `props.b`. The `FIXTURE_ENTRYPOINT` object defines the component and sequential render examples with different props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {makeArray} from 'shared-runtime';

function Component(props) {
  let x = [];
  if (props.cond) {
    x.push(props.a);
    // oops no memo!
    return x;
  } else {
    return makeArray(props.b);
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    // pattern 1
    {cond: true, a: 42},
    {cond: true, a: 42},
    // pattern 2
    {cond: false, b: 3.14},
    {cond: false, b: 3.14},
    // pattern 1
    {cond: true, a: 42},
    // pattern 2
    {cond: false, b: 3.14},
    // pattern 1
    {cond: true, a: 42},
    // pattern 2
    {cond: false, b: 3.14},
  ],
};

```

----------------------------------------

TITLE: Optimized React Component with Custom Compiler Runtime
DESCRIPTION: This snippet demonstrates an optimized version of the component using a custom compiler runtime. It implements memoization and conditional state updates for improved performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-array-assignment-to-context-var.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.value) {
    const [t0] = props.value;
    x = t0;
    const foo = () => {
      x = identity(props.value[0]);
    };

    foo();
    $[0] = props.value;
    $[1] = x;
  } else {
    x = $[1];
  }
  let t0;
  if ($[2] !== x) {
    t0 = { x };
    $[2] = x;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: [42] }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows the compiled version of the previous React component. It uses the React compiler runtime for memoization and pre-calculates the array of values. The Stringify component is used to render the pre-calculated array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-bit-ops.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <Stringify
        value={[
          123, 0, 123, 123, 123, 123, 123, 1, 122, 246, 61, 61, 9,
          15.588457268119896, 12.25, 3.3219970854839125, 0, 1.5, 1, 0.5,
        ]}
      />
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component Fixture with const Variables in JavaScript
DESCRIPTION: Similar to the previous snippet but uses const instead of let for variable declarations. Creates a function that manipulates arrays and exports a fixture configuration for a 'TodoAdd' component with specified parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-interleaved.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  const x = [];
  const y = [];
  x.push(a);
  y.push(b);
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Initial Function Implementation with Basic Logic
DESCRIPTION: A JavaScript function that processes input arrays and performs internal transformations with nested function invocation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function bar(a, b) {
  let x = [a, b];
  let y = {};
  let t = {};
  const f0 = function () {
    y = x[0][1];
    t = x[1][0];
  };
  f0();

  return y;
}
```

----------------------------------------

TITLE: Mutating Component with Shared-Runtime in JavaScript
DESCRIPTION: The snippet demonstrates a function named 'component' which utilizes the 'mutate' method from 'shared-runtime'. It initializes an object 'x' and a function scope variable 'y', modifies 'y' within an IIFE by attaching 'x', and then mutates 'y'. The exported 'FIXTURE_ENTRYPOINT' object aids in testing by specifying input parameters. No external dependencies apart from the 'shared-runtime' library are required. The function expects a single string parameter and returns a mutated object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-mutate-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {mutate} = require('shared-runtime');

function component(a) {
  let x = {a};
  let y = {};
  (function () {
    let a = y;
    a.x = x;
  })();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['foo'],
};

```

----------------------------------------

TITLE: Defining React Component with Dynamic Context (JavaScript)
DESCRIPTION: This snippet defines a React component that creates a dynamic context object based on input props. It uses the 'identity' function from a shared runtime and a constant SCALE factor.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

const SCALE = 2;

function Component(props) {
  const {key} = props;
  const context = {
    [key]: identity([props.value, SCALE]),
  };
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{key: 'Sathya', value: 'Compiler'}],
};
```

----------------------------------------

TITLE: React Component Function with Optimization in JavaScript
DESCRIPTION: This snippet enhances the 'foo' function with performance optimizations using 'react/compiler-runtime'. It keeps track of previous property values to reduce unnecessary operations. The snippet relies on React's runtime performance optimizations, expecting 'props' and reacting to changes effectively. The function's input is 'props' and it outputs the array 'x', managed by optimization checks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-via-destructuring.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar) {
    ({ x } = { x: [] });
    x.push(props.bar);
    $[0] = props.bar;
    $[1] = x;
  } else {
    x = $[1];
  }
  if (props.cond) {
    if ($[2] !== props.foo) {
      ({ x } = { x: [] });
      x.push(props.foo);
      $[2] = props.foo;
      $[3] = x;
    } else {
      x = $[3];
    }
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Mapping Error Codes with codes.json
DESCRIPTION: JSON file containing error code mappings used by Babel plugin and error decoder page. File is append-only and maintains a static mapping of error IDs to messages.
SOURCE: https://github.com/facebook/react/blob/main/scripts/error-codes/README.md#2025-04-21_snippet_0

LANGUAGE: json
CODE:
```
{
  "error_codes": [
    {
      "id": "error_unique_identifier",
      "message": "Original error message"
    }
  ]
}
```

----------------------------------------

TITLE: Original React Component Function
DESCRIPTION: A simple React function component named Foo that creates an object, passes it to a new instance of itself, mutates it, and returns it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/store-via-new.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {
  const x = {};
  const y = new Foo(x);
  y.mutate();
  return x;
}
```

----------------------------------------

TITLE: React Component Using Memoization with Import
DESCRIPTION: This snippet imports a memoization utility from 'react/compiler-runtime' and defines the function 'g' to handle a memoized value conditionally. It initializes the object 'x' based on a sentinel value. The function manipulates the object's properties and handles caching. It also exports the same 'FIXTURE_ENTRYPOINT' for usage in React, indicating it is not a component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations-complex-lvalue.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function g() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = { y: { z: 1 } };
    x.y.z = x.y.z + 1;
    x.y.z = x.y.z * 2;
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: g,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component with React compiler optimizations, including memoization using Symbol.for('react.memo_cache_sentinel'). Maintains the same functionality as the original component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-tagged-template-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { graphql } from "shared-runtime";

export function Component(t0) {
  const $ = _c(1);
  const fragment = graphql`
    fragment Foo on User {
      name
    }
  `;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <div>{fragment}</div>;
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 0, b: 0 }],
  sequentialRenders: [
    { a: 0, b: 0 },
    { a: 1, b: 0 },
    { a: 1, b: 1 },
    { a: 1, b: 2 },
    { a: 2, b: 2 },
    { a: 3, b: 2 },
    { a: 0, b: 0 },
  ],
};
```

----------------------------------------

TITLE: Modified Component Function in JavaScript
DESCRIPTION: An alternative JavaScript snippet for the Component function that uses a const declaration to define the local object. It still relies on an external function, mutate, to manipulate the object. The function takes a single parameter, c, and doesn't return any value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue852.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(c) {
  const x = { c };
  mutate(x);
}

```

----------------------------------------

TITLE: React Compiler-Optimized Version with Memoization
DESCRIPTION: Shows how React's compiler transforms the custom hook to include memoization. It adds dependency tracking to prevent unnecessary recreations of the callback object when inputs haven't changed, using React's compiler-runtime utilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/return-object-of-functions.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * Assume that only directly returned functions or JSX attributes are invoked.
 * Conservatively estimate that functions wrapped in objects or other containers
 * might never be called (and therefore their property loads are not hoistable).
 */
function useMakeCallback(t0) {
  const $ = _c(2);
  const { arr } = t0;
  let t1;
  if ($[0] !== arr) {
    t1 = { getElement0: () => arr[0].value, getElement1: () => arr[1].value };
    $[0] = arr;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{ arr: [1, 2] }],
  sequentialRenders: [{ arr: [1, 2] }, { arr: [] }],
};
```

----------------------------------------

TITLE: Integrating React Compiler Runtime in Component - JavaScript
DESCRIPTION: Enhances the basic React component by utilizing React's compiler-runtime to manage component rendering more efficiently. This version tracks state changes using an array `$` and avoids unnecessary re-renders with a mechanism to return previous render results if the state remains unchanged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-aliased-mutation-through-property-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const x = {};
  const y = [];
  x.y = y;
  x.y.push(props.input);

  let z = 0;
  if (x.y[0]) {
    z = 1;
  }
  let t0;
  if ($[0] !== z) {
    t0 = [z];
    $[0] = z;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { input: true },
    { input: true },
    { input: false },
    { input: false },
    { input: true },
    { input: false },
    { input: true },
    { input: false },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component with added memoization logic. Uses array-based caching to prevent unnecessary recalculations of makeArray and at() operations when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-array_.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, makeArray } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.id) {
    t0 = makeArray(props.id);
    $[0] = props.id;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = (t0: Array<number>);
  let t1;
  if ($[2] !== x) {
    t1 = x.at(0);
    $[2] = x;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const y = t1;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 42 }],
};
```

----------------------------------------

TITLE: React Component Transformed Output
DESCRIPTION: Transformed version of the component where the default parameter is extracted into a separate function and parameter handling is made explicit.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-with-reorderable-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(t0) {
  const x = t0 === undefined ? _temp : t0;
  return x;
}
function _temp() {
  return [-1, true, 42, "hello"];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization
DESCRIPTION: Transformed version of the hook using React's compiler runtime for memoization. Implements caching logic using Symbol.for() to optimize repeated executions of baz().
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-in-nested-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useBar(props) {
  const $ = _c(1);
  let z;
  if (props.a) {
    if (props.b) {
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = baz();
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      z = t0;
    }
  }
  return z;
}
```

----------------------------------------

TITLE: Custom Wall Implementation
DESCRIPTION: This JavaScript snippet demonstrates an advanced integration of React DevTools with a custom "wall" object, allowing for more control over communication between the frontend and backend.  It creates custom bridge and store objects, initializes DevTools with these custom objects, and then activates the backend with its own custom bridge. This is beneficial for environments where default message events are not sufficient.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_6

LANGUAGE: javascript
CODE:
```
import {
  activate as activateBackend,
  createBridge as createBackendBridge,
  initialize as initializeBackend,
} from 'react-devtools-inline/backend';
import {
  createBridge as createFrontendBridge,
  createStore,
  initialize as createDevTools,
} from 'react-devtools-inline/frontend';

// DevTools uses "message" events and window.postMessage() by default,
// but we can override this behavior by creating a custom "Wall" object.
// For example...
const wall = {
  _listeners: [],
  listen(listener) {
    wall._listeners.push(listener);
  },
  send(event, payload) {
    wall._listeners.forEach(listener => listener({event, payload}));
  },
};

// Initialize the DevTools backend before importing React (or any other packages that might import React).
initializeBackend(contentWindow);

// Prepare DevTools for rendering.
// To use the custom Wall we've created, we need to also create our own "Bridge" and "Store" objects.
const bridge = createFrontendBridge(contentWindow, wall);
const store = createStore(bridge);
const DevTools = createDevTools(contentWindow, { bridge, store });

// You can render DevTools now:
const root = createRoot(container);
root.render(<DevTools {...otherProps} />);

// Lastly, let the DevTools backend know that the frontend is ready.
// To use the custom Wall we've created, we need to also pass in the "Bridge".
activateBackend(contentWindow, {
  bridge: createBackendBridge(contentWindow, wall),
});
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiler-optimized version of the component that implements memoization using array-based caching to prevent unnecessary recalculations of values and dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-value-for-temporary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(listItem, thread) {
  const $ = _c(7);
  let t0;
  let t1;
  let t2;
  if ($[0] !== listItem || $[1] !== thread.threadType) {
    const isFoo = isFooThread(thread.threadType);
    t1 = useBar;
    t2 = listItem;
    t0 = getBadgeText(listItem, isFoo);
    $[0] = listItem;
    $[1] = thread.threadType;
    $[2] = t0;
    $[3] = t1;
    $[4] = t2;
  } else {
    t0 = $[2];
    t1 = $[3];
    t2 = $[4];
  }
  let t3;
  if ($[5] !== t0) {
    t3 = [t0];
    $[5] = t0;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const body = t1(t2, t3);
  return body;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization (JavaScript)
DESCRIPTION: This snippet shows the compiled version of the React component, incorporating memoization and compiler optimizations. It uses Symbol.for('react.memo_cache_sentinel') for caching and demonstrates how React's compiler transforms the original code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/frozen-after-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const a = t0;
  const b = a;
  useFreeze(a);
  foo(b);
  return b;
}

function useFreeze() {}
function foo(x) {}
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: Optimized version of the component using React compiler runtime for memoization. Implements value caching to prevent unnecessary array creation and push operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/debugger-memoized.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.value) {
    x = [];
    debugger;

    x.push(props.value);
    $[0] = props.value;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Initializing React Component with Memoized Dependency
DESCRIPTION: Demonstrates a React function component using useMemo with complex dependency inference and mutation. The example highlights potential challenges in automatic memoization optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-unrelated-mutation-in-depslist.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import {useMemo} from 'react';

function useFoo(input1) {
  const x = {};
  const y = [input1];
  const memoized = useMemo(() => {
    return [y];
  }, [(mutate(x), y)]);

  return [x, memoized];
}
```

----------------------------------------

TITLE: Managing State with React Compiler Runtime - React - JavaScript
DESCRIPTION: This snippet illustrates a more intricate implementation of a React component using the compiler runtime for managing internal state and property mutation. The component checks the values of props against an internal array and ensures efficient mutation and rendering using unique identifiers for state tracking. It is optimized to avoid unnecessary re-renders by checking dependencies before mutating state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-capture-ref-before-rename.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function Component(t0) {
  const $ = _c(7);
  const { a, b } = t0;
  let z;
  if ($[0] !== a) {
    z = { a };

    mutate(z);
    $[0] = a;
    $[1] = z;
  } else {
    z = $[1];
  }

  let y = z;
  let t1;
  if ($[2] !== b) {
    t1 = { b };
    $[2] = b;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const z_0 = t1;
  let t2;
  if ($[4] !== y || $[5] !== z_0) {
    t2 = { y, z: z_0 };
    $[4] = y;
    $[5] = z_0;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  y = t2;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 2, b: 3 }],
  sequentialRenders: [
    { a: 2, b: 3 },
    { a: 2, b: 3 },
    { a: 2, b: 4 },
    { a: 3, b: 4 },
  ],
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization
DESCRIPTION: This snippet showcases an optimized version of the React component using memoization techniques. It utilizes React's compiler runtime to cache and reuse computed values, improving performance for subsequent renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-capture-item-of-local-collection-mutate-later.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeObject_Primitives } from "shared-runtime";

function Component(props) {
  const $ = _c(1);
  let items;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    let lastItem = {};
    items = [makeObject_Primitives(), makeObject_Primitives()];
    for (const x of items) {
      lastItem = x;
    }
    if (lastItem != null) {
      lastItem.a = lastItem.a + 1;
    }
    $[0] = items;
  } else {
    items = $[0];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Compiled React useMemo Output
DESCRIPTION: Compiled version of the useMemo implementation showing how React internally handles memoization. It includes the compiler runtime and implements a caching mechanism using Symbol.for.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-scope-global.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";
import { CONST_STRING0 } from "shared-runtime";

// It's correct to infer a useMemo block has no reactive dependencies
function useFoo() {
  const $ = _c(1);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [CONST_STRING0];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  t0 = t1;
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: Defining and Invoking Functions with Closures in JavaScript
DESCRIPTION: This snippet defines a function 'foo' that utilizes closures by creating inner functions 'fn1' and 'fn2'. It demonstrates variable reassignment within these closures but raises concerns regarding React's rendering behavior when variables are reassigned post-render. The key parameters include 'x', which is being reassigned across closures, potentially leading to inconsistencies in state management. The expected output is an array containing results from invoking 'fn1' and the value of 'copy2'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.context-variable-only-chained-assign.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, invoke} from 'shared-runtime';

function foo() {
  let x = 2;
  const fn1 = () => {
    const copy1 = (x = 3);
    return identity(copy1);
  };
  const fn2 = () => {
    const copy2 = (x = 4);
    return [invoke(fn1), copy2, identity(copy2)];
  };
  return invoke(fn2);
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
};
```

----------------------------------------

TITLE: State Comparison and Conditional Rendering in React JavaScript
DESCRIPTION: The code features an advanced version of ComponentA and ComponentB in React JavaScript using a state array `_c` for efficient re-rendering by comparing current and previous props. State and mutation handling is carried out with array-based checks, ensuring re-renders only occur when necessary to improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-on-mutable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function ComponentA(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {
    const a = [];
    const b = [];
    if (b) {
      a.push(props.p0);
    }
    if (props.p1) {
      b.push(props.p2);
    }

    t0 = <Foo a={a} b={b} />;
    $[0] = props.p0;
    $[1] = props.p1;
    $[2] = props.p2;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

function ComponentB(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {
    const a = [];
    const b = [];
    if (mayMutate(b)) {
      a.push(props.p0);
    }
    if (props.p1) {
      b.push(props.p2);
    }

    t0 = <Foo a={a} b={b} />;
    $[0] = props.p0;
    $[1] = props.p1;
    $[2] = props.p2;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

function Foo() {}
function mayMutate() {}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet demonstrates the optimized version of the React component using memoization techniques. It imports a compiler runtime function and uses an array to store memoized values, reducing unnecessary computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/independent.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * Should produce 3 scopes:
 *
 * a: inputs=props.a, outputs=a
 *   a = compute(props.a);
 * b: inputs=props.b, outputs=b
 *   b = compute(props.b);
 * return: inputs=a, b outputs=return
 *   return = <Foo a={a} b={b} />
 */
function Component(props) {
  const $ = _c(7);
  let t0;
  if ($[0] !== props.a) {
    t0 = compute(props.a);
    $[0] = props.a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const a = t0;
  let t1;
  if ($[2] !== props.b) {
    t1 = compute(props.b);
    $[2] = props.b;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const b = t1;
  let t2;
  if ($[4] !== a || $[5] !== b) {
    t2 = <Foo a={a} b={b} />;
    $[4] = a;
    $[5] = b;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}

function compute() {}
function foo() {}
function Foo() {}
```

----------------------------------------

TITLE: Optimized React Component with Memoization (Compiled Output)
DESCRIPTION: The compiled version of the component that implements memoization using a cache array. It only recalculates values when inputs change, preserving the previous result when inputs remain the same, improving performance across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-reactive-capture.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { invoke } from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  const { value } = t0;
  let x;
  if ($[0] !== value) {
    x = null;
    const reassign = () => {
      x = value;
    };

    invoke(reassign);
    $[0] = value;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 2 }],
  sequentialRenders: [{ value: 2 }, { value: 4 }],
};
```

----------------------------------------

TITLE: Compiled Hook Implementation
DESCRIPTION: Compiled version of the hook using React compiler runtime with memoization. Uses an array $ for storing previous end value and result, implementing a caching mechanism for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unlabeled-break-within-label-loop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useHook(end) {
  const $ = _c(2);
  let log;
  if ($[0] !== end) {
    log = [];
    for (let i = 0; i < end + 1; i++) {
      log.push(`${i} @A`);
      if (i === end) {
        break;
      }

      log.push(`${i} @B`);

      log.push(`${i} @C`);
    }
    $[0] = end;
    $[1] = log;
  } else {
    log = $[1];
  }
  return log;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [1],
};
```

----------------------------------------

TITLE: Optimized Component State Management in JavaScript
DESCRIPTION: This JavaScript code snippet defines a more optimized version of a component, using a cache-like mechanism to store previous states and reduce unnecessary recalculations. It uses a compiler runtime to optimize component rendering decisions based on input changes. The function optimizes where possible by using a stored state when repeated inputs occur, reducing computational overhead. This approach is useful for performance-critical React applications where component rendering needs to be highly efficient.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-computed-mutate-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function component(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};

    const a_0 = y;
    a_0.x = x;

    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["foo"],
};

```

----------------------------------------

TITLE: Compiled React Component with react/compiler-runtime
DESCRIPTION: This is the compiled version of the React component using `react/compiler-runtime`. It utilizes the `_c` function for memoization and optimizes rendering by caching results based on props and dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/react-namespace.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const FooContext = React.createContext({ current: null });

function Component(props) {
  const $ = _c(5);
  React.useContext(FooContext);
  const ref = React.useRef();
  const [, setX] = React.useState(false);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setX(true);
      ref.current = true;
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onClick = t0;
  let t1;
  if ($[1] !== props.children) {
    t1 = React.cloneElement(props.children);
    $[1] = props.children;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t1) {
    t2 = <div onClick={onClick}>{t1}</div>;
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ children: <div>Hello</div> }],
};

```

----------------------------------------

TITLE: React Component Definition with State Loop
DESCRIPTION: This code defines a React component that increments variables x and y within a do-while loop based on the props.limit value. The value of 'y' is assigned to 'z' in each iteration, and the component returns an array containing the final value of 'z'. The component is designed to be used with React's sequential rendering mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-do-while-indirect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  let y = 0;
  let z = 0;
  do {
    x += 1;
    y += 1;
    z = y;
  } while (x < props.limit);
  return [z];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {limit: 10},
    {limit: 10},
    {limit: 1},
    {limit: 1},
    {limit: 10},
    {limit: 1},
    {limit: 10},
    {limit: 1},
  ],
};
```

----------------------------------------

TITLE: FBT Multiple Enum Error Message
DESCRIPTION: Error output showing that multiple fbt:enum tags within a single FBT component are not supported. The error occurs on line 7 of the code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-fbt-unknown-enum-value.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   5 |     <fbt desc="Description">
   6 |       <fbt:enum enum-range={['avalue1', 'avalue1']} value={a} />{' '}
>  7 |       <fbt:enum enum-range={['bvalue1', 'bvalue2']} value={b} />
     |        ^^^^^^^^ Todo: Support <fbt> tags with multiple <fbt:enum> values (7:7)
   8 |     </fbt>
   9 |   );
  10 | }
```

----------------------------------------

TITLE: React Component with useIdentity Hook (Duplicate)
DESCRIPTION: This code defines a React component named `useFoo` which leverages the `useIdentity` hook from the `shared-runtime` library. The component creates a Set, gets its values, and then returns the maximum value from the set. A fixture entry point is also exported for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-spread-argument-mutable-iterator.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useIdentity } from "shared-runtime";

function useFoo() {
  const it = new Set([1, 2]).values();
  useIdentity();
  return Math.max(...it);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}],
  sequentialRenders: [{}, {}],
};

```

----------------------------------------

TITLE: React Component with Error Handling
DESCRIPTION: Implementation of a React component that includes error handling with try-catch block. The component accepts props and returns the default value, with error fallback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-empty-try.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = props.default;
  try {
  } catch (e) {
    x = e;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{default: 42}],
};
```

----------------------------------------

TITLE: React Component with Primitive Dependency
DESCRIPTION: This code defines a React component, `PrimitiveAsDep`, that takes `props` as input, computes `props.b + 1`, and uses it as a dependency for the `foo` function. The function uses React's compiler runtime (`_c`) to memoize the result of `foo(props.b + 1)` based on `props.b`. It demonstrates how the compiler can optimize primitive dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-as-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// props.b + 1 is an non-allocating expression, which means Forget can
// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1
// separately from props.b)
// Correctness:
//   y depends on either props.b or props.b + 1
function PrimitiveAsDep(props) {
  let y = foo(props.b + 1);
  return y;
}

```

----------------------------------------

TITLE: React Memo Implementation with Compiler Runtime
DESCRIPTION: Implements React memo components with compiler runtime optimizations and feature flag conditional rendering. Includes caching mechanism using Symbol.for() checks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/reassigned-fnexpr-variable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
import * as React from "react";

/**
 * Test that the correct `Foo` is printed
 */
let Foo = isForgetEnabled_Fixtures()
  ? () => {
      const $ = _c(1);
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = <div>hello world 1!</div>;
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : () => <div>hello world 1!</div>;
const MemoOne = React.memo(Foo);
Foo = isForgetEnabled_Fixtures()
  ? () => {
      const $ = _c(1);
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = <div>hello world 2!</div>;
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : () => <div>hello world 2!</div>;
const MemoTwo = React.memo(Foo);

export const FIXTURE_ENTRYPOINT = {
  fn: () => {
    "use no memo";
    return (
      <>
        <MemoOne />
        <MemoTwo />
      </>
    );
  },
  params: [],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized Ref and Event Handling
DESCRIPTION: This snippet shows the compiled version of the React component, optimized for performance. It uses the React compiler runtime and implements memoization techniques to cache certain computations. The component's functionality remains the same as the input version, managing an input field's reference and providing a button to clear its value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-property-in-callback-passed-to-jsx-indirect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender
import { useRef } from "react";

function Component() {
  const $ = _c(2);
  const ref = useRef(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const setRef = () => {
      if (ref.current !== null) {
        ref.current.value = "";
      }
    };

    t0 = () => {
      setRef();
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onClick = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (
      <>
        <input ref={ref} />
        <button onClick={onClick} />
      </>
    );
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing React Component with Selective Memoization in JavaScript/JSX
DESCRIPTION: This snippet defines a React component named TestComponent that uses selective memoization. It demonstrates the use of 'use no memo' directive at the file level and 'use memo' directive within the component to control rendering optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/todo-function-scope-does-not-beat-module-scope-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
"use no memo";
function TestComponent({ x }) {
  "use memo";
  return <Button>{x}</Button>;
}
```

----------------------------------------

TITLE: React Component with Memo Directives
DESCRIPTION: A React component implementation that demonstrates the usage of memo directives. The component uses 'use no memo' at the module level while enabling memo within the component function. It renders a Button component with a dynamic value passed through props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-module-scope-usememo-function-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(all)
'use no memo';

function TestComponent({x}) {
  'use memo';
  return <Button>{x}</Button>;
}
```

----------------------------------------

TITLE: Initial Function Implementation with Nested Function
DESCRIPTION: A JavaScript function demonstrating nested function execution and object manipulation with dynamic array access
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-4-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function bar(a) {
  let x = [a];
  let y = {};
  (function () {
    y = x[0].a[1];
  })();

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [{a: ['val1', 'val2']}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing React Component with useMemo for Memoization Testing
DESCRIPTION: Original React component that uses useState and useMemo hooks to create and memoize an array. It includes multiple variable assignments and uses ValidateMemoization to verify the memoization is working correctly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/existing-variables-with-c-name.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo, useState} from 'react';
import {ValidateMemoization} from 'shared-runtime';

function Component(props) {
  const [state] = useState(0);
  // Test for conflicts with `c` import
  const c = state;
  const _c = c;
  const __c = _c;
  const c1 = __c;
  const $c = c1;
  const array = useMemo(() => [$c], [state]);
  return <ValidateMemoization inputs={[state]} output={array} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}, {}],
};
```

----------------------------------------

TITLE: Building and Running the React VectorWidget Example
DESCRIPTION: Commands to set up dependencies and build the React VectorWidget example project. Run these commands in the project directory, then open index.html in a browser to view the example.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/art/README.md#2025-04-21_snippet_0

LANGUAGE: bash
CODE:
```
yarn
yarn build
```

----------------------------------------

TITLE: Implementing useFoo Hook in React (Input Version)
DESCRIPTION: Original implementation of useFoo hook that creates and manipulates an array based on props. The function creates arrays, pushes values based on a condition property, and uses a shared utility function arrayPush.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-ternary-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {arrayPush} from 'shared-runtime';
function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond
    ? ((x = {}), (x = []), x.push(props.foo))
    : ((x = []), (x = []), x.push(props.bar));
  arrayPush(x, 4);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};
```

----------------------------------------

TITLE: Validating Ref Access During Render in React - JavaScript
DESCRIPTION: This code defines a functional component that attempts to access a ref's current value during the render cycle. It demonstrates the improper usage of React's `useRef` hook by modifying the `current` property, which is against React's rules and results in an error. The error indicates that accessing ref values in this way is invalid and directs to the React documentation for more information on proper usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-set-and-read-ref-during-render.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateRefAccessDuringRender
function Component(props) {
  const ref = useRef(null);
  ref.current = props.value;
  return ref.current;
}

```

----------------------------------------

TITLE: Code: Refactored Function Component with Temporary Function
DESCRIPTION: Modified version of the previous component using a separate temporary function for variable modification, maintaining similar functional structure
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-global-hook-arg.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
let b = 1;

export default function MyApp() {
  const fn = _temp;
  return useFoo(fn);
}
function _temp() {
  b = 2;
}

function useFoo(fn) {}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This code snippet shows the optimized version of the React component. It uses `react/compiler-runtime` to memoize the result of the `map` and `filter` operations based on the `props?.items` value. This prevents re-renders if the `items` prop hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-with-optional-property-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props?.items) {
    t0 = props?.items?.map?.(render)?.filter(Boolean) ?? [];
    $[0] = props?.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimized Component Function in React using Compiler Runtime in JavaScript
DESCRIPTION: Optimizes the Component function using React compiler runtime for efficient re-renders. It updates state variables based on input props changes, employing caching mechanism $ to minimize unnecessary updates. Dependencies include React and the compiler runtime (_c).
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-no-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0) {
  const $ = _c(5);
  const { a, b } = t0;
  let z;
  if ($[0] !== a || $[1] !== b) {
    z = { a };
    let t1;
    if ($[3] !== b) {
      t1 = { b };
      $[3] = b;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    const y = t1;
    const x = function () {
      z.a = 2;
      return Math.max(y.b, 0);
    };

    x();
    $[0] = a;
    $[1] = b;
    $[2] = z;
  } else {
    z = $[2];
  }
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 2, b: 3 }],
  sequentialRenders: [
    { a: 2, b: 3 },
    { a: 2, b: 3 },
    { a: 4, b: 3 },
    { a: 4, b: 5 },
  ],
};

```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime in JavaScript
DESCRIPTION: This snippet shows an optimized version of the 'useFoo' component using a compiler runtime. It introduces memoization to prevent unnecessary re-renders and object creations. The optimization uses an array '$' to store and retrieve memoized values based on input conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-jsx-and-break.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import {
  Stringify,
  makeObject_Primitives,
  mutate,
  mutateAndReturn,
} from "shared-runtime";

function useFoo(t0) {
  const $ = _c(3);
  const { data } = t0;
  let obj;
  let myDiv = null;
  bb0: if (data.cond) {
    if ($[0] !== data.cond1) {
      obj = makeObject_Primitives();
      if (data.cond1) {
        myDiv = <Stringify value={mutateAndReturn(obj)} />;
        break bb0;
      }

      mutate(obj);
      $[0] = data.cond1;
      $[1] = obj;
      $[2] = myDiv;
    } else {
      obj = $[1];
      myDiv = $[2];
    }
  }
  return myDiv;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ data: { cond: true, cond1: true } }],
  sequentialRenders: [
    { data: { cond: true, cond1: true } },
    { data: { cond: true, cond1: true } },
  ],
};
```

----------------------------------------

TITLE: Compiler-Optimized React Hook Implementation
DESCRIPTION: The React compiler-transformed version of the useMakeCallback hook with memoization optimizations. This optimized code uses the React compiler runtime to cache the callback function and returned object to prevent unnecessary re-renders and function recreations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditional-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState } from "react";
import { useIdentity } from "shared-runtime";

/**
 * Assume that conditionally called functions can be invoked and that their
 * property loads are hoistable to the function declaration site.
 */
function useMakeCallback(t0) {
  const $ = _c(4);
  const { obj } = t0;
  const [state, setState] = useState(0);
  let t1;
  if ($[0] !== obj.value) {
    t1 = () => {
      if (obj.value !== 0) {
        setState(obj.value);
      }
    };
    $[0] = obj.value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const cb = t1;

  useIdentity(null);
  if (state === 0) {
    cb();
  }
  let t2;
  if ($[2] !== cb) {
    t2 = { cb };
    $[2] = cb;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useMakeCallback,
  params: [{ obj: { value: 1 } }],
  sequentialRenders: [{ obj: { value: 1 } }, { obj: { value: 2 } }],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component implementation that creates an array and processes items with a conditional break statement. Includes fixture export for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-conditional-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  const x = [];
  for (const item of [1, 2]) {
    if (item === 1) {
      break;
    }
    x.push(item);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Compiler-Optimized Version with Memoization
DESCRIPTION: The compiler-transformed version of the hook, showing how React's compiler adds memoization. It uses a reactive scope with dependencies on 'other' and 'props' and only recalculates when those values change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-missing-case.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // props.a.b should NOT be added as a unconditional dependency to the reactive
// scope that produces x if it is not accessed in every path

import { identity } from "shared-runtime";

function useCondDepInSwitchMissingCase(props, other) {
  const $ = _c(3);
  let x;
  if ($[0] !== other || $[1] !== props) {
    x = {};
    bb0: switch (identity(other)) {
      case 1: {
        x.a = props.a.b;
        break bb0;
      }
      case 2: {
        x.b = 42;
        break bb0;
      }
      default: {
        x.c = props.a.b;
      }
    }
    $[0] = other;
    $[1] = props;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInSwitchMissingCase,
  params: [{ a: { b: 2 } }, 2],
};
```

----------------------------------------

TITLE: Implementing React Component with Invalid State Update in JavaScript
DESCRIPTION: This code snippet demonstrates a React functional component that incorrectly uses the useState hook. It unconditionally calls setState during render, which triggers an infinite loop error. The component also includes a for...of loop with conditional statements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-after-loop-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateNoSetStateInRender
function Component(props) {
  const [state, setState] = useState(false);
  for (const _ of props) {
    if (props.cond) {
      break;
    } else {
      continue;
    }
  }
  setState(true);
  return state;
}
```

----------------------------------------

TITLE: Defining React Component with Increment Operations (Input)
DESCRIPTION: This code defines a React component that receives props 'a', 'b', and 'c'. It then uses both pre-increment and post-increment operators on these props. The component returns an array containing the modified props and the results of the increment operations. The FIXTURE_ENTRYPOINT object provides the component, test parameters, and specifies that it is not a React Component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({a: a, b: [b], c: {c}}) {
  let d = a++;
  let e = ++a;
  let f = b--;
  let g = --b;
  let h = c++;
  let i = --c;
  return [a, b, c, d, e, f, g, h, i];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 2, b: [3], c: {c: 4}}],
  isComponent: false,
};

```

----------------------------------------

TITLE: Defining React Component with Stringify in JavaScript
DESCRIPTION: This snippet defines a React component that uses the Stringify function. It includes a callback function and passes props to the Stringify component. The FIXTURE_ENTRYPOINT is also defined for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component-inner-function-with-many-args.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';
function Component(props) {
  const cb = (x, y, z) => x + y + z;

  return <Stringify cb={cb} id={props.id} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{id: 0}],
};
```

----------------------------------------

TITLE: React Compiler Runtime Optimized Component
DESCRIPTION: Enhanced version of the component using React compiler runtime with memoization and conditional state updates. Implements caching and efficient state management using compiler-specific runtime hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-mutate-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { mutate } = require("shared-runtime");

function component(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};

    y.x = x;

    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}
```

----------------------------------------

TITLE: Running React Async Demo from NPM Version
DESCRIPTION: Instructions for installing dependencies and running the time-slicing demo using the npm version. This involves changing to the fixture directory, installing dependencies with yarn, and starting the application.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/concurrent/time-slicing/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
# 1: Install fixture dependencies
cd fixtures/unstable-async/time-slicing/
yarn

# 2: Run the app
yarn start
```

----------------------------------------

TITLE: Utilizing Fire Hook in React Component - JavaScript
DESCRIPTION: The snippet showcases a React component that imports 'fire' and 'useEffect' from 'react'. Within the component, 'foo' function logs the argument and props.bar. The useEffect hook is employed to trigger effects by calling 'fire' with 'foo'. The fire hook is used to manage side effects effectively in the component lifecycle.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/fire-and-autodeps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire @inferEffectDependencies
import {fire, useEffect} from 'react';

function Component(props) {
  const foo = arg => {
    console.log(arg, props.bar);
  };
  useEffect(() => {
    fire(foo(props));
  });

  return null;
}

```

----------------------------------------

TITLE: React Component Definition with fire function
DESCRIPTION: This code defines a React component that utilizes the `fire` function from the `react` library within a `useEffect` hook to trigger side effects. The component also uses `print` from `shared-runtime` to print the current value of a ref. It demonstrates how side effects were previously handled before the introduction of `useFire`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-ref-current-access.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableFire @panicThreshold(none)
import {fire} from 'react';
import {print} from 'shared-runtime';

component Component(prop1, ref) {
  const foo = () => {
    console.log(prop1);
  };
  useEffect(() => {
    fire(foo(prop1));
    bar();
    fire(foo());
  });

  print(ref.current);
  return null;
}

```

----------------------------------------

TITLE: Input Snippet: Nested Function React Component
DESCRIPTION: Initial implementation of a React component with nested functions and fire event handling, using useEffect and prop logging
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/deep-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire\nimport {fire} from 'react';\n\nfunction Component(props) {\n  const foo = props => {\n    console.log(props);\n  };\n  useEffect(() => {\n    function nested() {\n      function nestedAgain() {\n        function nestedThrice() {\n          fire(foo(props));\n        }\n        nestedThrice();\n      }\n      nestedAgain();\n    }\n    nested();\n  });\n\n  return null;\n}\n
```

----------------------------------------

TITLE: Managing Control Flow and Exports in JavaScript
DESCRIPTION: The snippet defines a JavaScript function 'foo' that uses labeled blocks to intelligently manage control flow based on function parameters. The function is exported via a constant 'FIXTURE_ENTRYPOINT' with specified parameters. This pattern facilitates clear block-level exits and modular exporting. Dependencies include ECMAScript 6 (ES6) or later for 'const' and 'export'. Inputs to 'foo' are three parameters 'a', 'b', and 'c', with an output determined by conditional logic. It requires 'TodoAdd' to implement the expected pattern.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inverted-if-else.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function foo(a, b, c) {
  let x = null;
  label: {
    if (a) {
      x = b;
      break label;
    }
    x = c;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

LANGUAGE: JavaScript
CODE:
```
function foo(a, b, c) {
  let x;
  bb0: {
    if (a) {
      x = b;
      break bb0;
    }

    x = c;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining a Basic Function in JavaScript
DESCRIPTION: This snippet defines a basic function `bar` that takes an argument, manipulates it, and returns a specific value. It initializes an array and an object, uses an immediately invoked function expression to set a property of the object, and returns the value from the array, which is indirectly modified.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-2-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function bar(a) {
  let x = [a];
  let y = {};
  (function () {
    y = x[0][1];
  })();

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [['val1', 'val2']],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing React Component with Conditional Reassignment - JavaScript
DESCRIPTION: This code snippet defines a React component that conditionally reassigns a variable based on a prop. It uses the 'invoke' function from a shared runtime and includes a fixture for testing with different prop values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reactive-explicit-control-flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {invoke} from 'shared-runtime';

function Component({shouldReassign}) {
  let x = null;
  const reassign = () => {
    if (shouldReassign) {
      x = 2;
    }
  };
  invoke(reassign);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{shouldReassign: true}],
  sequentialRenders: [{shouldReassign: false}, {shouldReassign: true}],
};
```

----------------------------------------

TITLE: Configuring eslint-plugin-react-hooks with flat config (ESLint 5.2.0)
DESCRIPTION: Setup for ESLint 5.2.0 using the flat config format with the recommended-latest configuration in eslint.config.js.
SOURCE: https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import * as reactHooks from 'eslint-plugin-react-hooks';

export default [
  // ...
  reactHooks.configs['recommended-latest'],
];
```

----------------------------------------

TITLE: Defining Conditional Function with Callback in JavaScript
DESCRIPTION: This snippet illustrates how to define a normal JavaScript function that includes a conditional check. If a specific condition is met, it executes another function. It can be used as a basic example of control flow in function calls.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-e5dd6caf4084.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because functions can call functions.
function normalFunctionWithConditionalFunction() {
  if (cond) {
    doSomething();
  }
}

```

----------------------------------------

TITLE: Defining React Component with Fire Usage - JavaScript
DESCRIPTION: This snippet defines a React functional component that uses the fire function to log the 'bar' prop and executes fire with the results of functions called with 'bar' and 'baz'. It utilizes useEffect for side-effect management and requires React and its hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/shared-hook-calls.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component({bar, baz}) {
  const foo = () => {
    console.log(bar);
  };
  useEffect(() => {
    fire(foo(bar));
    fire(baz(bar));
  });

  useEffect(() => {
    fire(foo(bar));
  });

  return null;
}

```

----------------------------------------

TITLE: Type Alias Parameter Annotation Transformed Output
DESCRIPTION: Transformed JavaScript code after TypeScript compilation. Shows how the type annotations are removed and the arrow function is converted to a regular function declaration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-annotation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
type Bar = string;
function TypeAliasUsedAsParamAnnotation() {
  const fun = _temp;

  fun("hello, world");
}
function _temp(f) {
  console.log(f);
}

export const FIXTURE_ENTRYPOINT = {
  fn: TypeAliasUsedAsParamAnnotation,
  params: [],
};
```

----------------------------------------

TITLE: Downloading Dependencies from CI for React DevTools
DESCRIPTION: Commands to download the latest experimental build from CI for React DevTools development, starting from the repository root.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/README.md#2025-04-21_snippet_2

LANGUAGE: sh
CODE:
```
cd scripts/release
yarn install
./download-experimental-build.js
```

----------------------------------------

TITLE: Defining Alternative React Component Implementation - JavaScript
DESCRIPTION: This snippet provides an alternative implementation of the 'Component', where 'x' is assigned a value in a slightly different manner using a comma operator. This variation produces the same output as the first snippet but showcases a different use of assignment and logical operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-conditional.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  ((x = 1), 1) && (x = 2);
  return x;
}
```

----------------------------------------

TITLE: Defining Original Function with Object Destructuring in JavaScript
DESCRIPTION: This snippet defines a function 'foo' that uses object destructuring to extract a value. It also exports a FIXTURE_ENTRYPOINT object containing the function and its metadata.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-string-literal-property-key.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const {data: t} = {data: 1};
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Refreshing dependencies after React rebuild
DESCRIPTION: Command to reinstall dependencies after making changes to React and rebuilding it.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/view-transition/README.md#2025-04-21_snippet_1

LANGUAGE: bash
CODE:
```
yarn
```

----------------------------------------

TITLE: Implementing Mutable State in React Component
DESCRIPTION: This snippet illustrates a basic React component in JavaScript that sets up initial mutable state and modifies it via a helper function 'mutate'. It highlights the creation of a stateful variable 'x', where its mutable range is modified based on the result from another function 'foo'. No external dependencies are required beyond standard React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-mutate-after-capture.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// x's mutable range should extend to `mutate(y)`

function Component(props) {
  let x = [42, {}];
  const idx = foo(props.b);
  let y = x.at(idx);
  mutate(y);

  return x;
}

```

----------------------------------------

TITLE: Optimizing React Component Compilation in JavaScript
DESCRIPTION: This snippet demonstrates an optimized version of the React component using a React compilation technique. It leverages a memoization strategy to cache and reuse the component structure, thus reducing render overhead. The '@compilationMode(infer)' directive aids the compiler in optimizing component compilation. Inputs and outputs are similar to the basic definition, with the added complexity of utilizing memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

```

----------------------------------------

TITLE: Creating an Object with Properties - JavaScript
DESCRIPTION: Defines a function 'makeObj' that creates and returns an array with an object storing a property 'b'. The function is intended to demonstrate object creation in JavaScript. It does not require any external dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue933-disjoint-set-infinite-loop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function makeObj() {
  'use no forget';
  const result = [];
  result.a = {b: 2};

  return result;
}
```

----------------------------------------

TITLE: Original React Function Implementation
DESCRIPTION: Simple conditional function that creates and mutates an object based on a condition parameter. Uses early returns and mutation patterns common in React hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scope-starts-within-cond.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

/**
 * Similar fixture to `align-scopes-nested-block-structure`, but
 * a simpler case.
 */
function useFoo(cond) {
  let s = null;
  if (cond) {
    s = {};
  } else {
    return null;
  }
  mutate(s);
  return s;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: Defining and Exporting a Component Function in JavaScript with React
DESCRIPTION: The function `component` defines a simple JavaScript object `z` with a property `a` passed as an argument. It uses nested functions to modify the object's property `b` and returns the updated object. The component is exported as part of `FIXTURE_ENTRYPOINT`. No dependencies beyond standard JavaScript syntax are required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture_mutate-across-fns.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a};
  const f0 = function () {
    const f1 = function () {
      z.b = 1;
    };
    f1();
  };
  f0();
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Error Message for Optional Chaining in Ternary Expression
DESCRIPTION: This snippet shows an error message indicating an unexpected terminal kind 'optional' for a ternary test block. The error occurs at line 5 where optional chaining is used in the useNoAlias function call.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-ternary.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  3 | function useFoo(props: {value: {x: string; y: string} | null}) {
  4 |   const value = props.value;
> 5 |   return useNoAlias(value?.x, value?.y) ? {} : null;
    |                               ^^^^^^^^ Todo: Unexpected terminal kind `optional` for ternary test block (5:5)
  6 | }
  7 |
  8 | export const FIXTURE_ENTRYPONT = {
```

----------------------------------------

TITLE: Defining Functional Component with Conditional Rendering in React
DESCRIPTION: This snippet demonstrates a more advanced React functional component named 'Test' that uses the 'react/compiler-runtime' to implement memoization. It conditionally renders a string within a div, allowing for efficient updates based on state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-bracket-in-text.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Test() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <div>
        {
          "If the string contains the string {pageNumber} it will be replaced by the page number."
        }
      </div>
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [],
};

```

----------------------------------------

TITLE: Defining React Components with Recursive Functions (Input)
DESCRIPTION: Original React component definitions with recursive callback functions that count down from 10 to 0. Component1 stores the result in a variable before returning, while Component directly returns the result of the recursive function call.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/recursive-function-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component1() {
  const x = callback(10);
  function callback(x) {
    if (x == 0) {
      return null;
    }
    return callback(x - 1);
  }
  return x;
}

function Component() {
  function callback(x) {
    if (x == 0) {
      return null;
    }
    return callback(x - 1);
  }
  return callback(10);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Demonstrating useMemo Memoization Preservation Issue in React
DESCRIPTION: This code demonstrates an edge case in React Compiler's memoization preservation. The function 'useFoo' creates an array 'x', modifies it, then uses it in a useMemo dependency array. The compiler flags this as an error because 'x' is considered potentially mutable after the useMemo call, even though its mutable range has ended.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-overlap-scopes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees:true
import {useMemo} from 'react';
import {arrayPush} from 'shared-runtime';

/**
 * Repro showing differences between mutable ranges and scope ranges.
 *
 * For useMemo dependency `x`:
 * - mutable range ends after the `arrayPush(x, b)` instruction
 * - scope range is extended due to MergeOverlappingScopes
 *
 * Since manual memo deps are guaranteed to be named (guaranteeing valid
 * codegen), it's correct to take a dependency on a dep *before* the end
 * of its scope (but after its mutable range ends).
 */

function useFoo(a, b) {
  const x = [];
  const y = [];
  arrayPush(x, b);
  const result = useMemo(() => {
    return [Math.max(x[1], a)];
  }, [a, x]);
  arrayPush(y, 3);
  return {result, y};
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [1, 2],
};
```

----------------------------------------

TITLE: Defining Test Fixture for React Component
DESCRIPTION: This snippet exports a FIXTURE_ENTRYPOINT object that includes the Component function and test parameters. It defines a series of sequential renders with different input arguments to test the component's behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arg: null}],
  sequentialRenders: [
    {arg: null},
    {arg: null},
    {arg: {items: {edges: null}}},
    {arg: {items: {edges: null}}},
    {arg: {items: {edges: {nodes: [1, 2, 'hello']}}}},
    {arg: {items: {edges: {nodes: [1, 2, 'hello']}}}},
  ],
};
```

----------------------------------------

TITLE: React Component Test Fixture Definition
DESCRIPTION: Test fixture configuration for a React component that defines the component function, parameters, and component identifier for testing purposes. The fixture is configured for a 'TodoAdd' component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-not-if-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [props.a];
  let y;
  if (x) {
    y = props.b;
  } else {
    y = props.c;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Fixture Entrypoint Configuration
DESCRIPTION: Defines test fixture configuration for the React component, specifying function, initial parameters, and a sequence of renders to test component behavior
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-arr-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{foo: 2, bar: 3}],
  sequentialRenders: [
    {foo: 2, bar: 3},
    {foo: 2, bar: 3},
    {foo: 2, bar: 4},
    {foo: 3, bar: 4},
  ],
};
```

----------------------------------------

TITLE: Original React Component with Conditional Object Mutation
DESCRIPTION: This snippet shows a React component that creates and mutates an object conditionally. It demonstrates a case where the compiler cannot safely hoist property reads as dependencies because x.a.b is accessed unconditionally before a potential mutation of x.a.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-access-in-mutable-range.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// x.a.b was accessed unconditionally within the mutable range of x.
// As a result, we cannot infer anything about whether `x` or `x.a`
// may be null. This means that it's not safe to hoist reads from x
// (e.g. take `x.a` or `x.a.b` as a dependency).

import {identity, makeObject_Primitives, setProperty} from 'shared-runtime';

function Component({cond, other}) {
  const x = makeObject_Primitives();
  setProperty(x, {b: 3, other}, 'a');
  identity(x.a.b);
  if (!cond) {
    x.a = null;
  }

  const y = [identity(cond) && x.a.b];
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: false}],
  sequentialRenders: [
    {cond: false},
    {cond: false},
    {cond: false, other: 8},
    {cond: true},
    {cond: true},
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Inferred Dependencies
DESCRIPTION: The compiled version of the component with automatically inferred dependencies for each effect hook. The compiler has added dependency tracking logic, memoization, and explicit dependency arrays based on the values referenced in each effect callback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/infer-effect-dependencies.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect, useRef } from "react";
import useEffectWrapper from "useEffectWrapper";

const moduleNonReactive = 0;

function Component(t0) {
  const $ = _c(12);
  const { foo, bar } = t0;

  const ref = useRef(0);
  let t1;
  if ($[0] !== foo) {
    t1 = { foo };
    $[0] = foo;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const localNonPrimitiveReactive = t1;
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = {};
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const localNonPrimitiveNonreactive = t2;
  let t3;
  if ($[3] !== bar || $[4] !== foo || $[5] !== localNonPrimitiveReactive) {
    t3 = () => {
      console.log(foo);
      console.log(bar);
      console.log(moduleNonReactive);
      console.log(0);
      console.log(globalValue);
      console.log(ref.current);
      console.log(localNonPrimitiveReactive);
      console.log(localNonPrimitiveNonreactive);
    };
    $[3] = bar;
    $[4] = foo;
    $[5] = localNonPrimitiveReactive;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  useEffect(t3, [
    foo,
    bar,
    localNonPrimitiveReactive,
    localNonPrimitiveNonreactive,
  ]);
  let t4;
  if ($[7] !== bar.baz || $[8] !== bar.qux) {
    t4 = () => {
      console.log(bar?.baz);
      console.log(bar.qux);
    };
    $[7] = bar.baz;
    $[8] = bar.qux;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  useEffect(t4, [bar.baz, bar.qux]);
  let t5;
  if ($[10] !== foo) {
    t5 = () => {
      console.log(foo);
    };
    $[10] = foo;
    $[11] = t5;
  } else {
    t5 = $[11];
  }
  useEffectWrapper(t5, [foo]);
}
```

----------------------------------------

TITLE: Compiled React Function with Memoization for Non-Overlapping Dependencies
DESCRIPTION: The compiled version of the test function with React compiler-runtime additions. It implements memoization that separately tracks each dependency path (props.a.c.x.y.z, props.a.x.y, and props.b) to avoid unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-nonoverlap-descendant.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Test that we can track non-overlapping dependencies separately.
// (not needed for correctness but for dependency granularity)
function TestNonOverlappingDescendantTracked(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.a.c.x.y.z || $[1] !== props.a.x.y || $[2] !== props.b) {
    x = {};
    x.a = props.a.x.y;
    x.b = props.b;
    x.c = props.a.c.x.y.z;
    $[0] = props.a.c.x.y.z;
    $[1] = props.a.x.y;
    $[2] = props.b;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: TestNonOverlappingDescendantTracked,
  params: [{ a: { x: {}, c: { x: { y: { z: 3 } } } } }],
};
```

----------------------------------------

TITLE: Function Component Definition in JavaScript
DESCRIPTION: Defines a basic function component in JavaScript that uses an instance of the Foo class. It initializes and returns a component object with internal properties. This snippet doesn't require specific dependencies other than the Foo class definition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-newexpression.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Foo() {}

function Component(props) {
  const a = [];
  const b = {};
  let c = new Foo(a, b);
  return c;
}

```

----------------------------------------

TITLE: Original Array Manipulation Function
DESCRIPTION: Input function that creates a nested array, accesses its first element using at(), and modifies it using set(). Includes an export of fixture configuration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations-complex-lvalue-array.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const a = [[1]];
  const first = a.at(0);
  first.set(0, 2);
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Function Implementation (Alternative Syntax)
DESCRIPTION: Alternative syntax version of the same React function component using double quotes for the 'use no memo' directive. Functionally identical to the previous snippet but with different string delimiter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-module-level.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
"use no memo";

export default function foo(x, y) {
  if (x) {
    return foo(false, y);
  }
  return [y * 10];
}
```

----------------------------------------

TITLE: Initializing React Component with useIdentity Hook
DESCRIPTION: Creates an array using makeArray function and attempts to spread its values into useIdentity hook. Contains a potential error related to spread syntax support.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hook-call-spreads-mutable-iterator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useIdentity} from 'shared-runtime';

function Component() {
  const items = makeArray(0, 1, 2, null, 4, false, 6);
  return useIdentity(...items.values());
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Direct Mutation and Variable Assignment in Component
DESCRIPTION: A simplified React component function performing mutation directly and declaring an undefined variable
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-return-empty.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function component(a) {
  let t0;

  mutate(a);
  t0 = undefined;
}
```

----------------------------------------

TITLE: Defining Hoisting Function with Closure in JavaScript
DESCRIPTION: This snippet defines a hoisting function that demonstrates variable scoping and closures in JavaScript. It initializes variables using `let` and `const`, ensuring expected results when called outside of temporal dead zones. The function returns the result of executing another function within its scope, utilizing inner function calls effectively.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-let-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function hoisting() {
  let qux = () => {
    let result;
    {
      result = foo();
    }
    return result;
  };
  let foo = () => {
    return bar + baz;
  };
  let bar = 3;
  const baz = 2;
  return qux(); // OK: called outside of TDZ
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining React Component with ESLint Rule Disable
DESCRIPTION: A simple React functional component with ESLint rules temporarily disabled, demonstrating potential compilation and optimization warnings
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.sketchy-code-rules-of-hooks.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/* eslint-disable react-hooks/rules-of-hooks */
function lowercasecomponent() {
  const x = [];
  return <div>{x}</div>;
}
/* eslint-enable react-hooks/rules-of-hooks */

export const FIXTURE_ENTRYPOINT = {
  fn: lowercasecomponent,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Hook inside Loop (Valid - Simplified)
DESCRIPTION: This JavaScript snippet demonstrates a simplified version of using `React.useLayoutEffect` inside a `for` loop.  The loop runs a fixed number of times, guaranteeing that the same hook is called during each render.  The `_temp` function is used as a placeholder for the effect.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-93dc5d5e538a.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// Valid because the loop doesn't change the order of hooks calls.
function RegressionTest() {
  const res = [];
  for (let i = 0; i !== 10 && true; ++i) {
    res.push(i);
  }

  React.useLayoutEffect(_temp);
}
function _temp() {}

```

----------------------------------------

TITLE: Transformed React Hook Test Code
DESCRIPTION: Transformed/compiled version of the hook test fixture with parameter destructuring moved into the function body. Maintains the same core functionality of returning a constant string based on the evaluation of an object with a getValue method.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-in-ternary-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import {
  createHookWrapper,
  CONST_STRING0,
  CONST_STRING1,
} from "shared-runtime";

function useHook(t0) {
  const { value } = t0;
  return {
    getValue() {
      return identity(value);
    },
  }
    ? CONST_STRING0
    : CONST_STRING1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ value: 0 }],
};
```

----------------------------------------

TITLE: Implementing Triple Nested While Loops with Incrementing Variable in React Test Fixture
DESCRIPTION: This code defines a JavaScript function 'foo' with triple nested while loops that increments a variable. The function is exported as a test fixture entrypoint with a 'TodoAdd' component parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-loops-no-reassign.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @xonly
function foo(a, b, c) {
  let x = 0;
  while (a) {
    while (b) {
      while (c) {
        x + 1;
      }
    }
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Using Memoization with Function Component in React
DESCRIPTION: This code snippet implements a more complex version of the 'Foo' component that incorporates memoization logic to store and retrieve a closure. It checks if a cache sentinel is present and conditionally assigns the function 'getX' to maintain local state. This demonstrates optimization in React by avoiding unnecessary re-computations, although initialization of 'x' must be handled correctly to avoid access issues. The snippet showcases the relationship between state management and performance in functional components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-invalid-tdz-let.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {
  const $ = _c(2);
  let getX;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    getX = () => x;
    console.log(getX());

    let x;
    x = 4;
    x = x + 5;
    $[0] = getX;
  } else {
    getX = $[0];
  }
  x;
  let t0;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Stringify getX={getX} shouldInvokeFns={true} />;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Implementing React Component with Hooks and Memoization
DESCRIPTION: This snippet defines a React component using hooks and memoization techniques. It demonstrates the use of useEffect, state management with objects, and conditional rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-memoize-array-with-capturing-map-after-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useEffect, useState} from 'react';
import {mutate} from 'shared-runtime';

function Component(props) {
  const x = [{...props.value}];
  useEffect(() => {}, []);
  const onClick = () => {
    console.log(x.length);
  };
  let y;
  return (
    <div onClick={onClick}>
      {x.map(item => {
        y = item;
        return <span key={item.id}>{item.text}</span>;
      })}
      {mutate(y)}
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: {id: 0, text: 'Hello!'}}],
  isComponent: true,
};
```

----------------------------------------

TITLE: Adding Root Node Operation in React DevTools
DESCRIPTION: Example showing the operation payload for adding a root node to the component tree. It includes the operation type, fiber id, element type, and various capability flags.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
[
  1, // add operation
  1, // fiber id
  11, // ElementTypeRoot
  1, // this root is StrictMode enabled
  1, // this root's renderer supports profiling
  1, // this root's renderer supports StrictMode
  1, // this root has owner metadata
]
```

----------------------------------------

TITLE: Managing State with React useState - JavaScript
DESCRIPTION: This JavaScript snippet demonstrates the use of an arrow function within a class to call React's useState hook. The code is commented to indicate that the test, which should have failed, unexpectedly passed. The snippet requires React and its hooks API as a dependency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-9c79feec4b9b.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @skip\n// Passed but should have failed\n\n(class {\n  h = () => {\n    useState();\n  };\n});
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This code defines a simple React component that returns the result of a method call on an object. The component is exported as `FIXTURE_ENTRYPOINT` with a set of parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let obj = {
    method() {
      return 1;
    },
  };
  return obj.method();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: 1}, {a: 2}, {b: 2}],
};

```

----------------------------------------

TITLE: React Function with No Memo Directive
DESCRIPTION: A React function component that implements recursive logic and array manipulation. The function takes two parameters (x, y), uses conditional recursion, and returns an array with a multiplied value. The 'use no memo' directive indicates that React's memoization should not be applied to this component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-module-level.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
'use no memo';

export default function foo(x, y) {
  if (x) {
    return foo(false, y);
  }
  return [y * 10];
}
```

----------------------------------------

TITLE: Optimizing React Components with Memoization
DESCRIPTION: This snippet shows optimized versions of ComponentA and ComponentB using memoization techniques. It uses a custom compiler runtime function _c to cache previous render results and avoid unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-on-mutable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function ComponentA(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {
    const a = [];
    const b = [];
    if (b) {
      a.push(props.p0);
    }
    if (props.p1) {
      b.push(props.p2);
    }

    t0 = <Foo a={a} b={b} />;
    $[0] = props.p0;
    $[1] = props.p1;
    $[2] = props.p2;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

function ComponentB(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {
    const a = [];
    const b = [];
    if (mayMutate(b)) {
      a.push(props.p0);
    }
    if (props.p1) {
      b.push(props.p2);
    }

    t0 = <Foo a={a} b={b} />;
    $[0] = props.p0;
    $[1] = props.p1;
    $[2] = props.p2;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

function Foo() {}
function mayMutate() {}
```

----------------------------------------

TITLE: Optimizing React Component State Management with Cached References
DESCRIPTION: This snippet shows an optimized method of managing component state by leveraging a custom cached array to track prop changes and computed results. It handles reactivity more efficiently, reducing unnecessary updates by checking and storing dependencies. Dependencies include React, a compiler runtime module, and the makeObject function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-independently-memoizeable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(10);
  let t0;
  let t1;
  if ($[0] !== props.a) {
    t1 = makeObject(props.a);
    $[0] = props.a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const a = t1;
  let t2;
  if ($[2] !== props.b) {
    t2 = makeObject(props.b);
    $[2] = props.b;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const b = t2;
  let t3;
  if ($[4] !== a || $[5] !== b) {
    t3 = [a, b];
    $[4] = a;
    $[5] = b;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  t0 = t3;
  const [a_0, b_0] = t0;
  let t4;
  if ($[7] !== a_0 || $[8] !== b_0) {
    t4 = [a_0, b_0];
    $[7] = a_0;
    $[8] = b_0;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  return t4;
}
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: Enhanced version of the component using React compiler runtime for memoization, with conditional state updates and object manipulation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-computed-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";
function Component(t0) {
  const $ = _c(2);
  const { a } = t0;
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};
    const f0 = function () {
      y.x = x;
    };

    f0();
    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This is the compiled version of the React component using React's compiler. The code memoizes the rendering based on `props.cond` and uses a compiler runtime helper `_c`. The `onChange` handler and conditional rendering logic are preserved within the memoized block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-function-expression-captures-value-later-frozen.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.cond) {
    const x = {};

    const onChange = (e) => {
      maybeMutate(x, e.target.value);
    };
    if (props.cond) {
    }

    onChange();
    t0 = <Foo value={x} />;
    $[0] = props.cond;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

```

----------------------------------------

TITLE: Compiled React Hook with Memoization
DESCRIPTION: The compiled version of the useFoo hook that implements React's memoization pattern. Uses Symbol.for to implement cache sentinel and maintains state across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(t0) {
  const $ = _c(3);
  const { cond } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {};
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let items = t1;
  bb0: if ($[1] !== cond) {
    if (cond) {
      items = [];
    } else {
      break bb0;
    }

    items.push(2);
    $[1] = cond;
    $[2] = items;
  } else {
    items = $[2];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: true }],
  sequentialRenders: [
    { cond: true },
    { cond: true },
    { cond: false },
    { cond: false },
    { cond: true },
  ],
};
```

----------------------------------------

TITLE: React Component with Delete Operation (JavaScript)
DESCRIPTION: Defines a React component that creates an object, attempts to delete a property based on the `props.value`, and returns the result of the delete operation (which will be a boolean). Assumes `makeObject()` is a globally available function that returns an object.  Note that deleting a non-existent property results in `true`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-computed-delete.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @debug
function Component(props) {
  const x = makeObject();
  const y = delete x[props.value];
  return y;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet shows the compiled version of the React component using React's compiler runtime. It implements memoization using Symbol.for('react.memo_cache_sentinel') to optimize performance by caching the computed value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-reassign-primitive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";

function Component() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = 40;

    const fn = function () {
      x = x + 1;
    };

    fn();
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Transformed React Component with memoization
DESCRIPTION: This code shows the transformed React component using `react/compiler-runtime` for optimization. It uses the `_c` function for memoization, checking the cache for existing rendered elements before re-rendering. This can potentially reduce re-renders and improve performance, especially for static content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-preserve-whitespace.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { StaticText1 } from "shared-runtime";

function Component() {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <StaticText1 />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <StaticText1 />;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (
      <div>
        Before text{t0}Middle text
        <StaticText1>
          Inner before text{t1}Inner middle text
          <StaticText1 />
          Inner after text
        </StaticText1>
        After text
      </div>
    );
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: Initializing React Hook with Optional Chaining and Complex Props
DESCRIPTION: A React hook function that demonstrates advanced optional chaining and dependency propagation with multiple nested prop types. Uses identity function and handles nested object access with optional chaining.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/nested-optional-chains.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({
  prop1,
  prop2,
  prop3,
  prop4,
  prop5,
  prop6,
}: {
  prop1: null | {value: number};
  prop2: null | {inner: {value: number}};
  prop3: null | {fn: (val: any) => NonNullable<object>};
  prop4: null | {inner: {value: number}};
  prop5: null | {fn: (val: any) => NonNullable<object>};
  prop6: null | {inner: {value: number}};
}) {
  const x = identity(prop1?.value)?.toString();
  const y = identity(prop2?.inner.value)?.toString();
  const z = prop3?.fn(prop4?.inner.value).toString();
  const zz = prop5?.fn(prop6?.inner.value)?.toString();
  return [x, y, z, zz];
}
```

----------------------------------------

TITLE: Extended Component Hook with Compiler Runtime - JavaScript
DESCRIPTION: This snippet extends the Component function by integrating with react/compiler-runtime, manipulating state using a memoization concept. It introduces a caching mechanism for function components using the memo_cache_sentinel symbol to store and reuse function references. Key dependencies include react/compiler-runtime and a custom useFoo hook. Inputs include component props, and outputs are adjustments to the ref value based on cached state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-ref-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useRef } from "react";

function Component(props) {
  const $ = _c(1);
  const ref = useRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      ref.current = 42;
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useFoo(t0);
}

function useFoo(x) {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: Memoizing Component Initialization in React
DESCRIPTION: Enhances the Component function using React's internal memoization cache to avoid repeated initialization of object instances. Utilizes the '_c' function imported from 'react/compiler-runtime' to cache the component state, increasing efficiency by only initializing once per component lifecycle.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-newexpression.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {}

function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = [];
    const b = {};
    t0 = new Foo(a, b);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const c = t0;
  return c;
}

```

----------------------------------------

TITLE: Compiled React Components with Optimization Logic
DESCRIPTION: This snippet shows the compiled version of the React components, including the optimization logic for the 'use forget' directive. It uses the React compiler runtime and a feature flag to conditionally apply the optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating @compilationMode(annotation)
const Bar = isForgetEnabled_Fixtures()
  ? function Bar(props) {
      "use forget";
      const $ = _c(2);
      let t0;
      if ($[0] !== props.bar) {
        t0 = <div>{props.bar}</div>;
        $[0] = props.bar;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : function Bar(props) {
      "use forget";
      return <div>{props.bar}</div>;
    };

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}
const Foo = isForgetEnabled_Fixtures()
  ? function Foo(props) {
      "use forget";
      const $ = _c(2);
      let t0;
      if ($[0] !== props.bar) {
        t0 = <Foo>{props.bar}</Foo>;
        $[0] = props.bar;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : function Foo(props) {
      "use forget";
      return <Foo>{props.bar}</Foo>;
    };

export const FIXTURE_ENTRYPOINT = {
  fn: eval("Bar"),
  params: [{ bar: 2 }],
};
```

----------------------------------------

TITLE: React-Specific Object Mutation with Caching (JavaScript)
DESCRIPTION: This snippet illustrates a React-specific pattern for object mutation, using a caching mechanism with a compiler runtime. It checks conditional parameters against cached values to optimize performance. Key parameters include 'a', the condition, and '$', the cache. Expected outputs are object 'x' with conditional properties. It assumes React and its compiler-runtime as dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate-inside-if.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a) {
  const $ = _c(3);
  let x;
  if ($[0] !== a) {
    x = {};
    if (a) {
      const y = {};
      x.y = y;
      mutate(y);
    } else {
      let t0;
      if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = {};
        $[2] = t0;
      } else {
        t0 = $[2];
      }
      const z = t0;
      x.z = z;
    }
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

```

----------------------------------------

TITLE: Creating Nested Objects in React Component
DESCRIPTION: A simple component function that creates nested objects and arrays. It initializes an empty array, creates object references, and returns a nested structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-nested-member-path.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component() {
  let z = [];
  let y = {};
  y.z = z;
  let x = {};
  x.y = y;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component with Compiler Runtime Fire Handling
DESCRIPTION: Refined implementation using useFire for more explicit fire event management and prop deconstruction
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-preserve-memo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useFire } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableFire @panicThreshold(none)
import { fire } from "react";
import { sum } from "shared-runtime";

function Component(t0) {
  const { prop1, bar } = t0;
  const foo = () => {
    console.log(prop1);
  };
  const t1 = useFire(foo);
  const t2 = useFire(bar);

  useEffect(() => {
    t1(prop1);
    t1();
    t2();
  });
  return useMemo(() => sum(bar), []);
}
```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: Transformed version of the React component using React compiler runtime, with memoization and cached effect handling
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/valid-setState-in-useEffect-listener-transitive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateNoSetStateInPassiveEffects
import { useEffect, useState } from "react";

function Component() {
  const $ = _c(1);
  const [state, setState] = useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      const f = () => {
        setState();
      };

      setTimeout(() => f(), 10);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(t0);
  return state;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Compiler Runtime Fixture
DESCRIPTION: React compiler-transformed version of the component with explicit memoization and early return handling using runtime cache and sentinels
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-no-declarations-reassignments-dependencies.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

let ENABLE_FEATURE = false;

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const x = [];
      if (ENABLE_FEATURE) {
        x.push(42);
        t0 = x;
        break bb0;
      } else {
        console.log("fallthrough");
      }
    }
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  let t1;
  if ($[1] !== props.a) {
    t1 = makeArray(props.a);
    $[1] = props.a;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
```

----------------------------------------

TITLE: Compiled React Component with Optimization in JavaScript
DESCRIPTION: This is a compiled and optimized version of the React component. It includes memoization for props and uses symbols for early returns. The core functionality remains the same as the original component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-value-modified-in-catch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { throwInput } = require("shared-runtime");

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.e || $[1] !== props.y) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      try {
        const y = [];
        y.push(props.y);
        throwInput(y);
      } catch (t1) {
        const e = t1;
        e.push(props.e);
        t0 = e;
        break bb0;
      }
    }
    $[0] = props.e;
    $[1] = props.y;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ y: "foo", e: "bar" }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component with React's compiler runtime optimizations. Includes memoization logic to prevent unnecessary recalculations of values using an internal cache array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-4.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0) {
  const $ = _c(4);
  let [b] = t0;
  const f = b--;
  const g = --b;
  let t1;
  if ($[0] !== b || $[1] !== f || $[2] !== g) {
    t1 = [b, f, g];
    $[0] = b;
    $[1] = f;
    $[2] = g;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [[3]],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiled version of the component that includes React runtime optimization. Implements caching mechanism using an array to store previous values and avoid unnecessary object creation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unary-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(8);
  const t = { t: a };
  const z = +t.t;
  const q = -t.t;
  const p = void t.t;
  const n = delete t.t;
  const m = !t.t;
  const e = ~t.t;
  const f = typeof t.t;
  let t0;
  if (
    $[0] !== e ||
    $[1] !== f ||
    $[2] !== m ||
    $[3] !== n ||
    $[4] !== p ||
    $[5] !== q ||
    $[6] !== z
  ) {
    t0 = { z, p, q, n, m, e, f };
    $[0] = e;
    $[1] = f;
    $[2] = m;
    $[3] = n;
    $[4] = p;
    $[5] = q;
    $[6] = z;
    $[7] = t0;
  } else {
    t0 = $[7];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component that implements memoization using React's compiler runtime. It caches values between renders, tracks dependency changes, and only recalculates when needed. The compilation adds optimizations to prevent unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-non-final-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(8);
  let t0;
  let y;
  if ($[0] !== props.p0 || $[1] !== props.p2) {
    const x = [];
    bb0: switch (props.p0) {
      case 1: {
        break bb0;
      }
      case true: {
        x.push(props.p2);
        let t1;
        if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
          t1 = [];
          $[4] = t1;
        } else {
          t1 = $[4];
        }
        y = t1;
      }
      default: {
        break bb0;
      }
      case false: {
        y = x;
      }
    }

    t0 = <Component data={x} />;
    $[0] = props.p0;
    $[1] = props.p2;
    $[2] = t0;
    $[3] = y;
  } else {
    t0 = $[2];
    y = $[3];
  }
  const child = t0;
  y.push(props.p4);
  let t1;
  if ($[5] !== child || $[6] !== y) {
    t1 = <Component data={y}>{child}</Component>;
    $[5] = child;
    $[6] = y;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  return t1;
}
```

----------------------------------------

TITLE: Getting First Child After Finding Root in React DevTools
DESCRIPTION: After finding the root containing the element at index N, this code gets the first child ID to begin traversal, skipping the root itself since roots aren't displayed in the component tree.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_10

LANGUAGE: javascript
CODE:
```
const firstChildID = root.children[0];
```

----------------------------------------

TITLE: React Component Definition with Mutation
DESCRIPTION: This code defines a React component that utilizes object mutation within a computed object key.  The `mutate` function, presumably from a shared runtime, modifies the `key` object. The `identity` function appears to preserve a reference. The component returns a context object and the mutated key object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-object-expression-computed-key-modified-during-after-construction-hoisted-sequence-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate} from 'shared-runtime';

/**
 * Bug: copy of error.todo-object-expression-computed-key-modified-during-after-construction-sequence-expr
 * with the mutation hoisted to a named variable instead of being directly
 * inlined into the Object key.
 *
 * Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok) [{"[object Object]":[42]},{"wat0":"joe","wat1":"joe"}]
 *   [{"[object Object]":[42]},{"wat0":"joe","wat1":"joe"}]
 *   Forget:
 *   (kind: ok) [{"[object Object]":[42]},{"wat0":"joe","wat1":"joe"}]
 *   [{"[object Object]":[42]},{"wat0":"joe","wat1":"joe","wat2":"joe"}]
 */
function Component(props) {
  const key = {};
  const tmp = (mutate(key), key);
  const context = {
    // Here, `tmp` is frozen (as it's inferred to be a primitive/string)
    [tmp]: identity([props.value]),
  };
  mutate(key);
  return [context, key];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
  sequentialRenders: [{value: 42}, {value: 42}],
};

```

----------------------------------------

TITLE: Advanced Ref Management in React Component
DESCRIPTION: This snippet enhances the custom ref usage by integrating it with a more complex logic structure using _c from the 'react/compiler-runtime'. It tracks whether the ref has changed and executes a function to print the ref when it does, demonstrating a pattern for conditional side effects based on ref changes in functional components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/helper-nonreactive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect, useRef } from "react";
function useCustomRef() {
  const ref = useRef();
  return ref;
}

function NonReactiveWrapper() {
  const $ = _c(2);
  const ref = useCustomRef();
  let t0;
  if ($[0] !== ref) {
    t0 = () => {
      print(ref);
    };
    $[0] = ref;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  useEffect(t0, [ref]);
}
```

----------------------------------------

TITLE: Output: Compiler-Optimized React Component Implementation with Memoization
DESCRIPTION: The compiler-transformed version of the component with React memoization. It uses the React compiler runtime to cache computed values and object references, reducing unnecessary re-renders and object allocations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/hoist-deps-diff-ssa-instance1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, shallowCopy, Stringify, useIdentity } from "shared-runtime";

type HasA = { kind: "hasA"; a: { value: number } };
type HasC = { kind: "hasC"; c: { value: number } };
function Foo(t0) {
  const $ = _c(7);
  const { cond } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = shallowCopy({ kind: "hasA", a: { value: 2 } });
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let x = t1;

  Math.max(x.a.value, 2);
  if (cond) {
    let t2;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = shallowCopy({ kind: "hasC", c: { value: 3 } });
      $[1] = t2;
    } else {
      t2 = $[1];
    }
    x = t2;
  }
  let t2;
  if ($[2] !== cond || $[3] !== x) {
    t2 = !cond && [(x as HasA).a.value + 2];
    $[2] = cond;
    $[3] = x;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== t2) {
    t3 = <Stringify val={t2} />;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ cond: false }],
  sequentialRenders: [{ cond: false }, { cond: true }],
};
```

----------------------------------------

TITLE: Defining a Function and Exporting with Const in JavaScript
DESCRIPTION: Similar to the previous snippet, this one defines the same function 'foo', but this time it uses 'const' for the array declarations. It also exports the same constant object with the function reference and metadata, showcasing a small variation in variable declaration style.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-shadowed.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b) {\n  const x = [];\n  const y = [];\n  y.push(b);\n  x.push(a);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ["TodoAdd"],\n  isComponent: "TodoAdd",\n};\n
```

----------------------------------------

TITLE: React Component with Mutator (Compiled Code)
DESCRIPTION: This is the compiled version of the React component, optimized using `react/compiler-runtime`. It memoizes the `poke` and `hide` functions and the rendering of the `Foo` component to avoid unnecessary re-creations and re-renders. It uses a state array `$` to store memoized values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-member-expr-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(t0) {
  const $ = _c(7);
  const { mutator } = t0;
  let t1;
  if ($[0] !== mutator) {
    t1 = () => {
      mutator.poke();
    };
    $[0] = mutator;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const poke = t1;
  let t2;
  if ($[2] !== mutator.user) {
    t2 = () => {
      mutator.user.hide();
    };
    $[2] = mutator.user;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const hide = t2;
  let t3;
  if ($[4] !== hide || $[5] !== poke) {
    t3 = <Foo poke={poke} hide={hide} />;
    $[4] = hide;
    $[5] = poke;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}
```

----------------------------------------

TITLE: Defining React Component with Mutable State
DESCRIPTION: This snippet defines a React component that uses mutable state and a closure. It imports a 'mutate' function and exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-reference-changes-type.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';
function Component({a}) {
  let x = {a};
  let y = 1;
  (function () {
    y = x;
  })();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 2}],
  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with added memoization optimization. Uses Symbol.for to implement caching mechanism for the ref access function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/return-ref-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";

import { useRef } from "react";

function Foo() {
  const $ = _c(1);
  const ref = useRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => ref.current;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const s = t0;
  return s;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Building the React Chrome Extension from Command Line
DESCRIPTION: Commands for building the React Chrome extension from either the extension directory or the root directory.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/chrome/README.md#2025-04-21_snippet_0

LANGUAGE: bash
CODE:
```
node build
```

LANGUAGE: bash
CODE:
```
yarn run build:extension:chrome
```

----------------------------------------

TITLE: Initializing React Component with Computed Property Destructuring
DESCRIPTION: A React component that dynamically extracts a property from props using a computed property name. The component imports the identity function and defines a SCALE constant, then destructures a prop based on a dynamically determined name.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.error.object-pattern-computed-key.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

const SCALE = 2;
function Component(props) {
  const {[props.name]: value} = props;
  return value;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Sathya'}],
};
```

----------------------------------------

TITLE: Compiled useMakeCallback Hook with React Compiler-Runtime
DESCRIPTION: This is the compiled version of the `useMakeCallback` hook using React's compiler-runtime.  It utilizes `_c` to memoize the callback function based on `obj.value` and `setState`.  This optimization prevents unnecessary callback recreation on subsequent renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditionally-return-fn.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper } from "shared-runtime";

/**
 * Assume that conditionally returned functions can be invoked and that their
 * property loads are hoistable to the function declaration site.
 */
function useMakeCallback(t0) {
  const $ = _c(3);
  const { obj, shouldMakeCb, setState } = t0;
  let t1;
  if ($[0] !== obj.value || $[1] !== setState) {
    t1 = () => setState(obj.value);
    $[0] = obj.value;
    $[1] = setState;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const cb = t1;
  if (shouldMakeCb) {
    return cb;
  } else {
    return null;
  }
}

const setState = (arg: number) => {
  "use no memo";
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useMakeCallback),
  params: [{ obj: { value: 1 }, shouldMakeCb: true, setState }],
  sequentialRenders: [
    { obj: { value: 1 }, shouldMakeCb: true, setState },
    { obj: { value: 2 }, shouldMakeCb: true, setState },
  ],
};

```

----------------------------------------

TITLE: Initializing React Component with Fire Import
DESCRIPTION: Creates a React functional component with fire import and useEffect hook. The component currently returns null and does not implement any specific rendering logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/use-effect-no-args-no-op.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  useEffect();

  return null;
}
```

LANGUAGE: javascript
CODE:
```
// @enableFire
import { fire } from "react";

function Component(props) {
  useEffect();
  return null;
}
```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimizations
DESCRIPTION: Compiler-transformed version of the component with React runtime optimizations. Includes memoization logic using Symbol sentinels and block-scoped error handling with labeled breaks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-with-catch-param.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { throwInput } = require("shared-runtime");

function Component(props) {
  const $ = _c(2);
  let t0;
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      try {
        throwInput(x);
      } catch (t1) {
        const e = t1;
        e.push(null);
        t0 = e;
        break bb0;
      }
    }
    $[0] = t0;
    $[1] = x;
  } else {
    t0 = $[0];
    x = $[1];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler-generated Memoization
DESCRIPTION: This snippet shows the compiled and optimized version of the React component. It includes compiler-generated memoization logic using an array for caching, and demonstrates how React's compiler optimizes the original code for better performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-mixed-scope-and-local-variables-with-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify, graphql } from "shared-runtime";

function useFragment(_arg1, _arg2) {
  "use no forget";
  return {
    urls: ["url1", "url2", "url3"],
    comments: ["comment1"],
  };
}

function Component(props) {
  const $ = _c(8);
  const post = useFragment(
    graphql`
      fragment F on T {
        id
      }
    `,
    props.post,
  );
  let t0;
  if ($[0] !== post) {
    const allUrls = [];

    const { media: t1, comments: t2, urls: t3 } = post;
    const media = t1 === undefined ? null : t1;
    let t4;
    if ($[2] !== t2) {
      t4 = t2 === undefined ? [] : t2;
      $[2] = t2;
      $[3] = t4;
    } else {
      t4 = $[3];
    }
    const comments = t4;
    let t5;
    if ($[4] !== t3) {
      t5 = t3 === undefined ? [] : t3;
      $[4] = t3;
      $[5] = t5;
    } else {
      t5 = $[5];
    }
    const urls = t5;
    let t6;
    if ($[6] !== comments.length) {
      t6 = (e) => {
        if (!comments.length) {
          return;
        }

        console.log(comments.length);
      };
      $[6] = comments.length;
      $[7] = t6;
    } else {
      t6 = $[7];
    }
    const onClick = t6;

    allUrls.push(...urls);
    t0 = <Stringify media={media} allUrls={allUrls} onClick={onClick} />;
    $[0] = post;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ post: {} }],
  isComponent: true,
};
```

----------------------------------------

TITLE: Compiled React Component using Compiler Runtime
DESCRIPTION: This is the compiled version of the React component using React's compiler runtime. It uses a caching mechanism for memoization and preserves the scoping behavior of the original component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-reassign-shadowed-primitive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;

  let x_0;
  x_0 = 56;
  const fn = function () {
    x_0 = 42;
  };

  fn();
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized Component Rendering in React with Memoization
DESCRIPTION: This code snippet demonstrates a more optimized version of the 'Component' and child functions using a memoization technique via the internal state representation of arguments. This approach helps to minimize unnecessary re-renders by storing the last rendered values and checking against new input values before rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dupe-attr-after-rename.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableJsxOutlining
function Component(t0) {
  const $ = _c(7);
  const { arr } = t0;
  const x = useX();
  let t1;
  if ($[0] !== arr || $[1] !== x) {
    let t2;
    if ($[3] !== x) {
      t2 = (i, id) => {
        const T0 = _temp;
        return <T0 k={i + "i"} k1={i + "j"} k12={i + "j"} key={id} x={x} />;
      };
      $[3] = x;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    t1 = arr.map(t2);
    $[0] = arr;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = <>{t1}</>;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
function _temp(t0) {
  const $ = _c(11);
  const { k: k, k1: k1, k12: k12, x: x } = t0;
  let t1;
  if ($[0] !== k) {
    t1 = <Foo k={k} />;
    $[0] = k;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== k1) {
    t2 = <Foo k={k1} />;
    $[2] = k1;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== k12) {
    t3 = <Baz k1={k12} />;
    $[4] = k12;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== t1 || $[7] !== t2 || $[8] !== t3 || $[9] !== x) {
    t4 = (
      <Bar x={x}>
        {t1}
        {t2}
        {t3}
      </Bar>
    );
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
    $[9] = x;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  return t4;
}
function Bar(t0) {
  const $ = _c(3);
  const { x, children } = t0;
  let t1;
  if ($[0] !== children || $[1] !== x) {
    t1 = (
      <>
        {x}
        {children}
      </>
    );
    $[0] = children;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Baz(t0) {
  const { k1 } = t0;
  return k1;
}

function Foo(t0) {
  const { k } = t0;
  return k;
}

function useX() {
  return "x";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arr: ["foo", "bar"] }],
};
```

----------------------------------------

TITLE: Defining a React Component with Reactive State
DESCRIPTION: This snippet defines a React component function named Component that initializes independent reactive states a and b, then manipulates them in a controlled manner. It uses the property cond from props to alter the state of b and indirectly makes dependent state variables reactive. The output is an array containing a seemingly non-reactive variable x, which is determined to be reactive due to its dependence on the control variable c. No additional dependencies are specified, aside from typical React usage. The inputs include props, and the output is an array with the variable x.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-in.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a and b are independent but their mutations are interleaved, so
  // they get grouped in a reactive scope. this means that a becomes
  // reactive since it will effectively re-evaluate based on a reactive
  // input
  const a = [];
  const b = [];
  b.push(props.cond);
  a.push({a: false});

  // Downstream consumer of a, which initially seems non-reactive except
  // that a becomes reactive, per above
  const c = [a];

  let x;
  for (const i in c[0][0]) {
    x = 1;
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `c[0]` which becomes reactive via
  // being interleaved with `b`.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};
```

----------------------------------------

TITLE: Compiler-Optimized React Component
DESCRIPTION: Compiler-transformed version of the component with caching logic added. Uses a cache array ($) to store and compare values, preventing unnecessary recalculations and array creations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-same-property-identifier-names.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(5);
  const { x: t0, sameName: renamed } = props;
  const { destructured } = t0;
  let t1;
  if ($[0] !== destructured) {
    t1 = identity(destructured);
    $[0] = destructured;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const sameName = t1;
  let t2;
  if ($[2] !== renamed || $[3] !== sameName) {
    t2 = [sameName, renamed];
    $[2] = renamed;
    $[3] = sameName;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ x: { destructured: 0 }, sameName: 2 }],
};
```

----------------------------------------

TITLE: Compiled React Function with Compiler Runtime Optimization
DESCRIPTION: Optimized version of useFoo function using React compiler runtime for memoization and dependency tracking
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR

import { Stringify } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(4);
  const { a } = t0;
  let t1;
  if ($[0] !== a.b.c) {
    t1 = () => () => ({ value: a.b.c });
    $[0] = a.b.c;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const fn = t1;
  let t2;
  if ($[2] !== fn) {
    t2 = <Stringify fn={fn} shouldInvokeFns={true} />;
    $[2] = fn;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}
```

----------------------------------------

TITLE: Memoized Click Handlers with Compiler Runtime - JavaScript
DESCRIPTION: This snippet implements the 'hoisting' function with memoization using React's compiler runtime. It also defines the click handlers ('onClick' and 'onClick2') that access properties of a 'bar' object. It includes logic to handle if the cache sentinel is present. Dependencies include 'react/compiler-runtime' and 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-computed-member-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function hoisting() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const onClick = function onClick() {
      return bar.baz;
    };

    const onClick2 = function onClick2() {
      return bar[baz];
    };

    const baz = "baz";
    const bar = { baz: 1 };

    t0 = (
      <Stringify onClick={onClick} onClick2={onClick2} shouldInvokeFns={true} />
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Logic
DESCRIPTION: The React component after compilation, showing how the React compiler runtime implements memoization. It uses a cache array to store previous values and dependencies to avoid recreating objects when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-non-escaping-interleaved-allocating-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.a) {
    t0 = [props.a];
    $[0] = props.a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const a = t0;
  let b;
  if ($[2] !== a || $[3] !== props.b) {
    b = [];
    const c = {};
    c.a = a;
    b.push(props.b);
    $[2] = a;
    $[3] = props.b;
    $[4] = b;
  } else {
    b = $[4];
  }
  return b;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Input JSX Implementation with FBT Plural
DESCRIPTION: JSX component implementation showing FBT plural handling with both fbt.plural() method and <fbt:plural> component. Demonstrates parameter passing and count display for multiple items (apples and bananas).
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/bug-fbt-plural-multiple-mixed-call-tag.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import fbt from 'fbt';

function useFoo({apples, bananas}) {
  return (
    <div>
      <fbt desc="Test Description">
        {fbt.param('number of apples', apples)}
        {'  '}
        {fbt.plural('apple', apples)} and
        {'  '}
        <fbt:plural name={'number of bananas'} count={bananas} showCount="yes">
          banana
        </fbt:plural>
      </fbt>
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{apples: 1, bananas: 2}],
};
```

----------------------------------------

TITLE: Handling Memo Cache in React Effect Hooks - JavaScript
DESCRIPTION: This snippet extends NonReactiveDepInEffect to incorporate memoization. It checks if certain cached values are marked with a sentinel to determine whether to create a new object or use a cached one. The React useEffect and SharedRuntime hooks are used to manage side-effects based on these checks. Dependencies on 'react/compiler-runtime' and 'shared-runtime' are necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/import-namespace-useEffect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import * as React from "react";
import * as SharedRuntime from "shared-runtime";

function NonReactiveDepInEffect() {
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = makeObject_Primitives();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const obj = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => print(obj);
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  React.useEffect(t1, [obj]);
  let t2;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => print(obj);
    t3 = [obj];
    $[2] = t2;
    $[3] = t3;
  } else {
    t2 = $[2];
    t3 = $[3];
  }
  SharedRuntime.useSpecialEffect(t2, t3, [obj]);
}

```

----------------------------------------

TITLE: Compiled React Component with Optimizations
DESCRIPTION: The compiled version of the component with React runtime optimizations including memoization caching for the onClick handler and conditional rendering based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-hoisting.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  const wat = _temp;

  const pathname_0 = props.wat;
  const deeplinkItemId = pathname_0 ? props.itemID : null;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => wat();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== deeplinkItemId) {
    t1 = <button onClick={t0}>{deeplinkItemId}</button>;
    $[1] = deeplinkItemId;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
function _temp() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ wat: "/dev/null", itemID: 42 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Logic
DESCRIPTION: Compiled version of the React component showing the internal memoization implementation using a cache array ($) and dependency checking. Includes test fixtures for sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { typedArrayPush, ValidateMemoization } from "shared-runtime";

export function Component(t0) {
  const $ = _c(27);
  const { a, b } = t0;
  let t1;
  let t2;
  if ($[0] !== a) {
    t2 = { a };
    $[0] = a;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const item1 = t1;
  let t3;
  let t4;
  if ($[2] !== b) {
    t4 = { b };
    $[2] = b;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  t3 = t4;
  const item2 = t3;
  let t5;
  let items;
  if ($[4] !== item1 || $[5] !== item2) {
    items = [];
    typedArrayPush(items, item1);
    typedArrayPush(items, item2);
    $[4] = item1;
    $[5] = item2;
    $[6] = items;
  } else {
    items = $[6];
  }
  t5 = items;
  const items_0 = t5;
  let t6;
  if ($[7] !== a) {
    t6 = [a];
    $[7] = a;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  if ($[9] !== items_0[0] || $[10] !== t6) {
    t7 = <ValidateMemoization inputs={t6} output={items_0[0]} />;
    $[9] = items_0[0];
    $[10] = t6;
    $[11] = t7;
  } else {
    t7 = $[11];
  }
  let t8;
  if ($[12] !== b) {
    t8 = [b];
    $[12] = b;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  let t9;
  if ($[14] !== items_0[1] || $[15] !== t8) {
    t9 = <ValidateMemoization inputs={t8} output={items_0[1]} />;
    $[14] = items_0[1];
    $[15] = t8;
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  let t10;
  if ($[17] !== a || $[18] !== b) {
    t10 = [a, b];
    $[17] = a;
    $[18] = b;
    $[19] = t10;
  } else {
    t10 = $[19];
  }
  let t11;
  if ($[20] !== items_0 || $[21] !== t10) {
    t11 = <ValidateMemoization inputs={t10} output={items_0} />;
    $[20] = items_0;
    $[21] = t10;
    $[22] = t11;
  } else {
    t11 = $[22];
  }
  let t12;
  if ($[23] !== t11 || $[24] !== t7 || $[25] !== t9) {
    t12 = (
      <>
        {t7}
        {t9}
        {t11}
      </>
    );
    $[23] = t11;
    $[24] = t7;
    $[25] = t9;
    $[26] = t12;
  } else {
    t12 = $[26];
  }
  return t12;
}
```

----------------------------------------

TITLE: Defining a Function and Exporting an Object in JavaScript
DESCRIPTION: This snippet defines a function `foo` which adds two elements from a props array and exports an object `FIXTURE_ENTRYPOINT` containing a reference to the function and component parameters. The function uses destructuring to extract values from `props.a`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-array-middle-element.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(props) {
  const [x, , y] = props.a;
  return x + y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This is the compiled version of the React component, transformed by the React compiler.  It leverages the `_c` function from `react/compiler-runtime` for memoization and optimizes the component's rendering logic. This version aims to be more efficient than the original, uncompiled version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/block-scoping-switch-variable-scoping.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";

function Component(props) {
  const $ = _c(2);
  let t0;
  let t1;
  if ($[0] !== props.value) {
    t1 = { value: props.value };
    $[0] = props.value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const handlers = t1;
bb0: switch (props.test) {
    case true: {
      console.log(handlers.value);
      break bb0;
    }
    default: {
    }
  }

  t0 = handlers;
  const outerHandlers = t0;
  return outerHandlers;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ test: true, value: "hello" }],
};

```

----------------------------------------

TITLE: Compiled React Component with Compiler-Runtime
DESCRIPTION: This snippet presents the compiled version of the `useFoo` React component, generated using React's compiler-runtime. It utilizes the `_c` function from "react/compiler-runtime" for memoization. The compiled code optimizes the rendering process by caching the `SharedRuntime.Text` component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-memberexpr-tag-conditional.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as SharedRuntime from "shared-runtime";
function useFoo(t0) {
  const $ = _c(1);
  const { cond } = t0;
  if (cond) {
    let t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = <SharedRuntime.Text value={4} />;
      $[0] = t1;
    } else {
      t1 = $[0];
    }
    return t1;
  } else {
    return null;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: true }],
};

```

----------------------------------------

TITLE: Importing React Feature Flag and Default Export
DESCRIPTION: Demonstrates importing a feature flag from ReactForgetFeatureFlag module and exporting a default value of 42. The code includes a @gating comment indicating feature gating functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/repro-no-gating-import-without-compiled-functions.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import {isForgetEnabled_Fixtures} from 'ReactForgetFeatureFlag';

export default 42;
```

LANGUAGE: javascript
CODE:
```
// @gating
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag";

export default 42;
```

----------------------------------------

TITLE: React Component with Memoization and Array Handling
DESCRIPTION: This snippet illustrates the implementation of the 'Component' function with additional usage of memoization through 'react/compiler-runtime'. It uses 'makeArray' to generate values, processes them to compute a sum, and utilizes a memoization cache to optimize performance. The snippet highlights dependencies on both 'react/compiler-runtime' and 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-in-while-loop-condition.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

// @flow
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const items = makeArray(0, 1, 2);
    let item;
    let sum = 0;
    while ((item = items.pop())) {
      sum = sum + item;
    }

    t0 = [items, sum];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component with Mutable Object in JSX
DESCRIPTION: A React hook function that demonstrates how a mutable object is created, potentially mutated, and then captured in a JSX expression. The example explores a complex edge case of scope management when JSX references values across different scopes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-jsx.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  Stringify,
  makeObject_Primitives,
  mutateAndReturn,
} from 'shared-runtime';

/**
 * In this example, the `<Stringify ... />` JSX block mutates then captures obj.
 * As JSX expressions freeze their values, we know that `obj` and `myDiv` cannot
 * be mutated past this.
 * This set of mutable range + scopes is an edge case because the JSX expression
 * references values in two scopes.
 * - (freeze) the result of `mutateAndReturn`
 *   this is a mutable value with a mutable range starting at `makeObject()`
 * - (mutate) the lvalue storing the result of `<Stringify .../>`
 *   this is a immutable value and so gets assigned a different scope
 *
 * obj@0 = makeObj();                         scope@0
 * if (cond) {                               |
 *   $1@0 = mutate(obj@0);                   |
 *   myDiv@1 = JSX $1@0          <- scope@1  |
 * }                                         
 *
 * Coincidentally, the range of `obj` is extended by alignScopesToBlocks to *past*
 * the end of the JSX instruction. As we currently alias identifier mutableRanges to
 * scope ranges, this `freeze` reference is perceived as occurring during the mutable
 * range of `obj` (even though it is after the last mutating reference).
 *
 * This case is technically safe as `myDiv` correctly takes `obj` as a dependency. As
 * a result, developers can never observe myDiv can aliasing a different value generation
 * than `obj` (e.g. the invariant `myDiv.props.value === obj` always holds).
 */
function useFoo({data}) {
  let obj = null;
  let myDiv = null;
  if (data.cond) {
    obj = makeObject_Primitives();
    if (data.cond1) {
      myDiv = <Stringify value={mutateAndReturn(obj)} />;
    }
  }
  return myDiv;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{data: {cond: true, cond1: true}}],
  sequentialRenders: [
    {data: {cond: true, cond1: true}},
    {data: {cond: true, cond1: true}},
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with FBT Optimization in JavaScript
DESCRIPTION: This snippet shows the compiled and optimized version of the 'Foo' component. It uses the FBT runtime functions for efficient internationalization and includes memoization to avoid unnecessary re-renders when props don't change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace-two-subtrees.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Foo(t0) {
  const $ = _c(3);
  const { name1, name2 } = t0;
  let t1;
  if ($[0] !== name1 || $[1] !== name2) {
    t1 = fbt._(
      "{user1} and {user2} accepted your PR!",
      [
        fbt._param(
          "user1",

          <span key={name1}>
            <b>{name1}</b>
          </span>,
        ),
        fbt._param(
          "user2",

          <span key={name2}>
            <b>{name2}</b>
          </span>,
        ),
      ],
      { hk: "2PxMie" },
    );
    $[0] = name1;
    $[1] = name2;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ name1: "Mike", name2: "Jan" }],
};
```

----------------------------------------

TITLE: React Component with Reactive Handling in JavaScript
DESCRIPTION: This snippet shows an enhanced version of the React component that includes a mechanism for handling reactive state using a custom reactive system. It utilizes an imported function from 'react/compiler-runtime' to manage changes to the value 'x' more efficiently and returns the computed state reactively.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-while-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  let i = 0;
  while (i < props.test) {
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }

    i++;
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { test: 12 },
    { test: 12 },
    { test: 1 },
    { test: 1 },
    { test: 12 },
    { test: 1 },
    { test: 12 },
    { test: 1 },
  ],
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization
DESCRIPTION: Compiler-optimized version of useBar that implements memoization using React's compiler runtime. The transformed code caches results based on the arg parameter to avoid unnecessary recomputation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-spread-later-mutated.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useBar(t0) {
  const $ = _c(2);
  const { arg } = t0;
  let arr;
  if ($[0] !== arg) {
    const obj = {};
    const s = new Set([obj, 5, 4]);
    const mutableIterator = s.values();
    arr = [...mutableIterator];

    obj.x = arg;
    $[0] = arg;
    $[1] = arr;
  } else {
    arr = $[1];
  }
  return arr;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useBar,
  params: [{ arg: 3 }],
  sequentialRenders: [{ arg: 3 }, { arg: 3 }, { arg: 4 }],
};
```

----------------------------------------

TITLE: Exposing createBridge and createStore in react-devtools-inline Frontend
DESCRIPTION: The react-devtools-inline package now exports createBridge and createStore functions from the frontend entrypoint to support advanced use cases.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { createBridge, createStore } from 'react-devtools-inline/frontend';

const bridge = createBridge();
const store = createStore(bridge);
```

----------------------------------------

TITLE: Initial React Fixture Implementation
DESCRIPTION: Original implementation of a test fixture demonstrating block fallthrough behavior with mutable state. Shows conditional logic and mutation patterns across different execution blocks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-nested-block-structure.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function useFoo({cond1, cond2}) {
  let s = null;
  if (cond1) {
    s = {};
  } else {
    return null;
  }

  if (cond2) {
    mutate(s);
  }

  return s;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond1: true, cond2: false}],
  sequentialRenders: [
    {cond1: true, cond2: false},
    {cond1: true, cond2: false},
    {cond1: true, cond2: true},
    {cond1: true, cond2: true},
    {cond1: false, cond2: true},
  ],
};
```

----------------------------------------

TITLE: Defining Array Length Manipulation Test in JavaScript for React Compiler
DESCRIPTION: This snippet defines a function 'useFoo' that creates an array, returns its length, and then sets it to zero. It's designed to test the React compiler's handling of property access and assignment order.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/evaluation-order-mutate-store-after-dependency-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
/**
 * Test that we preserve order of evaluation on the following case scope@0
 * ```js
 * // simplified HIR
 * scope@0
 *    ...
 *    $0 = arr.length
 *    $1 = arr.length = 0
 *
 * scope@1 <-- here we should depend on $0 (the value of the property load before the
 *             property store)
 *   [$0, $1]
 * ```
 */
function useFoo(source: Array<number>): [number, number] {
  const arr = [1, 2, 3, ...source];
  return [arr.length, (arr.length = 0)];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [[5, 6]],
};
```

----------------------------------------

TITLE: React Compiler Runtime Conditional Dependencies - JavaScript
DESCRIPTION: This snippet enhances the previously defined function by incorporating the React compiler runtime. It uses '_c' from 'react/compiler-runtime' to manage reactive state within the function 'useReactiveDepsInCondScope'. This extended version introduces memoized state to store dependencies, such as 'props' and 'props.a.b'. It conditionally updates and retrieves values based on the current state, ensuring efficient dependency management within the reactive scope.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cond-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";\nimport { CONST_FALSE, identity } from "shared-runtime";\n\nfunction useReactiveDepsInCondScope(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props) {\n    x = {};\n    if (CONST_FALSE) {\n      let t0;\n      if ($[2] !== props.a.b) {\n        t0 = identity(props.a.b);\n        $[2] = props.a.b;\n        $[3] = t0;\n      } else {\n        t0 = $[3];\n      }\n      const tmp = t0;\n      x.a = tmp;\n    }\n    $[0] = props;\n    $[1] = x;\n  } else {\n    x = $[1];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useReactiveDepsInCondScope,\n  params: [{}],\n};
```

----------------------------------------

TITLE: Original String Concatenation Implementation
DESCRIPTION: Initial implementation of a function that concatenates string literals using multiple variables and concatenation operations. Includes fixture setup for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-string-concat.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const a = 'a' + 'b';
  const c = 'c';
  return a + c;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Input Function with Array Manipulation
DESCRIPTION: Initial implementation of a function creating an object with a nested array, demonstrating basic object and array manipulation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const x = [];
  const y = {x: x};
  y.x.push([]);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining Function foo
DESCRIPTION: This snippet defines a function foo which executes a recursive call based on the value of x and returns an array with y multiplied by 10. No external dependencies are specified. The function accepts two parameters: x and y, where x dictates conditional recursion, and it returns an array containing the product of y and 10.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
export default function foo(x, y) {
  if (x) {
    return foo(false, y);
  }
  return [y * 10];
}

```

----------------------------------------

TITLE: Reactive Array Handling with Compiler Runtime in JavaScript
DESCRIPTION: This JavaScript snippet builds upon reactive rendering, leveraging a compiler-generated context _c from react/compiler-runtime to manage component state. It conditionally updates an array with new values and uses the mutate function from the shared-runtime, aiming to minimize unnecessary render cycles by caching previous results. Essential inputs include an object parameter with a value attribute to track and manage changes reactively.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-try.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { arrayPush, mutate } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(2);
  const { value } = t0;
  let items;
  if ($[0] !== value) {
    try {
      items = [];
      arrayPush(items, value);
    } catch {}

    mutate(items);
    $[0] = value;
    $[1] = items;
  } else {
    items = $[1];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ value: 2 }],
  sequentialRenders: [{ value: 2 }, { value: 2 }, { value: 3 }],
};

```

----------------------------------------

TITLE: Using Fire in React Component with JavaScript
DESCRIPTION: The snippet shows how to use the fire function in a React component, showcasing dependencies such as React and its hooks. The snippet attempts to call fire with a callback and again within a useCallback hook. The primary parameter is props, which is used within the foo function to log values and is passed to fire. The limitation here is the incorrect usage of fire outside proper lifecycle management, highlighted by an error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-outside-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @enableFire
import {fire, useCallback} from 'react';

function Component({props, bar}) {
  const foo = () => {
    console.log(props);
  };
  fire(foo(props));

  useCallback(() => {
    fire(foo(props));
  }, [foo, props]);

  return null;
}

```

----------------------------------------

TITLE: Defining Base Component in React - JavaScript
DESCRIPTION: This snippet defines a simple React component that updates items in an array to indicate they have been updated. It utilizes props and returns two arrays, one original and one updated, but doesn't utilize the props in this implementation. Expected inputs are the component's props, while the outputs are an array of original and updated items.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-mutating-lambda-noAlias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = [];
  const y = x.map(item => {
    item.updated = true;
    return item;
  });
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This code shows the compiled version of the React component Foo, using the react/compiler-runtime. It memoizes the result of rendering the Stringify component based on the state to optimize performance. The useEffect hook's callback updates the state, triggering a re-render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-setstate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useState } from "react";
import { Stringify } from "shared-runtime";

function Foo() {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(() => setState(2), t0);

  const [state, t1] = useState(0);
  const setState = t1;
  let t2;
  if ($[1] !== state) {
    t2 = <Stringify state={state} />;
    $[1] = state;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
  sequentialRenders: [{}, {}],
};

```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the React component, likely produced by a compiler. It includes memoization techniques to improve performance and efficiency in handling state and effects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-reassignment-in-effect-indirect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useState } from "react";

let someGlobal = false;

function Component() {
  const $ = _c(6);
  const [state, setState] = useState(someGlobal);

  const setGlobal = _temp;
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setGlobal();
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  let t2;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      setState(someGlobal);
    };
    t3 = [someGlobal];
    $[2] = t2;
    $[3] = t3;
  } else {
    t2 = $[2];
    t3 = $[3];
  }
  useEffect(t2, t3);

  const t4 = String(state);
  let t5;
  if ($[4] !== t4) {
    t5 = <div>{t4}</div>;
    $[4] = t4;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  return t5;
}
function _temp() {
  someGlobal = true;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the 'Foo' component using memoization. It prevents unnecessary re-renders by caching the result when the input 'userIds' hasn't changed. The FIXTURE_ENTRYPOINT remains the same for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-backedge-reference-effect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Foo(t0) {
  const $ = _c(2);
  const { userIds } = t0;
  let t1;
  if ($[0] !== userIds) {
    t1 = (
      <Stringify
        fn={() => {
          const arr = [];
          for (const selectedUser of userIds) {
            arr.push(selectedUser);
          }
          return arr;
        }}
        shouldInvokeFns={true}
      />
    );
    $[0] = userIds;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ userIds: [1, 2, 3] }],
  sequentialRenders: [{ userIds: [1, 2, 4] }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Optimized version of the component using React's compiler runtime for memoization. Implements caching logic using Symbol.for() checks and a compiler runtime utility.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-captures-value-later-frozen-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (e) => {
      maybeMutate(x, e.target.value);
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const onChange = t1;
  if (props.cond) {
  }
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = <Foo value={x} onChange={onChange} />;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet presents the compiled version of the `Component` function.  It utilizes `react/compiler-runtime` for memoization. The compiled function memoizes the result of `foo?.(props)` based on the input props, improving performance by avoiding redundant computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    t0 = foo?.(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

```

----------------------------------------

TITLE: Compiled React Component with Subpath Dependency Tracking
DESCRIPTION: This code shows the compiled version of the React component. It imports `_c` from `react/compiler-runtime`, which likely represents the compiler's memoization/optimization helper.  It checks for changes in `props.a` to determine whether to update the local variable `x` and avoids unnecessary re-renders by reusing cached values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-overlap-descendant.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Test that we correctly track a subpath if the subpath itself is accessed as
// a dependency
function TestOverlappingDescendantTracked(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.a) {
    x = {};
    x.b = props.a.b.c;
    x.c = props.a.b.c.x.y;
    x.a = props.a;
    $[0] = props.a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: TestOverlappingDescendantTracked,
  params: [{ a: { b: { c: { x: { y: 5 } } } } }],
};

```

----------------------------------------

TITLE: Optimized React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows an optimized version of the React component using compiler-runtime and memoization. It uses a Symbol-based cache sentinel to determine whether to execute the callback or return a cached result.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-function-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  const callback = _temp;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = callback();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  try {
    return [];
  } catch (t0) {
    return;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Using @validateBlocklistedImports Directive with a Dangerous Import in React
DESCRIPTION: This code snippet demonstrates the usage of the @validateBlocklistedImports directive to mark certain imports as dangerous. The code attempts to import from a module named 'DangerousImport' which is blocklisted, causing validation to fail.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.validate-blocklisted-imports.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validateBlocklistedImports(DangerousImport)
import {foo} from 'DangerousImport';
import {useIdentity} from 'shared-runtime';

function useHook() {
  useIdentity(foo);
  return;
}

```

----------------------------------------

TITLE: Output: Compiled React Code with Memoization for Lambda Functions
DESCRIPTION: Compiled version of the React code showing how the compiler optimizes lambda functions through memoization. It uses internal caching to avoid recreating function references when dependencies haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-chained-callbacks.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * Forked from array-map-simple.js
 *
 * Here, getVal1 has a known callsite in `cb1`, but `cb1` isn't known to be
 * called (it's only passed to array.map). In this case, we should be
 * conservative and assume that all named lambdas are conditionally called.
 */
function useFoo(t0) {
  const $ = _c(17);
  const { arr1, arr2 } = t0;
  let t1;
  if ($[0] !== arr1[0]) {
    t1 = () => arr1[0].value;
    $[0] = arr1[0];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const getVal1 = t1;
  let t2;
  if ($[2] !== getVal1) {
    t2 = (e) => getVal1() + e.value;
    $[2] = getVal1;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const cb1 = t2;
  let t3;
  if ($[4] !== arr1 || $[5] !== cb1) {
    t3 = arr1.map(cb1);
    $[4] = arr1;
    $[5] = cb1;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const x = t3;
  let t4;
  if ($[7] !== arr2) {
    t4 = () => arr2[0].value;
    $[7] = arr2;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const getVal2 = t4;
  let t5;
  if ($[9] !== getVal2) {
    t5 = (e_0) => getVal2() + e_0.value;
    $[9] = getVal2;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  const cb2 = t5;
  let t6;
  if ($[11] !== arr1 || $[12] !== cb2) {
    t6 = arr1.map(cb2);
    $[11] = arr1;
    $[12] = cb2;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  const y = t6;
  let t7;
  if ($[14] !== x || $[15] !== y) {
    t7 = [x, y];
    $[14] = x;
    $[15] = y;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  return t7;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ arr1: [], arr2: [] }],
  sequentialRenders: [
    { arr1: [], arr2: [] },
    { arr1: [], arr2: null },
    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Optimizations in JavaScript
DESCRIPTION: The compiled version of the React component with memoization optimizations applied. It uses React compiler runtime to cache values between renders and conditionally rebuilds arrays only when dependent props change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-array-push-consecutive-phis.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

function Component(props) {
  const $ = _c(6);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  let t1;
  if (
    $[1] !== props.cond ||
    $[2] !== props.cond2 ||
    $[3] !== props.value ||
    $[4] !== props.value2
  ) {
    let y;
    if (props.cond) {
      if (props.cond2) {
        y = [props.value];
      } else {
        y = [props.value2];
      }
    } else {
      y = [];
    }

    y.push(x);

    t1 = [x, y];
    $[1] = props.cond;
    $[2] = props.cond2;
    $[3] = props.value;
    $[4] = props.value2;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, cond2: true, value: 42 }],
  sequentialRenders: [
    { cond: true, cond2: true, value: 3.14 },
    { cond: true, cond2: true, value: 42 },
    { cond: true, cond2: true, value: 3.14 },
    { cond: true, cond2: false, value2: 3.14 },
    { cond: true, cond2: false, value2: 42 },
    { cond: true, cond2: false, value2: 3.14 },
    { cond: false },
    { cond: false },
  ],
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the React component using memoization and compiler-specific features. It uses a Symbol-based cache sentinel to determine whether to recompute the component's output or use a cached version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeObject_Primitives, mutateAndReturn, toJSON } from "shared-runtime";

function Component(_props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const collection = [makeObject_Primitives()];
    const results = [];
    for (const item of collection) {
      results.push(
        <div key={toJSON(item)}>{toJSON(mutateAndReturn(item))}</div>,
      );
    }

    t0 = <div>{results}</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Optimized React Compiler Function
DESCRIPTION: This snippet shows the optimized version of the 'foo' function using React's compiler runtime. It introduces caching mechanisms to avoid redundant computations and object creations, potentially improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-nested-if-else-with-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c, d) {
  const $ = _c(3);
  someObj();
  let x;
  if ($[0] !== a || $[1] !== b) {
    if (a) {
      let z;
      if (b) {
        const w = someObj();
        z = w;
      } else {
        z = someObj();
      }

      x = z;
    } else {
      x = someObj();
    }

    x.f = 1;
    $[0] = a;
    $[1] = b;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with added memoization logic using compiler runtime. Shows how the component is optimized to avoid unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-independently-memoized-property-load-for-method-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0) {
  const $ = _c(8);
  const { label, highlightedItem } = t0;
  const serverTime = useServerTime();
  let t1;
  let timestampLabel;
  if ($[0] !== highlightedItem || $[1] !== label || $[2] !== serverTime) {
    const highlight = new Highlight(highlightedItem);

    const time = serverTime.get();

    timestampLabel = time / 1000 || label;

    t1 = highlight.render();
    $[0] = highlightedItem;
    $[1] = label;
    $[2] = serverTime;
    $[3] = t1;
    $[4] = timestampLabel;
  } else {
    t1 = $[3];
    timestampLabel = $[4];
  }
  let t2;
  if ($[5] !== t1 || $[6] !== timestampLabel) {
    t2 = (
      <>
        {t1}
        {timestampLabel}
      </>
    );
    $[5] = t1;
    $[6] = timestampLabel;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  return t2;
}

function useServerTime() {
  "use no forget";

  return {
    get() {
      return 42000;
    },
  };
}

class Highlight {
  constructor(value) {
    this.value = value;
  }

  render() {
    return this.value;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ label: "<unused>", highlightedItem: "Seconds passed: " }],
};
```

----------------------------------------

TITLE: Defining a Memoized React Component - JavaScript
DESCRIPTION: This snippet represents a more optimized version of the React component that utilizes a memoization technique for performance. It changes the behavior based on previous props and conditions to avoid unnecessary object creation if the props havent changed. The memoization relies on symbols and maintains a cache-like behavior to store previous results. This snippet also requires React as a dependency. It returns an array with similar structure and conditions as the first snippet.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-property-store.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @debug @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  let t1;
  if ($[1] !== props.a || $[2] !== props.cond) {
    let y;
    if (props.cond) {
      y = {};
    } else {
      y = { a: props.a };
    }

    y.x = x;

    t1 = [x, y];
    $[1] = props.a;
    $[2] = props.cond;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: false, a: "a!" }],
};

```

----------------------------------------

TITLE: Testing with a Specific URL
DESCRIPTION: Speed up testing by passing a specific URL to the test script when launching the DevTools.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_7

LANGUAGE: sh
CODE:
```
yarn build:chrome && yarn test:chrome --url=<url-to-test>
```

----------------------------------------

TITLE: React Component with Flow Type Suppression
DESCRIPTION: React component example showing Flow type suppression using $FlowFixMe comment. Includes a custom hook useX and exports a fixture entrypoint configuration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/no-flow-bailout-unrelated.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFlowSuppressions

function useX() {}

function Foo(props) {
  // $FlowFixMe[incompatible-type]
  useX();
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: React Hook Implementation with External Function
DESCRIPTION: This snippet defines a React hook, `useMyHook`, which returns a reference to an external function `_temp`. The `_temp` function modifies the value of the variable `b` to 2 when called. The module also exports a `FIXTURE_ENTRYPOINT` to facilitate testing the hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassign-global-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
let b = 1;

export default function useMyHook() {
  const fn = _temp;
  return fn;
}
function _temp() {
  b = 2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useMyHook,
  params: [],
};

```

----------------------------------------

TITLE: Adding Leaf Node Operation in React DevTools
DESCRIPTION: Example showing the operation payload for adding a leaf node (component) to the tree. It includes the operation type, fiber id, element type, parent id, owner id, and references to the string table for display name and key.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
[
  1,   // add operation
  2,   // fiber id
  1,   // ElementTypeClass
  1,   // parent id
  0,   // owner id
  1,   // id of "Foo" displayName in the string table
  0,   // id of null key in the string table (always zero for null)
]
```

----------------------------------------

TITLE: Implementing React Components with Hooks Misuse
DESCRIPTION: This JavaScript snippet demonstrates the creation of React components with improper usage of React hooks and class components within function components. It highlights the usage of 'use forget' directive, which is a non-standard practice, and disabling of ESLint rules, causing React Compiler to skip optimization. The snippet includes functions like 'lowercasecomponent', 'Haunted', and 'CrimesAgainstReact' illustrating deviant patterns in React component design.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-unclosed-eslint-suppression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Note: Everything below this is sketchy
/* eslint-disable react-hooks/rules-of-hooks */
function lowercasecomponent() {
  'use forget';
  const x = [];
  return <div>{x}</div>;
}

function Haunted() {
  return <div>This entire file is haunted oOoOo</div>;
}

function CrimesAgainstReact() {
  let x = React.useMemo(async () => {
    await a;
  }, []);

  class MyAmazingInnerComponent {
    render() {
      return <div>Why would you do this</div>;
    }
  }

  // Note: This shouldn't reset the eslint suppression to just this line
  // eslint-disable-next-line react-hooks/rules-of-hooks
  return <MyAmazingInnerComponent />;
}

```

----------------------------------------

TITLE: Defining React Component with Subpath Dependency
DESCRIPTION: This code defines a React component, `TestOverlappingDescendantTracked`, that accesses a nested property (`props.a.b.c`) and its descendant (`props.a.b.c.x.y`). It then creates an object with references to both these properties as well as `props.a`.  The component illustrates a scenario where careful dependency tracking is required, specifically when overlapping descendants are involved.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-overlap-descendant.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Test that we correctly track a subpath if the subpath itself is accessed as
// a dependency
function TestOverlappingDescendantTracked(props) {
  let x = {};
  x.b = props.a.b.c;
  x.c = props.a.b.c.x.y;
  x.a = props.a;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: TestOverlappingDescendantTracked,
  params: [{a: {b: {c: {x: {y: 5}}}}}],
};

```

----------------------------------------

TITLE: Invalid React Hook Implementation Example
DESCRIPTION: Shows an incorrect pattern of calling a hook through a player object's method. This violates React's rules of hooks which require hooks to be called at the top level and be the same function on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-hook-from-property-of-other-hook.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({data}) {
  const player = useVideoPlayer();
  const foo = player.useMedia();
  return foo;
}
```

LANGUAGE: plaintext
CODE:
```
  1 | function useFoo({data}) {
  2 |   const player = useVideoPlayer();
> 3 |   const foo = player.useMedia();
    |               ^^^^^^^^^^^^^^^ InvalidReact: Hooks must be the same function on every render, but this value may change over time to a different function. See https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks (3:3)
  4 |   return foo;
  5 | }
  6 |

```

----------------------------------------

TITLE: Invalid Assignment Warning in React
DESCRIPTION: This section highlights an error in the React component regarding variable reassignment after rendering. It indicates that reassigning the callback variable can lead to inconsistent behavior and advises using React state instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.function-expression-references-variable-its-assigned-to.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  1 | function Component() {
  2 |   let callback = () => {
> 3 |     callback = null;
    |     ^^^^^^^^ InvalidReact: Reassigning a variable after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead. Variable `callback` cannot be reassigned after render (3:3)
  4 |   };
  5 |   return <div onClick={callback} />;
  6 | }

```

----------------------------------------

TITLE: Compiled React Component with Hook Guards
DESCRIPTION: The compiled version of the React component with added hook dispatcher guards and memo caching. Implements safety checks and caching mechanisms around hook calls to ensure hooks are called in the correct order and context.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/flag-enable-emit-hook-guards.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { $dispatcherGuard } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @enableEmitHookGuards
import { createContext, useContext, useEffect, useState } from "react";
import {
  CONST_STRING0,
  ObjectWithHooks,
  getNumber,
  identity,
  print,
} from "shared-runtime";

const MyContext = createContext("my context value");
function Component(t0) {
  const $ = _c(4);
  try {
    $dispatcherGuard(0);
    const { value } = t0;
    print(identity(CONST_STRING0));
    let t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = getNumber();
      $[0] = t1;
    } else {
      t1 = $[0];
    }
    const [state, setState] = (function () {
      try {
        $dispatcherGuard(2);
        return useState(t1);
      } finally {
        $dispatcherGuard(3);
      }
    })();
    print(value, state);
    let t2;
    let t3;
    if ($[1] !== state) {
      t2 = () => {
        if (state === 4) {
          setState(5);
        }
      };

      t3 = [state];
      $[1] = state;
      $[2] = t2;
      $[3] = t3;
    } else {
      t2 = $[2];
      t3 = $[3];
    }
    (function () {
      try {
        $dispatcherGuard(2);
        return useEffect(t2, t3);
      } finally {
        $dispatcherGuard(3);
      }
    })();
    print(identity(value + state));
    return (function () {
      try {
        $dispatcherGuard(2);
        return ObjectWithHooks.useIdentity(
          (function () {
            try {
              $dispatcherGuard(2);
              return useContext(MyContext);
            } finally {
              $dispatcherGuard(3);
            }
          })()
        );
      } finally {
        $dispatcherGuard(3);
      }
    })();
  } finally {
    $dispatcherGuard(1);
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  args: [{ value: 0 }],
};
```

----------------------------------------

TITLE: Enhanced React Component Logic with Compiler Runtime - JavaScript
DESCRIPTION: This snippet expands the initial React component by importing and utilizing `react/compiler-runtime`. It introduces an optimization mechanism to cache memoized results, ensuring that unnecessary recomputations are avoided. The core logic follows similar reactive principles but with added performance enhancements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-switch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);

  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(null);

  const c = [a];

  let x;
  bb0: switch (c[0][0]) {
    case true: {
      x = 1;
      break bb0;
    }
    default: {
      x = 2;
    }
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};

```

----------------------------------------

TITLE: React Compiler Output with Memoization Transformation
DESCRIPTION: Compiled output showing how React's compiler transforms components with 'use forget' directive. The compiler adds memoization logic using the compiler-runtime utilities and cell-based cache to avoid unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-instrument-forget-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { shouldInstrument, useRenderCounter } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @enableEmitInstrumentForget @compilationMode(annotation)

function Bar(props) {
  "use forget";
  if (DEV && shouldInstrument)
    useRenderCounter("Bar", "/codegen-instrument-forget-test.ts");
  const $ = _c(2);
  let t0;
  if ($[0] !== props.bar) {
    t0 = <div>{props.bar}</div>;
    $[0] = props.bar;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}

function Foo(props) {
  "use forget";
  if (DEV && shouldInstrument)
    useRenderCounter("Foo", "/codegen-instrument-forget-test.ts");
  const $ = _c(2);
  let t0;
  if ($[0] !== props.bar) {
    t0 = <Foo>{props.bar}</Foo>;
    $[0] = props.bar;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled Version of useFoo Function with Memoization in JavaScript
DESCRIPTION: This snippet shows the compiled version of the useFoo function, including memoization logic. It uses React's compiler runtime to optimize the function, caching results based on input changes and implementing the same logic as the original function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutate-outer-scope-within-value-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_TRUE, identity, shallowCopy } from "shared-runtime";

function mutate(_) {}

/**
 * There are three values with their own scopes in this fixture.
 * - arr, whose mutable range extends to the `mutate(...)` call
 * - cond, which has a mutable range of exactly 1 (e.g. created but not
 *   mutated)
 * - { val: CONST_TRUE }, which is also not mutated after creation. However,
 *   its scope range becomes extended to the value block.
 *
 * After AlignScopesToBlockScopes, our scopes look roughly like this
 * ```js
 *  [1] arr = shallowCopy()            @0
 *  [2] cond = identity()        <- @1 |
 *  [3] $0 = Ternary test=cond     @2 |
 *  [4]        {val : CONST_TRUE}  |   |
 *  [5]        mutate(arr)         |   |
 *  [6] return $0                     
 * ```
 *
 * Observe that instruction 5 mutates scope 0, which means that scopes 0 and 2
 * should be merged.
 */
function useFoo(t0) {
  const $ = _c(2);
  const { input } = t0;
  let t1;
  if ($[0] !== input) {
    const arr = shallowCopy(input);

    const cond = identity(false);
    t1 = cond ? { val: CONST_TRUE } : mutate(arr);
    $[0] = input;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: 3 }],
};
```

----------------------------------------

TITLE: Compiled React Components with Runtime Optimization
DESCRIPTION: Compiled version of the components with memoization using react/compiler-runtime. Includes optimization for preventing unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component-declaration-basic.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
export default function Foo(t0) {
  const $ = _c(2);
  const { bar } = t0;
  let t1;
  if ($[0] !== bar) {
    t1 = <Bar bar={bar} />;
    $[0] = bar;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function Bar(t0) {
  const $ = _c(2);
  const { bar } = t0;
  let t1;
  if ($[0] !== bar) {
    t1 = <div>{bar}</div>;
    $[0] = bar;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function shouldNotCompile() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ bar: 42 }],
};
```

----------------------------------------

TITLE: React Compiler Runtime Optimized Component
DESCRIPTION: Enhanced version of the React component using React compiler runtime with memoization and cache optimization techniques
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-snap-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useState } from "react";

function Component() {
  const $ = _c(4);
  const [state, setState] = useState("hello");
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setState("goodbye");
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  let t2;
  if ($[2] !== state) {
    t2 = <div>{state}</div>;
    $[2] = state;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled: React Hook with Memoization
DESCRIPTION: The compiled version of useFoo hook with added memoization logic using React compiler runtime. Implements caching mechanism to prevent unnecessary recalculations while maintaining mutation behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-capture-and-mutablerange.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

/**
 * This test fixture is similar to mutation-within-jsx. The only difference
 * is that there is no `freeze` effect here, which means that `z` may be
 * mutated after its memo block through mutating `y`.
 *
 * While this is technically correct (as `z` is a nested memo block), it
 * is an edge case as we believe that values are not mutated after their
 * memo blocks (which may lead to 'tearing', i.e. mutating one render's
 * values in a subsequent render.
 */
function useFoo(t0) {
  const $ = _c(3);
  const { a, b } = t0;
  let z;
  if ($[0] !== a || $[1] !== b) {
    const x = { a };
    const y = [b];
    mutate(x);

    z = [mutate(y)];

    mutate(y);
    $[0] = a;
    $[1] = b;
    $[2] = z;
  } else {
    z = $[2];
  }
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: 2, b: 3 }],
};
```

----------------------------------------

TITLE: Defining React Component with Unused Variable
DESCRIPTION: This snippet defines a React functional component named 'Component' that returns the 'value' prop. It also includes an unused variable '_'. The component is then exported as part of a FIXTURE_ENTRYPOINT object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-const.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const _ = 42;
  return props.value;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Defining Test Fixture for Sequential Rendering (JavaScript)
DESCRIPTION: This snippet exports a test fixture object named FIXTURE_ENTRYPOINT. It includes the Component function, initial parameters, and a series of sequential renders with different prop values for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-leave-case.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ p0: false, p1: 2 }],
  sequentialRenders: [
    { p0: false, p1: 2 },
    { p0: false, p1: 2 },
    { p0: true, p1: 2 },
    { p0: true, p1: 3 },
  ],
};
```

----------------------------------------

TITLE: Simplified React Component
DESCRIPTION: Simplified version of the React component without error handling. The component directly returns the default prop value without any try-catch block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-empty-try.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = props.default;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ default: 42 }],
};
```

----------------------------------------

TITLE: Defining a Function and Exporting as Fixture Entrypoint in JavaScript
DESCRIPTION: This snippet defines a JavaScript function named foo which changes the value of a variable and throws it, and then exports it within an object named FIXTURE_ENTRYPOINT. The function initially sets a variable x to 1, changes it to 2 if it equals 1, and throws the value. The FIXTURE_ENTRYPOINT object uses the function foo, has an empty params array, and a boolean indicating it is not a component. There are no additional dependencies, but the function's behavior is straightforward and could result in an exception within certain environments.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-throw.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  if (x === 1) {
    x = 2;
  }
  throw x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled Conditional Subpath Dependency React Code
DESCRIPTION: This JavaScript code represents the compiled version of the `useConditionalSubpath2` function. It utilizes the `react/compiler-runtime` to optimize the function's execution and dependency tracking. The compiler inserts logic to cache the result of the function based on the input `props.a` and `other` values. If the inputs haven't changed, the cached result is returned, otherwise, the function executes and the result is cached.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/subpath-order2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // When a conditional dependency `props.a` is a subpath of an unconditional
// dependency `props.a.b`, we can access `props.a` while preserving program
// semantics (with respect to nullthrows).
// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`

import { identity } from "shared-runtime";

// ordering of accesses should not matter
function useConditionalSubpath2(props, other) {
  const $ = _c(3);
  let x;
  if ($[0] !== other || $[1] !== props.a) {
    x = {};
    if (identity(other)) {
      x.a = props.a;
    }

    x.b = props.a.b;
    $[0] = other;
    $[1] = props.a;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useConditionalSubpath2,
  params: [{ a: { b: 3 } }, false],
};

```

----------------------------------------

TITLE: Managing Array Mutations with shared-runtime in JavaScript
DESCRIPTION: This snippet uses shared-runtime to demonstrate how the concat method captures values from one array into another. The Foo function shows potential impacts of mutating the resulting array, which may affect the original array. The dependency includes the shared-runtime library, and it showcases how later mutations of the resulting array may write to values within the original array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-concat-should-capture.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

/**
 * Fixture showing why `concat` needs to capture both the callee and rest args.
 * Here, observe that arr1's values are captured into arr2.
 *  - Later mutations of arr2 may write to values within arr1.
 *  - Observe that it's technically valid to separately memoize the array arr1
 *    itself.
 */
function Foo({inputNum}) {
  const arr1: Array<number | object> = [{a: 1}, {}];
  const arr2 = arr1.concat([1, inputNum]);
  mutate(arr2[0]);
  return arr2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{inputNum: 2}],
  sequentialRenders: [{inputNum: 2}, {inputNum: 3}],
};
```

----------------------------------------

TITLE: React Compiler Error for Invalid Hook Usage
DESCRIPTION: Error output from the React compiler showing that labeled statements combined with value blocks (conditional, logical, optional chaining) are not supported with hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-useMemo-with-optional.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  1 | function Component(props) {
  2 |   return (
> 3 |     useMemo(() => {
    |     ^^^^^^^^^^^^^^^
> 4 |       return [props.value];
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 5 |     }) || []
    | ^^^^^^^^^^^^^ Todo: Support labeled statements combined with value blocks (conditional, logical, optional chaining, etc) (3:5)
  6 |   );
  7 | }
  8 |

```

----------------------------------------

TITLE: React Component with fire function
DESCRIPTION: This code defines a React component that uses the 'fire' function to execute a function 'foo' on every render. The 'foo' function logs the value of the 'prop1' prop. The useEffect hook is used to call 'fire' with the result of 'foo(prop1)'. Also, the prop1.value is being incremented on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-prop-write.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire @panicThreshold(none)
import {fire} from 'react';

function Component({prop1}) {
  const foo = () => {
    console.log(prop1);
  };
  useEffect(() => {
    fire(foo(prop1));
  });
  prop1.value += 1;
}

```

----------------------------------------

TITLE: Defining React Hook Test Input
DESCRIPTION: Original hook implementation showing the input pattern for creating a test fixture. Uses createHookWrapper to wrap a custom hook that processes a value parameter and returns one of two constant strings.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-in-ternary-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper, CONST_STRING0, CONST_STRING1} from 'shared-runtime';

function useHook({value}) {
  return {
    getValue() {
      return identity(value);
    },
  }
    ? CONST_STRING0
    : CONST_STRING1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{value: 0}],
};
```

----------------------------------------

TITLE: Component Definition with Mutation
DESCRIPTION: This JavaScript code defines a component function that takes a parameter 'a', creates an object 'x' with 'a', assigns 'x' to 'y', mutates 'y' using the 'mutate' function from 'shared-runtime', and returns 'y'. The component is designed to demonstrate mutation and its interaction with the shared runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-simple-alias-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {mutate} = require('shared-runtime');

function component(a) {
  let x = {a};
  let y = {};
  (function () {
    y = x;
  })();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['foo'],
};

```

----------------------------------------

TITLE: Build Error for Computed Property Name
DESCRIPTION: Error output showing the build failure when using a computed property name with a function call in an object literal. The error indicates the build system expected an Identifier but found a CallExpression in the object's key.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-member-expr-call.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   5 |   const key = {};
   6 |   const context = {
>  7 |     [obj.mutateAndReturn(key)]: identity([props.value]),
     |      ^^^^^^^^^^^^^^^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Expected Identifier, got CallExpression key in ObjectExpression (7:7)
   8 |   };
   9 |   mutate(key);
  10 |   return context;
```

----------------------------------------

TITLE: Initializing React DevTools Frontend with React and Socket.io
DESCRIPTION: This snippet sets up the frontend for React DevTools using React and Socket.io. It creates a bridge between the frontend and backend, initializes the DevTools store, and renders the DevTools component.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_9

LANGUAGE: javascript
CODE:
```
import { createElement } from 'react';
import { createRoot } from 'react-dom/client';
import {
  createBridge,
  createStore,
  initialize as createDevTools,
} from 'react-devtools-inline/frontend';
import { io } from "socket.io-client";

let root = null;

const socket = io(`http://${HOST}:${PORT}`);
socket.on("connect", () => {
  const wall = {
    listen(listener) {
      socket.on("message", (data) => {
        if (data.uid === UID) {
          listener(data);
        }
      });
    },
    send(event, payload) {
      const data = { event, payload, uid: UID };
      socket.emit('message', data);
    },
  };

  const bridge = createBridge(window, wall);
  const store = createStore(bridge);
  const DevTools = createDevTools(window, { bridge, store });

  root = createRoot(document.getElementById('root'));
  root.render(createElement(DevTools));
});
socket.on("disconnect", () => {
  root.unmount();
  root = null;
});
```

----------------------------------------

TITLE: Compiled React Components with Memoization
DESCRIPTION: Compiled output showing memoization implementation with render counter instrumentation and conditional compilation based on forget feature flag. Includes caching logic for optimized rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/codegen-instrument-forget-gating-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { shouldInstrument, useRenderCounter } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @enableEmitInstrumentForget @compilationMode(annotation) @gating
const Bar = isForgetEnabled_Fixtures()
  ? function Bar(props) {
      "use forget";
      if (DEV && shouldInstrument)
        useRenderCounter("Bar", "/codegen-instrument-forget-gating-test.ts");
      const $ = _c(2);
      let t0;
      if ($[0] !== props.bar) {
        t0 = <div>{props.bar}</div>;
        $[0] = props.bar;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : function Bar(props) {
      "use forget";
      return <div>{props.bar}</div>;
    };

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}
const Foo = isForgetEnabled_Fixtures()
  ? function Foo(props) {
      "use forget";
      if (DEV && shouldInstrument)
        useRenderCounter("Foo", "/codegen-instrument-forget-gating-test.ts");
      const $ = _c(3);
      if (props.bar < 0) {
        return props.children;
      }

      const t0 = props.bar - 1;
      let t1;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = <NoForget />;
        $[0] = t1;
      } else {
        t1 = $[0];
      }
      let t2;
      if ($[1] !== t0) {
        t2 = <Foo bar={t0}>{t1}</Foo>;
        $[1] = t0;
        $[2] = t2;
      } else {
        t2 = $[2];
      }
      return t2;
    }
  : function Foo(props) {
      "use forget";
      if (props.bar < 0) {
        return props.children;
      }
      return (
        <Foo bar={props.bar - 1}>
          <NoForget />
        </Foo>
      );
    };

global.DEV = true;
export const FIXTURE_ENTRYPOINT = {
  fn: eval("Foo"),
  params: [{ bar: 2 }],
};
```

----------------------------------------

TITLE: Advanced Fixture Function with Compiler Runtime in React JavaScript
DESCRIPTION: This snippet illustrates an advanced fixture function that optimizes state management using React's compiler runtime. It imports constants from both 'react/compiler-runtime' and 'shared-runtime' and employs a cached value to reduce unnecessary recalculations. This efficiently manages prop changes using a cached array and exports the function for fixed entry points. Dependency on 'react/compiler-runtime' and 'shared-runtime' is required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_STRING0 } from "shared-runtime";

function t(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    t0 = [, CONST_STRING0, props];
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: t,
  params: [{ a: 1, b: 2 }],
  isComponent: false,
};

```

----------------------------------------

TITLE: Original React Memo Input Code
DESCRIPTION: Input code demonstrating improper usage of React.memo() with an undefined component, used to test error handling
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/invalid-fnexpr-reference.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import * as React from 'react';

let Foo;
const MemoFoo = React.memo(Foo);
Foo = () => <div>hello world!</div>;

/**
 * Evaluate this fixture module to assert that compiler + original have the same
 * runtime error message.
 */
export const FIXTURE_ENTRYPOINT = {
  fn: () => {},
  params: [],
};
```

----------------------------------------

TITLE: Original React Hook Implementation
DESCRIPTION: Defines a custom React hook 'useTest' that creates an array using function evaluation and side effects. Uses the makeArray utility and demonstrates sequence evaluation order.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife-reassign.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray, print} from 'shared-runtime';

function useTest() {
  let w = {};
  return makeArray(
    (w = 42),
    w,
    (function foo() {
      w = 999;
      return 2;
    })(),
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [],
};
```

----------------------------------------

TITLE: Error Output for Using Hook - Documented Output
DESCRIPTION: This represents the error output encountered when the invalid hook configuration is detected during the return statement in the component. It highlights the specific issue of the type configuration mismatch for the hook being used. This is crucial for debugging and understanding the need for correct hook typing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hook-name-not-typed-as-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  2 |
  3 | function Component() {
> 4 |   return useHookNotTypedAsHook();
    |          ^^^^^^^^^^^^^^^^^^^^^ InvalidConfig: Invalid type configuration for module. Expected type for object property 'useHookNotTypedAsHook' from module 'ReactCompilerTest' to be a hook based on the property name (4:4)
  5 | }
  6 |

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: React component demonstrating memo block behavior with non-reactive values. Shows how array references are maintained when dealing with recreated values and memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-pruned-scope-leaks-value-via-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import invariant from 'invariant';
import {makeObject_Primitives, mutate, sum, useIdentity} from 'shared-runtime';

/**
 * Here, `z`'s original memo block is removed due to the inner hook call.
 * However, we also infer that `z` is non-reactive, so by default we would create
 * the memo block for `thing = [y, z]` as only depending on `y`.
 *
 * This could then mean that `thing[1]` and `z` may not refer to the same value,
 * since z recreates every time but `thing` doesn't correspondingly invalidate.
 *
 * The fix is to consider pruned memo block outputs as reactive, since they will
 * recreate on every render. This means `thing` depends on both y and z.
 */
function MyApp({count}) {
  const z = makeObject_Primitives();
  const x = useIdentity(2);
  const y = sum(x, count);
  mutate(z);
  const z2 = z;
  const thing = [y, z2];
  if (thing[1] !== z) {
    invariant(false, 'oh no!');
  }
  return thing;
}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [{count: 2}],
  sequentialRenders: [{count: 2}, {count: 2}, {count: 3}],
};
```

----------------------------------------

TITLE: React Component with Conditional Caching in JavaScript
DESCRIPTION: A React component that demonstrates conditional caching using React's internal memoization pattern. It imports a compiler runtime utility, initializes an object only when a cache sentinel is detected, and utilizes optional chaining to access deeply nested properties based on dynamic props. This design ensures efficient rerenders with cached objects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-with-optional-member-expr-as-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = makeObject();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  return x.y?.[props.a?.[props.b?.[props.c]]];
}

```

----------------------------------------

TITLE: Defining a React Component with Hook and Fixture Testing - JavaScript
DESCRIPTION: This JavaScript snippet defines a React component that uses a hook from 'shared-runtime' to influence memoization behavior. The Component function creates an instance of the Foo class and assigns a property from its input props. The snippet also exports a FIXTURE_ENTRYPOINT object for testing, providing the Component function and specific parameters to simulate execution and observe outputs. The key elements to focus on include the use of the useHook function to interject processing and influence the outcomes of instance creation and assignment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-new.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useHook} from 'shared-runtime';

function Component(props) {
  const x = new Foo();
  useHook(); // intersperse a hook call to prevent memoization of x
  x.value = props.value;

  const y = {x};

  return {y};
}

class Foo {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 'sathya'}],
};
```

----------------------------------------

TITLE: Implementing React Component with Memo Block Optimization
DESCRIPTION: This snippet shows the original implementation of the 'MyApp' React component. It demonstrates the use of hooks, custom functions, and a potential issue with non-reactive variables in memo blocks. The component takes a 'count' prop and returns an array 'thing'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-pruned-scope-leaks-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import invariant from 'invariant';
import {makeObject_Primitives, mutate, sum, useIdentity} from 'shared-runtime';

/**
 * Here, `z`'s original memo block is removed due to the inner hook call.
 * However, we also infer that `z` is non-reactive, so by default we would create
 * the memo block for `thing = [y, z]` as only depending on `y`.
 *
 * This could then mean that `thing[1]` and `z` may not refer to the same value,
 * since z recreates every time but `thing` doesn't correspondingly invalidate.
 *
 * The fix is to consider pruned memo block outputs as reactive, since they will
 * recreate on every render. This means `thing` depends on both y and z.
 */
function MyApp({count}) {
  const z = makeObject_Primitives();
  const x = useIdentity(2);
  const y = sum(x, count);
  mutate(z);
  const thing = [y, z];
  if (thing[1] !== z) {
    invariant(false, 'oh no!');
  }
  return thing;
}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [{count: 2}],
  sequentialRenders: [{count: 2}, {count: 2}, {count: 3}],
};
```

----------------------------------------

TITLE: React Compiler Error for Memoization Violation
DESCRIPTION: The error output from React Compiler showing it has skipped optimizing the component due to unsafe memoization patterns. The compiler detects that a dependency value is mutated later, which would cause unexpected behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.invalid-useCallback-captures-reassigned-context.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  10 |
  11 |   // makeArray() is captured, but depsList contains [props]
> 12 |   const cb = useCallback(() => [x], [x]);
     |                                      ^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly (12:12)

CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (12:12)
  13 |
  14 |   x = makeArray();
  15 |
```

----------------------------------------

TITLE: Compiled getItem Function Definition
DESCRIPTION: The getItem function returns an object containing the srcName and uid.  This function is used to store and retrieve the properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_4

LANGUAGE: javascript
CODE:
```
function _temp(srcName, uid) {
  return { srcName, uid };
}
```

----------------------------------------

TITLE: Optimized Component with State Caching - React - JavaScript
DESCRIPTION: Implements a React functional component that utilizes caching for improved performance by comparing current props with previous props. It conditionally calls processing functions based on the props state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-receiver-optional-method.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    const x = makeOptionalObject(props);
    const y = makeObject(props);
    t0 = x?.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  return z;
}

```

----------------------------------------

TITLE: Defining React Component with Error Handling (JavaScript)
DESCRIPTION: This code defines a React component that demonstrates error handling. It attempts to throw an input, catches the error, and manipulates an array. The component is exported as part of a FIXTURE_ENTRYPOINT object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-alias-try-values.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {throwInput} = require('shared-runtime');

function Component(props) {
  let y;
  let x = [];
  try {
    // throws x
    throwInput(x);
  } catch (e) {
    // e = x
    y = e; // y = x
  }
  y.push(null);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Using Hook with Mutation - JavaScript
DESCRIPTION: This snippet defines a custom hook `useHook` which returns an object with a method to get a mutated value. It uses the `mutateAndReturn` function to modify the incoming value. The primary purpose is to optimize value retrieval based on whether the value has changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-derived-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper, mutateAndReturn} from 'shared-runtime';
function useHook({value}) {
  const x = mutateAndReturn({value});
  const obj = {
    getValue() {
      return x;
    },
  };
  return obj;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{value: 0}],
};
```

----------------------------------------

TITLE: ESLint Error: Invalid React useMemo arguments
DESCRIPTION: This ESLint error message indicates that the callback function passed to useMemo should not accept any arguments when the dependency array is empty. This is because the memoized value will only be calculated once, so the callback function shouldn't depend on any inputs. Removing the argument from the callback will resolve the error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-useMemo-callback-args.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function component(a, b) {
> 2 |   let x = useMemo(c => a, []);
    |                   ^^^^^^ InvalidReact: useMemo callbacks may not accept any arguments (2:2)
  3 |   return x;
  4 | }
  5 |
```

----------------------------------------

TITLE: Setting Up Fizz Fixtures with Local React Build
DESCRIPTION: Command sequence to set up Fizz Fixtures using a local build of React. This requires first building React at the project root, then navigating to the fixtures directory to install dependencies and start the development server.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/fizz/README.md#2025-04-21_snippet_0

LANGUAGE: bash
CODE:
```
cd fixtures/fizz
yarn
yarn start
```

----------------------------------------

TITLE: React Component Definition with useFire Hook
DESCRIPTION: This code defines a React component that uses the `useFire` hook from `react/compiler-runtime` to manage side effects. The `useFire` hook transforms the original `fire` calls. The component is wrapped with `React.forwardRef` to allow passing a ref. It shows how side effects are now managed using the new `useFire` hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-ref-current-access.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useFire } from "react/compiler-runtime";
import { fire } from "react";
import { print } from "shared-runtime";

const Component = React.forwardRef(Component_withRef);
function Component_withRef(t0, ref) {
  const { prop1 } = t0;
  const foo = () => {
    console.log(prop1);
  };
  const t1 = useFire(foo);
  useEffect(() => {
    t1(prop1);
    bar();
    t1();
  });
  print(ref.current);
  return null;
}

```

----------------------------------------

TITLE: Input: React Hook with Mutation Effects
DESCRIPTION: Defines a React hook 'useFoo' that demonstrates mutation behavior and potential tearing effects. The code shows how mutations can affect memoized values after their memo blocks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-capture-and-mutablerange.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

/**
 * This test fixture is similar to mutation-within-jsx. The only difference
 * is that there is no `freeze` effect here, which means that `z` may be
 * mutated after its memo block through mutating `y`.
 *
 * While this is technically correct (as `z` is a nested memo block), it
 * is an edge case as we believe that values are not mutated after their
 * memo blocks (which may lead to 'tearing', i.e. mutating one render's
 * values in a subsequent render.
 */
function useFoo({a, b}) {
  // x and y's scopes start here
  const x = {a};
  const y = [b];
  mutate(x);
  // z captures the result of `mutate(y)`, which may be aliased to `y`.
  const z = [mutate(y)];
  // the following line may also mutate z
  mutate(y);
  // and end here
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: 2, b: 3}],
};
```

----------------------------------------

TITLE: Running ESLint v6 Tests for React Hooks Plugin
DESCRIPTION: A sequence of shell commands to test the eslint-plugin-react-hooks functionality with ESLint version 6. The commands navigate to the fixture directory, install dependencies, build the project, and run linting.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/eslint-v6/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
cd fixtures/eslint-v6
yarn
yarn build
yarn lint
```

----------------------------------------

TITLE: Input React Components with 'use forget' Directive
DESCRIPTION: Original React component code before compilation, showing Bar and Foo components with 'use forget' directives. Both components import from 'shared-runtime' and use the 'use forget' directive to optimize rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conflict-codegen-instrument-forget.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableEmitInstrumentForget @compilationMode(annotation)

import {identity} from 'shared-runtime';

function Bar(props) {
  'use forget';
  const shouldInstrument = identity(null);
  const _shouldInstrument = identity(null);
  const _x2 = () => {
    const _shouldInstrument2 = 'hello world';
    return identity({_shouldInstrument2});
  };
  return (
    <div style={shouldInstrument} other={_shouldInstrument}>
      {props.bar}
    </div>
  );
}

function Foo(props) {
  'use forget';
  return <Foo>{props.bar}</Foo>;
}
```

----------------------------------------

TITLE: Original React Component with Implicit Effect Dependencies
DESCRIPTION: A React component function demonstrating useEffect with no dependency array specified. The effect calls a 'print' function with a string literal. The comment indicates this is a test case for the effect dependencies inference system.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/outlined-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {useEffect} from 'react';
import {print} from 'shared-runtime';
/**
 * This compiled output is technically incorrect but this is currently the same
 * case as a bailout (an effect that overfires).
 *
 * To ensure an empty deps array is passed, we need special case
 * `InferEffectDependencies` for outlined functions (likely easier) or run it
 * before OutlineFunctions
 */
function OutlinedFunctionInEffect() {
  useEffect(() => print('hello world!'));
}
```

----------------------------------------

TITLE: Defining Function with Conditional Logic in JavaScript
DESCRIPTION: This snippet defines a function 'foo' that takes four parameters and executes different actions based on the conditions. The function uses a while loop to process its first parameter and continues certain actions based on the conditions of the other parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-conditional-continue.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  while (a) {
    if (b) {
      continue;
    }
    c();
    continue;
  }
  d();
}
```

----------------------------------------

TITLE: Original Input Function Implementation
DESCRIPTION: Original function that performs mathematical operations on a nested object property, with exports for testing setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-expression-nested-path.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function g(props) {
  const a = {b: {c: props.c}};
  a.b.c = a.b.c + 1;
  a.b.c *= 2;
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: g,
  params: [{c: 2}],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Hook Call Error Message
DESCRIPTION: This snippet contains an error message indicating that the useEffect hook must be called at the top level of the function component. This highlights the common rule violation when a hook is called inside another function or conditional statement.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-nested-use-effect.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
   7 |   };
   8 |   useEffect(() => {
>  9 |     useEffect(() => {
     |     ^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call useEffect within a function component (9:9)
  10 |       function nested() {
  11 |         fire(foo(props));
  12 |       }

```

----------------------------------------

TITLE: Input: Promoting Unconditional Access to Dependency in React
DESCRIPTION: Original function that conditionally accesses nested properties. It demonstrates how React should promote the nearest unconditional access to a dependency when a conditional dependency (props.a.b.c) has no unconditional dependency in its subpath or superpath.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/promote-uncond.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// When a conditional dependency `props.a.b.c` has no unconditional dependency
// in its subpath or superpath, we should find the nearest unconditional access

import {identity} from 'shared-runtime';

// and promote it to an unconditional dependency.
function usePromoteUnconditionalAccessToDependency(props, other) {
  const x = {};
  x.a = props.a.a.a;
  if (identity(other)) {
    x.c = props.a.b.c;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: usePromoteUnconditionalAccessToDependency,
  params: [{a: {a: {a: 3}}}, false],
};
```

----------------------------------------

TITLE: Input React Component with Error Handling
DESCRIPTION: Basic React component implementation that attempts to throw an error and falls back to creating a shallow copy of props. Uses shared runtime utilities for error throwing and shallow copying.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-mutate-outer-value.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {shallowCopy, throwErrorWithMessage} = require('shared-runtime');

function Component(props) {
  const x = [];
  try {
    x.push(throwErrorWithMessage('oops'));
  } catch {
    x.push(shallowCopy({a: props.a}));
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1}],
};
```

----------------------------------------

TITLE: Creating React Component with No Memo
DESCRIPTION: A functional React component that renders a Button component with a prop value. The component explicitly opts out of memoization using the 'use no memo' directive.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/module-scope-use-no-memo-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
"use no memo";
export default function TestComponent({ x }) {
  return <Button>{x}</Button>;
}
```

----------------------------------------

TITLE: Defining and Exporting a Function with Parameters in Javascript
DESCRIPTION: This code defines a function `bar` that takes an argument `a`, initializes variables, defines an inner function `f0`, and returns a value derived from the input. It then exports the function `bar` along with its parameter configuration and a flag indicating it is not a React component, packaged as `FIXTURE_ENTRYPOINT`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-4.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
```javascript
function bar(a) {
  let x = [a];
  let y = {};
  const f0 = function () {
    y = x[0].a[1];
  };
  f0();

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [{a: ['val1', 'val2']}],
  isComponent: false,
};

```
```

----------------------------------------

TITLE: Implementing a JavaScript Function with Variable Assignment in React
DESCRIPTION: Defines a function 'foo' with variable assignment operations and conditional logic. Exports a fixture entrypoint object that references the function for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-complex-single-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  let y = 2;
  if (y === 2) {
    x = 3;
  }

  y = x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Initializing Mutable Array in React Component
DESCRIPTION: Creates an empty array that is mutated using useNoAlias and mutate functions, then rendered in a div
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unmemoized-nonreactive-dependency-is-pruned-as-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate, useNoAlias} from 'shared-runtime';

function Component(props) {
  // Here `x` cannot be memoized bc its mutable range spans a hook call:
  const x = [];
  useNoAlias();
  mutate(x);

  // However, `x` is non-reactive. It cannot semantically change, so we
  // exclude it as a dependency of the JSX element:
  return <div>{x}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Component State Mutation with Shared Runtime in JavaScript
DESCRIPTION: This snippet demonstrates a React component that manipulates an object state using a shared runtime's mutate function. The component takes props and modifies an internal state object, invoking an external mutation function to perform the update.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-simple-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function Component({a}) {
  let x = {a};
  let y = {};
  const f0 = function () {
    y = x;
  };
  f0();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 2}],
  sequentialRenders: [{a: 2}, {a: 2}, {a: 3}],
};

```

----------------------------------------

TITLE: Advanced React Hook with Memoization
DESCRIPTION: This snippet enhances the 'useFoo' hook by introducing memoization. It checks a sentinel value to either return a new text element or a cached one, improving performance by reducing unnecessary renders. It utilizes the 'react/compiler-runtime' for more complex runtime behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-memberexpr-tag.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as SharedRuntime from "shared-runtime";
function useFoo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <SharedRuntime.Text value={4} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: Implementing Memoization in a React Component using JavaScript
DESCRIPTION: This code snippet enhances a React component with memoization capabilities. Utilizing the React compiler runtime, it checks for a memo cache sentinel symbol to determine if the component's output can be retrieved from cache, optimizing performance. Dependencies include React and the React compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-args-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = makeObject();
    x.foo((x = makeObject()));
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

```

----------------------------------------

TITLE: React Component Definition (Optimized)
DESCRIPTION: This code snippet presents an optimized version of the `Component` using `react/compiler-runtime`. It uses a cache (`_c(4)`) to store previous results based on props. The optimized component memoizes its output based on `props.p0` and `props.p1`, avoiding re-renders if these props haven't changed. It effectively prevents unnecessary updates by checking if the props have changed before re-computing the component's output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.p0 || $[1] !== props.p1) {
    let x = [];
    x.push(props.p0);
    const y = x;
    let t1;
    if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = [];
      $[3] = t1;
    } else {
      t1 = $[3];
    }
    x = t1;

    y.push(props.p1);

    t0 = <Component x={x} y={y} />;
    $[0] = props.p0;
    $[1] = props.p1;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

```

----------------------------------------

TITLE: Compiler-Transformed React Component with Optimization
DESCRIPTION: The compiler-transformed version of the React component with explicit memoization caching. It uses a Symbol-based cache to avoid recalculating values that haven't changed between renders, implementing the same behavior as useMemo but with compiler optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-reloading.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableResetCacheOnSourceFileChanges
import { useMemo, useState } from "react";
import { ValidateMemoization } from "shared-runtime";

function Component(props) {
  const $ = _c(8);
  if (
    $[0] !== "20945b0193e529df490847c66111b38d7b02485d5b53d0829ff3b23af87b105c"
  ) {
    for (let $i = 0; $i < 8; $i += 1) {
      $[$i] = Symbol.for("react.memo_cache_sentinel");
    }
    $[0] = "20945b0193e529df490847c66111b38d7b02485d5b53d0829ff3b23af87b105c";
  }
  const [state] = useState(0);
  let t0;
  const t1 = state * 2;
  let t2;
  if ($[1] !== t1) {
    t2 = [t1];
    $[1] = t1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  t0 = t2;
  const doubled = t0;
  let t3;
  if ($[3] !== state) {
    t3 = [state];
    $[3] = state;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== doubled || $[6] !== t3) {
    t4 = <ValidateMemoization inputs={t3} output={doubled} />;
    $[5] = doubled;
    $[6] = t3;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Conditional Memoization with Custom Checks
DESCRIPTION: This snippet contains a component that checks if the memo cache sentinel is present and either creates or retrieves a memoized object. It enhances performance and avoids unnecessary re-computation using shared functions and React's memoization strategy.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-maybe-modified-later-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees
import { useMemo } from "react";
import { identity, makeObject_Primitives, mutate } from "shared-runtime";

function Component(props) {
  const $ = _c(1);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = makeObject_Primitives();
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  t0 = t1;
  const object = t0;
  identity(object);
  return object;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component that includes memoization logic using Symbol.for('react.memo_cache_sentinel') and compiler runtime utilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-outside-of-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    let x;
    x = null;
    const callback = () => {
      console.log(x);
    };

    x = {};
    t0 = <Stringify callback={callback} shouldInvokeFns={true} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Transformed React Component
DESCRIPTION: This snippet represents the transformed version of the React component, optimized by the React compiler. It introduces memoization using the `_c` function from `react/compiler-runtime` to store and reuse intermediate values. This reduces redundant computations during rendering by checking if input values have changed since the last render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequential-destructuring-both-mixed-local-and-scope-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(statusName) {
  const $ = _c(12);
  let font;
  let t0;
  let text;
  if ($[0] !== statusName) {
    const { status, text: t1 } = foo(statusName);
    text = t1;

    const { color, font: t2 } = getStyles(status);
    font = t2;

    t0 = identity(color);
    $[0] = statusName;
    $[1] = font;
    $[2] = t0;
    $[3] = text;
  } else {
    font = $[1];
    t0 = $[2];
    text = $[3];
  }
  const bg = t0;
  let t1;
  if ($[4] !== text) {
    t1 = [text];
    $[4] = text;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== font || $[7] !== t1) {
    t2 = <span className={font}>{t1}</span>;
    $[6] = font;
    $[7] = t1;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  let t3;
  if ($[9] !== bg || $[10] !== t2) {
    t3 = <div className={bg}>{t2}</div>;
    $[9] = bg;
    $[10] = t2;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
}

function foo(name) {
  const $ = _c(2);

  const t0 = `${name}!`;
  let t1;
  if ($[0] !== t0) {
    t1 = { status: `<status>`, text: t0 };
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function getStyles(status) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { font: "comic-sans", color: "#657b83" };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["Sathya"],
};

```

----------------------------------------

TITLE: Initializing Shared Runtime Mutation in JavaScript
DESCRIPTION: Defines a component function that creates an object with nested properties and applies a mutation using shared runtime. The function handles object creation and mutation with a closure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-mutate-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {mutate} = require('shared-runtime');

function component(a) {
  let x = {a};
  let y = {};
  (function () {
    y.x = x;
  })();
  mutate(y);
  return y;
}
```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimizations
DESCRIPTION: The transformed version of the component using React compiler runtime. Shows memoization and optimization techniques including cache sentinel checks and state management optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-function-shadowed-identifiers.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  const [x, setX] = useState(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (e) => {
      setX(_temp);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onChange = t0;
  let t1;
  if ($[1] !== x) {
    t1 = <input value={x} onChange={onChange} />;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
function _temp(currentX) {
  return currentX + null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Compiler Runtime Memoized Component
DESCRIPTION: The compiled version of the component using React's compiler runtime for memoization. It uses a cache sentinel to determine whether to create new objects or return previously cached ones for performance optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-nested-member-path.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const z = [];
    const y = {};
    y.z = z;
    x = {};
    x.y = y;
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component Implementation
DESCRIPTION: Compiled version of the React component showing how memoization is implemented at runtime. Uses the compiler-runtime to manage cached values and dependencies tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reordering-across-blocks.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Component(t0) {
  const $ = _c(9);
  const { config } = t0;
  let t1;
  let t2;
  if ($[0] !== config) {
    t2 = (event) => {
      config?.onA?.(event);
    };
    $[0] = config;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const a = t2;
  let t3;
  if ($[2] !== config) {
    t3 = (event_0) => {
      config?.onB?.(event_0);
    };
    $[2] = config;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const b = t3;
  let t4;
  if ($[4] !== a || $[5] !== b) {
    t4 = { b, a };
    $[4] = a;
    $[5] = b;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  t1 = t4;
  const object = t1;
  let t5;
  if ($[7] !== object) {
    t5 = <Stringify value={object} />;
    $[7] = object;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  return t5;
}
```

----------------------------------------

TITLE: Compiled useFoo function with React compiler-runtime
DESCRIPTION: This is the compiled version of the `useFoo` function. It uses `_c` from `react/compiler-runtime` for memoization and incorporates an early return mechanism. The function caches the results of conditional checks and input values to optimize performance in subsequent renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/reduce-if-exhaustive-nonpoisoned-deps1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(11);
  const { input, cond2, cond1 } = t0;
  let t1;
  let x;
  if ($[0] !== cond1 || $[1] !== cond2 || $[2] !== input.a.b) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      if (cond1) {
        if (!cond2) {
          let t2;
          if ($[5] !== input.a.b) {
            t2 = identity(input.a.b);
            $[5] = input.a.b;
            $[6] = t2;
          } else {
            t2 = $[6];
          }
          x.push(t2);
          t1 = null;
          break bb0;
        } else {
          let t2;
          if ($[7] !== input.a.b) {
            t2 = identity(input.a.b);
            $[7] = input.a.b;
            $[8] = t2;
          } else {
            t2 = $[8];
          }
          x.push(t2);
        }
      } else {
        let t2;
        if ($[9] !== input.a.b) {
          t2 = identity(input.a.b);
          $[9] = input.a.b;
          $[10] = t2;
        } else {
          t2 = $[10];
        }
        x.push(t2);
      }
    }
    $[0] = cond1;
    $[1] = cond2;
    $[2] = input.a.b;
    $[3] = t1;
    $[4] = x;
  } else {
    t1 = $[3];
    x = $[4];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { b: 1 }, cond1: true, cond2: false }],
  sequentialRenders: [
    { input: { a: { b: 1 } }, cond1: true, cond2: true },
    { input: null, cond1: true, cond2: false },
    // preserve nullthrows
    { input: { a: { b: undefined } }, cond1: true, cond2: true },
    { input: { a: null }, cond1: true, cond2: true },
    { input: { a: { b: undefined } }, cond1: true, cond2: true },
  ],
};

```

----------------------------------------

TITLE: Compiled React Components with Memoization
DESCRIPTION: Compiled version of the components with added memoization logic using the compiler runtime. Includes feature flag checks and cache management for optimized rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-function-and-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating @compilationMode(annotation)
const Bar = isForgetEnabled_Fixtures()
  ? function Bar(props) {
      "use forget";
      const $ = _c(2);
      let t0;
      if ($[0] !== props.bar) {
        t0 = <div>{props.bar}</div>;
        $[0] = props.bar;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : function Bar(props) {
      "use forget";
      return <div>{props.bar}</div>;
    };
export default Bar;

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}
const Foo = isForgetEnabled_Fixtures()
  ? function Foo(props) {
      "use forget";
      const $ = _c(3);
      if (props.bar < 0) {
        return props.children;
      }

      const t0 = props.bar - 1;
      let t1;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = <NoForget />;
        $[0] = t1;
      } else {
        t1 = $[0];
      }
      let t2;
      if ($[1] !== t0) {
        t2 = <Foo bar={t0}>{t1}</Foo>;
        $[1] = t0;
        $[2] = t2;
      } else {
        t2 = $[2];
      }
      return t2;
    }
  : function Foo(props) {
      "use forget";
      if (props.bar < 0) {
        return props.children;
      }
      return (
        <Foo bar={props.bar - 1}>
          <NoForget />
        </Foo>
      );
    };

export const FIXTURE_ENTRYPOINT = {
  fn: eval("Bar"),
  params: [{ bar: 2 }],
};
```

----------------------------------------

TITLE: Compiler-Transformed useKeyCommand Hook with Reactive Scope Optimization
DESCRIPTION: The React compiler-transformed version of the useKeyCommand hook that implements reactive scope optimization. It uses compiler runtime features to memoize function results and avoid unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/original-reactive-scopes-fork/capture-ref-for-later-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableReactiveScopesInHIR:false
import { useRef } from "react";
import { addOne } from "shared-runtime";

function useKeyCommand() {
  const $ = _c(1);
  const currentPosition = useRef(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const handleKey = (direction) => () => {
      const position = currentPosition.current;
      const nextPosition = direction === "left" ? addOne(position) : position;
      currentPosition.current = nextPosition;
    };

    const moveLeft = { handler: handleKey("left") };

    const moveRight = { handler: handleKey("right") };

    t0 = [moveLeft, moveRight];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useKeyCommand,
  params: [],
};
```

----------------------------------------

TITLE: Compiled Version of Custom React Hook Using Compiler Runtime
DESCRIPTION: This snippet shows the compiled version of the 'useTest' hook using React's compiler runtime. It includes memoization logic and optimizations for conditional rendering and value caching.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-allocating-ternary-test-instruction-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, makeObject_Primitives } from "shared-runtime";

function useHook() {}

function useTest(t0) {
  const $ = _c(3);
  const { cond } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = makeObject_Primitives();
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const val = t1;

  useHook();
  let t2;
  if ($[1] !== cond) {
    t2 = identity(cond) ? val : null;
    $[1] = cond;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const result = t2;
  return result;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [{ cond: true }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component with React's memoization logic implemented. Uses a sentinel value to check if cached values should be used or recomputed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-capture-item-of-local-collection-mutate-later-value-initially-null.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeObject_Primitives } from "shared-runtime";

function Component(props) {
  const $ = _c(1);
  let items;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    let lastItem = null;
    items = [makeObject_Primitives(), makeObject_Primitives()];
    for (const x of items) {
      lastItem = x;
    }
    if (lastItem != null) {
      lastItem.a = lastItem.a + 1;
    }
    $[0] = items;
  } else {
    items = $[0];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}, {}],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization Techniques
DESCRIPTION: This snippet shows the compiled version of the React component. It includes various optimization techniques, such as memoization and conditional rendering, to improve performance and efficiency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-memoize-array-with-mutable-map-after-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useState } from "react";
import { mutate } from "shared-runtime";

function Component(props) {
  const $ = _c(7);
  const x = [{ ...props.value }];
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(_temp, t0);
  const onClick = () => {
    console.log(x.length);
  };

  let y;

  const t1 = x.map(_temp2);
  let t2;
  if ($[1] !== y) {
    t2 = mutate(y);
    $[1] = y;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== onClick || $[4] !== t1 || $[5] !== t2) {
    t3 = (
      <div onClick={onClick}>
        {t1}
        {t2}
      </div>
    );
    $[3] = onClick;
    $[4] = t1;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}
function _temp2(item) {
  item.flag = true;
  return <span key={item.id}>{item.text}</span>;
}
function _temp() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: { id: 0, text: "Hello", flag: false } }],
  isComponent: true,
};
```

----------------------------------------

TITLE: Defining a Simple React Component with Constant (JavaScript)
DESCRIPTION: This snippet defines a React component 'Foo' that returns a constant value through a nested function. It imports an 'identity' function and exports a FIXTURE_ENTRYPOINT object for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-to-object-method.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function Foo() {
  const CONSTANT = 1;
  const x = {
    foo() {
      return identity(CONSTANT);
    },
  };
  return x.foo();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Cache Implementation
DESCRIPTION: The compiled version of the React component that implements caching logic using Symbol.for('react.memo_cache_sentinel'). It includes memoization of computation results and prop comparison for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-array-push.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  let t1;
  if ($[1] !== props.cond || $[2] !== props.value) {
    let y;
    if (props.cond) {
      y = [props.value];
    } else {
      y = [];
    }

    y.push(x);

    t1 = [x, y];
    $[1] = props.cond;
    $[2] = props.value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, value: 42 }],
  sequentialRenders: [
    { cond: true, value: 3.14 },
    { cond: false, value: 3.14 },
    { cond: true, value: 42 },
  ],
};
```

----------------------------------------

TITLE: Installing and Running React Compiler Tests
DESCRIPTION: Basic shell commands for setting up the development environment and running the React Compiler test suite using the custom 'snap' test runner in watch mode.
SOURCE: https://github.com/facebook/react/blob/main/compiler/docs/DEVELOPMENT_GUIDE.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
# Install dependencies
yarn

# build the custom test runner
yarn snap:build

# Run the primary tests in watch mode
yarn snap --watch
```

----------------------------------------

TITLE: Installing react-devtools as Project Dependency with Yarn
DESCRIPTION: Command for adding react-devtools as a development dependency to a specific project using Yarn. This approach avoids global installations by scoping the tool to a single project.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_1

LANGUAGE: shell
CODE:
```
yarn add --dev react-devtools
```

----------------------------------------

TITLE: Define and Export JavaScript Function
DESCRIPTION: This code defines a JavaScript function `foo` that takes two arguments, `a` and `b`. It initializes an array `x`, and if `a` is truthy, it reassigns `x` to the value `1`. Finally, it assigns `x` to `y` and returns `y`. The function is then exported as part of the `FIXTURE_ENTRYPOINT` object, which includes information about its parameters and its use as a component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-non-empty-initializer.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  let x = [];
  if (a) {
    x = 1;
  }

  let y = x;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Compiled React Component Output
DESCRIPTION: The compiled version of the component showing compiler runtime optimizations. Includes memo cache sentinel checking and extraction of the callback function into a separate function declaration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-unused-usecallback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useCallback, useEffect, useState } from "react";

function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div>Ok</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  window.foo = true;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React ForwardRef with Conditional Hook Call (Invalid)
DESCRIPTION: This code defines a `FancyButton` component using `React.forwardRef`. It attempts to conditionally call `useCustomHook` based on the `props.fancy` value. This is an invalid usage of hooks because hooks must be called in the same order on every render. It violates the Rules of Hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.rules-of-hooks-27c18dc8dad2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @skip
// Unsupported input

// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
const FancyButton = React.forwardRef((props, ref) => {
  if (props.fancy) {
    useCustomHook();
  }
  return <button ref={ref}>{props.children}</button>;
});
```

----------------------------------------

TITLE: Compiled React Component with FBT Optimizations
DESCRIPTION: This snippet shows the compiled version of the React component with FBT optimizations. It includes memoization for performance improvements and uses the FBT runtime functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-unmerged-fbt-call-merge-overlapping-reactive-scopes.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";
import { Stringify } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.cond || $[1] !== props.value.length) {
    const label = fbt._(
      { "*": "{number} bars", _1: "1 bar" },
      [fbt._plural(props.value.length, "number")],
      { hk: "4mUen7" },
    );

    t0 = props.cond ? (
      <Stringify
        description={fbt._("Text here", null, { hk: "21YpZs" })}
        label={label.toString()}
      />
    ) : null;
    $[0] = props.cond;
    $[1] = props.value.length;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, value: [0, 1, 2] }],
};
```

----------------------------------------

TITLE: Original JavaScript Function Implementation
DESCRIPTION: Original function implementation with conditional object creation and property assignment. The function creates new objects based on a condition and sets a property 'f' before returning.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-if-else.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  let x = someObj();
  if (a) {
    x = someObj();
  } else {
    x = someObj();
  }

  x.f = 1;
  return x;
}
```

----------------------------------------

TITLE: Compiler-Optimized React Component
DESCRIPTION: The compiler-transformed version of the component with optimizations like memoization cache, early returns using symbols, and efficient prop comparison logic. Demonstrates how React internally optimizes component rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-renaming-conflicting-decls.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify, identity, makeArray, toJSON } from "shared-runtime";
import { useMemo } from "react";

function Component(props) {
  const $ = _c(13);
  let t0;
  let t1;
  let t2;
  if ($[0] !== props) {
    t2 = Symbol.for("react.early_return_sentinel");
    bb0: {
      t0 = toJSON(props);
      const propsString = t0;
      if (propsString.length <= 2) {
        t2 = null;
        break bb0;
      }

      t1 = identity(propsString);
    }
    $[0] = props;
    $[1] = t1;
    $[2] = t2;
    $[3] = t0;
  } else {
    t1 = $[1];
    t2 = $[2];
    t0 = $[3];
  }
  if (t2 !== Symbol.for("react.early_return_sentinel")) {
    return t2;
  }
  let t3;
  if ($[4] !== t1) {
    t3 = { url: t1 };
    $[4] = t1;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const linkProps = t3;
  let t4;
  if ($[6] !== linkProps) {
    const x = {};
    let t5;
    let t6;
    let t7;
    let t8;
    let t9;
    if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
      t5 = [1];
      t6 = [2];
      t7 = [3];
      t8 = [4];
      t9 = [5];
      $[8] = t5;
      $[9] = t6;
      $[10] = t7;
      $[11] = t8;
      $[12] = t9;
    } else {
      t5 = $[8];
      t6 = $[9];
      t7 = $[10];
      t8 = $[11];
      t9 = $[12];
    }
    t4 = (
      <Stringify
        link={linkProps}
        val1={t5}
        val2={t6}
        val3={t7}
        val4={t8}
        val5={t9}
      >
        {makeArray(x, 2)}
      </Stringify>
    );
    $[6] = linkProps;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ val: 2 }],
};
```

----------------------------------------

TITLE: Input Hook Implementation in JavaScript
DESCRIPTION: Initial implementation of a React hook using createHookWrapper and mutate function, creating an object with a method that mutates its input
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-3.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper, mutate} from 'shared-runtime';

function useHook(a) {
  const x = {a};
  let obj = {
    method() {
      mutate(x);
      return x;
    },
  };
  return obj.method();
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{x: 1}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization and Function Extraction
DESCRIPTION: Compiler output showing how React transforms the component. The compiler extracts the arrow function to a separate _temp function and implements memoization using Symbol.for("react.memo_cache_sentinel") to optimize rendering performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-nested-object-method.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)

import { Stringify } from "shared-runtime";

function Test() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const context = {
      testFn() {
        return _temp;
      },
    };

    t0 = <Stringify value={context} shouldInvokeFns={true} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  return "test";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: The compiled version of the component with React compiler optimizations. It uses memoization and change detection to avoid unnecessary re-renders and calculations, maintaining references to previous values using an array cache.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-memo-value-not-promoted-to-outer-scope-dynamic.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(15);
  const item = useFragment(FRAGMENT, props.item);
  useFreeze(item);
  let T0;
  let T1;
  let t0;
  let t1;
  if ($[0] !== item) {
    const count = new MaybeMutable(item);

    T1 = View;
    T0 = View;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = <span>Text</span>;
      $[5] = t1;
    } else {
      t1 = $[5];
    }
    t0 = maybeMutate(count);
    $[0] = item;
    $[1] = T0;
    $[2] = T1;
    $[3] = t0;
    $[4] = t1;
  } else {
    T0 = $[1];
    T1 = $[2];
    t0 = $[3];
    t1 = $[4];
  }
  let t2;
  if ($[6] !== t0) {
    t2 = <span>{t0}</span>;
    $[6] = t0;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  let t3;
  if ($[8] !== T0 || $[9] !== t1 || $[10] !== t2) {
    t3 = (
      <T0>
        {t1}
        {t2}
      </T0>
    );
    $[8] = T0;
    $[9] = t1;
    $[10] = t2;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  let t4;
  if ($[12] !== T1 || $[13] !== t3) {
    t4 = <T1>{t3}</T1>;
    $[12] = T1;
    $[13] = t3;
    $[14] = t4;
  } else {
    t4 = $[14];
  }
  return t4;
}
```

----------------------------------------

TITLE: React Component with FBT Internationalization - Compiled
DESCRIPTION: Compiled output of the FBT component with optimized rendering and caching logic. Implements plural forms and parameter interpolation with proper memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-trailing-whitespace.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.count || $[1] !== props.option) {
    t0 = (
      <span>
        {fbt._(
          { "*": "{count} votes for {option}", _1: "1 vote for {option}" },
          [
            fbt._plural(identity(props.count), "count"),
            fbt._param(
              "option",

              props.option,
            ),
          ],
          { hk: "3Bg20a" },
        )}
        !
      </span>
    );
    $[0] = props.count;
    $[1] = props.option;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ count: 42, option: "thing" }],
  sequentialRenders: [
    { count: 42, option: "thing" },
    { count: 42, option: "thing" },
    { count: 1, option: "other" },
    { count: 1, option: "other" },
    { count: 42, option: "thing" },
    { count: 1, option: "other" },
    { count: 42, option: "thing" },
    { count: 1, option: "other" },
  ],
};
```

----------------------------------------

TITLE: Input React Hook Implementation with Test Fixture
DESCRIPTION: Original implementation of useFoo hook that processes an array and returns both the processed array and callback function. Includes test fixture configuration for sequential renders with different inputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/jsx-and-passed.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper} from 'shared-runtime';

function useFoo({arr1}) {
  const cb1 = e => arr1[0].value + e.value;
  const x = arr1.map(cb1);
  return [x, cb1];
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useFoo),
  params: [{arr1: [], arr2: []}],
  sequentialRenders: [
    {arr1: [], arr2: []},
    {arr1: [], arr2: null},
    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},
  ],
};
```

----------------------------------------

TITLE: React Component with XML Attribute
DESCRIPTION: This snippet defines a React component that renders an XML element with a dynamic attribute. The `protocol:version` attribute of the `xml:http` element is set to the value of the `version` prop passed to the component.  It also exports a fixture entry point for testing or demonstration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-namespaced-name.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return <xml:http protocol:version={props.version} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Defining Component Logic with Reactive Values using React Compiler Runtime in JavaScript
DESCRIPTION: This snippet enhances the previous component definition by using the React Compiler Runtime. It creates a reactive component where the values of x and y utilize React's state management. The while loop ensures that y fetches the value from props reactively, allowing for state updates in response to changes. The final output will also be an array containing the updated value of x, leveraging the compiler's optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-fixpoint.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x = 0;
  let y = 0;
  while (x === 0) {
    x = y;
    y = props.value;
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Using Stringify Component in React - JavaScript
DESCRIPTION: This snippet demonstrates the use of the Stringify component to render a React component based on the evaluation of a nested property. It depends on the shared-runtime and expects an object parameter with nested properties to evaluate. Expected inputs are objects with deeply nested structures.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-hoisted.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```

// @enablePropagateDepsInHIR

import {Stringify} from 'shared-runtime';

function useFoo({a}) {
  return <Stringify fn={() => a.b.c} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: null}],
  sequentialRenders: [{a: null}, {a: {b: {c: 4}}}],
};

```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime Memoization
DESCRIPTION: Transformed version of the React component using React compiler runtime for state tracking, memoization, and conditional re-rendering
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/same-variable-as-dep-and-redeclare-maybe-frozen.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(props) {
  const $ = _c(16);
  let x;
  if ($[0] !== props.a) {
    x = [];
    x.push(props.a);
    $[0] = props.a;
    $[1] = x;
  } else {
    x = $[1];
  }
  // ... rest of the optimized implementation
  return t2;
}
```

----------------------------------------

TITLE: Defining useFoo function and fixture entrypoint in React
DESCRIPTION: This code defines a `useFoo` function that takes an input object and conditional flags as arguments. It conditionally pushes the result of `identity(input.a.b)` to an array based on the values of `cond1` and `cond2`.  It also exports a `FIXTURE_ENTRYPOINT` object that contains test data for the function, including parameters and expected sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/reduce-if-exhaustive-nonpoisoned-deps1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function useFoo({input, cond2, cond1}) {
  const x = [];
  if (cond1) {
    if (!cond2) {
      x.push(identity(input.a.b));
      return null;
    } else {
      x.push(identity(input.a.b));
    }
  } else {
    x.push(identity(input.a.b));
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {b: 1}, cond1: true, cond2: false}],
  sequentialRenders: [
    {input: {a: {b: 1}}, cond1: true, cond2: true},
    {input: null, cond1: true, cond2: false},
    // preserve nullthrows
    {input: {a: {b: undefined}}, cond1: true, cond2: true},
    {input: {a: null}, cond1: true, cond2: true},
    {input: {a: {b: undefined}}, cond1: true, cond2: true},
  ],
};

```

----------------------------------------

TITLE: Fixture Entrypoint for Function Hook Testing
DESCRIPTION: Defines test parameters and sequential renders for the useFoo function, providing a test fixture to validate component behavior under different prop conditions
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};
```

----------------------------------------

TITLE: Compiled React Hook Component
DESCRIPTION: Compiled version of the React hook with added memoization and feature flag handling. Includes compiler runtime imports and conditional implementations based on feature flags.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-nonreferenced-identifier-collision.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
import { identity, useHook as useRenamed } from "shared-runtime";
const _ = {
  useHook: isForgetEnabled_Fixtures() ? () => {} : () => {},
};
identity(_.useHook);
const useHook = isForgetEnabled_Fixtures()
  ? function useHook() {
      const $ = _c(1);
      useRenamed();
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = <div>hello world!</div>;
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : function useHook() {
      useRenamed();
      return <div>hello world!</div>;
    };

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React.memo Component with Compiler-Runtime
DESCRIPTION: Compiled output code showing how React optimizes the memoized component with a caching mechanism. It imports a compiler runtime utility and implements a cache check to avoid recreating the div element on re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-React-memo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
React.memo((props) => {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
});
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows the compiler-optimized version of the React component. It implements memoization using a caching mechanism to avoid unnecessary re-computations and preserves the original component's behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/memberexpr-join-optional-chain.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
// To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a.b` or a subpath as a dependency.
//
// (1) Since the reactive block producing x unconditionally read props.a.<...>,
//     reading `props.a.b` outside of the block would still preserve nullthrows
//     semantics of source code
// (2) Technically, props.a, props.a.b, and props.a.b.c are all reactive deps.
//     However, `props.a?.b` is only dependent on whether `props.a` is nullish,
//     not its actual value. Since we already preserve nullthrows on `props.a`,
//     we technically do not need to add `props.a` as a dependency.

function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.a.b) {
    x = [];
    x.push(props.a?.b);
    x.push(props.a.b.c);
    $[0] = props.a.b;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: { b: { c: 1 } } }],
};
```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: An optimized version of the React component using React's compiler runtime for efficient memoization and object caching
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-if-else-multiple-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  let t0;
  bb0: {
    if (props.cond) {
      let t1;
      if ($[0] !== props.a) {
        t1 = makeObject(props.a);
        $[0] = props.a;
        $[1] = t1;
      } else {
        t1 = $[1];
      }
      t0 = t1;
      break bb0;
    }
    let t1;
    if ($[2] !== props.b) {
      t1 = makeObject(props.b);
      $[2] = props.b;
      $[3] = t1;
    } else {
      t1 = $[3];
    }
    t0 = t1;
  }
  const x = t0;
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This code presents the compiled version of the `Component` function using `react/compiler-runtime`. It imports `_c` from the runtime, which is used for memoization. The component now uses `_c(4)` to create a memoized scope (`$`) and checks if the input `c`, calculated `h` and `i` have changed. If they have, it updates the memoized result; otherwise, it returns the cached result, improving performance by avoiding unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-3.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0) {
  const $ = _c(4);
  let { c } = t0;
  const h = c++;
  const i = --c;
  let t1;
  if ($[0] !== c || $[1] !== h || $[2] !== i) {
    t1 = [c, h, i];
    $[0] = c;
    $[1] = h;
    $[2] = i;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ c: 4 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized VideoTab Component with Compiler Runtime
DESCRIPTION: An enhanced version of the VideoTab component using React compiler runtime for memoization and caching, with explicit caching logic and Symbol-based cache management
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-not-added-to-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function VideoTab() {
  const $ = _c(1);
  const ref = useRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = () => {
      console.log(ref.current);
    };

    t0 = <VideoList videos={x} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled React Component with Inferred Effect Dependencies
DESCRIPTION: Shows the transformed code after React's compiler has processed it to automatically infer and track dependencies for the useEffect hook. The compiler adds caching logic to optimize re-renders and correctly identifies the ref objects as dependencies rather than their .current properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-ref-helper.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect } from "react";
import { print } from "shared-runtime";

/**
 * We never include a .current access in a dep array because it may be a ref access.
 * This might over-capture objects that are not refs and happen to have fields named
 * current, but that should be a rare case and the result would still be correct
 * (assuming the effect is idempotent). In the worst case, you can always write a manual
 * dep array.
 */
function RefsInEffects() {
  const $ = _c(3);
  const ref = useRefHelper();
  const wrapped = useDeeperRefHelper();
  let t0;
  if ($[0] !== ref.current || $[1] !== wrapped.foo.current) {
    t0 = () => {
      print(ref.current);
      print(wrapped.foo.current);
    };
    $[0] = ref.current;
    $[1] = wrapped.foo.current;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  useEffect(t0, [ref, wrapped.foo]);
}

function useRefHelper() {
  return useRef(0);
}

function useDeeperRefHelper() {
  const $ = _c(2);
  const t0 = useRefHelper();
  let t1;
  if ($[0] !== t0) {
    t1 = { foo: t0 };
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Defining Component Logic with Non-reactive Values in JavaScript
DESCRIPTION: This snippet defines a simple React component that initializes two variables, x and y, as non-reactive values. The component processes props and uses a while loop to make y reactive, then flows this value into x. The expected output from invoking this component is an array containing the final value of x.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-fixpoint.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  let y = 0;

  while (x === 0) {
    x = y;
    y = props.value;
  }

  // x and y initially start out with non-reactive values,
  // but after an iteration of the loop y becomes reactive,
  // and this reactive value then flows into x on the next
  // loop iteration, making x reactive.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Transformed TypeScript-like Code in React
DESCRIPTION: This snippet shows the transformed version of the input code, removing Flow annotations and type aliases. It retains the core functionality of the 'TypeAliasUsedAsAnnotation' function and the 'FIXTURE_ENTRYPOINT' export.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-used-as-annotation_.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
type Bar = string;
function TypeAliasUsedAsAnnotation() {
  const fun = _temp;

  fun("hello, world");
}
function _temp(f) {
  console.log(f);
}

export const FIXTURE_ENTRYPOINT = {
  fn: TypeAliasUsedAsAnnotation,
  params: [],
};
```

----------------------------------------

TITLE: Optimized Hook Function with React Compiler Runtime JavaScript
DESCRIPTION: This optimized JavaScript code snippet involves creating a custom hook with dynamic properties `x`, `y`, and `z`, utilizing caching mechanisms for performance. It imports `_c` from `react/compiler-runtime` and `createHookWrapper` from `shared-runtime`. The function takes `a`, `b`, and `c` as parameters and returns an object based on cache states to minimize recalculation. Dependencies include specific modules for runtime and caching, with the expected output being an optimized reactive object representation. The usage is constrained to environments with React compiler-runtime support.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-2.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper } from "shared-runtime";

function useHook(t0) {
  const $ = _c(8);
  const { a, b, c } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = [a];
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== b || $[3] !== c || $[4] !== t1) {
    let t3;
    if ($[6] !== c) {
      t3 = { c };
      $[6] = c;
      $[7] = t3;
    } else {
      t3 = $[7];
    }
    t2 = {
      x: t1,
      y() {
        return [b];
      },
      z: t3,
    };
    $[2] = b;
    $[3] = c;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ a: 1, b: 2, c: 2 }],
};
```

----------------------------------------

TITLE: Initializing Compiler-Transformed React Function
DESCRIPTION: A React function demonstrating compiler runtime transformation with memoization and shallow copying of complex objects
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-local-var.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({a}: {a: {b: {c: number}}}) {
  const local = shallowCopy(a);
  mutate(local);
  const fn = () => local.b.c;
  return <Stringify fn={fn} shouldInvokeFns={true} />;
}
```

LANGUAGE: javascript
CODE:
```
function useFoo(t0) {
  const $ = _c(6);
  const { a } = t0;
  let local;
  if ($[0] !== a) {
    local = shallowCopy(a);
    mutate(local);
    $[0] = a;
    $[1] = local;
  } else {
    local = $[1];
  }
  // ... rest of transformed function
}
```

----------------------------------------

TITLE: Conditional Symbol and Identity Handling in React - JavaScript
DESCRIPTION: Implements 'useFoo' with additional logic for optimizations using symbols and compiler runtime integration. It handles state changes to prevent redundant computations, checking conditions against precalculated states. The snippet uses symbols 'react.early_return_sentinel' for control flow. Parameters include an object with 'input' and 'cond', outputting conditional results based on render sequences.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-poisons-outer-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(6);
  const { input, cond } = t0;
  let t1;
  let x;
  if ($[0] !== cond || $[1] !== input) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      if (cond) {
        t1 = null;
        break bb0;
      }
      let t2;
      if ($[4] !== input.a.b) {
        t2 = identity(input.a.b);
        $[4] = input.a.b;
        $[5] = t2;
      } else {
        t2 = $[5];
      }
      x.push(t2);
    }
    $[0] = cond;
    $[1] = input;
    $[2] = t1;
    $[3] = x;
  } else {
    t1 = $[2];
    x = $[3];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { a: { b: 2 } }, cond: false }],
  sequentialRenders: [
    { input: { a: { b: 2 } }, cond: false },
    // preserve nullthrows
    { input: null, cond: false },
    { input: null, cond: true },
    { input: {}, cond: false },
    { input: { a: { b: null } }, cond: false },
    { input: { a: null }, cond: false },
    { input: { a: { b: 3 } }, cond: false },
  ],
};
```

----------------------------------------

TITLE: Defining StoreLandingUnseenGiftModalContainer Function Component
DESCRIPTION: This snippet defines the StoreLandingUnseenGiftModalContainer function which takes a parameter 'a' representing the gifts seen. It returns a function that checks if a gift is seen or not. It is a simple utility component that checks the visibility status of gifts.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-skip-computed-path.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function StoreLandingUnseenGiftModalContainer(a) {
  const giftsSeen = {a};
  return (gift => (gift.id ? giftsSeen[gift.id] : false))();
}

export const FIXTURE_ENTRYPOINT = {
  fn: StoreLandingUnseenGiftModalContainer,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Optimized useTest Function with Memoization in JavaScript
DESCRIPTION: This snippet shows an optimized version of the 'useTest' function with memoization. It uses the '_c' function from 'react/compiler-runtime' to create a memoization cache, improving performance by avoiding unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-slow-validate-preserve-memo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { Builder } from "shared-runtime";
function useTest(t0) {
  const $ = _c(3);
  const { isNull, data } = t0;
  let t1;
  if ($[0] !== data || $[1] !== isNull) {
    t1 = Builder.makeBuilder(isNull, "hello world")
      ?.push("1", 2)
      ?.push(3, { a: 4, b: 5, c: data })
      ?.push(
        6,

        data,
      )
      ?.push(7, "8")
      ?.push("8", Builder.makeBuilder(!isNull)?.push(9).vals)?.vals;
    $[0] = data;
    $[1] = isNull;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const result = t1;
  return result;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [{ isNull: false, data: "param" }],
};
```

----------------------------------------

TITLE: Implementing Reactive Component with Compiler Runtime in JavaScript
DESCRIPTION: This JavaScript snippet implements a Reactive style Component with optional chaining. It includes an import from the 'react/compiler-runtime' which suggests a custom React compiler setup. The function compares and stores component state efficiently, minimizing recalculation. This relies on JavaScript optional chaining and state management in a reactive paradigm.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-chain.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Note that `a?.b.c` is semantically different from `(a?.b).c`
// We should codegen the correct member expressions
function Component(props) {
  const $ = _c(3);
  const x = props?.b.c;
  const y = props?.b.c.d?.e.f.g?.h;
  let t0;
  if ($[0] !== x || $[1] !== y) {
    t0 = { x, y };
    $[0] = x;
    $[1] = y;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: React Array Memoization Input Source
DESCRIPTION: Source code for a React test fixture that validates array memoization using Array.from(). Includes a validation component and a hook that creates and updates an array with memoized values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-inference-array-from.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useIdentity, ValidateMemoization} from 'shared-runtime';

/**
 * Fixture to assert that we can infer the type and effects of an array created
 * with `Array.from`.
 */
function Validate({x, val1, val2}) {
  'use no memo';
  return (
    <>
      <ValidateMemoization
        inputs={[val1]}
        output={x[0]}
        onlyCheckCompiled={true}
      />
      <ValidateMemoization
        inputs={[val2]}
        output={x[1]}
        onlyCheckCompiled={true}
      />
    </>
  );
}
function useFoo({val1, val2}) {
  'use memo';
  const x = Array.from([]);
  useIdentity();
  x.push([val1]);
  x.push([val2]);
  return <Validate x={x} val1={val1} val2={val2} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{val1: 1, val2: 2}],
  params: [
    {val1: 1, val2: 2},
    {val1: 1, val2: 2},
    {val1: 1, val2: 3},
    {val1: 4, val2: 2},
  ],
};
```

----------------------------------------

TITLE: Defining a test fixture for React component (compiled)
DESCRIPTION: This JavaScript code defines a `FIXTURE_ENTRYPOINT` object, after compilation. It contains the `useFoo` function (compiled), an array of `params` with sample inputs, and a `sequentialRenders` array for testing different scenarios with varying input values and conditions, including null and empty objects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-label.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { a: { b: 2 } }, cond: false }],
  sequentialRenders: [
    { input: { a: { b: 2 } }, cond: false },
    // preserve nullthrows
    { input: null, cond: false },
    { input: null, cond: true },
    { input: {}, cond: false },
    { input: { a: { b: null } }, cond: false },
    { input: { a: null }, cond: false },
    { input: { a: { b: 3 } }, cond: false },
  ],
};
```

----------------------------------------

TITLE: Compiled React Hook with Dependency Tracking
DESCRIPTION: This code presents the compiled version of the `useFoo` hook. It utilizes `_c` from `react/compiler-runtime` for dependency tracking. The code checks if the props (`props.bar`, `props.cond`, `props.foo`) have changed since the last render. If so, it re-executes the original logic, otherwise, it reuses the cached value in `$[3]`. This optimized version aims to prevent unnecessary re-renders.  It also shows the use of the `mutate` function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { mutate } from "shared-runtime";

function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    x = [];
    x.push(props.bar);
    props.cond ? ((x = []), x.push(props.foo)) : null;
    mutate(x);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};

```

----------------------------------------

TITLE: React Component with Memoized View (Code with compiler)
DESCRIPTION: This code snippet demonstrates how the React compiler runtime optimizes a React component using internal caching mechanisms. The `_c` function is part of the compiler runtime and helps to cache intermediate results to avoid redundant computations.  The `View` component is memoized to prevent unnecessary re-renders by checking if the `items` prop has changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-react-memo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    t0 = <View {...props} />;
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

const View = React.memo((t0) => {
  const $ = _c(4);
  const { items } = t0;
  let t1;
  if ($[0] !== items) {
    t1 = items.map(_temp);
    $[0] = items;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== t1) {
    t2 = <ul>{t1}</ul>;
    $[2] = t1;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
});

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      items: [
        { id: 2, name: "foo" },
        { id: 3, name: "bar" },
      ],
    },
  ],
};
function _temp(item) {
  return <li key={item.id}>{item.name}</li>;
}

```

----------------------------------------

TITLE: Using Action State with Memoization in React Component (Extended Version)
DESCRIPTION: This snippet illustrates an enhanced version of the initial component where memoization is introduced using the '_c' function from 'react/compiler-runtime'. It manages the memoization of the component rendering by caching the output. Similar to the first snippet, it uses the 'useActionState' hook for handling actions. The use case remains the same, but with optimizations for re-rendering. Dependencies include the React library and the compiler runtime. It takes props for action handlers and returns the rendered component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useActionState-dispatch-considered-as-non-reactive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useActionState } from "react";

function Component() {
  const $ = _c(1);
  const [, dispatchAction] = useActionState();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const onSubmitAction = () => {
      dispatchAction();
    };

    t0 = <Foo onSubmitAction={onSubmitAction} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function Foo() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: Implementing a React Hook with Conditional Logic Using Label Statement
DESCRIPTION: This snippet implements a React hook called useFoo that conditionally manipulates an array based on input parameters. It uses a label statement with break to conditionally skip part of the logic, demonstrating a pattern for conditional manipulation of mutable state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-label.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {arrayPush} from 'shared-runtime';

function useFoo({cond, value}) {
  let items;
  label: {
    items = [];
    // Mutable range of `items` begins here, but its reactive scope block
    // should be aligned to above the label-block
    if (cond) break label;
    arrayPush(items, value);
  }
  arrayPush(items, value);
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: true, value: 2}],
  sequentialRenders: [
    {cond: true, value: 2},
    {cond: true, value: 2},
    {cond: true, value: 3},
    {cond: false, value: 3},
  ],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoized Effect - Compiled Version
DESCRIPTION: This snippet presents an optimized, compiled version of the React component. It uses memoization techniques to optimize re-renders and effect dependencies, demonstrating advanced React optimization strategies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merged-scopes-are-valid-effect-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateMemoizedEffectDependencies

import { useEffect } from "react";

function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.value) {
    t0 = [[props.value]];
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const y = t0;
  let t1;
  let t2;
  if ($[2] !== y) {
    t1 = () => {
      console.log(y);
    };
    t2 = [y];
    $[2] = y;
    $[3] = t1;
    $[4] = t2;
  } else {
    t1 = $[3];
    t2 = $[4];
  }
  useEffect(t1, t2);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: BuildHIR Error for Computed Property Key
DESCRIPTION: This error message shows that the BuildHIR process cannot handle a CallExpression as a key in an ObjectExpression. The error points to line 6 where mutateAndReturn(key) is used as a computed property name.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-modified-during-after-construction.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  4 |   const key = {};
  5 |   const context = {
> 6 |     [mutateAndReturn(key)]: identity([props.value]),
    |      ^^^^^^^^^^^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Expected Identifier, got CallExpression key in ObjectExpression (6:6)
  7 |   };
  8 |   mutate(key);
  9 |   return context;
```

----------------------------------------

TITLE: Compiled React Component with Feature Flags
DESCRIPTION: Compiled version of the React components with forget feature flag implementation, including memoization and conditional rendering logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-gating-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
import { Stringify } from "shared-runtime";

const ErrorView = isForgetEnabled_Fixtures()
  ? (error, _retry) => {
      const $ = _c(2);
      let t0;
      if ($[0] !== error) {
        t0 = <Stringify error={error} />;
        $[0] = error;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : (error, _retry) => <Stringify error={error}></Stringify>;

const Renderer = isForgetEnabled_Fixtures()
  ? (props) => {
      const $ = _c(1);
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = (
          <div>
            <span />
            <ErrorView />
          </div>
        );
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : (props) => (
      <div>
        <span></span>
        <ErrorView></ErrorView>
      </div>
    );
export default Renderer;

export const FIXTURE_ENTRYPOINT = {
  fn: eval("Renderer"),
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Inferred Effect Dependencies
DESCRIPTION: The compiled version of the component after transformation. The arrow function has been outlined to a separate named function '_temp', and an empty dependencies array has been inferred. This demonstrates how React's dependency inference handles outlined functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/outlined-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import { useEffect } from "react";
import { print } from "shared-runtime";
/**
 * This compiled output is technically incorrect but this is currently the same
 * case as a bailout (an effect that overfires).
 *
 * To ensure an empty deps array is passed, we need special case
 * `InferEffectDependencies` for outlined functions (likely easier) or run it
 * before OutlineFunctions
 */
function OutlinedFunctionInEffect() {
  useEffect(_temp, []);
}
function _temp() {
  return print("hello world!");
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the 'Foo' component using memoization techniques. It includes caching mechanisms to prevent unnecessary re-renders and optimizes the useEffect hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-parameter-mutate-in-effect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect } from "react";

function Foo(props, ref) {
  const $ = _c(5);
  let t0;
  if ($[0] !== ref) {
    t0 = () => {
      ref.current = 2;
    };
    $[0] = ref;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  useEffect(t0, t1);
  let t2;
  if ($[3] !== props.bar) {
    t2 = <div>{props.bar}</div>;
    $[3] = props.bar;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ bar: "foo" }, { ref: { current: 1 } }],
  isComponent: true,
};
```

----------------------------------------

TITLE: Test Fixture Configuration for React Hook
DESCRIPTION: Configuration object defining test parameters for the useFoo hook. Includes initial parameters and a sequence of render states to test various conditions including null inputs that would cause runtime errors.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-poisons-outer-scope.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { a: { b: 2 } }, cond: false }],
  sequentialRenders: [
    { input: { a: { b: 2 } }, cond: false },
    // preserve nullthrows
    { input: null, cond: false },
    { input: null, cond: true },
    { input: {}, cond: false },
    { input: { a: { b: null } }, cond: false },
    { input: { a: null }, cond: false },
    { input: { a: { b: 3 } }, cond: false },
  ],
};
```

----------------------------------------

TITLE: Complex Conditional Function Implementation in JavaScript
DESCRIPTION: A multi-level conditional function that assigns values to variable x based on nested conditions and returns the final value
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-multiple-phis.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  let x = 0;
  if (true) {
    if (true) {
      x = a;
    } else {
      x = b;
    }
    x;
  } else {
    if (true) {
      x = c;
    } else {
      x = d;
    }
    x;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with added memoization logic and transformed FBT calls. Includes symbol-based caching mechanism and early return optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-no-value-for-temporary-reactive-scope-with-early-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, makeObject_Primitives } from "shared-runtime";
import fbt from "fbt";

function Component(props) {
  const $ = _c(2);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const object = makeObject_Primitives();
      const cond = makeObject_Primitives();
      if (!cond) {
        t1 = null;
        break bb0;
      }

      t0 = (
        <div className="foo">
          {fbt._(
            "Lorum ipsum{thing} blah blah blah",
            [fbt._param("thing", object.b)],
            { hk: "lwmuH" },
          )}
        </div>
      );
    }
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return t0;
}
```

----------------------------------------

TITLE: Initializing React Component with Name Rendering
DESCRIPTION: Defines a React functional component that renders its own name within a div element. Supports conditional compilation based on feature flags.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-access-function-name-in-component.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
function Component() {
  const name = Component.name;
  return <div>{name}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
const Component = isForgetEnabled_Fixtures()
  ? function Component() {
      const $ = _c(1);
      const name = Component.name;
      let t0;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = <div>{name}</div>;
        $[0] = t0;
      } else {
        t0 = $[0];
      }
      return t0;
    }
  : function Component() {
      const name = Component.name;
      return <div>{name}</div>;
    };

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Using Compiler Runtime in React Component
DESCRIPTION: This snippet demonstrates a React component with enhanced state management via a compiler runtime helper. It adapts the initial mutable state based on property changes, preserving state between renders with a cache-like mechanism. Dependencies include 'react/compiler-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-mutate-after-capture.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // x's mutable range should extend to `mutate(y)`

function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.b) {
    x = [42, {}];
    const idx = foo(props.b);
    const y = x.at(idx);
    mutate(y);
    $[0] = props.b;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

```

----------------------------------------

TITLE: Compiler-Optimized Component Implementation
DESCRIPTION: Optimized version of the component using React's compiler runtime for memoization. Uses Symbol.for('react.memo_cache_sentinel') to cache object creation and prevent unnecessary recreations between renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-field-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { t: 1 };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  const p = x.t;
  return p;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component Definition with Reactive Props
DESCRIPTION: This code defines a React component that uses a for loop whose update expression is determined by the `props.update` value. Although the variable `x` is directly assigned non-reactive values, its value depends on the loop variable `i`, whose update is influenced by `props.update`. This makes `x` implicitly reactive. The component returns an array containing `x`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-update.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  for (let i = 0; i < 10; i += props.update) {
    if (i > 0 && i % 2 === 0) {
      x = 2;
    } else {
      x = 1;
    }
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" variable `i`, whose possible values are
  // affected by `props.update` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {update: 2},
    {update: 2},
    {update: 1},
    {update: 1},
    {update: 2},
    {update: 1},
    {update: 2},
    {update: 1},
  ],
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows an optimized version of the 'useFoo' component using memoization techniques. It uses a custom compiler runtime to cache previous results and avoid unnecessary computations, improving performance for repeated renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-maybe-null-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

/**
 * Not safe to hoist read of maybeNullObject.value.inner outside of the
 * try-catch block, as that might throw
 */
function useFoo(maybeNullObject) {
  const $ = _c(4);
  let y;
  if ($[0] !== maybeNullObject) {
    y = [];
    try {
      let t0;
      if ($[2] !== maybeNullObject.value.inner) {
        t0 = identity(maybeNullObject.value.inner);
        $[2] = maybeNullObject.value.inner;
        $[3] = t0;
      } else {
        t0 = $[3];
      }
      y.push(t0);
    } catch {
      y.push("null");
    }
    $[0] = maybeNullObject;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [null],
  sequentialRenders: [null, { value: 2 }, { value: 3 }, null],
};
```

----------------------------------------

TITLE: Compiled React useFoo Function and Fixture
DESCRIPTION: This code represents the compiled version of the `useFoo` function using `react/compiler-runtime`. It introduces memoization using `_c` to optimize re-renders based on changes to `cond` and `input`.  The `FIXTURE_ENTRYPOINT` remains the same, providing the test scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/else-branch-scope-unpoisoned.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(5);
  const { input, cond } = t0;
  let x;
  if ($[0] !== cond || $[1] !== input) {
    x = [];
    bb0: if (cond) {
      break bb0;
    } else {
      let t1;
      if ($[3] !== input.a.b) {
        t1 = identity(input.a.b);
        $[3] = input.a.b;
        $[4] = t1;
      } else {
        t1 = $[4];
      }
      x.push(t1);
    }
    $[0] = cond;
    $[1] = input;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x[0];
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { a: { b: 2 } }, cond: false }],
  sequentialRenders: [
    { input: null, cond: true },
    { input: { a: { b: 2 } }, cond: false },
    { input: null, cond: true },
    // preserve nullthrows
    { input: {}, cond: false },
    { input: { a: { b: null } }, cond: false },
    { input: { a: null }, cond: false },
    { input: { a: { b: 3 } }, cond: false },
  ],
};

```

----------------------------------------

TITLE: Rendering and Memoization in React Component
DESCRIPTION: This snippet demonstrates how to use memoization to optimize rendering in a React component. With the help of an imported memoization method from 'react/compiler-runtime', it checks for cached values before rendering the child component 'Child'. If a cache hit occurs, it reuses the previously rendered component, otherwise, it renders a new instance. This is encapsulated in 'FIXTURE_ENTRYPOINT' for export.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/quoted-strings-in-jsx-attribute-escaped.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
export function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Child text={'Some \\"text\"'} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function Child(props) {
  return props.text;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: React Component with Global State - Compiled Output
DESCRIPTION: The compiled version of the React component showing the internal implementation details after compilation. It includes compiler-specific optimizations, memoization logic, and the React runtime utilities for handling effects and state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutate-global-in-effect-fixpoint.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useState } from "react";

let someGlobal = { value: null };

function Component() {
  const $ = _c(5);
  const [state, setState] = useState(someGlobal);

  let x = someGlobal;
  while (x == null) {
    x = someGlobal;
  }

  const y = x;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      y.value = "hello";
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(t0);
  let t1;
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      setState(someGlobal.value);
    };
    t2 = [someGlobal];
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useEffect(t1, t2);

  const t3 = String(state);
  let t4;
  if ($[3] !== t3) {
    t4 = <div>{t3}</div>;
    $[3] = t3;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Original React Component Input
DESCRIPTION: Original source code showing a simple component function that creates an object combining a parameter and global variable. Includes test fixture configuration for the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-capture-global.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
let someGlobal = {};
function component(a) {
  let x = {a, someGlobal};
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['value 1'],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining Memoized React Component - JavaScript
DESCRIPTION: This snippet defines a React functional component that incorporates memoization logic using the React compiler runtime. It checks if the component's states are memoized and returns either a new object or the memoized values, optimizing performance by avoiding unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-String.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  const y = String(x);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [x, y];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimizing React Component Performance with Compiler Runtime in JavaScript
DESCRIPTION: This snippet optimizes a React component using a compiler runtime to handle caching effectively. It ensures components render efficiently by tracking changes to inputs and applying memoization techniques. The integration with `react/compiler-runtime` facilitates nuanced updates based on prior state and identity, leading to enhanced performance during component lifecycle operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequential-destructuring-assignment-to-scope-declarations.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(statusName) {
  const $ = _c(12);
  let t0;
  let t1;
  let text;
  if ($[0] !== statusName) {
    const { status, text: t2 } = foo(statusName);
    text = t2;
    const { bg, color } = getStyles(status);

    t1 = identity(bg);
    t0 = identity(color);
    $[0] = statusName;
    $[1] = t0;
    $[2] = t1;
    $[3] = text;
  } else {
    t0 = $[1];
    t1 = $[2];
    text = $[3];
  }
  let t2;
  if ($[4] !== text) {
    t2 = [text];
    $[4] = text;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== t0 || $[7] !== t2) {
    t3 = <span className={t0}>{t2}</span>;
    $[6] = t0;
    $[7] = t2;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== t1 || $[10] !== t3) {
    t4 = <div className={t1}>{t3}</div>;
    $[9] = t1;
    $[10] = t3;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  return t4;
}

function foo(name) {
  const $ = _c(2);

  const t0 = `${name}!`;
  let t1;
  if ($[0] !== t0) {
    t1 = { status: `<status>`, text: t0 };
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function getStyles(status) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { bg: "#eee8d5", color: "#657b83" };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["Mofei"],
};

```

----------------------------------------

TITLE: Compiled React Component with Optimizations
DESCRIPTION: The transformed component after React's compiler processing. It includes cache sentinel values, memoization of computations, and tracking of dependency changes to optimize rendering performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/partial-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(6);
  let t0;
  let y;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const x = [];
      if (props.cond) {
        x.push(props.a);
        t0 = x;
        break bb0;
      } else {
        let t1;
        if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
          t1 = foo();
          $[5] = t1;
        } else {
          t1 = $[5];
        }
        y = t1;
        if (props.b) {
          t0 = undefined;
          break bb0;
        }
      }
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.cond;
    $[3] = t0;
    $[4] = y;
  } else {
    t0 = $[3];
    y = $[4];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, a: 42 }],
};
```

----------------------------------------

TITLE: Original React Components with Forget Directive
DESCRIPTION: Original React component definitions using the 'use forget' directive. Includes Bar and Foo components with forget functionality, and a NoForget component without it. Also includes a fixture entrypoint for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-function.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating @compilationMode(annotation)
export function Bar(props) {
  'use forget';
  return <div>{props.bar}</div>;
}

export function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}

export function Foo(props) {
  'use forget';
  return <Foo>{props.bar}</Foo>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval('Bar'),
  params: [{bar: 2}],
};
```

----------------------------------------

TITLE: Optimized Component Rendering with Caching in React - JavaScript
DESCRIPTION: This snippet is an optimized version of the previous component, using caching to prevent re-computation of functions when prop values remain unchanged. It employs a compiler runtime utility for cache management. Dependencies are React and the shared-runtime library, requiring a specific cache management utility.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/conditional-call-chain.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useRef } from "react";
import { Stringify } from "shared-runtime";

function Component(t0) {
  const $ = _c(9);
  const { a, b } = t0;
  let t1;
  if ($[0] !== a.value) {
    t1 = () => {
      console.log(a.value);
    };
    $[0] = a.value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const logA = t1;
  let t2;
  if ($[2] !== b.value) {
    t2 = () => {
      console.log(b.value);
    };
    $[2] = b.value;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const logB = t2;

  const hasLogged = useRef(false);
  let t3;
  if ($[4] !== logA || $[5] !== logB) {
    t3 = () => {
      if (!hasLogged.current) {
        logA();
        logB();
        hasLogged.current = true;
      }
    };
    $[4] = logA;
    $[5] = logB;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const log = t3;
  let t4;
  if ($[7] !== log) {
    t4 = <Stringify log={log} shouldInvokeFns={true} />;
    $[7] = log;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: { value: 1 }, b: { value: 2 } }],
  sequentialRenders: [
    { a: { value: 1 }, b: { value: 2 } },
    { a: { value: 3 }, b: { value: 4 } },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Caching
DESCRIPTION: Compiled version of the component with added memoization using React compiler runtime. Implements caching for array creation and element access operations to optimize performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableUseTypeAnnotations
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.id) {
    t0 = makeArray(props.id);
    $[0] = props.id;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0 as number[];
  let t1;
  if ($[2] !== x) {
    t1 = x.at(0);
    $[2] = x;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const y = t1;
  return y;
}

function makeArray(x) {
  const $ = _c(2);
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 42 }],
};
```

----------------------------------------

TITLE: Compiled React Runtime Optimized Version
DESCRIPTION: The compiler-optimized version of the function that uses React's runtime cache (_c) to memoize values and prevent unnecessary object creation. It includes logic to only create new objects when values change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(props) {
  const $ = _c(4);
  let x = props.x;
  const y = x++;
  const z = x--;
  let t0;
  if ($[0] !== x || $[1] !== y || $[2] !== z) {
    t0 = { x, y, z };
    $[0] = x;
    $[1] = y;
    $[2] = z;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{ x: 1 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Optimized version of the component with compiler-generated memoization. Uses a cache array to store previous values and implements conditional recomputation based on input changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoization-comments.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableMemoizationComments
import { addOne, getNumber, identity } from "shared-runtime";

function Component(props) {
  const $ = _c(9);
  let t0;
  let x; // "useMemo" for t0 and x:
  // check if props.a changed
  if ($[0] !== props.a) {
    // Inputs changed, recompute
    x = identity(props.a);
    t0 = addOne(x);
    $[0] = props.a;
    $[1] = t0;
    $[2] = x;
  } else {
    // Inputs did not change, use cached value
    t0 = $[1];
    x = $[2];
  }
  const y = t0;
  let t1; // "useMemo" for t1:
  // check if props.b changed
  if ($[3] !== props.b) {
    // Inputs changed, recompute
    t1 = identity(props.b);
    $[3] = props.b;
    $[4] = t1;
  } else {
    // Inputs did not change, use cached value
    t1 = $[4];
  }
  const z = t1;
  let t2; // "useMemo" for t2:
  // check if x, y, or z changed
  if ($[5] !== x || $[6] !== y || $[7] !== z) {
    // Inputs changed, recompute
    t2 = [x, y, z];
    $[5] = x;
    $[6] = y;
    $[7] = z;
    $[8] = t2;
  } else {
    // Inputs did not change, use cached value
    t2 = $[8];
  }
  return t2;
}
export const FIXTURE_ENTRYPOINT = { fn: Component, params: [{ a: 1, b: 10 }] };
```

----------------------------------------

TITLE: Compiled React Component with useEffect and State Update
DESCRIPTION: This is the compiled version of the React component. It uses `react/compiler-runtime` and memoization techniques to optimize performance. It defines the state and associated update logic, encapsulating the increment within a separate function `_temp`. The `useEffect` hook is set up to trigger this incrementing logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-setState-in-useEffect-transitive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger @validateNoSetStateInPassiveEffects
import { useEffect, useState } from "react";

function Component() {
  const $ = _c(2);
  const [state, setState] = useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const f = () => {
      setState(_temp);
    };

    t0 = () => {
      f();
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const g = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      g();
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  useEffect(t1);
  return state;
}
function _temp(s) {
  return s + 1;
}

```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: The compiler-optimized version of the component that implements memoization using React's compiler runtime to avoid unnecessary object creation and property deletion operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/delete-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let x;
  if ($[0] !== props.a || $[1] !== props.b) {
    x = { a: props.a, b: props.b };
    delete x.b;
    $[0] = props.a;
    $[1] = props.b;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining an Enhanced React Component with State Management in JavaScript
DESCRIPTION: This snippet expands on the previous component by introducing additional state management using a compiled runtime function. It also employs the use of conditional checks to manage the component's state across multiple render cycles. The component captures the previous state and conditionally updates it based on its inputs, returning the appropriate state management results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-may-invalidate-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useHook, identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let x = 42;
  if (props.cond) {
    x = [];
  }

  useHook();
  identity(x);
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const y = t0;
  let t1;
  if ($[2] !== y) {
    t1 = [y];
    $[2] = y;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "sathya" }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component using React compiler runtime. Implements memoization using an array cache to prevent unnecessary re-renders when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-propagate-type-of-ternary-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function V0(t0) {
  const $ = _c(4);
  const { v1, v2 } = t0;
  const v5 = v1.v6?.v7;
  let t1;
  if ($[0] !== v1 || $[1] !== v2 || $[2] !== v5) {
    t1 = (
      <Component8 c9={va} cb="apqjx">
        {v5 != null ? (
          <ComponentC cd={v5}>
            <ComponentE cf={v1} c10={v2} />
          </ComponentC>
        ) : (
          <ComponentE cf={v1} c10={v2} />
        )}
      </Component8>
    );
    $[0] = v1;
    $[1] = v2;
    $[2] = v5;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime in JavaScript
DESCRIPTION: This snippet provides an optimized version of a React component using `react/compiler-runtime`. It maintains state for the `Foo` element using an array to cache element type changes, improving rendering performance. Dependencies include `shared-runtime` and `react/compiler-runtime`, which should be pre-installed. The function is exported with its parameters encapsulated in `FIXTURE_ENTRYPOINT`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-reactive-local-variable-member-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as sharedRuntime from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  const { something } = t0;
  const Foo = something.StaticText1;
  let t1;
  if ($[0] !== Foo) {
    t1 = () => <Foo />;
    $[0] = Foo;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ something: sharedRuntime }],
};

```

----------------------------------------

TITLE: React Component Definition (Compiled Code)
DESCRIPTION: This JavaScript code represents the compiled version of a React component. It utilizes `react/compiler-runtime`'s `_c` function, likely for memoization or optimization. The code checks if the input `a` has changed, and if so, updates a cached object `t0`. This optimizes rendering by preventing unnecessary re-renders when the input remains the same. The `FIXTURE_ENTRYPOINT` remains consistent with the input code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-3.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a, b) {
  const $ = _c(2);
  let t0;
  if ($[0] !== a) {
    t0 = { a };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Implementing Hook Wrapper in Shared Runtime - JavaScript
DESCRIPTION: This snippet demonstrates how to create a custom hook using the 'shared-runtime' library. It uses the 'mutate' and 'mutateAndReturn' functions to manipulate state and demonstrate caching behavior. It returns an object with a 'getValue' function that fetches the current value for testing or other functional needs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-aliased-mutate-after.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {createHookWrapper, mutate, mutateAndReturn} from 'shared-runtime';
function useHook({value}) {
  const x = mutateAndReturn({value});
  const obj = {
    getValue() {
      return value;
    },
  };
  mutate(x);
  return obj;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{value: 0}],
};

```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This is the compiled output of the React component using the React compiler runtime.  It uses the `_c` function from "react/compiler-runtime" to manage reactivity.  It includes logic to memoize the output of the component using a cache.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-of.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);

  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(null);

  const c = [a];

  let x;
  for (const i of c[0]) {
    x = 1;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};

```

----------------------------------------

TITLE: Optimized Functional Component Implementation in React - JavaScript
DESCRIPTION: This snippet shows the optimized version of the same Component which utilizes an internal memoization technique using '_c' to store previous values of props to avoid unnecessary re-renders. The same structures, types, and component functionalities are preserved with added performance enhancements through memoization. The Component receives an 'items' prop, and it renders the Foo, Bar, and Item components similarly while checking and optimizing rendering logic based on previous values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-attribute-with-jsx-element-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(t0) {
  const $ = _c(2);
  const { items } = t0;
  let t1;
  if ($[0] !== items) {
    t1 =
      items.length > 0 ? <Foo value={<Bar>{items.map(_temp)}</Bar>} /> : null;
    $[0] = items;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
function _temp(item) {
  return <Item key={item.id} item={item} />;
}

function Foo(t0) {
  const { value } = t0;
  return value;
}

function Bar(t0) {
  const $ = _c(2);
  const { children } = t0;
  let t1;
  if ($[0] !== children) {
    t1 = <div>{children}</div>;
    $[0] = children;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function Item(t0) {
  const $ = _c(2);
  const { item } = t0;
  let t1;
  if ($[0] !== item.name) {
    t1 = <div>{item.name}</div>;
    $[0] = item.name;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ items: [{ id: 1, name: "One!" }] }],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with added memoization logic using React's compiler runtime. Includes symbol-based cache sentinel checks and block-scoped error handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-with-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { shallowCopy, throwInput } = require("shared-runtime");

function Component(props) {
  const $ = _c(2);
  let t0;
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      try {
        const y = shallowCopy({});
        if (y == null) {
          t0 = undefined;
          break bb0;
        }

        x.push(throwInput(y));
      } catch {
        t0 = null;
        break bb0;
      }
    }
    $[0] = t0;
    $[1] = x;
  } else {
    t0 = $[0];
    x = $[1];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized String Concatenation Implementation
DESCRIPTION: Optimized version of the same function that directly returns the concatenated string literal. Maintains the same fixture setup for consistent testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-string-concat.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  return "abc";
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimizing useFoo Hook in React with JavaScript
DESCRIPTION: This snippet further optimizes the previously defined useFoo hook by introducing conditionally memoized values and a cache mechanism using arrays. It aims to fix the scoping issues noted in the prior implementation, utilizing a custom compiler runtime function and maintaining the same dependencies and input/output structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-reordering-depslist-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useCallback } from "react";
import { Stringify } from "shared-runtime";

// We currently produce invalid output (incorrect scoping for `y` declaration)
function useFoo(arr1, arr2) {
  const $ = _c(5);
  let t0;
  if ($[0] !== arr1 || $[1] !== arr2) {
    const x = [arr1];

    let y;
    t0 = () => ({ y });

    (y = x.concat(arr2)), y;
    $[0] = arr1;
    $[1] = arr2;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const getVal = t0;
  let t1;
  if ($[3] !== getVal) {
    t1 = <Stringify getVal={getVal} shouldInvokeFns={true} />;
    $[3] = getVal;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [
    [1, 2],
    [3, 4],
  ],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet presents the compiled version of the React component, utilizing `react/compiler-runtime` for optimization. It uses `_c` for memoization and manages state to avoid unnecessary re-renders. The component's logic remains the same, conditionally returning an array based on `props.cond`, but with added memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { makeArray } from "shared-runtime";

function Component(props) {
  const $ = _c(6);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const x = [];
      if (props.cond) {
        x.push(props.a);
        t0 = x;
        break bb0;
      } else {
        let t1;
        if ($[4] !== props.b) {
          t1 = makeArray(props.b);
          $[4] = props.b;
          $[5] = t1;
        } else {
          t1 = $[5];
        }
        t0 = t1;
        break bb0;
      }
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.cond;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    // pattern 1
    { cond: true, a: 42 },
    { cond: true, a: 42 },
    // pattern 2
    { cond: false, b: 3.14 },
    { cond: false, b: 3.14 },
    // pattern 1
    { cond: true, a: 42 },
    // pattern 2
    { cond: false, b: 3.14 },
    // pattern 1
    { cond: true, a: 42 },
    // pattern 2
    { cond: false, b: 3.14 },
  ],
};

```

----------------------------------------

TITLE: Compiled React Component with Optimized Effect Dependencies
DESCRIPTION: The compiler-transformed output of the React component, showing how the compiler adds memoization for the effect callback and automatically sets an empty dependency array. This optimization recognizes that setState is a stable reference.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-setState.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect, useState } from "react";
import { print } from "shared-runtime";

/**
 * Special case of `infer-effect-deps/nonreactive-dep`.
 *
 * We know that local `useRef` return values are stable, regardless of
 * inferred memoization.
 */
function NonReactiveSetStateInEffect() {
  const $ = _c(1);
  const [, setState] = useState("initial value");
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => print(setState);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(t0, []);
}
```

----------------------------------------

TITLE: Defining useFoo with Basic Input Handling in JavaScript
DESCRIPTION: The first implementation of the useFoo function processes input properties based on the hasAB and returnNull flags. It returns an array constructed from the identity of input.a or null based on the conditions. Dependencies include 'shared-runtime' for identity function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/reduce-if-exhaustive-nonpoisoned-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

function useFoo({input, hasAB, returnNull}) {
  const x = [];
  if (!hasAB) {
    x.push(identity(input.a));
    if (!returnNull) {
      return null;
    }
  } else {
    x.push(identity(input.a.b));
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{input: {b: 1}, hasAB: false, returnNull: false}],
};

```

----------------------------------------

TITLE: React Hook State Management with Compiler Runtime
DESCRIPTION: This code implements a useFoo function which leverages React compiler-runtime for optimizing component state management. It uses a cache mechanism to reduce redundant calculations. The function processes an input object and conditionally returns a JSX component. Dependencies are similar to the first snippet, focusing on shared-runtime functionalities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-cond-access-local-var.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR

import { shallowCopy, mutate, Stringify } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(5);
  const { a, shouldReadA } = t0;
  let local;
  if ($[0] !== a) {
    local = shallowCopy(a);
    mutate(local);
    $[0] = a;
    $[1] = local;
  } else {
    local = $[1];
  }
  let t1;
  if ($[2] !== local || $[3] !== shouldReadA) {
    t1 = (
      <Stringify
        fn={() => {
          if (shouldReadA) {
            return local.b.c;
          }
          return null;
        }}
        shouldInvokeFns={true}
      />
    );
    $[2] = local;
    $[3] = shouldReadA;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: null, shouldReadA: true }],
  sequentialRenders: [
    { a: null, shouldReadA: true },
    { a: null, shouldReadA: false },
    { a: { b: { c: 4 } }, shouldReadA: true },
  ],
};

```

----------------------------------------

TITLE: Input React Component with useSpecialEffect
DESCRIPTION: The original React component using useSpecialEffect hooks with two different dependency configurations. The first case expects automatic dependency inference while the second provides explicit dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/infer-deps-custom-config.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies
import {print, useSpecialEffect} from 'shared-runtime';

function CustomConfig({propVal}) {
  // Insertion
  useSpecialEffect(() => print(propVal), [propVal]);
  // No insertion
  useSpecialEffect(() => print(propVal), [propVal], [propVal]);
}

```

----------------------------------------

TITLE: Optimizing Component Logic with Cached Values
DESCRIPTION: This snippet presents an optimized version of the React component that implements caching for performance improvements. It uses a cached array and checks dependencies using a global variable to avoid unnecessary updates. This code version also leverages a local variable to manage the output JSX efficiently, enhancing re-rendering logic based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-global-load-cached.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from 'react/compiler-runtime';
import { Stringify } from 'shared-runtime';
import { makeArray } from 'shared-runtime';

/**
 * Here, we don't need to memoize Stringify as it is a read off of a global.
 * TODO: in PropagateScopeDeps (hir), we should produce a sidemap of global rvals
 * and avoid adding them to `temporariesUsedOutsideDefiningScope`.
 */
function Component(t0) {
  const $ = _c(6);
  const { num } = t0;
  let T0;
  let t1;
  if ($[0] !== num) {
    const arr = makeArray(num);
    T0 = Stringify;
    t1 = arr.push(num);
    $[0] = num;
    $[1] = T0;
    $[2] = t1;
  } else {
    T0 = $[1];
    t1 = $[2];
  }
  let t2;
  if ($[3] !== T0 || $[4] !== t1) {
    t2 = <T0 value={t1} />;
    $[3] = T0;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ num: 2 }],
};

```

----------------------------------------

TITLE: Compiled React Component Output
DESCRIPTION: This snippet shows the compiled version of the component function. It introduces memoization using Symbol.for('react.memo_cache_sentinel') and imports a compiler runtime function. The structure is optimized for performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-reassign.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  let x;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Function Component
DESCRIPTION: Compiled version of the React component showing how the compiler transforms nested functions using React's compiler runtime. It implements caching logic using Symbol.for() and handles default parameters differently.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/deeply-nested-function-expressions-with-params.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {
  const $ = _c(1);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = function a(t2) {
      const x_0 = t2 === undefined ? _temp : t2;
      return (function b(t3) {
        const y_0 = t3 === undefined ? [] : t3;
        return [x_0, y_0];
      })();
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  t0 = t1;
  return t0;
}
function _temp() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime in JavaScript
DESCRIPTION: This JavaScript snippet introduces optimizations for a React component by using runtime checks and compiler runtime constructs. It ensures efficient rendering by caching the items and their mapped JSX elements, reducing unnecessary re-rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.unnecessary-lambda-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  const data = useFreeze();
  let t0;
  if ($[0] !== data.items) {
    t0 = data.items.map(_temp);
    $[0] = data.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const items = t0;
  let t1;
  if ($[2] !== items) {
    t1 = <div>{items}</div>;
    $[2] = items;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
function _temp(item) {
  return <Item item={item} />;
}

```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime Optimizations
DESCRIPTION: Transformed version of the React component using React compiler runtime (_c) for advanced memoization and caching strategies
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-mabye-modified-free-variable-preserve-memoization-guarantees.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import {
  identity,
  makeObject_Primitives,
  mutate,
  useHook,
} from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = makeObject_Primitives();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const free = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = makeObject_Primitives();
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const free2 = t1;
  const part = free2.part;

  useHook();
  let t2;
  let x;
  if ($[2] !== props.value) {
    x = makeObject_Primitives();
    x.value = props.value;
    mutate(x, free, part);
    $[2] = props.value;
    $[3] = x;
  } else {
    x = $[3];
  }
  t2 = x;
  const object = t2;

  identity(free);
  identity(part);
  return object;
}
```

----------------------------------------

TITLE: Optimized useFoo Function with React Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the useFoo function using React's compiler-runtime. It implements memoization manually, caching computed values and only recalculating when dependencies change, potentially improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-constant-prop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useMemo } from "react";
import { identity } from "shared-runtime";

function useFoo(cond) {
  const $ = _c(5);
  const sourceDep = 0;
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = identity(0);
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  t0 = t1;
  const derived1 = t0;

  const derived2 = (cond ?? Math.min(0, 1)) ? 1 : 2;
  let t2;
  let t3;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = identity(0);
    $[1] = t3;
  } else {
    t3 = $[1];
  }
  t2 = t3;
  const derived3 = t2;

  const derived4 = (Math.min(0, -1) ?? cond) ? 1 : 2;
  let t4;
  if ($[2] !== derived2 || $[3] !== derived4) {
    t4 = [derived1, derived2, derived3, derived4];
    $[2] = derived2;
    $[3] = derived4;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows the optimized version of the component using React's compiler-runtime. It implements memoization to cache the component's state, potentially improving performance by avoiding unnecessary re-computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/declare-reassign-variable-in-closure.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(p) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const foo = () => {
      x = {};
    };

    foo();
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled useFoo React Component with Memoization
DESCRIPTION: This code presents the compiled version of the `useFoo` React component. It imports `_c` from `react/compiler-runtime` for memoization and conditionally executes the component's logic based on prop changes. The compiled version uses an array `$` to store previous prop values and the result of the component, optimizing for re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    x = [];
    x.push(props.bar);
    if (props.cond) {
      x = [];
      x.push(props.foo);
    }

    mutate(x);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ bar: "bar", foo: "foo", cond: true }],
  sequentialRenders: [
    { bar: "bar", foo: "foo", cond: true },
    { bar: "bar", foo: "foo", cond: true },
    { bar: "bar", foo: "foo", cond: false },
  ],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The React compiler-transformed version of the component that implements memoization. It uses the compiler runtime to cache results based on prop changes and employs Symbol.for() for cache validation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment-conditional.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.p0 || $[1] !== props.p1 || $[2] !== props.p2) {
    let x = [];
    x.push(props.p0);
    const y = x;
    if (props.p1) {
      let t1;
      if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
        t1 = [];
        $[4] = t1;
      } else {
        t1 = $[4];
      }
      x = t1;
    }

    y.push(props.p2);

    t0 = <Component x={x} y={y} />;
    $[0] = props.p0;
    $[1] = props.p1;
    $[2] = props.p2;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime in JavaScript
DESCRIPTION: This snippet demonstrates an optimized version of the React component 'Component' using an imported '_c' function from 'react/compiler-runtime'. It employs memoization to minimize recalculation and re-rendering by caching computed values based on prop changes. This requires the 'react/compiler-runtime' package. The export section remains similar to the initial snippet, facilitating parameterized testing of the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ignore-use-no-forget.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @ignoreUseNoForget
function Component(prop) {
  "use no forget";
  const $ = _c(4);
  let t0;
  if ($[0] !== prop.x) {
    t0 = prop.x.toFixed();
    $[0] = prop.x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const result = t0;
  let t1;
  if ($[2] !== result) {
    t1 = <div>{result}</div>;
    $[2] = result;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ x: 1 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization and Mutation
DESCRIPTION: This snippet shows the compiled version of the 'useFoo' component. It includes React's compiler-runtime and implements memoization using an array '_c(4)'. The component checks for changes in input parameters and updates memoized values accordingly, while preserving the original functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonmutating-capture-in-unsplittable-memo-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, mutate } from "shared-runtime";

/**
 * Currently, InferReactiveScopeVariables do not ensure that maybe-aliased
 * values get assigned the same reactive scope. This is safe only when an
 * already-constructed value is captured, e.g.
 * ```js
 * const x = makeObj();   mutable range of x
 * mutate(x);            
 *                       <-- after this point, we can produce a canonical version
 *                           of x for all following aliases
 * const y = [];
 * y.push(x);            <-- y captures x
 * ```
 *
 * However, if a value is captured/aliased during its mutable range and the
 * capturing container is separately memoized, it becomes difficult to guarantee
 * that all aliases refer to the same value.
 *
 */
function useFoo(t0) {
  const $ = _c(4);
  const { a, b } = t0;
  let y;
  let z;
  if ($[0] !== a || $[1] !== b) {
    const x = { a };
    y = {};
    mutate(x);
    z = [identity(y), b];
    mutate(y);
    $[0] = a;
    $[1] = b;
    $[2] = y;
    $[3] = z;
  } else {
    y = $[2];
    z = $[3];
  }
  if (z[0] !== y) {
    throw new Error("oh no!");
  }
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: 2, b: 3 }],
  sequentialRenders: [
    { a: 2, b: 3 },
    { a: 4, b: 3 },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Inferred Effect Dependencies
DESCRIPTION: The compiled output of the React component after the dependency inference transformation. It shows how React's compiler adds the selected ref as a dependency to useEffect and uses memoization to optimize re-renders and effect executions based on the reactive ref.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-ref.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect, useRef } from "react";
import { print } from "shared-runtime";

/*
 * Ref types are not enough to determine to omit from deps. Must also take reactivity into account.
 */
function ReactiveRefInEffect(props) {
  const $ = _c(4);
  const ref1 = useRef("initial value");
  const ref2 = useRef("initial value");
  let ref;
  if ($[0] !== props.foo) {
    if (props.foo) {
      ref = ref1;
    } else {
      ref = ref2;
    }
    $[0] = props.foo;
    $[1] = ref;
  } else {
    ref = $[1];
  }
  let t0;
  if ($[2] !== ref) {
    t0 = () => print(ref);
    $[2] = ref;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  useEffect(t0, [ref]);
}
```

----------------------------------------

TITLE: Creating React Component with Memo Cache - JavaScript
DESCRIPTION: Implements a React component with a memoization caching system using a Symbol-based cache. The component inspects cache slots before processing and updating. The component uses an imported variable and returns a cached result. It requires react/compiler-runtime and symbol usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-frozen-array.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
"import { c as _c } from \"react/compiler-runtime\";\nfunction Component(props) {\n  const $ = _c(2);\n  let t0;\n  if ($[0] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = [];\n    $[0] = t0;\n  } else {\n    t0 = $[0];\n  }\n  const x = t0;\n  let t1;\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    const y = x.map(_temp);\n    t1 = [x, y];\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n  return t1;\n}\nfunction _temp(item) {\n  return item;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{}],\n  isComponent: false,\n};"
```

----------------------------------------

TITLE: Conditional Subpath Dependency Test Case in React
DESCRIPTION: This JavaScript code defines a test case with a function `useConditionalSubpath2` that accesses a property `props.a` conditionally and then unconditionally accesses a subproperty `props.a.b`. The purpose is to demonstrate how the React compiler can optimize the dependency tracking to only depend on `props.a` rather than both `props.a` and `props.a.b`. The `FIXTURE_ENTRYPOINT` is used for testing the function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/subpath-order2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// When a conditional dependency `props.a` is a subpath of an unconditional
// dependency `props.a.b`, we can access `props.a` while preserving program
// semantics (with respect to nullthrows).
// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`

import {identity} from 'shared-runtime';

// ordering of accesses should not matter
function useConditionalSubpath2(props, other) {
  const x = {};
  if (identity(other)) {
    x.a = props.a;
  }
  x.b = props.a.b;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useConditionalSubpath2,
  params: [{a: {b: 3}}, false],
};

```

----------------------------------------

TITLE: Memoizing and Exporting a Function in Javascript
DESCRIPTION: This code defines a memoized function `bar` that uses `react/compiler-runtime` to optimize execution. It checks if the input `a` has changed and only re-executes the function's core logic if it has, storing the result in the `$` array. The function returns a value derived from the input.  It also exports metadata needed to run and test this function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-4.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```javascript
import { c as _c } from "react/compiler-runtime";
function bar(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = [a];
    y = {};
    const f0 = function () {
      y = x[0].a[1];
    };

    f0();
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [{ a: ["val1", "val2"] }],
  isComponent: false,
};

```
```

----------------------------------------

TITLE: Component Manipulation with Cached Values in React JavaScript
DESCRIPTION: This code snippet enhances a component function by caching its previous state and inputs using an array. It utilizes a custom React compiler runtime import and handles object mutation based on the comparison of incoming parameters with cached values. Dependencies include `mutate` from `shared-runtime` and `_c` from 'react/compiler-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { mutate } = require("shared-runtime");

function component(foo, bar) {
  const $ = _c(3);
  let y;
  if ($[0] !== bar || $[1] !== foo) {
    const x = { foo };
    y = { bar };

    const a = { y };
    const b = x;
    a.x = b;

    mutate(y);
    $[0] = bar;
    $[1] = foo;
    $[2] = y;
  } else {
    y = $[2];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["foo", "bar"],
};
```

----------------------------------------

TITLE: Caching and Mutating Component with React/Compiler Runtime in JavaScript
DESCRIPTION: This code extends component mutation by introducing caching via React's compiler-runtime. The function checks a cached value before initializing 'x' and 'y', thereby optimizing repeated executions. The include of 'react/compiler-runtime' adds caching functionality, requiring this dependency for execution. The function inputs a string and outputs the mutated and potentially cached object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-mutate-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { mutate } = require("shared-runtime");

function component(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};

    const a_0 = y;
    a_0.x = x;

    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["foo"],
};

```

----------------------------------------

TITLE: Dynamic Hook Integration in React Component using useFire in JavaScript
DESCRIPTION: This code illustrates a React component using a custom hook useFire from 'react/compiler-runtime'. It defines a temporary function to process properties and invokes it inside a useEffect hook, ensuring that changes in component properties trigger specific logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/repro-dont-add-hook-guards-on-retry.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useFire } from "react/compiler-runtime";\nimport { useEffect, fire } from "react";\n\nfunction Component(props, useDynamicHook) {\n  "use memo";\n\n  useDynamicHook();\n  const foo = _temp;\n  const t0 = useFire(foo);\n\n  useEffect(() => {\n    t0(props);\n  });\n  return <div>hello world</div>;\n}\nfunction _temp(props_0) {\n  console.log(props_0);\n}\n
```

----------------------------------------

TITLE: Logging Props with Fire Hook in React
DESCRIPTION: This snippet defines a React functional component that logs its props to the console using a fire hook. It renders nothing and executes the logging effect when props are received.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/hook-guard.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire @enableEmitHookGuards
import {fire} from 'react';

function Component(props) {
  const foo = props => {
    console.log(props);
  };
  useEffect(() => {
    fire(foo(props));
  });

  return null;
}

```

----------------------------------------

TITLE: Demonstrating JavaScript Hoisting
DESCRIPTION: This code snippet defines a function that showcases JavaScript's hoisting behavior, particularly how functions access variables from the outer scope. It includes a function 'hoisting' that calls a nested function 'foo', which in turn calls another nested function 'bar', demonstrating access to 'bar' despite its declaration being below its usage. The expected output is '1' when 'foo' is invoked.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-function-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function hoisting() {
  const foo = () => {
    return bar();
  };
  const bar = () => {
    return 1;
  };

  return foo(); // OK: bar's value is only accessed outside of its TDZ
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Defining React Component with Debugging Options
DESCRIPTION: This JavaScript snippet defines a simple React functional component. It attempts to enable both `disableMemoizationForDebugging` and `enableChangeDetectionForDebugging` simultaneously, which are mutually exclusive debugging options.  This configuration is intended to trigger an error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.nomemo-and-change-detect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @disableMemoizationForDebugging @enableChangeDetectionForDebugging
function Component(props) {}
```

----------------------------------------

TITLE: Implementing Conditional Hoisting in JavaScript
DESCRIPTION: This snippet defines a 'hoisting' function that conditionally pushes a value returned from 'bar' into an array, based on the input parameter 'cond'. It uses closures to wrap the calls and ensure correct scope usage.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-const-declaration-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function hoisting(cond) {
  let items = [];
  if (cond) {
    const foo = () => {
      items.push(bar());
    };
    const bar = () => true;
    foo();
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [true],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled FBT Output Code
DESCRIPTION: Compiled version of the FBT code showing how the pluralization and parameter interpolation are transformed. Includes memoization logic and the final string template structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/repro-macro-property-not-handled.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";
import { useIdentity } from "shared-runtime";

/**
 * MemoizeFbtAndMacroOperandsInSameScope should also track PropertyLoads (e.g. fbt.plural).
 * This doesn't seem to be an issue for fbt, but affects other internal macros invoked as
 * `importSpecifier.funcName` (see https://fburl.com/code/72icxwmn)
 */
function useFoo(t0) {
  const $ = _c(2);
  const { items } = t0;
  let t1;
  if ($[0] !== items) {
    t1 = [...items];
    $[0] = items;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return fbt._(
    {
      "*": "There are {number of items} items",
      "_1": "There is {number of items} items",
    },
    [
      fbt._plural(useIdentity(t1).length),
      fbt._param(
        "number of items",

        items.length,
      ),
    ],
    { hk: "xsa7w" },
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ items: [2, 3] }],
};
```

----------------------------------------

TITLE: Compiled React FBT Component Output
DESCRIPTION: The compiled version of the FBT component showing how the internationalization markup is transformed into efficient runtime code. Includes caching mechanism for repeated values and parameter handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-whitespace-within-text.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

const _ = fbt;
function Component(t0) {
  const $ = _c(2);
  const { value } = t0;
  let t1;
  if ($[0] !== value) {
    t1 = fbt._(
      "Before text {paramName} after text more text and more and more and more and more and more and more and more and more and blah blah blah blah",
      [fbt._param("paramName", value)],
      { hk: "24ZPpO" },
    );
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "hello world" }],
};
```

----------------------------------------

TITLE: Original Object Allocation and Mutation Loop
DESCRIPTION: Shows a function that creates three objects and cyclically swaps their references in a while loop, with mutations occurring between swaps. The function demonstrates a pattern of object allocation and reference manipulation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-while.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(cond) {
  let a = {};
  let b = {};
  let c = {};
  while (cond) {
    let z = a;
    a = b;
    b = c;
    c = z;
    mutate(a, b);
  }
  a;
  b;
  c;
  return a;
}

function mutate(x, y) {}
```

----------------------------------------

TITLE: Debugging React Component with Fixture Export
DESCRIPTION: A React functional component that includes multiple debugger statements for debugging purposes, along with a fixture export configuration. The component uses conditional and loop structures with embedded debugger statements. Includes an export for testing setup with TodoAdd component parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/debugger.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  debugger;
  if (props.cond) {
    debugger;
  } else {
    while (props.cond) {
      debugger;
    }
  }
  debugger;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Debugging Unit Tests
DESCRIPTION: Connect tests to a debugger for a more thorough testing experience.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_9

LANGUAGE: sh
CODE:
```
yarn debug-test-build-devtools
```

----------------------------------------

TITLE: Optimized Conditional Computation in React Component (JavaScript)
DESCRIPTION: This snippet implements the same Component using the React compiler-runtime to handle memoization through a custom mechanism. It tracks previous props using an internal array to determine when the values should be recalculated, improving performance in more complex scenarios. This version retains the same input and output structure as the previous snippet but is optimized for React's reconciliation process. It includes additional handling for maintaining internal state across renders, aiming to minimize unnecessary computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/useMemo-multiple-if-else.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { useMemo } from "react";

function Component(props) {
  const $ = _c(6);
  let t0;
  bb0: {
    let y;
    if (
      $[0] !== props.a ||
      $[1] !== props.b ||
      $[2] !== props.cond ||
      $[3] !== props.cond2
    ) {
      y = [];
      if (props.cond) {
        y.push(props.a);
      }
      if (props.cond2) {
        t0 = y;
        break bb0;
      }

      y.push(props.b);
      $[0] = props.a;
      $[1] = props.b;
      $[2] = props.cond;
      $[3] = props.cond2;
      $[4] = y;
      $[5] = t0;
    } else {
      y = $[4];
      t0 = $[5];
    }
    t0 = y;
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1, b: 2, cond2: false }],
};

```

----------------------------------------

TITLE: Original React Components with Forget Directive
DESCRIPTION: React components Bar, NoForget, and Foo implementing the 'use forget' directive for optimization. Includes an export for fixture testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-function-and-default.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating @compilationMode(annotation)
export default function Bar(props) {
  'use forget';
  return <div>{props.bar}</div>;
}

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}

function Foo(props) {
  'use forget';
  if (props.bar < 0) {
    return props.children;
  }
  return (
    <Foo bar={props.bar - 1}>
      <NoForget />
    </Foo>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval('Bar'),
  params: [{bar: 2}],
};
```

----------------------------------------

TITLE: Creating useFoo with Memoization - React - JavaScript
DESCRIPTION: This snippet expands on the previous useFoo definition, utilizing a compiler runtime for memoization. It checks for a cache sentinel and returns either a cached value or calls a function to create and cache a new value. The snippet ultimately also returns a text element displaying '4'. It depends on 'react/compiler-runtime' and 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-memberexpr-tag-in-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as SharedRuntime from "shared-runtime";
function useFoo() {
  const $ = _c(1);

  const callback = _temp;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = callback();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  return <SharedRuntime.Text value={4} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Defining React Component with Do-While Loop (Input Version)
DESCRIPTION: This snippet defines a React component function with a do-while loop, although the loop immediately breaks. It also exports a FIXTURE_ENTRYPOINT object for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  do {
    break;
  } while (props.cond);
  return props;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Optimizing Hook with Compiler Runtime in React
DESCRIPTION: This snippet enhances the `useHook` function by adding caching mechanism provided by React's `compiler-runtime`, imported as `_c`. The function logs messages only when the condition changes, utilizing the compiler runtime to store previous states. It requires the `react/compiler-runtime` and `shared-runtime` modules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/labeled-break-within-label-switch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_STRING0 } from "shared-runtime";

function useHook(cond) {
  const $ = _c(2);
  let log;
  if ($[0] !== cond) {
    log = [];
    switch (CONST_STRING0) {
      case CONST_STRING0: {
        log.push(`@A`);
        bb0: {
          if (cond) {
            break bb0;
          }

          log.push(`@B`);
        }

        log.push(`@C`);
      }
    }
    $[0] = cond;
    $[1] = log;
  } else {
    log = $[1];
  }
  return log;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [true],
};

```

----------------------------------------

TITLE: Defining React Hook with Change Variable Codegen Enabled
DESCRIPTION: This snippet defines a React hook 'useFoo' with Change Variable Codegen enabled. It imports the 'identity' function, defines some module-level constants, and exports a fixture entrypoint for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableChangeVariableCodegen
import {identity} from 'shared-runtime';

const $ = 'module_$';
const t0 = 'module_t0';
const c_0 = 'module_c_0';
function useFoo(props: {value: number}): number {
  const results = identity(props.value);
  console.log($);
  console.log(t0);
  console.log(c_0);
  return results;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{value: 0}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Implementation
DESCRIPTION: This snippet shows the compiled version of the React component, implementing memoization using React's compiler runtime. It uses a Symbol-based cache to store and retrieve the computed object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-no-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { getNumber } = require("shared-runtime");

function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { session_id: getNumber() };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Advanced ReactiveScope Handling with Compiler Runtime in JavaScript
DESCRIPTION: This advanced snippet handles variable propagation using React's compiler runtime, specifically using cache handling techniques. It ensures stability in rendering by capturing changes in objects and uses a caching mechanism for React's memory optimization. The dependencies include 'react/compiler-runtime' and aim to mitigate invariant breaking through memoization and react-specific pattern handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-invalid-phi-as-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_TRUE, Stringify, mutate, useIdentity } from "shared-runtime";

/**
 * Fixture showing an edge case for ReactiveScope variable propagation.
 *
 * Found differences in evaluator results
 *   Non-forget (expected):
 *   <div>{"obj":{"inner":{"value":"hello"},"wat0":"joe"},"inner":["[[ cyclic ref *2 ]]"]}</div>
 *   <div>{"obj":{"inner":{"value":"hello"},"wat0":"joe"},"inner":["[[ cyclic ref *2 ]]"]}</div>
 *   Forget:
 *   <div>{"obj":{"inner":{"value":"hello"},"wat0":"joe"},"inner":["[[ cyclic ref *2 ]]"]}</div>
 *   [[ (exception in render) Error: invariant broken ]]
 *
 */
function Component() {
  const $ = _c(4);
  const obj = CONST_TRUE ? { inner: { value: "hello" } } : null;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [obj?.inner];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const boxedInner = t0;
  useIdentity(null);
  mutate(obj);
  if (boxedInner[0] !== obj?.inner) {
    throw new Error("invariant broken");
  }
  let t1;
  if ($[1] !== boxedInner || $[2] !== obj) {
    t1 = <Stringify obj={obj} inner={boxedInner} />;
    $[1] = boxedInner;
    $[2] = obj;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arg: 0 }],
  sequentialRenders: [{ arg: 0 }, { arg: 1 }],
};

```

----------------------------------------

TITLE: React Compiler Runtime Function Optimization
DESCRIPTION: Transformed function using React compiler runtime with memoization and cache management using Symbol sentinel
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-function-with-param-as-captured-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {
  const $ = _c(1);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = function a(t2) {
      const x_0 = t2 === undefined ? _temp : t2;
      return x_0;
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  t0 = t1;
  return t0;
}
function _temp() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Incorrect useMemo Implementation
DESCRIPTION: This code snippet demonstrates an incorrect implementation of a custom hook that breaks memoization guarantees. The `useMemo` hook is not used to memoize a value; instead, it uses conditional logic to assign value `t0`. This results in the value being recomputed on every render, negating the benefits of memoization. The `identity` function is used for cases where `cond` is false.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/prune-nonescaping-useMemo-mult-returns-primitive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";
import { identity } from "shared-runtime";

function useFoo(cond) {
  let t0;
  if (cond) {
    t0 = 2;
  } else {
    t0 = identity(5);
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};

```

----------------------------------------

TITLE: Problematic React Component Implementation
DESCRIPTION: Modified version of the component with an infinite loop bug due to improper loop variable declaration (const) and missing increment. This appears to be a test case for detecting problematic implementations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  for (const i = 0; 0 < props.count; ) {
    return;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining Native Log Function with Compiler Runtime
DESCRIPTION: This snippet defines the 'getNativeLogFunction' utilizing the React compiler-runtime. It is similar to the previous function but adds optimizations to address performance, while managing logging behaviors for different input scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-param-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function getNativeLogFunction(level) {
  const $ = _c(2);
  let t0;
  if ($[0] !== level) {
    t0 = function () {
      let str;
      if (arguments.length === 1 && typeof arguments[0] === "string") {
        str = arguments[0];
      } else {
        str = Array.prototype.map.call(arguments, _temp).join(", ");
      }

      const firstArg = arguments[0];
      let logLevel = level;
      if (
        typeof firstArg === "string" &&
        firstArg.slice(0, 9) === "Warning: " &&
        logLevel >= LOG_LEVELS.error
      ) {
        logLevel = LOG_LEVELS.warn;
      }
      if (global.__inspectorLog) {
        global.__inspectorLog(
          INSPECTOR_LEVELS[logLevel],
          str,
          [].slice.call(arguments),
          INSPECTOR_FRAMES_TO_SKIP,
        );
      }
      if (groupStack.length) {
        str = groupFormat("", str);
      }

      global.nativeLoggingHook(str, logLevel);
    };
    $[0] = level;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function _temp(arg) {
  return inspect(arg, { depth: 10 });
}

```

----------------------------------------

TITLE: Defining Foo Functionality with Direct Return - JavaScript
DESCRIPTION: This snippet defines a function 'foo' that directly returns the value 2. It simplifies the function's logic by removing the conditional checks from the previous version. The 'FIXTURE_ENTRYPOINT' constant again exports this streamlined version of the function as part of an object, allowing it to be used externally in other modules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  return 2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Utilizing React Compiler Runtime Caching
DESCRIPTION: This JavaScript snippet leverages React's compiler runtime for memoization. The function uses runtime cache checks to optimize conditional object creation within a React component, returning a memoized object based on the input condition. This enhances performance by avoiding unnecessary recomputation of unchanged states.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a) {
  const $ = _c(4);
  let x;
  if ($[0] !== a) {
    x = {};
    if (a) {
      let t0;
      if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = {};
        $[2] = t0;
      } else {
        t0 = $[2];
      }
      const y = t0;
      x.y = y;
    } else {
      let t0;
      if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = {};
        $[3] = t0;
      } else {
        t0 = $[3];
      }
      const z = t0;
      x.z = z;
    }
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: React Component Implementation
DESCRIPTION: Duplicate implementation of the React component with debugger statements and fixture export, but with double quotes in the export object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/debugger.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  debugger;
  if (props.cond) {
    debugger;
  } else {
    while (props.cond) {
      debugger;
    }
  }
  debugger;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Implementing Memoization Cache Handling in React Compiler Runtime
DESCRIPTION: This function, nonReactFn, interacts with React's compiler runtime to handle memoization caching. It uses a Symbol to check for a cache sentinel and either creates a new cache object or returns an existing one.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/compilationMode-all-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // 
        @compilationMode(all)
function nonReactFn() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Defining a Test Function and Fixture Entrypoint for 'TodoAdd' Component
DESCRIPTION: This snippet defines a JavaScript function 'f' that takes a parameter 'y', assigns it to 'x', and returns a sum involving reassignment. It also exports a fixture entrypoint object that specifies the function, parameters, and component name for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/expression-with-assignment-dynamic.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function f(y) {
  let x = y;
  return x + (x = 2) + x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Updated Object Property Assignment with Static Index
DESCRIPTION: Modified version of the object manipulation function where dynamic index calculation is replaced with static value 3. Includes the same fixture export configuration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-computed-access-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const x = { ...a };
  x[b] = c[b];
  x[3] = c[b * 4];
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component with 'use no memo' and Fire
DESCRIPTION: This React component demonstrates the use of the 'use no memo' directive and attempts to use a `fire` function within a `useEffect` hook. It logs props within the `foo` function and triggers side effects using `fire`. The component's intent is likely to test or demonstrate the interaction between memoization disabling and compiler-required features like `fire`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.use-no-memo.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire @panicThreshold(none)
import {fire} from 'react';

/**
 * TODO: we should eventually distinguish between `use no memo` and `use no
 * compiler` directives. The former should be used to *only* disable memoization
 * features.
 */
function Component({props, bar}) {
  'use no memo';
  const foo = () => {
    console.log(props);
  };
  useEffect(() => {
    fire(foo(props));
    fire(foo());
    fire(bar());
  });

  return null;
}

```

----------------------------------------

TITLE: Input Functional Component with Shallow Copy and Mutation
DESCRIPTION: Original implementation of useFoo function demonstrating shallow copying of nested objects and function creation with closure
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access-local-var.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({a}: {a: {b: {c: number}}}) {
  const local = shallowCopy(a);
  mutate(local);
  const fn = () => [() => local.b.c];
  return <Stringify fn={fn} shouldInvokeFns={true} />;
}
```

----------------------------------------

TITLE: React Component using fire in useEffect
DESCRIPTION: This code defines a React component that uses the 'fire' function within a useEffect hook to execute a function (foo) with props.  It imports 'fire' from 'react'. The hook attempts to include 'foo' and 'props' as dependencies, triggering an error when using spread syntax.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-rewrite-deps-spread.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = props => {
    console.log(props);
  };

  const deps = [foo, props];

  useEffect(
    () => {
      fire(foo(props));
    },
    ...deps
  );

  return null;
}
```

----------------------------------------

TITLE: Input Implementation of useFoo Function with Conditional Object Creation
DESCRIPTION: The input version of a useFoo function that conditionally creates objects with different property values based on a condition parameter. This demonstrates an edge case where the compiler could optimize by merging re-orderability across phi nodes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/todo-merge-ssa-phi-access-nodes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  identity,
  makeObject_Primitives,
  setPropertyByKey,
} from 'shared-runtime';

/**
 * A bit of an edge case, but we could further optimize here by merging
 * re-orderability of nodes across phis.
 */
function useFoo(cond) {
  let x;
  if (cond) {
    /** start of scope for x_@0 */
    x = {};
    setPropertyByKey(x, 'a', {b: 2});
    /** end of scope for x_@0 */
    Math.max(x.a.b, 0);
  } else {
    /** start of scope for x_@1 */
    x = makeObject_Primitives();
    setPropertyByKey(x, 'a', {b: 3});
    /** end of scope for x_@1 */
    Math.max(x.a.b, 0);
  }
  /**
   * At this point, we have a phi node.
   * x_@2 = phi(x_@0, x_@1)
   *
   * We can assume that both x_@0 and x_@1 both have non-null `x.a` properties,
   * so we can infer that x_@2 does as well.
   */

  // Here, y should take a dependency on `x.a.b`
  const y = [];
  if (identity(cond)) {
    y.push(x.a.b);
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: Using useNoAlias in a React Component - JavaScript
DESCRIPTION: This snippet defines a React functional component that utilizes the 'useNoAlias' function from the 'shared-runtime' package. The purpose is to create an object 'item' using properties from 'props' and then pass it to 'useNoAlias' for efficient handling. Key functionality includes logging 'props' whenever 'props.a' changes, which demonstrates dependency tracking. It assumes that 'useNoAlias' is a custom hook that might handle side effects or optimization strategies, and requires 'shared-runtime' as a prerequisite.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-noAlias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useNoAlias} from 'shared-runtime';

function Component(props) {
  const item = {a: props.a};
  const x = useNoAlias(item, () => {
    console.log(props);
  }, [props.a]);
  return [x, item];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: {id: 42}}],
  isComponent: true,
};

```

----------------------------------------

TITLE: Compiled React Component with FBT Optimization
DESCRIPTION: Compiled and optimized version of the component with React compiler runtime integrations. Includes caching logic for memoization of FBT translations and Stringify wrapper components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-template-string-same-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";
import { Stringify } from "shared-runtime";

export function Component(props) {
  const $ = _c(4);
  let count = 0;
  if (props.items) {
    count = props.items.length;
  }
  let t0;
  if ($[0] !== count) {
    t0 = fbt._("for {count} experiences", [fbt._param("count", count)], {
      hk: "nmYpm",
    });
    $[0] = count;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = <Stringify>{t0}</Stringify>;
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ items: [1, 2, 3] }],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows the optimized version of the Component function. It uses memoization to avoid unnecessary re-renders and imports a compiler runtime function from React. The FIXTURE_ENTRYPOINT remains the same for testing consistency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-multiple-variable-declarations-in-initializer.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let items;
  if ($[0] !== props.items) {
    items = [];
    for (let i = 0, length = props.items.length; i < length; i++) {
      items.push(props.items[i]);
    }
    $[0] = props.items;
    $[1] = items;
  } else {
    items = $[1];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ items: ["a", "b", 42] }],
};
```

----------------------------------------

TITLE: Initialising Component with React's Compiler Runtime in JavaScript
DESCRIPTION: This JavaScript code snippet uses React's compiler-runtime, showing an advanced pattern for state management in components. It initializes a component with potential React state management utilities, updating or retaining previous states using dependency 'compiler-runtime'. Expected input is parameter 'a', influencing how the object 'x' is manipulated.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-indirect-mutate-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let x;
  if ($[0] !== a) {
    x = { a };
    const f0 = function () {
      const q = x;
      const f1 = function () {
        q.b = 1;
      };

      f1();
    };

    f0();
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Component with Caching Logic in React - JavaScript
DESCRIPTION: This code snippet illustrates a React component that uses caching for optimizing the rendering logic. It imports a cache management function from 'react/compiler-runtime' to store and check previous values of items' edges and length, determining if updates are necessary. The cached values help avoid redundant computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/memberexpr-join-optional-chain2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(5);
  let x;
  if ($[0] !== props.items?.edges || $[1] !== props.items?.length) {
    x = [];
    x.push(props.items?.length);
    let t0;
    if ($[3] !== props.items?.edges) {
      t0 = props.items?.edges?.map?.(render)?.filter?.(Boolean) ?? [];
      $[3] = props.items?.edges;
      $[4] = t0;
    } else {
      t0 = $[4];
    }
    x.push(t0);
    $[0] = props.items?.edges;
    $[1] = props.items?.length;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ items: { edges: null, length: 0 } }],
};

```

----------------------------------------

TITLE: Compiler-Transformed React Component with Memoization
DESCRIPTION: The compiler-transformed version of the input code with memoization. It uses React's compiler runtime to optimize rendering, but still contains the fundamental issue of creating components during render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-constructed-component-new.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger @validateStaticComponents
function Example(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const Component = new ComponentFactory();
    t0 = <Component />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Starting React Compiler Playground Development Server
DESCRIPTION: Commands for starting the local development server and updating the playground when React Compiler changes locally.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/README.md#2025-04-21_snippet_1

LANGUAGE: sh
CODE:
```
# Start the local development server with
$ yarn dev

# Or
$ npm run dev

# Rerun the following (in a separate terminal window) when React Compiler
# is changed locally to keep Playground in sync.
$ yarn
```

----------------------------------------

TITLE: Implementing React Compiler Runtime Memoization
DESCRIPTION: Uses React compiler runtime to create a memoized cache for component rendering, optimizing performance by caching computed values and rendered elements
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/parse-typescript-output.txt#2025-04-21_snippet_0

LANGUAGE: typescript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = foo();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0 as number;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <div>{x}</div>;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Creating Advanced React Component with Memoization
DESCRIPTION: This code snippet defines a more complex version of a React functional component that employs memoization techniques to ensure optimal performance through conditional rendering based on state values. It checks whether the current props.count matches the stored value, resulting in either the reuse of existing elements or the creation of new ones. This component also requires the 'react/compiler-runtime' and 'shared-runtime' as dependencies. The inputs are props with a count property, resulting in a rendered React element in the form of a div containing dynamic content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-overlapping-scopes-with-intermediate-reassignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Component(props) {
  const $ = _c(7);
  let x;
  let t0;
  if ($[0] !== props.count) {
    t0 = [props.count];
    $[0] = props.count;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const array = t0;
  x = array;
  let t1;
  if ($[2] !== array) {
    t1 = <div>{array}</div>;
    $[2] = array;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const element = t1;
  let t2;
  if ($[4] !== element || $[5] !== x) {
    t2 = (
      <div>
        {element}
        {x}
      </div>
    );
    $[4] = element;
    $[5] = x;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ count: 42 }],
};
```

----------------------------------------

TITLE: Initial Input Component with Mutation
DESCRIPTION: JavaScript component that creates an object with dynamic property assignment and uses the mutate function from shared runtime to modify state
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-computed-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';
function Component({a}) {
  let x = {a};
  let y = {};
  const f0 = function () {
    y['x'] = x;
  };
  f0();
  mutate(y);
  return y;
}
```

----------------------------------------

TITLE: Simplified React Component Definition and Fixture Entrypoint
DESCRIPTION: This snippet defines a simplified React component function that directly returns its props. It also exports a FIXTURE_ENTRYPOINT object for testing, identical to the input version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-break.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  return props;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Using Fire Function with React Component
DESCRIPTION: This snippet demonstrates a React functional component that imports and uses a method named fire from the react library. Within the component, it declares a function foo to log incoming props and attempts to call fire within a useEffect hook. It highlights an error due to incorrect arguments being passed to fire, which only accepts a single call expression.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-multiple-args.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component({bar, baz}) {
  const foo = () => {
    console.log(bar, baz);
  };
  useEffect(() => {
    fire(foo(bar), baz);
  });

  return null;
}

```

----------------------------------------

TITLE: Compiled React Component with Optimized Memoization
DESCRIPTION: This snippet shows the compiled version of the React component, optimized for performance. It uses the React compiler runtime to implement efficient memoization and conditional rendering based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-own-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useMemo } from "react";

function Component(t0) {
  const $ = _c(2);
  const { propA, propB } = t0;
  let t1;
  bb0: {
    if (propA) {
      let t2;
      if ($[0] !== propB.x.y) {
        t2 = { value: propB.x.y };
        $[0] = propB.x.y;
        $[1] = t2;
      } else {
        t2 = $[1];
      }
      t1 = t2;
      break bb0;
    }
    t1 = undefined;
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ propA: 1, propB: { x: { y: [] } } }],
};
```

----------------------------------------

TITLE: Implementing Counter Function with Two Variables in JavaScript
DESCRIPTION: A function that increments two variables in a while loop until reaching a maximum value specified in props. The function returns the final value of the y variable. This is the original implementation with both x and y variables.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-loop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let x = 0;
  let y = 0;
  while (y < props.max) {
    x++;
    y++;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{max: 10}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows the optimized version of the React component using compiler-specific functions and memoization techniques. It includes caching mechanisms for callbacks and effects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-global-mutation-in-effect-indirect-usecallback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useCallback, useEffect, useState } from "react";

let someGlobal = {};

function Component() {
  const $ = _c(6);
  const [state, setState] = useState(someGlobal);

  const setGlobal = _temp;
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setGlobal();
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  let t2;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      setState(someGlobal.value);
    };
    t3 = [someGlobal];
    $[2] = t2;
    $[3] = t3;
  } else {
    t2 = $[2];
    t3 = $[3];
  }
  useEffect(t2, t3);

  const t4 = String(state);
  let t5;
  if ($[4] !== t4) {
    t5 = <div>{t4}</div>;
    $[4] = t4;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  return t5;
}
function _temp() {
  someGlobal.value = true;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiler-optimized version of the component that includes memoization logic to prevent unnecessary array creation. Uses React compiler runtime utilities to cache computed values and resulting arrays.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-with-assignment-as-update.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x = props.init;
  for (let i = 0; i < 100; i = i + 1) {
    x = x + i;
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ init: 0 }],
};
```

----------------------------------------

TITLE: Optimized Component Logic with Props in JavaScript
DESCRIPTION: This snippet presents an optimized version of a React component that processes properties using a cached approach. It checks if incoming prop values have changed and conditionally populates an array `a`. This includes handling of `props.b` and ensures efficient updates by utilizing an array `$` to store previous prop values. Dependencies include React Compiler Runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/conditional-break-labeled.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
/**
 * props.b *does* influence `a`
 */
function Component(props) {
  const $ = _c(5);
  let a;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d
  ) {
    a = [];
    a.push(props.a);
    bb0: {
      if (props.b) {
        break bb0;
      }

      a.push(props.c);
    }

    a.push(props.d);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = a;
  } else {
    a = $[4];
  }
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized useFoo Function with Compiler Runtime Integration - JavaScript
DESCRIPTION: This snippet showcases an optimized version of the 'useFoo' function that integrates with React's compiler runtime. It maintains state across renders and minimizes recalculations when the input has not changed, improving performance in React applications.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(t0) {
  const $ = _c(2);
  const { a } = t0;
  let x;
  if ($[0] !== a.b.c.d.e) {
    x = [];
    x.push(a?.b.c?.d.e);
    x.push(a.b?.c.d?.e);
    $[0] = a.b.c.d.e;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: React Component Definition with Shared-Runtime
DESCRIPTION: This code defines a React component that accepts a prop 'a', creates a function 'x' that mutates a local variable 'z', and then renders a `Stringify` component from `shared-runtime`, passing `x` as the `fn` prop and setting `shouldInvokeFns` to `true`. The `FIXTURE_ENTRYPOINT` exports an object containing the component, initial parameters, and sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-shadow-captured.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate, Stringify} from 'shared-runtime';
function Component({a}) {
  let z = {a};
  let x = function () {
    let z;
    mutate(z);
    return z;
  };
  return <Stringify fn={x} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 1}],
  sequentialRenders: [{a: 1}, {a: 1}, {a: 2}],
};

```

----------------------------------------

TITLE: Defining React Component with Hooks and Stringify
DESCRIPTION: This snippet defines a React component that uses the useHook custom hook and renders multiple Stringify components. It demonstrates the use of the identity function and component props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-instruction-part-of-already-closed-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact
import {Stringify, identity, useHook} from 'shared-runtime';

function Component({index}) {
  const data = useHook();

  const a = identity(data, index);
  const b = identity(data, index);
  const c = identity(data, index);

  return (
    <div>
      <Stringify value={identity(b)} />
      <Stringify value={identity(a)} />
      <Stringify value={identity(c)} />
    </div>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{index: 0}],
};
```

----------------------------------------

TITLE: Initializing React Component with Shared Runtime in JavaScript
DESCRIPTION: This snippet defines a React component that imports shared runtime dependencies. It extracts a specific element, `StaticText1`, from the `something` prop and returns it as the component. The exported object, `FIXTURE_ENTRYPOINT`, includes the function and its parameters. Ensure `shared-runtime` is available for import prior to execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-reactive-local-variable-member-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as sharedRuntime from 'shared-runtime';

function Component({something}: {something: {StaticText1: React.ElementType}}) {
  const Foo = something.StaticText1;
  return () => <Foo />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{something: sharedRuntime}],
};

```

----------------------------------------

TITLE: Defining React Component with Array Filtering and Rendering in JavaScript
DESCRIPTION: This snippet defines a React component that creates an array, filters it using a mutateAndReturn function, and renders the first and last elements using a Stringify component. It also includes a FIXTURE_ENTRYPOINT for testing different renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-filter-capture-mutate-bug.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutateAndReturn, Stringify, useIdentity} from 'shared-runtime';

/**
 * Repro for bug with `mutableOnlyIfOperandsAreMutable` flag
 * Found differences in evaluator results
  * Non-forget (expected):
  * (kind: ok)
  * <div>{"children":[{"value":"foo","wat0":"joe"},{"value":5,"wat0":"joe"}]}</div>
  * <div>{"children":[{"value":"foo","wat0":"joe"},{"value":6,"wat0":"joe"}]}</div>
  * <div>{"children":[{"value":"foo","wat0":"joe"},{"value":6,"wat0":"joe"}]}</div>
  * Forget:
  * (kind: ok)
  * <div>{"children":[{"value":"foo","wat0":"joe"},{"value":5,"wat0":"joe"}]}</div>
  * <div>{"children":[{"value":"foo","wat0":"joe","wat1":"joe"},{"value":6,"wat0":"joe"}]}</div>
  * <div>{"children":[{"value":"foo","wat0":"joe","wat1":"joe"},{"value":6,"wat0":"joe"}]}</div>

 */
function Component({value}) {
  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];
  useIdentity(null);
  const derived = arr.filter(mutateAndReturn);
  return (
    <Stringify>
      {derived.at(0)}
      {derived.at(-1)}
    </Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 5}],
  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],
};
```

----------------------------------------

TITLE: Implementing Dependency-driven React Component Rendering Logic in JavaScript
DESCRIPTION: This snippet modifies the 'Component' function to preserve state over re-renders using a dependency list. It conditionally updates a stored array of values based on property changes and efficiently manages state through comparisons. Key dependencies include a '_c' utility from 'react/compiler-runtime'. Expected inputs are property objects, and outputs are arrays reflecting component states, constrained by the 'react/compiler-runtime' assumptions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-cascading-eliminated-phis.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(7);
  let x = 0;
  let values;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d ||
    $[4] !== x
  ) {
    values = [];
    const y = props.a || props.b;
    values.push(y);
    if (props.c) {
      x = 1;
    }

    values.push(x);
    if (props.d) {
      x = 2;
    }

    values.push(x);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = x;
    $[5] = values;
    $[6] = x;
  } else {
    values = $[5];
    x = $[6];
  }
  return values;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 0, b: 1, c: true, d: true }],
  sequentialRenders: [
    { a: 0, b: 1, c: true, d: true },
    { a: 4, b: 1, c: true, d: true },
    { a: 4, b: 1, c: false, d: true },
    { a: 4, b: 1, c: false, d: false },
  ],
};

```

----------------------------------------

TITLE: Implementing Original Router Component in React
DESCRIPTION: Defines a Router component that takes title and mapping props to create arrays of route entries. Includes test fixture setup with sequential renders using different titles.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-immutable-collection.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Router({title, mapping}) {
  const array = [];
  for (let [, entry] of mapping) {
    array.push([title, entry]);
  }
  return array;
}

const routes = new Map([
  ['about', '/about'],
  ['contact', '/contact'],
]);

export const FIXTURE_ENTRYPOINT = {
  fn: Router,
  params: [],
  sequentialRenders: [
    {
      title: 'Foo',
      mapping: routes,
    },
    {
      title: 'Bar',
      mapping: routes,
    },
  ],
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization
DESCRIPTION: The compiled version of the useTest hook showing React's internal memoization implementation using Symbol.for('react.memo_cache_sentinel'). Includes optimization and caching logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife-reassign.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray, print } from "shared-runtime";

function useTest() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    let w;
    w = {};

    const t1 = (w = 42);
    const t2 = w;
    let t3;

    w = 999;
    t3 = 2;
    t0 = makeArray(t1, t2, t3);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component using Stringify and identity functions. Renders two Stringify components with identity-transformed empty objects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/renaming-jsx-tag-lowercase.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify, identity, useIdentity} from 'shared-runtime';

function Foo({}) {
  const x = {};
  const y = {};
  useIdentity(0);
  return (
    <>
      <Stringify value={identity(y)} />
      <Stringify value={identity(x)} />
    </>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Error Message for Multiple FBT Plural Tags
DESCRIPTION: The error message shown when attempting to use multiple fbt:plural tags within a single fbt component. The error indicates that support for multiple fbt:plural values is not implemented.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-multiple-fbt-plural.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  31 |       </fbt:plural>
  32 |       to Rust 
> 33 |       <fbt:plural count={months} name="number of months" showCount="yes">
     |        ^^^^^^^^^^ Todo: Support <fbt> tags with multiple <fbt:plural> values (33:33)
  34 |         month
  35 |       </fbt:plural>
  36 |       traveling
```

----------------------------------------

TITLE: React Compiler Transformed Component with Memoization
DESCRIPTION: Compiler-generated version of useFoo with explicit memoization and state tracking using _c runtime helper, handling nested function and component rendering
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access-local-var.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useFoo(t0) {
  const $ = _c(6);
  const { a } = t0;
  let local;
  if ($[0] !== a) {
    local = shallowCopy(a);
    mutate(local);
    $[0] = a;
    $[1] = local;
  } else {
    local = $[1];
  }
  // ... rest of transformed implementation
}
```

----------------------------------------

TITLE: React Hook Compiled Implementation
DESCRIPTION: Compiled version of the hook showing the internal React compiler optimizations. Implements the same functionality but with additional caching logic using array-based memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/consecutive-use-memo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { identity } from "shared-runtime";

function useHook(t0) {
  const $ = _c(7);
  const { a, b } = t0;
  let t1;
  let t2;
  if ($[0] !== a) {
    t2 = identity({ a });
    $[0] = a;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const valA = t1;
  let t3;
  let t4;
  if ($[2] !== b) {
    t4 = identity([b]);
    $[2] = b;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  t3 = t4;
  const valB = t3;
  let t5;
  if ($[4] !== valA || $[5] !== valB) {
    t5 = [valA, valB];
    $[4] = valA;
    $[5] = valB;
    $[6] = t5;
  } else {
    t5 = $[6];
  }
  return t5;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ a: 2, b: 3 }],
};
```

----------------------------------------

TITLE: Managing Reactive Dependencies in React with Compiler Runtime
DESCRIPTION: This JavaScript code snippet enhances a React component using the compiler runtime's conditional dependency management. It maintains the reactivity of properties within the component by employing a caching technique, using the array '$' to store computed properties. If the property's old value differs from the new one, it updates and caches the result. This snippet depends on the 'react/compiler-runtime' import for the '_c' function which facilitates this caching mechanism. The snippet exports a fixture entry point as a testable part.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/conditional-member-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
// To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a` as a dependency (since `props.a.b` is
// a conditional dependency, i.e. gated behind control flow)

function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.a?.b) {
    x = [];
    x.push(props.a?.b);
    $[0] = props.a?.b;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: null }],
};
```

----------------------------------------

TITLE: React Compiler Transformed Function with Memoization
DESCRIPTION: The compiled version of the function using React's compiler runtime. It adds memoization to prevent unnecessary object creation and mutation on subsequent calls by storing the result in a cache array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let y;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = {};
    const x = a;

    y = {};
    y.x = x;

    mutate(a);
    $[0] = y;
  } else {
    y = $[0];
  }
  return y;
}
```

----------------------------------------

TITLE: Optimizing Loop Function in JavaScript
DESCRIPTION: This snippet shows an optimized version of the 'foo' function. The infinite loop is replaced with a false condition, effectively removing the loop. The function now always returns 0.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-while.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  let y = 0;
  while (false) {
    y = y + 1;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Transformed Worklet Function
DESCRIPTION: Shows the compiler-transformed version of the worklet function where the inline arrow function is hoisted to a separate named function '_temp' while maintaining the same functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-function-one-line-directive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useFoo() {
  const update = _temp;
  return update;
}
function _temp() {
  "worklet";
  return 1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled: React Compiler Transformed Switch Statement
DESCRIPTION: React compiler's transformed version of the function with memoization and optimization techniques to manage reactive dependencies
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-missing-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useCondDepInSwitchMissingDefault(props, other) {
  const $ = _c(3);
  let x;
  if ($[0] !== other || $[1] !== props) {
    x = {};
    bb0: switch (identity(other)) {
      case 1: {
        x.a = props.a.b;
        break bb0;
      }
      case 2: {
        x.b = props.a.b;
      }
    }
    $[0] = other;
    $[1] = props;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}
```

----------------------------------------

TITLE: Optimized React Hook Implementation with Compiler-Generated Code
DESCRIPTION: This snippet shows an optimized version of the 'useFoo' hook, likely generated by a React compiler. It includes additional logic for memoization and dependency tracking, improving performance by minimizing unnecessary re-renders and calculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-in-other-reactive-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useMemo, useState } from "react";
import { arrayPush } from "shared-runtime";

// useMemo-produced values can exist in nested reactive blocks, as long
// as their reactive dependencies are a subset of depslist from source
function useFoo(minWidth, otherProp) {
  const $ = _c(6);
  const [width] = useState(1);
  let t0;
  if ($[0] !== minWidth || $[1] !== otherProp || $[2] !== width) {
    const x = [];
    let t1;

    const t2 = Math.max(minWidth, width);
    let t3;
    if ($[4] !== t2) {
      t3 = { width: t2 };
      $[4] = t2;
      $[5] = t3;
    } else {
      t3 = $[5];
    }
    t1 = t3;
    const style = t1;

    arrayPush(x, otherProp);
    t0 = [style, x];
    $[0] = minWidth;
    $[1] = otherProp;
    $[2] = width;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [2, "other"],
};
```

----------------------------------------

TITLE: Transformed React Component Implementation
DESCRIPTION: Shows the compiled/transformed version of the component with explicit parameter destructuring and default value handling. Demonstrates how the syntactic sugar of default parameters is implemented under the hood.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-param-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(t0) {
  const { a: t1 } = t0;
  const a = t1 === undefined ? 2 : t1;
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized Rendering in JavaScript
DESCRIPTION: This snippet shows the compiled version of the React component with optimized rendering. It includes runtime imports and uses a caching mechanism to prevent unnecessary re-renders of the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-namespace-assigned-to-temporary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer) @enableAssumeHooksFollowRulesOfReact:false @customMacros(cx)
import { identity } from "shared-runtime";

const DARK = "dark";

function Component() {
  const $ = _c(2);
  const theme = useTheme();

  const t0 = cx.foo({
    "styles/light": true,
    "styles/dark": identity([theme.getTheme()]),
  });
  let t1;
  if ($[0] !== t0) {
    t1 = <div className={t0} />;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

const cx = {
  foo(obj) {
    const classes = [];
    for (const [key, value] of Object.entries(obj)) {
      if (value) {
        classes.push(key);
      }
    }
    return classes.join(" ");
  },
};

function useTheme() {
  return {
    getTheme() {
      return DARK;
    },
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet demonstrates an optimized version of the React component using the `react/compiler-runtime`. It utilizes the `_c` function to memoize the rendered output, potentially avoiding unnecessary re-renders if the props haven't changed. The `$` variable stores the memoized data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-at-start-of-value-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    t0 = isMenuShown ? <Bar> {props.a ? props.b : props.c}</Bar> : null;
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  return x;
}

```

----------------------------------------

TITLE: React Compiler Runtime Optimized Dependency Tracking
DESCRIPTION: Optimized version of the function using React compiler runtime, demonstrating memoization and efficient object tracking with minimal recomputation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function TestDepsSubpathOrder2(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.a) {
    x = {};
    x.a = props.a;
    x.b = props.a.b;
    x.c = props.a.b.c;
    $[0] = props.a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: Compiled Component with Memoization
DESCRIPTION: This code represents the compiled output of the `Component` defined previously, utilizing the `react/compiler-runtime`. It incorporates memoization techniques to optimize rendering performance by caching previous prop values and rendered results. The `_c` function from `react/compiler-runtime` is used for memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-with-only-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Component(t0) {
  const $ = _c(5);
  let kind;
  let props;
  if ($[0] !== t0) {
    ({ kind, ...props } = t0);
    $[0] = t0;
    $[1] = kind;
    $[2] = props;
  } else {
    kind = $[1];
    props = $[2];
  }
  switch (kind) {
    default: {
      let t1;
      if ($[3] !== props) {
        t1 = <Stringify {...props} />;
        $[3] = props;
        $[4] = t1;
      } else {
        t1 = $[4];
      }
      return t1;
    }
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ kind: "foo", a: 1, b: true, c: "sathya" }],
};

```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This is the compiled version of the `VideoTab` component. It uses `react/compiler-runtime` to optimize the rendering. The compiled version caches the rendered output using the `_c` function and a sentinel value for memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-aliased-no-added-to-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender false
function VideoTab() {
  const $ = _c(1);
  const ref = useRef();
  const t = ref.current;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = () => {
      console.log(t);
    };

    t0 = <VideoList videos={x} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

```

----------------------------------------

TITLE: Installing React and React Markup
DESCRIPTION: This snippet provides installation instructions for the react and react-markup packages using npm, allowing the rendering of standalone HTML for embedded contexts.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-markup/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
npm install react react-markup
```

----------------------------------------

TITLE: Exporting a Fixture Entry Point - JavaScript
DESCRIPTION: Exports a constant 'FIXTURE_ENTRYPOINT' containing the 'MyApp' function, an empty parameter array, and a flag indicating it's not a component. This is useful for module exports in JavaScript and allows for easy integration into other parts of the application.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/issue933-disjoint-set-infinite-loop.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Regression Test with Conditional Expression
DESCRIPTION: This snippet demonstrates a regression test in React for a conditional expression assigned to a variable. It checks if the conditional ternary operator 'cond ? a : b' is correctly parsed within a function component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-c5d1f3143c4c.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Regression test for incorrectly flagged valid code.
function RegressionTest() {
  const foo = cond ? a : b;
  useState();
}

```

----------------------------------------

TITLE: Original JavaScript Function
DESCRIPTION: This is the original JavaScript function `foo` that takes an argument `a`. It initializes an empty object `b`, aliases it to `x`, conditionally creates objects `y` or `z` based on `a`, and assigns them as properties of `x`. Finally, it calls `mutate(b)` and returns `x`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-alias-mutate-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a) {\n  const b = {};\n  const x = b;\n  if (a) {\n    let y = {};\n    x.y = y;\n  } else {\n    let z = {};\n    x.z = z;\n  }\n  mutate(b); // aliases x, y & z\n  return x;\n}\n
```

----------------------------------------

TITLE: React Compiler Memoization Error
DESCRIPTION: This is the error message generated by the React Compiler.  It explains why the compiler skipped optimizing a component.  The error `CannotPreserveMemoization` explains that the inferred dependencies did not match the manually specified dependencies.  The message pinpoints the line where useCallback is used and the dependencies array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useCallback-property-call-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  3 |
  4 | function Component({propA}) {
> 5 |   return useCallback(() => {
    |                      ^^^^^^^
> 6 |     return propA.x();
    | ^^^^^^^^^^^^^^^^^^^^^
> 7 |   }, [propA.x]);
    | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:7)
  8 | }
  9 |

```

----------------------------------------

TITLE: Rendering Error View Using Stringify Component in JavaScript
DESCRIPTION: This snippet constructs an ErrorView component that utilizes the Stringify component to display errors in a React application. It exports the component and defines a FIXTURE_ENTRYPOINT for integration, evaluating ErrorView in runtime. Dependencies include 'shared-runtime' for Stringify.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/arrow-function-expr-gating-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import {Stringify} from 'shared-runtime';
const ErrorView = ({error, _retry}) => <Stringify error={error}></Stringify>;

export default ErrorView;

export const FIXTURE_ENTRYPOINT = {
  fn: eval('ErrorView'),
  params: [{}],
};

```

----------------------------------------

TITLE: Optimizing React Component with Caching
DESCRIPTION: This snippet presents an optimized version of the React component. It uses a custom compiler runtime for caching, which helps avoid unnecessary computations when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-value-modified-in-catch-escaping.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { throwInput } = require("shared-runtime");

function Component(props) {
  const $ = _c(3);
  let x;
  if ($[0] !== props.e || $[1] !== props.y) {
    try {
      const y = [];
      y.push(props.y);
      throwInput(y);
    } catch (t0) {
      const e = t0;
      e.push(props.e);
      x = e;
    }
    $[0] = props.e;
    $[1] = props.y;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ y: "foo", e: "bar" }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The optimized version of the component after React compiler processing. It implements memoization using an array to track input and output values, preventing unnecessary recomputation when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/interdependent-across-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function compute() {}
function foo() {}
function Foo() {}

/**
 * Should produce 1 scope:
 *
 * return: inputs=props.a & props.b & props.c; outputs=return
 *   const a = compute(props.a);
 *   const b = compute(props.b);
 *   if (props.c)
 *     foo(a, b);
 *   return = <Foo a={a} b={b} />
 */
function Component(props) {
  const $ = _c(8);
  let a;
  let b;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.c) {
    a = compute(props.a);
    b = compute(props.b);
    if (props.c) {
      foo(a, b);
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = a;
    $[4] = b;
  } else {
    a = $[3];
    b = $[4];
  }
  let t0;
  if ($[5] !== a || $[6] !== b) {
    t0 = <Foo a={a} b={b} />;
    $[5] = a;
    $[6] = b;
    $[7] = t0;
  } else {
    t0 = $[7];
  }
  return t0;
}
```

----------------------------------------

TITLE: Using Labeled Break Statements in JavaScript Function
DESCRIPTION: This code snippet demonstrates a function that uses a labeled break statement to exit from nested loops. The function takes three parameters and contains a labeled if-statement with nested while and if blocks, using 'break label' to exit the outer block when condition c is true.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/complex-while.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  label: if (a) {
    while (b) {
      if (c) {
        break label;
      }
    }
  }
  return c;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows the compiled and optimized version of the React component. It uses memoization techniques to improve performance by caching values and only updating when necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-maybe-mutates-hook-return-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  const id = useSelectedEntitytId();
  let t0;
  if ($[0] !== id) {
    t0 = () => {
      log(id);
    };
    $[0] = id;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onLoad = t0;
  let t1;
  if ($[2] !== onLoad) {
    t1 = <Foo onLoad={onLoad} />;
    $[2] = onLoad;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
```

----------------------------------------

TITLE: Implementing React Component with Local State Mutation
DESCRIPTION: This snippet defines a React component that increments a local variable. It demonstrates writing to primitives, which is not considered a 'mutate' or 'store' operation in the context of AnalyzeFunctions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-reassign-primitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component() {
  let x = 40;

  const fn = function () {
    x = x + 1;
  };
  fn();
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Compiler-Runtime
DESCRIPTION: This code shows the compiled version of the React component using `react/compiler-runtime`.  The compiler memoizes the Stringify component render.  The function `_temp` is equivalent to the function `x` in the previous snippet and also uses `mutate` from `shared-runtime` to modify the variable `z_0`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-shadow-captured.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate, Stringify } from "shared-runtime";
function Component(t0) {
  const $ = _c(1);

  const x = _temp;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <Stringify fn={x} shouldInvokeFns={true} />;
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  return t1;
}
function _temp() {
  let z_0;
  mutate(z_0);
  return z_0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1 }],
  sequentialRenders: [{ a: 1 }, { a: 1 }, { a: 2 }],
};

```

----------------------------------------

TITLE: Using React Memoization with Hoisting
DESCRIPTION: This snippet showcases a refined version of the 'hoisting' function that integrates the React compiler runtime for memoization. It uses the '_c' function from React to work with a parameter that is memoized. If a certain condition is met, it invokes 'bar' through 'foo'. This code aims to demonstrate functional behavior reliant on React's memoization which improves performance by avoiding unnecessary re-computation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-function-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function hoisting() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const foo = () => bar();

    const bar = _temp;

    t0 = foo();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  return 1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Compiled React Hook with Memoization Optimization
DESCRIPTION: The compiler-optimized version of useFoo that implements memoization using React's memo cache sentinel. Adds caching for both the Set creation and spread operation results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/call-spread-argument-set.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useIdentity } from "shared-runtime";

/**
 * Forked version of call-spread-argument-mutable-iterator that is known to not mutate
 * the spread argument since it is a Set
 */
function useFoo() {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = new Set([1, 2]);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const s = t0;
  useIdentity(null);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [Math.max(...s), s];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The React compiler-transformed version of the Foo component that implements memoization. It uses a compiler runtime utility to cache the created object and avoid recreating it on subsequent renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/store-via-new.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = {};
    const y = new Foo(x);
    y.mutate();
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}
```

----------------------------------------

TITLE: React Component Compiled Output
DESCRIPTION: Compiled version of the React component showing the implementation of memoization caching using symbols and compilation-time optimizations. Includes cache invalidation logic and memoized render output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-refresh-on-const-changes-dev.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer) @enableResetCacheOnSourceFileChanges
import { useEffect, useMemo, useState } from "react";
import { ValidateMemoization } from "shared-runtime";

let pretendConst = 0;

function unsafeResetConst() {
  pretendConst = 0;
}

function unsafeUpdateConst() {
  pretendConst += 1;
}

function Component() {
  const $ = _c(3);
  if (
    $[0] !== "8d7015668f857996c3d895a7a90e3e16b8a791d5b9cd13f2c76e1c254aeedebb"
  ) {
    for (let $i = 0; $i < 3; $i += 1) {
      $[$i] = Symbol.for("react.memo_cache_sentinel");
    }
    $[0] = "8d7015668f857996c3d895a7a90e3e16b8a791d5b9cd13f2c76e1c254aeedebb";
  }
  useState(_temp);

  unsafeUpdateConst();
  let t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [{ pretendConst }];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const value = t0;
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = <ValidateMemoization inputs={[pretendConst]} output={value} />;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}
function _temp() {
  unsafeResetConst();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization Using Compiler Runtime
DESCRIPTION: This snippet shows the compiled output of the useFoo hook using React's compiler runtime. It implements memoization to avoid redundant calculations by tracking changes to inputs (cond and value). The compiled version uses a labeled block (bb0) instead of the original label statement and adds dependency tracking for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-reactive-scope-overlaps-label.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { arrayPush } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(3);
  const { cond, value } = t0;
  let items;
  if ($[0] !== cond || $[1] !== value) {
    bb0: {
      items = [];
      if (cond) {
        break bb0;
      }
      arrayPush(items, value);
    }

    arrayPush(items, value);
    $[0] = cond;
    $[1] = value;
    $[2] = items;
  } else {
    items = $[2];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: true, value: 2 }],
  sequentialRenders: [
    { cond: true, value: 2 },
    { cond: true, value: 2 },
    { cond: true, value: 3 },
    { cond: false, value: 3 },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component using react/compiler-runtime
DESCRIPTION: This snippet shows the compiled output of the `Foo` component using `react/compiler-runtime`. It utilizes the `_c` function for memoization and optimization. The compiled code avoids recomputing the factorial if the component is rendered with the same props, using a cache stored in `$[0]`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-recursive-call-within-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(t0) {
  const $ = _c(1);
  const outer = _temp;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = outer(3);
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  return t1;
}
function _temp(val) {
  const fact = (x) => {
    if (x <= 0) {
      return 1;
    }
    return x * fact(x - 1);
  };
  return fact(val);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}]
};

```

----------------------------------------

TITLE: Compiled React Component with Optimizations
DESCRIPTION: Compiled version of the React component with added optimization logic including caching mechanisms and dependency tracking. Shows how the compiler transforms the code for better performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useEffect-arg-memoized.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(6);
  const dispatch = useDispatch();
  useFreeze(dispatch);
  let t0;
  if ($[0] !== dispatch) {
    t0 = () => {
      dispatch({ kind: "update" });
    };
    $[0] = dispatch;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onUpdate = t0;
  let t1;
  let t2;
  if ($[2] !== onUpdate) {
    t1 = () => {
      onUpdate();
    };
    t2 = [onUpdate];
    $[2] = onUpdate;
    $[3] = t1;
    $[4] = t2;
  } else {
    t1 = $[3];
    t2 = $[4];
  }
  useEffect(t1, t2);
  let t3;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = <div />;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return t3;
}
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows the compiled and optimized version of the React component. It includes compiler-specific optimizations and memoization logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-unreachable-code-early-return-in-useMemo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
import { useMemo, useState } from "react";
import { ValidateMemoization, identity } from "shared-runtime";

function Component(t0) {
  const $ = _c(7);
  const { value } = t0;
  let t1;
  bb0: {
    if (value == null) {
      t1 = null;
      break bb0;
    }
    try {
      let t3;
      if ($[0] !== value) {
        t3 = { value };
        $[0] = value;
        $[1] = t3;
      } else {
        t3 = $[1];
      }
      t1 = t3;
    } catch (t2) {
      t1 = null;
    }
  }
  const result = t1;
  let t2;
  if ($[2] !== value) {
    t2 = [value];
    $[2] = value;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== result || $[5] !== t2) {
    t3 = <ValidateMemoization inputs={t2} output={result} />;
    $[4] = result;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: null }],
  sequentialRenders: [
    { value: null },
    { value: null },
    { value: 42 },
    { value: 42 },
    { value: null },
    { value: 42 },
    { value: null },
    { value: 42 },
  ],
};
```

----------------------------------------

TITLE: React Component with Compilation Inference in JavaScript
DESCRIPTION: This snippet imports a specific module from react/compiler-runtime and defines a React component Foo that uses compilation inference to manage component references and preserve component state. The function returns a div element, and changes are tracked with a cache mechanism. FIXTURE_ENTRYPOINT exports the component. It requires the react/compiler-runtime package.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-component-with-ref-arg.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)

function Foo(t0, ref) {
  const $ = _c(2);
  let t1;
  if ($[0] !== ref) {
    t1 = <div ref={ref} />;
    $[0] = ref;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};

```

----------------------------------------

TITLE: Optimizing React Component with Compiler Enhancements in JavaScript
DESCRIPTION: This snippet showcases an optimized version of a React component using the `react/compiler-runtime`. It employs compiler utilities to efficiently handle prop changes and JSX rendering. The component uses an array `$` for maintaining state between renders and leverages caching to only update the DOM when `props.text` changes. Dependencies include the `react/compiler-runtime` and any implementations needed for `makeFunction`. The component expects `props` with `text` and returns a potentially memoized JSX element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-with-independently-memoizable-arg.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props) {
    const x = makeFunction(props);
    let t1;
    if ($[2] !== props.text) {
      t1 = (
        <div>
          <span>{props.text}</span>
        </div>
      );
      $[2] = props.text;
      $[3] = t1;
    } else {
      t1 = $[3];
    }
    t0 = x(t1);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const y = t0;
  return y;
}

```

----------------------------------------

TITLE: Compiled Array.at Implementation with React Optimization
DESCRIPTION: The compiled version of the Array.at component with React's compiler optimizations. Includes caching mechanism using _c compiler runtime and conditional execution based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-effect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // arrayInstance.at should have the following effects:
//  - read on arg0
//  - read on receiver
//  - mutate on lvalue
function ArrayAtTest(props) {
  const $ = _c(9);
  let t0;
  if ($[0] !== props.x) {
    t0 = foo(props.x);
    $[0] = props.x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = [t0];
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const arr = t1;
  let t2;
  if ($[4] !== arr || $[5] !== props.y) {
    let t3;
    if ($[7] !== props.y) {
      t3 = bar(props.y);
      $[7] = props.y;
      $[8] = t3;
    } else {
      t3 = $[8];
    }
    t2 = arr.at(t3);
    $[4] = arr;
    $[5] = props.y;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const result = t2;
  return result;
}
```

----------------------------------------

TITLE: Defining a Hook Function and Entry Point - JavaScript
DESCRIPTION: This snippet defines a hook function 'useHook' that takes an object with parameters 'a' and 'b'. It utilizes the 'mutate' function from 'shared-runtime' to perform actions with these parameters. The output is a mutated object that contains the original 'a' value as the return value, while 'b' is mutated separately. The snippet also includes a fixture 'FIXTURE_ENTRYPOINT' for testing the hook with predefined parameters and sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-renamed-ref.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function useHook({a, b}) {
  let z = {a};
  {
    let z = {b};
    (function () {
      mutate(z);
    })();
  }
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{a: 2, b: 3}],
  sequentialRenders: [
    {a: 2, b: 3},
    {a: 2, b: 3},
    {a: 2, b: 4},
    {a: 3, b: 4},
  ],
};

```

----------------------------------------

TITLE: React Compiler Memoization Error
DESCRIPTION: This code snippet highlights the error message generated by the React Compiler when it fails to preserve existing manual memoization. The error, `CannotPreserveMemoization`, indicates that the compiler has skipped optimizing the component because the memoized value in source is not preserved in the compilation output, pinpointing the issue within the `useCallback` call.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.todo-useCallback-captures-invalidating-value.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  11 |   x.push(props);
  12 |
> 13 |   return useCallback(() => [x], [x]);
     |                      ^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (13:13)
  14 | }
  15 |
  16 | export const FIXTURE_ENTRYPOINT = {
```

----------------------------------------

TITLE: Compiled React Component Output
DESCRIPTION: Compiled version of the component with runtime optimizations. Uses caching mechanism to prevent unnecessary object recreation when props.name hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.name) {
    t0 = { name: props.name };
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const user = t0;
  return user;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Mofei" }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Transformed version of the component with React's internal memoization logic added. Uses Symbol.for() to implement a cache sentinel and stores computed values for reuse.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/uninitialized-declaration-in-reactive-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = mutate();
    let y;
    foo(x);
    t0 = [y, x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimizing React Component with Compiler-Runtime
DESCRIPTION: This snippet shows an optimized version of the component using React's compiler-runtime. It implements memoization for the outer 'x' variable and maintains proper scoping for the inner 'x' variable.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-mutate-shadowed-object.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;

  const x_0 = [];
  const fn = function () {
    mutate(x_0);
  };

  fn();
  return x;
}
```

----------------------------------------

TITLE: Compiled: React Compiler-Optimized Code with Dependency Tracking
DESCRIPTION: Compiled version of the function that includes React compiler's optimizations. It adds dependency tracking using the compiler runtime, storing values in a cache array to prevent unnecessary recalculations and renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/promote-uncond.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // When a conditional dependency `props.a.b.c` has no unconditional dependency
// in its subpath or superpath, we should find the nearest unconditional access

import { identity } from "shared-runtime";

// and promote it to an unconditional dependency.
function usePromoteUnconditionalAccessToDependency(props, other) {
  const $ = _c(4);
  let x;
  if ($[0] !== other || $[1] !== props.a.a.a || $[2] !== props.a.b) {
    x = {};
    x.a = props.a.a.a;
    if (identity(other)) {
      x.c = props.a.b.c;
    }
    $[0] = other;
    $[1] = props.a.a.a;
    $[2] = props.a.b;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: usePromoteUnconditionalAccessToDependency,
  params: [{ a: { a: { a: 3 } } }, false],
};
```

----------------------------------------

TITLE: Compiled React Component with React Compiler Runtime
DESCRIPTION: This code represents the compiled version of the React component, utilizing the `_c` function from the `react/compiler-runtime` module.  It uses memoization techniques to optimize rendering based on prop changes, accessing potentially nested data through the `idx` macro variations.  Helper functions like `_temp`, `_temp2`, and `_temp3` are generated to extract the desired data.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-method-no-outlining-wildcard.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```javascript
import { c as _c } from "react/compiler-runtime"; // @customMacros(idx.*.b)

function Component(props) {
  const $ = _c(16);
  let t0;
  if ($[0] !== props) {
    t0 = idx(props, _temp);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const groupName1 = t0;
  let t1;
  if ($[2] !== props) {
    t1 = idx.a(props, _temp2);
    $[2] = props;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const groupName2 = t1;
  let t2;
  if ($[4] !== props) {
    t2 = idx.a.b(props, (__1) => __1.group.label);
    $[4] = props;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const groupName3 = t2;
  let t3;
  if ($[6] !== props) {
    t3 = idx.hello_world.b(props, (__2) => __2.group.label);
    $[6] = props;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  const groupName4 = t3;
  let t4;
  if ($[8] !== props) {
    t4 = idx.hello_world.b.c(props, _temp3);
    $[8] = props;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  const groupName5 = t4;
  let t5;
  if (
    $[10] !== groupName1 ||
    $[11] !== groupName2 ||
    $[12] !== groupName3 ||
    $[13] !== groupName4 ||
    $[14] !== groupName5
  ) {
    t5 = (
      <div>
        {groupName1}
        {groupName2}
        {groupName3}
        {groupName4}
        {groupName5}
      </div>
    );
    $[10] = groupName1;
    $[11] = groupName2;
    $[12] = groupName3;
    $[13] = groupName4;
    $[14] = groupName5;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  return t5;
}
function _temp3(__3) {
  return __3.group.label;
}
function _temp2(__0) {
  return __0.group.label;
}
function _temp(_) {
  return _.group.label;
}

```
```

----------------------------------------

TITLE: Optimized useFoo React Hook with Compiler Runtime in JavaScript
DESCRIPTION: This snippet shows an optimized version of the useFoo hook using React's compiler runtime. It implements memoization to avoid unnecessary computations and object creations. The optimization includes caching of previous inputs and outputs using an array managed by the compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-in-branch-ssa.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(props) {
  const $ = _c(9);

  let x = null;
  let y = null;
  let z;
  let myList;
  if ($[0] !== props) {
    myList = [];
    if (props.doDestructure) {
      ({ x, y, z } = props);

      myList.push(z);
    }
    $[0] = props;
    $[1] = myList;
    $[2] = x;
    $[3] = y;
    $[4] = z;
  } else {
    myList = $[1];
    x = $[2];
    y = $[3];
    z = $[4];
  }
  let t0;
  if ($[5] !== myList || $[6] !== x || $[7] !== y) {
    t0 = { x, y, myList };
    $[5] = myList;
    $[6] = x;
    $[7] = y;
    $[8] = t0;
  } else {
    t0 = $[8];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ x: "hello", y: "world", doDestructure: true }],
};
```

----------------------------------------

TITLE: Utilizing Compiler Runtime for Hooks in React - JavaScript
DESCRIPTION: This JavaScript snippet showcases the integration of a compiler-supported runtime for hooks in React. It demonstrates a refined approach to the 'useHook' function by utilizing a compiler helper '_c'. This approach dynamically caches and updates the hook outputs based on input values, optimizing re-render cycles. 'FIXTURE_ENTRYPOINT' is set with the wrapped hook function 'useHook' and initializes parameters 'a' and 'b'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper } from "shared-runtime";
function useHook(t0) {
  const $ = _c(5);
  const { a, b } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = function () {
      return [a];
    };
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== b || $[3] !== t1) {
    t2 = {
      x: t1,
      y() {
        return [b];
      },
    };
    $[2] = b;
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ a: 1, b: 2 }],
};

```

----------------------------------------

TITLE: React Compiler Runtime Optimization with Memoization
DESCRIPTION: Transformed version of the useFoo hook using React compiler runtime (_c) for dependency tracking and memoization. Implements complex caching logic to minimize unnecessary recomputations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/nested-optional-chains.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useFoo(t0) {
  const $ = _c(15);
  const { prop1, prop2, prop3, prop4, prop5, prop6 } = t0;
  let t1;
  if ($[0] !== prop1?.value) {
    t1 = identity(prop1?.value)?.toString();
    $[0] = prop1?.value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  // ... similar memoization logic for other variables
  return t5;
}
```

----------------------------------------

TITLE: Integrating Structural Checks in React Component - JavaScript
DESCRIPTION: This enhanced snippet incorporates structural checks within a React Component to facilitate debugging by tracking changes and caching results to prevent unnecessary recalculations. It employs $structuralCheck and compiler runtime functions to handle these checks, improving component performance during state transitions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-and-other-hook-unpruned-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { $structuralCheck } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime";
import { useState } from "react"; // @enableChangeDetectionForDebugging

function useOther(x) {
  return x;
}

function Component(props) {
  const $ = _c(4);
  let t0;
  {
    t0 = f(props.x);
    let condition = $[0] !== props.x;
    if (!condition) {
      let old$t0 = $[1];
      $structuralCheck(old$t0, t0, "t0", "Component", "cached", "(8:8)");
    }
    $[0] = props.x;
    $[1] = t0;
    if (condition) {
      t0 = f(props.x);
      $structuralCheck($[1], t0, "t0", "Component", "recomputed", "(8:8)");
      t0 = $[1];
    }
  }
  const w = t0;
  const z = useOther(w);
  const [x] = useState(z);
  let t1;
  {
    t1 = <div>{x}</div>;
    let condition = $[2] !== x;
    if (!condition) {
      let old$t1 = $[3];
      $structuralCheck(old$t1, t1, "t1", "Component", "cached", "(11:11)");
    }
    $[2] = x;
    $[3] = t1;
    if (condition) {
      t1 = <div>{x}</div>;
      $structuralCheck($[3], t1, "t1", "Component", "recomputed", "(11:11)");
      t1 = $[3];
    }
  }
  return t1;
}

function f(x) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ x: 42 }],
  isComponent: true,
};

```

----------------------------------------

TITLE: Optimized React Component using Compiler Runtime in JavaScript
DESCRIPTION: This snippet shows the optimized version of the component using React's compiler runtime. It introduces memoization to prevent unnecessary object creation and improves performance. The FIXTURE_ENTRYPOINT remains the same for testing consistency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-object-pattern.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(t) {
  const $ = _c(2);
  const { a } = t;
  let t0;
  if ($[0] !== a) {
    t0 = { a };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const y = t0;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [{ a: 42 }],
};
```

----------------------------------------

TITLE: Optimized React Hook with Compiler Runtime
DESCRIPTION: This snippet is an optimized version of the React hook using a function imported from the React compiler runtime. The hook employs a memoization technique to store previous state conditions. The function gets a 'cond' parameter and conditionally updates a value, returning a JSX component if necessary. It uses the same constants and has similar functionality as the first snippet but follows a different memoization pattern. It expects an object with 'cond' as a parameter and outputs a JSX component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-reassigned-twice-let-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_NUMBER0, CONST_NUMBER1, Stringify } from "shared-runtime";

function useHook(t0) {
  "use memo";
  const $ = _c(2);
  const { cond } = t0;
  let t1;
  if ($[0] !== cond) {
    const getX = () => x;

    let x;
    x = CONST_NUMBER0;
    if (cond) {
      x = x + CONST_NUMBER1;
      x;
      x = Math.min(x, 100);
    }

    t1 = <Stringify getX={getX} shouldInvokeFns={true} />;
    $[0] = cond;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ cond: true }],
  sequentialRenders: [{ cond: true }, { cond: true }, { cond: false }],
};

```

----------------------------------------

TITLE: Optimized React Component Implementation
DESCRIPTION: Enhanced version of the component with Forget optimization, including both optimized and unoptimized paths with caching mechanism for props and ref.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-use-before-decl-ref.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
import { createRef, forwardRef } from "react";
import { Stringify } from "shared-runtime";

const Foo = forwardRef(Foo_withRef);
const isForgetEnabled_Fixtures_result = isForgetEnabled_Fixtures();
function Foo_withRef_optimized(props, ref) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props || $[1] !== ref) {
    t0 = <Stringify ref={ref} {...props} />;
    $[0] = props;
    $[1] = ref;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
function Foo_withRef_unoptimized(props, ref) {
  return <Stringify ref={ref} {...props} />;
}
function Foo_withRef(arg0, arg1) {
  if (isForgetEnabled_Fixtures_result) return Foo_withRef_optimized(arg0, arg1);
  else return Foo_withRef_unoptimized(arg0, arg1);
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval("(...args) => React.createElement(Foo, args)"),
  params: [{ prop1: 1, prop2: 2, ref: createRef() }],
};
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This snippet shows the compiled version of the `useFoo` React component, using `react/compiler-runtime` for optimization. It uses `_c` for memoization and caching. The compiled component checks for a sentinel value in the cache, and if not present, invokes the callback function `_temp` to render the `Stringify` component, then caches the result. The result is returned.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-local-tag-in-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";
function useFoo() {
  const $ = _c(1);

  const callback = _temp;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = callback();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  return <Stringify value={4} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Enhanced Function Foo with Memo Cache Handling - JavaScript
DESCRIPTION: This snippet enhances the previous definition of function 'Foo'. It now includes memoization support using the '_c' function from 'react/compiler-runtime'. Based on a condition, it decides whether to create a new object or use a cached value. It retains the mutation logic if 'CONST_TRUE' is true, and handles exceptions silently. Dependencies include 'CONST_TRUE', 'makeObject_Primitives', and '_c'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-trycatch-nested-overlapping-range.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_TRUE, makeObject_Primitives } from "shared-runtime";

function Foo() {
  const $ = _c(1);
  try {
    let thing;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      thing = null;
      if (cond) {
        thing = makeObject_Primitives();
      }
      if (CONST_TRUE) {
        mutate(thing);
      }
      $[0] = thing;
    } else {
      thing = $[0];
    }
    return thing;
  } catch {}
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Advanced Component Definition Handling Memoization - JavaScript
DESCRIPTION: This snippet provides a more complex React component definition that incorporates memoization to optimize rendering based on changes in props. It uses an internal cache to store previous states, thereby reducing unnecessary re-renders of child components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/switch-non-final-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(8);
  let t0;
  let y;
  if ($[0] !== props.p0 || $[1] !== props.p2) {
    const x = [];
    bb0: switch (props.p0) {
      case 1: {
        break bb0;
      }
      case true: {
        x.push(props.p2);
        let t1;
        if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
          t1 = [];
          $[4] = t1;
        } else {
          t1 = $[4];
        }
        y = t1;
      }
      default: {
        break bb0;
      }
      case false: {
        y = x;
      }
    }

    t0 = <Component data={x} />;
    $[0] = props.p0;
    $[1] = props.p2;
    $[2] = t0;
    $[3] = y;
  } else {
    t0 = $[2];
    y = $[3];
  }
  const child = t0;
  y.push(props.p4);
  let t1;
  if ($[5] !== child || $[6] !== y) {
    t1 = <Component data={y}>{child}</Component>;
    $[5] = child;
    $[6] = y;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  return t1;
}

```

----------------------------------------

TITLE: Defining React Component with State Mutation - JavaScript
DESCRIPTION: This code defines a React component named 'Component' that utilizes the 'mutate' function from 'shared-runtime' to update state based on input properties. It processes inputs 'foo' and 'bar' and performs state mutation based on the conditions provided.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function Component({foo, bar}) {
  let x = {foo};
  let y = {bar};
  const f0 = function () {
    let a = {y};
    let b = x;
    a.x = b;
  };
  f0();
  mutate(y);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{foo: 2, bar: 3}],
  sequentialRenders: [
    {foo: 2, bar: 3},
    {foo: 2, bar: 3},
    {foo: 2, bar: 4},
    {foo: 3, bar: 4},
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized Dependency Tracking
DESCRIPTION: The transformed version of the component after React compilation. It uses the compiler runtime to track dependencies and only recreates objects and effect callbacks when dependencies change, explicitly adding obj.a.b as a dependency to useEffect.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-memberexpr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect } from "react";
import { print } from "shared-runtime";

function ReactiveMemberExpr(t0) {
  const $ = _c(4);
  const { propVal } = t0;
  let t1;
  if ($[0] !== propVal) {
    t1 = { a: { b: propVal } };
    $[0] = propVal;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const obj = t1;
  let t2;
  if ($[2] !== obj.a.b) {
    t2 = () => print(obj.a.b);
    $[2] = obj.a.b;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  useEffect(t2, [obj.a.b]);
}
```

----------------------------------------

TITLE: React Hook Error Message
DESCRIPTION: This error message shows the exact location of the invalid hook call within the callback function passed to `useEffect`. It clearly states that Hooks must be called at the top level in the body of a function component or custom hook and not within function expressions, and it provides a link to the Rules of Hooks documentation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid.invalid-rules-of-hooks-0de1224ce64b.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  4 |   return function ComponentWithHookInsideCallback() {
  5 |     useEffect(() => {
> 6 |       useHookInsideCallback();
    |       ^^^^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call Custom within a function component (6:6)

InvalidReact: Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning). Cannot call useEffect within a function component (5:5)
  7 |     });
  8 |   };
  9 | }

```

----------------------------------------

TITLE: Compiled React Component with React Compiler Runtime
DESCRIPTION: This code presents the compiled version of the `Component` function using React's compiler runtime. It imports `_c` from `react/compiler-runtime` and utilizes it to manage the component's state. The compiled code efficiently updates the rendered output based on changes in the `props.cond` value while optimizing for scenarios where `x` remains unchanged. The `FIXTURE_ENTRYPOINT` configuration defines the component and provides a sequence of `cond` values for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  if (props.cond) {
    x = 1;
  } else {
    x = 2;
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { cond: true },
    { cond: true },
    { cond: false },
    { cond: false },
    { cond: true },
    { cond: false },
    { cond: true },
    { cond: false },
  ],
};
```

----------------------------------------

TITLE: Optimized Component with Shared Runtime - JavaScript
DESCRIPTION: This snippet provides an optimized version of the `useComponentFactory` function that maintains component state using a closure and an internal cache. It prevents unnecessary re-renders by checking existing cached values before invoking the callback function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-localvar-memberexpr-in-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as SharedRuntime from "shared-runtime";
import { invoke } from "shared-runtime";
function useComponentFactory(t0) {
  const $ = _c(4);
  const { name } = t0;
  let t1;
  if ($[0] !== name) {
    t1 = () => (
      <SharedRuntime.Stringify>hello world {name}</SharedRuntime.Stringify>
    );
    $[0] = name;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const cb = t1;
  let t2;
  if ($[2] !== cb) {
    t2 = invoke(cb);
    $[2] = cb;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useComponentFactory,
  params: [{ name: "sathya" }],
};
```

----------------------------------------

TITLE: Compiled useCallback with Compiler-Runtime
DESCRIPTION: This is the compiled version of the previous code snippet. It demonstrates how the React compiler automatically memoizes the function based on the `propA` prop. The `_c` function from `react/compiler-runtime` is used to manage the memoization cache, storing the previous value of `propA` and the memoized function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-with-no-depslist.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useCallback } from "react";

// Compiler can produce any memoization it finds valid if the
// source listed no memo deps
function Component(t0) {
  const $ = _c(2);
  const { propA } = t0;
  let t1;
  if ($[0] !== propA) {
    t1 = () => [propA];
    $[0] = propA;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ propA: 2 }],
};

```

----------------------------------------

TITLE: Initializing React Hook with Compiler Support in JavaScript
DESCRIPTION: This snippet offers an enhanced version of the `useFoo` function utilizing a compiler utility `_c` from 'react/compiler-runtime' to optimize changes and state tracking. The function efficiently manages state over multiple renders by minimizing redundant computations through caching with `_c`. It is intended to work with a shared runtime for state mutations and is driven by properties `bar`, `foo`, and `cond`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    x = [];
    x.push(props.bar);
    props.cond ? ((x = []), x.push(props.foo)) : null;
    mutate(x);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};

```

----------------------------------------

TITLE: Defining Conditional Component Logic - JavaScript
DESCRIPTION: This snippet defines a simple React component that returns an array based on props. It utilizes basic conditional checks to push values into an array and handles cases where props are not provided. The expected input is an object with boolean and numerical properties, leading to an array output.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-nested-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [];
  if (props.cond) {
    x.push(props.a);
    if (props.b) {
      const y = [props.b];
      x.push(y);
      // oops no memo!
      return x;
    }
    // oops no memo!
    return x;
  } else {
    return foo();
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, a: 42, b: 3.14}],
};
```

----------------------------------------

TITLE: React Component Compiled Output
DESCRIPTION: This code shows the compiled output for the React component `useFoo`. The compiler has introduced memoization using `_c` from `react/compiler-runtime` and `_makeReadOnly` from `react-compiler-runtime` to avoid re-rendering if the input `props.x` hasn't changed. The component now stores the result of `foo(props.x)` in a cache and reuses it if `props.x` is the same.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/emit-freeze-conflicting-imports.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { makeReadOnly as _makeReadOnly } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @enableEmitFreeze @instrumentForget

let makeReadOnly = "conflicting identifier";
function useFoo(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.x) {
    t0 = foo(props.x);
    $[0] = props.x;
    $[1] = __DEV__ ? _makeReadOnly(t0, "useFoo") : t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

```

----------------------------------------

TITLE: Optimized React Component Implementation
DESCRIPTION: Optimized version where the arrow function is hoisted to a named function _temp. The local variable assignments are simplified to directly return the final value, while maintaining the same behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-colliding-identifier.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { invoke } from "shared-runtime";

function Component() {
  const fn = _temp;

  invoke(fn);
  return 3;
}
function _temp() {
  return { x: "value" };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime and Memoization
DESCRIPTION: The compiled version of the Component function with React compiler runtime optimizations. It introduces memoization through the _c function, tracking state changes using an array, and only recalculating values when dependencies change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/createElement-freeze.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import React from "react";
import { shallowCopy } from "shared-runtime";

function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.width) {
    t0 = { style: { width: props.width } };
    $[0] = props.width;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const childProps = t0;
  let t1;
  if ($[2] !== childProps) {
    let t2;
    if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = ["hello world"];
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    t1 = React.createElement("div", childProps, t2);
    $[2] = childProps;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const element = t1;
  shallowCopy(childProps);
  return element;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Transforming React Component with Compiler Runtime Enhancements
DESCRIPTION: This snippet provides a transformed version of the given component using 'react/compiler-runtime'. It incorporates a cache mechanism to optimize rendering by comparing previous and current states, and selectively mutates the component state using the 'mutate' function if changes are detected. This version is also set up for using fixture entry points for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  const { a } = t0;
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};
    const f0 = function () {
      const a_0 = y;
      a_0.x = x;
    };

    f0();
    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 2 }],
  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],
};

```

----------------------------------------

TITLE: Implementing React Component with Structural Checks
DESCRIPTION: This snippet builds upon the previous component by integrating structural checks using the '$structuralCheck' method from 'react-compiler-runtime'. It performs change detection on the component's props and state for debugging purposes. The code includes the useState hook and checks for updates, recomputing values as necessary. This component expects a props object similar to the basic version and includes additional dependencies for debugging.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-unpruned-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { $structuralCheck } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime";
import { useState } from "react"; // @enableChangeDetectionForDebugging

function Component(props) {
  const $ = _c(5);
  let t0;
  {
    t0 = f(props.x);
    let condition = $[0] !== props.x;
    if (!condition) {
      let old$t0 = $[1];
      $structuralCheck(old$t0, t0, "t0", "Component", "cached", "(4:4)");
    }
    $[0] = props.x;
    $[1] = t0;
    if (condition) {
      t0 = f(props.x);
      $structuralCheck($[1], t0, "t0", "Component", "recomputed", "(4:4)");
      t0 = $[1];
    }
  }
  const w = t0;
  const [x] = useState(w);
  let t1;
  {
    t1 = (
      <div>
        {x}
        {w}
      </div>
    );
    let condition = $[2] !== w || $[3] !== x;
    if (!condition) {
      let old$t1 = $[4];
      $structuralCheck(old$t1, t1, "t1", "Component", "cached", "(7:10)");
    }
    $[2] = w;
    $[3] = x;
    $[4] = t1;
    if (condition) {
      t1 = (
        <div>
          {x}
          {w}
        </div>
      );
      $structuralCheck($[4], t1, "t1", "Component", "recomputed", "(7:10)");
      t1 = $[4];
    }
  }
  return t1;
}

function f(x) {
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ x: 42 }],
  isComponent: true,
};

```

----------------------------------------

TITLE: Optimized Conditional Rendering in React - JavaScript
DESCRIPTION: This snippet demonstrates optimized conditional rendering using internal caching mechanisms to prevent unnecessary recomputations in a React component 'Foo'. The snippet imports utilities from 'react/compiler-runtime' and 'shared-runtime' for functions and rendering. It maintains cache status to control when new computations for rendering are necessary, thereby ensuring efficient component updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-component-props-non-null.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR\nimport { identity, Stringify } from "shared-runtime";\n\nfunction Foo(props) {\n  const $ = _c(5);\n  let t0;\n  if ($[0] !== props.cond || $[1] !== props.value) {\n    const arr = [];\n    if (props.cond) {\n      let t1;\n      if ($[3] !== props.value) {\n        t1 = identity(props.value);\n        $[3] = props.value;\n        $[4] = t1;\n      } else {\n        t1 = $[4];\n      }\n      arr.push(t1);\n    }\n\n    t0 = <Stringify arr={arr} />;\n    $[0] = props.cond;\n    $[1] = props.value;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  return t0;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Foo,\n  params: [{ value: 2, cond: true }],\n};\n
```

----------------------------------------

TITLE: Compiled React Components with Instrumentation and Memoization
DESCRIPTION: Compiled output with instrumentation and optimization features added. The compiler adds render counters for development mode and implements a memoization strategy using Symbol tokens to avoid redundant rendering. Components maintain the same functionality but with optimized performance characteristics.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conflict-codegen-instrument-forget.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import {
  shouldInstrument as _shouldInstrument3,
  useRenderCounter,
} from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @enableEmitInstrumentForget @compilationMode(annotation)

import { identity } from "shared-runtime";

function Bar(props) {
  "use forget";
  if (DEV && _shouldInstrument3)
    useRenderCounter("Bar", "/conflict-codegen-instrument-forget.ts");
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = identity(null);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const shouldInstrument = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = identity(null);
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const _shouldInstrument = t1;
  let t2;
  if ($[2] !== props.bar) {
    t2 = (
      <div style={shouldInstrument} other={_shouldInstrument}>
        {props.bar}
      </div>
    );
    $[2] = props.bar;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

function Foo(props) {
  "use forget";
  if (DEV && _shouldInstrument3)
    useRenderCounter("Foo", "/conflict-codegen-instrument-forget.ts");
  const $ = _c(2);
  let t0;
  if ($[0] !== props.bar) {
    t0 = <Foo>{props.bar}</Foo>;
    $[0] = props.bar;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimized State Management with React Compiler in JavaScript
DESCRIPTION: This snippet illustrates an optimized approach to managing component state using the react/compiler-runtime. It tracks changes in props to avoid unnecessary computations and uses a shared runtime to mutate state only when necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-simple-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  const { a } = t0;
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};
    const f0 = function () {
      y = x;
    };

    f0();
    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 2 }],
  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],
};

```

----------------------------------------

TITLE: Memoization in React Component with Compiler Runtime in JavaScript
DESCRIPTION: This snippet extends the React component logic by integrating the `react/compiler-runtime` import for memoization. The `$` variable holds a react.memo_cache_sentinel symbol to cache the component output. It includes a conditional check to reuse the memoized output or render and reassign the new output. It demonstrates basic memoization strategy. Dependencies include the `react/compiler-runtime` library.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {}

function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = [];
    const b = {};
    foo(a, b);

    foo(b);
    t0 = <div a={a} b={b} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

```

----------------------------------------

TITLE: Exporting a Constant Object in JavaScript
DESCRIPTION: This snippet exports a constant object 'FIXTURE_ENTRYPOINT' that contains a reference to the 'foo' function and parameters for usage in other parts of the application as a component entry point.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-conditional-continue.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: Presents the compiled version of the React component. It utilizes `react/compiler-runtime` for optimization. It memoizes the result using the `_c` function to avoid unnecessary re-renders if the 'name' prop hasn't changed. The `FIXTURE_ENTRYPOINT` exports the component and a set of params used when evaluating the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-memberexpr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as SharedRuntime from "shared-runtime";
function Component(t0) {
  const $ = _c(2);
  const { name } = t0;
  let t1;
  if ($[0] !== name) {
    t1 = <SharedRuntime.Stringify>hello world {name}</SharedRuntime.Stringify>;
    $[0] = name;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "sathya" }],
};

```

----------------------------------------

TITLE: Optimized State Mutation - JavaScript
DESCRIPTION: In this snippet, the component function includes an optimization mechanism that checks if the input parameter has changed. It only constructs and mutates the state object if the parameter differs from the previous invocation, utilizing the `mutate` function appropriately.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-computed-mutate-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { mutate } = require("shared-runtime");

function component(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};

    y.x = x;

    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["foo"],
};
```

----------------------------------------

TITLE: Creating Hook Wrapper using Shared Runtime JavaScript
DESCRIPTION: This code snippet defines a function `useHook` that creates a custom hook with properties `x`, `y`, and `z` using a shared runtime utility. Dependencies include the `createHookWrapper` from the 'shared-runtime'. Parameters include `a`, `b`, and `c`, which are input to the hook, functioning as the source of reactive data. The output is an object with properties `x`, `y`, and `z`, reflecting the inputs. Additional limitations include its use within a shared-runtime compatible setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-shorthand-method-2.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import {createHookWrapper} from 'shared-runtime';

function useHook({a, b, c}) {
  return {
    x: [a],
    y() {
      return [b];
    },
    z: {c},
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{a: 1, b: 2, c: 2}],
};
```

----------------------------------------

TITLE: Defining and Mutating a React Component - JavaScript
DESCRIPTION: This snippet defines a React component that utilizes external 'mutate' functionality. It demonstrates state mutation based on props 'foo' and 'bar', dynamically adjusting component rendering. Prerequisites include the 'shared-runtime' library. Parameters include input properties 'foo' and 'bar'. Expected output changes dynamically as these parameters alter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-arr.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import {mutate} from 'shared-runtime';
function Component({foo, bar}) {
  let x = {foo};
  let y = {bar};
  const f0 = function () {
    let a = [y];
    let b = x;
    a.x = b;
  };
  f0();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{foo: 2, bar: 3}],
  sequentialRenders: [
    {foo: 2, bar: 3},
    {foo: 2, bar: 3},
    {foo: 2, bar: 4},
    {foo: 3, bar: 4},
  ],
};
```

----------------------------------------

TITLE: Optimized React Component with Lower Context Access
DESCRIPTION: Transformed version of the App component that uses useContext_withSelector for optimized context access. It includes memoization logic to prevent unnecessary re-renders when context values haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lower-context-selector-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useContext_withSelector } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @lowerContextAccess
function App() {
  const $ = _c(3);
  const { foo, bar } = useContext_withSelector(MyContext, _temp);
  let t0;
  if ($[0] !== bar || $[1] !== foo) {
    t0 = <Bar foo={foo} bar={bar} />;
    $[0] = bar;
    $[1] = foo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
function _temp(t0) {
  return [t0.foo, t0.bar];
}
```

----------------------------------------

TITLE: Defining a Non-React Function with useEffect
DESCRIPTION: This function, nonReactFn, incorrectly attempts to use the useEffect hook from React. Proper dependency handling is necessary to avoid build errors. The function takes an argument which is used within the useEffect hook. Prerequisites include a React environment and knowledge of hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.callsite-in-non-react-fn.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @compilationMode(infer) @panicThreshold(none)
import {useEffect} from 'react';

function nonReactFn(arg) {
  useEffect(() => [1, 2, arg]);
}

```

----------------------------------------

TITLE: React Error Message for Invalid Ref Access
DESCRIPTION: The error message produced when trying to access ref.current during render, which is not allowed in React. The error points to line 5 and includes a link to the React documentation about useRef.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-optional.expect.md#2025-04-22_snippet_1

LANGUAGE: text
CODE:
```
  3 | function Component(props) {
  4 |   const ref = useRef();
> 5 |   return ref?.current;
    |          ^^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)
  6 | }
  7 |
  8 | export const FIXTURE_ENTRYPOINT = {
```

----------------------------------------

TITLE: Optimized React Hook with Memoization using React Compiler Runtime
DESCRIPTION: The compiled version of the useFoo hook with memoization applied. It uses React's compiler runtime to store previous values and skip recalculations when props haven't changed, improving performance during re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-destruction.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(props) {
  const $ = _c(5);
  let x;
  if ($[0] !== props.bar) {
    x = [];
    x.push(props.bar);
    $[0] = props.bar;
    $[1] = x;
  } else {
    x = $[1];
  }
  if ($[2] !== props.cond || $[3] !== props.foo) {
    props.cond ? (([x] = [[]]), x.push(props.foo)) : null;
    $[2] = props.cond;
    $[3] = props.foo;
    $[4] = x;
  } else {
    x = $[4];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};
```

----------------------------------------

TITLE: React Functional Component Compilation with Memoization
DESCRIPTION: This snippet presents the compiled code for a React functional component (TestComponent2) that uses a compiler runtime function (`_c`) for memoization. Similar to TestComponent, it avoids re-rendering the `<Button>` component unless the `x` prop has changed, retrieving the cached result when possible.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/use-memo-output.txt#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
const TestComponent2 = (t0) => {
  "usememo";
  const $ = _c(2);
  const { x } = t0;
  let t1;
  if ($[0] !== x) {
    t1 = <Button>{x}</Button>;
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component using React's compiler runtime for memoization. It includes a cache sentinel check and separates the mapping function into a standalone helper.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-non-mutating-lambda-mutated-result.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [{}];
    const y = x.map(_temp);
    y[0].flag = true;
    t0 = [x, y];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp(item) {
  return item;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: The original component implementation assigns a value to x, then passes a reassignment expression to the function call of x, creating a side effect during function invocation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-reassign-in-rval.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Forget should call the original x (x = foo()) to compute result
function Component() {
  let x = foo();
  let result = x((x = bar()), 5);
  return [result, x];
}
```

----------------------------------------

TITLE: Original Array.at Implementation in React Component
DESCRIPTION: Demonstrates a React component that uses Array.at() method with props. The component creates an array with a single element and accesses it using the at() method with dynamic indices.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-effect.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// arrayInstance.at should have the following effects:
//  - read on arg0
//  - read on receiver
//  - mutate on lvalue
function ArrayAtTest(props) {
  const arr = [foo(props.x)];
  const result = arr.at(bar(props.y));
  return result;
}
```

----------------------------------------

TITLE: Utilize Caching in useFoo Function with React.memo_cache_sentinel in JavaScript
DESCRIPTION: An optimized version of useFoo leveraging caching with react.memo_cache_sentinel and managing state across renders. It implements cache validation for input parameter changes, utilizes shared constants for caching, and returns array manipulations. Dependencies include the 'shared-runtime' for arrayPush and 'react/compiler-runtime' for caching helper _c.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/return-before-scope-starts.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { arrayPush } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(3);
  const { input, cond } = t0;
  if (cond) {
    let t1;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = { result: "early return" };
      $[0] = t1;
    } else {
      t1 = $[0];
    }
    return t1;
  }
  let x;
  if ($[1] !== input.a.b) {
    x = [];
    arrayPush(x, input.a.b);
    $[1] = input.a.b;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { a: { b: 2 } }, cond: false }],
  sequentialRenders: [
    { input: null, cond: true },
    { input: { a: { b: 2 } }, cond: false },
    { input: null, cond: true },
    // preserve nullthrows
    { input: {}, cond: false },
    { input: { a: { b: null } }, cond: false },
    { input: { a: null }, cond: false },
    { input: { a: { b: 3 } }, cond: false },
  ],
};

```

----------------------------------------

TITLE: Compiled Output with React Memoization
DESCRIPTION: Compiled version of the useTest hook showing React's memoization implementation using Symbol.for('react.memo_cache_sentinel') and compiler runtime utilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife-storeprop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray, print } from "shared-runtime";

function useTest() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const w = {};

    const t1 = (w.x = 42);
    const t2 = w.x;
    let t3;

    w.x = 999;
    t3 = 2;
    t0 = makeArray(t1, t2, t3);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [],
};
```

----------------------------------------

TITLE: Memoization and Dynamic Component Construction in React - JavaScript
DESCRIPTION: This snippet demonstrates a pattern of using memoization with React components to optimize rendering by caching components. The code utilizes a compiler runtime import from React and checks a symbol for memoization cache validity before deciding to create a new component or reuse the cached one. Dependencies include the 'react/compiler-runtime'. Key parameters include the props passed to the Example function, and it outputs a React component that is memoized to prevent unnecessary renderings.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/static-components/invalid-dynamically-construct-component-in-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger @validateStaticComponents
function Example(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const Component = createComponent();
    t0 = <Component />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiler-optimized version of the component using React's compiler runtime for state management. Implements caching mechanism to avoid redundant calculations and maintain state consistency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reassigned-objectmethod.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { invoke } from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  const { cond } = t0;
  let x;
  if ($[0] !== cond) {
    x = 2;
    const obj = {
      method(cond_0) {
        if (cond_0) {
          x = 4;
        }
      },
    };

    invoke(obj.method, cond);
    $[0] = cond;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};
```

----------------------------------------

TITLE: Implementing React Component with Compiler Runtime Memoization
DESCRIPTION: A React component implementation that uses the compiler runtime for memoization optimization. The component renders a div with 'Hello World' text and implements memo caching using Symbol.for() to check cache state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/02-default-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
export default function MyApp() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div>Hello World</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled React Component (useCallback Replacement)
DESCRIPTION: This code represents the compiled version of the React component Foo, where the useCallback hook has been replaced with a more efficient mechanism. Instead of useCallback, it utilizes a compiler runtime helper (_c) to cache the function (t0). The function is only recreated when the router location changes, mirroring the behavior of useCallback but optimized by the compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-member-expr-arguments.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.router.location) {
    t0 = (reason) => {
      log(props.router.location);
    };
    $[0] = props.router.location;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onFoo = t0;
  return onFoo;
}

```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiled version of the component with React compiler runtime optimizations. Includes conditional rendering based on forget feature flag and memoization implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-with-hoisted-type-reference.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag";
import { memo } from "react";

type Props = React.ElementConfig<typeof Component>;
const Component = isForgetEnabled_Fixtures()
  ? function Component(t0) {
      const $ = _c(2);
      const { value } = t0;
      let t1;
      if ($[0] !== value) {
        t1 = <div>{value}</div>;
        $[0] = value;
        $[1] = t1;
      } else {
        t1 = $[1];
      }
      return t1;
    }
  : function Component({ value }: $ReadOnly<{ value: string }>) {
      return <div>{value}</div>;
    };

export default memo<Props>(Component);

export const FIXTURE_ENTRYPOINT = {
  fn: eval("Component"),
  params: [{ value: "foo" }],
};
```

----------------------------------------

TITLE: React Component Definition with useHook
DESCRIPTION: This React component utilizes the `useHook` function from the `shared-runtime` module.  The hook call is intentionally interspersed within the component's logic to prevent memoization of the 'x' variable. The component accepts 'props' as input, specifically expecting a 'value' property, and returns a nested array containing this value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useHook } from "shared-runtime";

function Component(props) {
  const x = [];
  useHook();
  x.push(props.value);

  const y = [x];
  return [y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "sathya" }],
};
```

----------------------------------------

TITLE: React Compiler Runtime Memoization Implementation
DESCRIPTION: Demonstrates the React compiler's runtime memoization strategy using a cache sentinel and conditional caching mechanism. Shows how complex reactive dependencies are tracked and memoized to optimize performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const $ = _c(1);

  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(10);

  const c = [a];

  let x;
  for (let i = 0; i < c[0][0]; i++) {
    x = 1;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled React Hook useFoo with Memoization
DESCRIPTION: This code presents the compiled version of the `useFoo` React hook, utilizing React's compiler runtime (`react/compiler-runtime`). It employs memoization techniques using the `_c` function to optimize rendering. The compiled code checks if the input `a` has changed and, if so, re-executes the hook's logic. It also memoizes the callback function `cb` using a similar pattern, storing and reusing the function if the length of `obj_alias.arr` hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-aliased-capture-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { setPropertyByKey, Stringify } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(4);
  const { a } = t0;
  let t1;
  if ($[0] !== a) {
    const arr = [];
    const obj = { value: a };

    setPropertyByKey(obj, "arr", arr);
    const obj_alias = obj;
    let t2;
    if ($[2] !== obj_alias.arr.length) {
      t2 = () => obj_alias.arr.length;
      $[2] = obj_alias.arr.length;
      $[3] = t2;
    } else {
      t2 = $[3];
    }
    const cb = t2;
    for (let i = 0; i < a; i++) {
      arr.push(i);
    }

    t1 = <Stringify cb={cb} shouldInvokeFns={true} />;
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: 2 }],
  sequentialRenders: [{ a: 2 }, { a: 3 }],
};

```

----------------------------------------

TITLE: Defining a Reactive Component with Memoization - JavaScript
DESCRIPTION: This snippet demonstrates a more complex version of the 'Component' function that integrates memoization using 'react/compiler-runtime'. It processes props in a similar manner but includes additional logic to determine memoized output. Parameters include 'props' with 'cond' and the output is the memoized array based on the reactive state of 'x'. This version is crucial for performance in larger applications.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-update.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);

  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(10);

  const c = [a];

  let x;
  for (let i = 0; i < 10; i = i + c[0][0], i) {
    x = 1;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};
```

----------------------------------------

TITLE: Optimized Hook with Conditional Mutation - JavaScript
DESCRIPTION: This snippet enhances the previous hook implementation by adding conditional checks to optimize value changes. It ensures that the value is only mutated when necessary, thus improving performance. It still exports a fixture entry point to interface with React's hook system.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-derived-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper, mutateAndReturn } from "shared-runtime";
function useHook(t0) {
  const $ = _c(4);
  const { value } = t0;
  let t1;
  if ($[0] !== value) {
    t1 = mutateAndReturn({ value });
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  let t2;
  if ($[2] !== x) {
    t2 = {
      getValue() {
        return x;
      },
    };
    $[2] = x;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const obj = t2;
  return obj;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ value: 0 }],
};
```

----------------------------------------

TITLE: Creating React Hook with Caching Mechanism - JavaScript
DESCRIPTION: This snippet utilizes 'react/compiler-runtime' and 'shared-runtime' libraries to create a React hook with caching capabilities. It checks whether the stored cache differs from the new value, applying state mutations to ensure efficient re-renders. The hook generates an object with a 'getValue' method to access the current state's value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand-aliased-mutate-after.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper, mutate, mutateAndReturn } from "shared-runtime";
function useHook(t0) {
  const $ = _c(2);
  const { value } = t0;
  let obj;
  if ($[0] !== value) {
    const x = mutateAndReturn({ value });
    obj = {
      getValue() {
        return value;
      },
    };

    mutate(x);
    $[0] = value;
    $[1] = obj;
  } else {
    obj = $[1];
  }
  return obj;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ value: 0 }],
};

```

----------------------------------------

TITLE: React Compiler Transformed Component with Memoization
DESCRIPTION: The React Compiler version of the component with added memoization using the _c runtime function. It caches the returned function and only recreates it when props change, improving performance by avoiding unnecessary function recreation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassigned-phi-in-returned-function-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    t0 = () => {
      let str;
      if (arguments.length) {
        str = arguments[0];
      } else {
        str = props.str;
      }

      global.log(str);
    };
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: React Counter Component Implementation - Compiled Output
DESCRIPTION: Compiled version of the counter component showing React's compiler runtime optimizations including memoization logic and scope handling for improved performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-deps-subset-of-decls.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState } from "react";

function Component() {
  const $ = _c(2);
  const [count, setCount] = useState(0);
  let t0;
  if ($[0] !== count) {
    t0 = (
      <div>
        <button onClick={() => setCount(count - 1)}>Decrement</button>

        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
    $[0] = count;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Hook Implementation
DESCRIPTION: The compiled version of the hook using React's compiler runtime, implementing memoization using an array-based cache. Includes the same fixture setup as the original.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-derived-in-ternary-consequent.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, createHookWrapper } from "shared-runtime";

function useHook(t0) {
  const $ = _c(3);
  const { isCond, value } = t0;
  let t1;
  if ($[0] !== isCond || $[1] !== value) {
    t1 = isCond
      ? identity({
          getValue() {
            return value;
          },
        })
      : 42;
    $[0] = isCond;
    $[1] = value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ isCond: true, value: 0 }],
};
```

----------------------------------------

TITLE: React Compiler Optimized Dependency Tracking Function
DESCRIPTION: Compiled version of the function with runtime dependency tracking and memoization using React compiler runtime
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order3.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function TestDepsSubpathOrder3(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.a) {
    x = {};
    x.c = props.a.b.c;
    x.a = props.a;
    x.b = props.a.b;
    $[0] = props.a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: React Component with Unused Variable (Input)
DESCRIPTION: This code snippet defines a React component named `Component` that receives `props` as an argument. Inside the component, an object is created using `makeObject()`, and an optional chaining expression `obj.a?.b?.(props.c)` is used. However, the result of this expression is assigned to an unused variable `_`. The component returns null, indicating that it does not render any visible content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-optional-method-assigned-to-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // unused!
  const obj = makeObject();
  const _ = obj.a?.b?.(props.c);
  return null;
}
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This code represents the compiled version of the React component, potentially optimized using a React compiler. It uses `_c` from 'react/compiler-runtime' for memoization. The compiled component aims to achieve the same functionality as the original component, calculating and rendering `expensiveNumber`, but with enhanced performance due to compiler optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/babel-existing-react-namespace-import.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as React from "react";
import { calculateExpensiveNumber } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  const [x] = React.useState(0);
  let t0;
  let t1;
  if ($[0] !== x) {
    t1 = calculateExpensiveNumber(x);
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const expensiveNumber = t0;
  let t2;
  if ($[2] !== expensiveNumber) {
    t2 = <div>{expensiveNumber}</div>;
    $[2] = expensiveNumber;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};

```

----------------------------------------

TITLE: Compiled React Component Output
DESCRIPTION: Compiled version of the component with React compiler runtime optimizations. Implements caching mechanism using the _c compiler helper to avoid recreating objects on each render when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-capture-global.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
let someGlobal = {};
function component(a) {
  const $ = _c(2);
  let t0;
  if ($[0] !== a) {
    t0 = { a, someGlobal };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["value 1"],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component with Memoization Caching - JavaScript
DESCRIPTION: This code snippet features a React component with enhanced memoization capabilities using a custom caching mechanism. It focuses on optimizing the useEffect hooks by storing memoized computations and cache keys, allowing efficient re-rendering and dependency tracking of ref and state changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-access-in-effect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender
import { useEffect, useRef, useState } from "react";

function Component() {
  const $ = _c(6);
  const ref = useRef(null);
  const [state, setState] = useState(false);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      ref.current = "Ok";
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  let t2;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      setState(true);
    };
    t3 = [];
    $[2] = t2;
    $[3] = t3;
  } else {
    t2 = $[2];
    t3 = $[3];
  }
  useEffect(t2, t3);

  const t4 = String(state);
  let t5;
  if ($[4] !== t4) {
    t5 = <Child key={t4} ref={ref} />;
    $[4] = t4;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  return t5;
}

function Child(t0) {
  const { ref } = t0;
  return ref.current;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: Compiled React Component with Optimization Logic
DESCRIPTION: Compiled version of the React component with added optimization logic. Includes memoization using compiler runtime and conditional rendering based on state changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/module-scoped-bindings.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import React from "react";
import { useState } from "react";

const CONST = true;

let NON_REASSIGNED_LET = true;

let REASSIGNED_LET = false;
REASSIGNED_LET = true;

function reassignedFunction() {}
reassignedFunction = true;

function nonReassignedFunction() {}

class ReassignedClass {}
ReassignedClass = true;

class NonReassignedClass {}

function Component() {
  const $ = _c(2);
  const [state] = useState(null);
  let t0;
  if ($[0] !== state) {
    t0 = [
      React,

      state,
      CONST,
      NON_REASSIGNED_LET,
      REASSIGNED_LET,
      reassignedFunction,
      nonReassignedFunction,
      ReassignedClass,
      NonReassignedClass,
    ];
    $[0] = state;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with Conditional Logic in JavaScript
DESCRIPTION: This snippet defines a React component using conditional logic to check if a prop has changed and conditionally initialize the component state. It makes use of an imported compiler-runtime function to handle state management within the component function. The component is then exported as a fixture entry with specified parameters and an indicator of its component status.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-decl.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let t;
  if ($[0] !== a) {
    t = { a };
    const x = function x() {
      t.foo();
    };

    x(t);
    $[0] = a;
    $[1] = t;
  } else {
    t = $[1];
  }
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining Foo Component with Stringify - Enhanced Version
DESCRIPTION: This snippet provides an enhanced version of the Foo component using the react/compiler-runtime's _c function to optimize rendering. It captures previous props in an array to prevent unnecessary renders. The same FIXTURE_ENTRYPOINT is retained for testing, showcasing sequential rendering scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-cond-access-not-hoisted.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR

import { Stringify } from "shared-runtime";

function Foo(t0) {
  const $ = _c(3);
  const { a, shouldReadA } = t0;
  let t1;
  if ($[0] !== a || $[1] !== shouldReadA) {
    t1 = (
      <Stringify
        fn={() => {
          if (shouldReadA) {
            return a.b.c;
          }
          return null;
        }}
        shouldInvokeFns={true}
      />
    );
    $[0] = a;
    $[1] = shouldReadA;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ a: null, shouldReadA: true }],
  sequentialRenders: [
    { a: null, shouldReadA: true },
    { a: null, shouldReadA: false },
    { a: { b: { c: 4 } }, shouldReadA: true },
  ],
};

```

----------------------------------------

TITLE: Creating a Stateful Component with React Compiler Runtime in JavaScript
DESCRIPTION: This snippet implements a component function using the React compiler runtime. It checks for changes in input values and maintains state in an array. The function returns another function that logs the current state of 'a'. This pattern showcases a more dynamic way to handle functional components in React with efficient state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-member-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(4);
  let t0;
  if ($[0] !== a) {
    t0 = { a };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  let t1;
  if ($[2] !== z.a) {
    t1 = function () {
      console.log(z.a);
    };
    $[2] = z.a;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization (JavaScript)
DESCRIPTION: This snippet shows an optimized version of the 'Foo' component using React's compiler runtime for memoization. It uses a Symbol-based caching mechanism to avoid unnecessary recalculations of the constant value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-to-object-method.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = {
      foo() {
        return identity(1);
      },
    };

    t0 = x.foo();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing useCallback with Compiler Runtime in JavaScript
DESCRIPTION: Demonstrates an enhanced approach for implementing memoized functions in React using an internal compiler runtime utility. The function useFoo is optimized to cache its computation with a minimal dependency array, using a custom cache slot to manage dependency changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-fewer-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { useCallback } from "react";

// It's correct to produce memo blocks with fewer deps than source
function useFoo(a, b) {
  const $ = _c(2);
  let t0;
  if ($[0] !== a) {
    t0 = () => [a];
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [1, 2],
};

```

----------------------------------------

TITLE: Simplified React Component with Constant Return
DESCRIPTION: Simplified version of the React component that directly returns a constant value of 42. This implementation removes the error handling and demonstrates the same functional outcome as the more complex version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-try-immediately-throws-after-constant-propagation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  return 42;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ default: 42 }],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime Memoization
DESCRIPTION: A React component using compiler runtime memoization with symbol-based caching mechanism to optimize rendering and prevent unnecessary re-renders
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-memo-value-not-promoted-to-outer-scope-static.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const count = new MaybeMutable();

    t0 = (
      <View>
        <View>
          <span>Text</span>
          <span>{maybeMutate(count)}</span>
        </View>
      </View>
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: React Array Memoization Compiled Output
DESCRIPTION: Compiled version of the test fixture with implemented memoization logic. Shows how the compiler transforms the source code to include cache checks and memoization optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-inference-array-from.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useIdentity, ValidateMemoization } from "shared-runtime";

/**
 * Fixture to assert that we can infer the type and effects of an array created
 * with `Array.from`.
 */
function Validate({ x, val1, val2 }) {
  "use no memo";
  return (
    <>
      <ValidateMemoization
        inputs={[val1]}
        output={x[0]}
        onlyCheckCompiled={true}
      />

      <ValidateMemoization
        inputs={[val2]}
        output={x[1]}
        onlyCheckCompiled={true}
      />
    </>
  );
}
function useFoo(t0) {
  "use memo";
  const $ = _c(9);
  const { val1, val2 } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const x = Array.from(t1);
  useIdentity();
  let t2;
  if ($[1] !== val1) {
    t2 = [val1];
    $[1] = val1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  x.push(t2);
  let t3;
  if ($[3] !== val2) {
    t3 = [val2];
    $[3] = val2;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  x.push(t3);
  let t4;
  if ($[5] !== val1 || $[6] !== val2 || $[7] !== x) {
    t4 = <Validate x={x} val1={val1} val2={val2} />;
    $[5] = val1;
    $[6] = val2;
    $[7] = x;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ val1: 1, val2: 2 }],
  params: [
    { val1: 1, val2: 2 },
    { val1: 1, val2: 2 },
    { val1: 1, val2: 3 },
    { val1: 4, val2: 2 },
  ],
};
```

----------------------------------------

TITLE: Initializing React Function Hook with Memoization
DESCRIPTION: A React function component that uses compiler runtime memoization to track and optimize state changes, with conditional array manipulation based on input props
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;
  return x;
}
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function useFoo(props) {
  const $ = _c(5);
  let x;
  if ($[0] !== props.bar) {
    x = [];
    x.push(props.bar);
    $[0] = props.bar;
    $[1] = x;
  } else {
    x = $[1];
  }
  if ($[2] !== props.cond || $[3] !== props.foo) {
    props.cond ? ((x = []), x.push(props.foo)) : null;
    $[2] = props.cond;
    $[3] = props.foo;
    $[4] = x;
  } else {
    x = $[4];
  }
  return x;
}
```

----------------------------------------

TITLE: Optimized React Compiler Output for Object Destructuring in JavaScript
DESCRIPTION: This snippet shows the optimized version of the 'foo' function after React compiler processing. It introduces memoization and uses React's compiler runtime for performance improvements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-string-literal-property-key.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { data: 1 };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const { data: t } = t0;
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Components with Compiler Runtime (JavaScript)
DESCRIPTION: The output of a React compiler transforming the source JSX components. This code shows how JSX elements are represented as JavaScript objects and how runtime logic (`_c2`, `$`) is injected for memoization and state management, demonstrating the compiler's internal transformation process.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inline-jsx-transform.expect.md#_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c2 } from "react/compiler-runtime"; // @inlineJsxTransform

function Parent(t0) {
  const $ = _c2(3);
  const { children, ref } = t0;
  let t1;
  if ($[0] !== children || $[1] !== ref) {
    if (DEV) {
      t1 = <div ref={ref}>{children}</div>;
    } else {
      t1 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: "div",
        ref: ref,
        key: null,
        props: { ref: ref, children: children },
      };
    }
    $[0] = children;
    $[1] = ref;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Child(t0) {
  const $ = _c2(2);
  const { children } = t0;
  let t1;
  if ($[0] !== children) {
    if (DEV) {
      t1 = <>{children}</>;
    } else {
      t1 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: Symbol.for("react.fragment"),
        ref: null,
        key: null,
        props: { children: children },
      };
    }
    $[0] = children;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function GrandChild(t0) {
  const $ = _c2(3);
  const { className } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    if (DEV) {
      t1 = <React.Fragment key="fragmentKey">Hello world</React.Fragment>;
    } else {
      t1 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: React.Fragment,
        ref: null,
        key: "fragmentKey",
        props: { children: "Hello world" },
      };
    }
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== className) {
    if (DEV) {
      t2 = <span className={className}>{t1}</span>;
    } else {
      t2 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: "span",
        ref: null,
        key: null,
        props: { className: className, children: t1 },
      };
    }
    $[1] = className;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}

function ParentAndRefAndKey(props) {
  const $ = _c2(1);
  const testRef = useRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    if (DEV) {
      t0 = <Parent a="a" b={{ b: "b" }} c={C} key="testKey" ref={testRef} />;
    } else {
      t0 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: Parent,
        ref: testRef,
        key: "testKey",
        props: { a: "a", b: { b: "b" }, c: C, ref: testRef },
      };
    }
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function ParentAndChildren(props) {
  const $ = _c2(14);
  let t0;
  if ($[0] !== props.foo) {
    t0 = () => {
      let t1;
      if (DEV) {
        t1 = <div key="d">{props.foo}</div>;
      } else {
        t1 = {
          $$typeof: Symbol.for("react.transitional.element"),
          type: "div",
          ref: null,
          key: "d",
          props: { children: props.foo },
        };
      }
      return t1;
    };
    $[0] = props.foo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const render = t0;
  let t1;
  if ($[2] !== props) {
    if (DEV) {
      t1 = <Child key="a" {...props} />;
    } else {
      t1 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: Child,
        ref: null,
        key: "a",
        props: props,
      };
    }
    $[2] = props;
    $[3] = t1;
  } else {
    t1 = $[3];
  }

  const t2 = props.foo;
  let t3;
  if ($[4] !== props) {
    if (DEV) {
      t3 = <GrandChild key="c" className={t2} {...props} />;
    } else {
      t3 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: GrandChild,
        ref: null,
        key: "c",
        props: { className: t2, ...props },
      };
    }
    $[4] = props;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== render) {
    t4 = render();
    $[6] = render;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== t3 || $[9] !== t4) {
    if (DEV) {
      t5 = (
        <Child key="b">
          {t3}
          {t4}
        </Child>
      );
    } else {
      t5 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: Child,
        ref: null,
        key: "b",
        props: { children: [t3, t4] },
      };
    }
    $[8] = t3;
    $[9] = t4;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== t1 || $[12] !== t5) {
    if (DEV) {
      t6 = (
        <Parent>
          {t1}
          {t5}
        </Parent>
      );
    } else {
      t6 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: Parent,
        ref: null,
        key: null,
        props: { children: [t1, t5] },
      };
    }
    $[11] = t1;
    $[12] = t5;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  return t6;
}

const propsToSpread = { a: "a", b: "b", c: "c" };
function PropsSpread() {
  const $ = _c2(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    let t1;
    if (DEV) {
      t1 = <Test key="a" {...propsToSpread} />;
    } else {
      t1 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: Test,
        ref: null,
        key: "a",
        props: propsToSpread,
      };
    }
    let t2;
    if (DEV) {
      t2 = <Test key="b" {...propsToSpread} a="z" />;
    } else {
      t2 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: Test,
        ref: null,
        key: "b",
        props: { ...propsToSpread, a: "z" },
      };
    }
    if (DEV) {
      t0 = (
        <>
          {t1}
          {t2}
        </>
      );
    } else {
      t0 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: Symbol.for("react.fragment"),
        ref: null,
        key: null,
        props: { children: [t1, t2] },
      };
    }
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function ConditionalJsx(t0) {
  const $ = _c2(2);
  const { shouldWrap } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    if (DEV) {
      t1 = <div>Hello</div>;
    } else {
      t1 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: "div",
        ref: null,
        key: null,
        props: { children: "Hello" },
      };
    }
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let content = t1;
  if (shouldWrap) {
    const t2 = content;
    let t3;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      if (DEV) {
        t3 = <Parent>{t2}</Parent>;
      } else {
        t3 = {
          $$typeof: Symbol.for("react.transitional.element"),
          type: Parent,
          ref: null,
          key: null,
          props: { children: t2 },
        };
      }
      $[1] = t3;
    } else {
      t3 = $[1];
    }
    content = t3;
  }
  return content;
}

function ComponentWithSpreadPropsAndRef(t0) {
  const $ = _c2(6);
  let other;
  let ref;
  if ($[0] !== t0) {
    ({ ref, ...other } = t0);
    $[0] = t0;
    $[1] = other;
    $[2] = ref;
  } else {
    other = $[1];
    ref = $[2];
  }
  let t1;
  if ($[3] !== other || $[4] !== ref) {
    if (DEV) {
      t1 = <Foo ref={ref} {...other} />;
    } else {
      t1 = {
        $$typeof: Symbol.for("react.transitional.element"),
        type: Foo,
        ref: ref,
        key: null,
        props: { ref: ref, ...other },
      };
    }
    $[3] = other;
    $[4] = ref;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}

// TODO: Support value blocks
function TernaryJsx(t0) {
  const $ = _c2(2);
  const { cond } = t0;
  let t1;
  if ($[0] !== cond) {
    t1 = cond ? <div /> : null;
    $[0] = cond;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

global.DEV = true;
export const FIXTURE_ENTRYPOINT = {
  fn: ParentAndChildren,
  params: [{ foo: "abc" }],
};
```

----------------------------------------

TITLE: Compiled Output of FBT React Component
DESCRIPTION: This snippet shows the compiled output of the FBT component after processing by the React compiler. It demonstrates how FBT syntax is transformed into function calls with memoization for performance optimization through the use of the _c compiler runtime function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-params-complex-param-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.name) {
    t0 = fbt._(
      "Hello {user name}",
      [fbt._param("user name", capitalize(props.name))],
      { hk: "2zEDKF" },
    );
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: React Compiler Runtime Optimized Component
DESCRIPTION: Compiled version of the React component using React compiler runtime with memoization and performance optimization techniques
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(t0) {
  const $ = _c(7);
  const { arr } = t0;
  const x = useX();
  let t1;
  if ($[0] !== arr || $[1] !== x) {
    let t2;
    if ($[3] !== x) {
      t2 = (i, id) => {
        const T0 = _temp;
        return <T0 i={i} key={id} x={x} />;
      };
      $[3] = x;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    t1 = arr.map(t2);
    $[0] = arr;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = <>{t1}</>;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
```

----------------------------------------

TITLE: Transformed React Component with memoization
DESCRIPTION: This code represents the transformed React component after applying the custom `idx` macro. It uses the `react/compiler-runtime` to optimize the component's rendering by memoizing the results of the `idx` calls. This improves performance by avoiding redundant calculations when the input `props` object remains unchanged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-method-no-outlining.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```javascript
import { c as _c } from "react/compiler-runtime"; // @customMacros(idx.a)

function Component(props) {
  const $ = _c(10);
  let t0;
  if ($[0] !== props) {
    t0 = idx(props, _temp);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const groupName1 = t0;
  let t1;
  if ($[2] !== props) {
    t1 = idx.a(props, (__0) => __0.group.label);
    $[2] = props;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const groupName2 = t1;
  let t2;
  if ($[4] !== props) {
    t2 = idx.a.b(props, _temp2);
    $[4] = props;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const groupName3 = t2;
  let t3;
  if ($[6] !== groupName1 || $[7] !== groupName2 || $[8] !== groupName3) {
    t3 = (
      <div>
        {groupName1}
        {groupName2}
        {groupName3}
      </div>
    );
    $[6] = groupName1;
    $[7] = groupName2;
    $[8] = groupName3;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  return t3;
}
function _temp2(__1) {
  return __1.group.label;
}
function _temp(_) {
  return _.group.label;
}

```
```

----------------------------------------

TITLE: Defining React Hook useFoo (Processed) - Javascript
DESCRIPTION: Shows a potentially processed version of the useFoo hook. It appears functionally similar but has minor structural differences (argument handling, duplicate dependency in useSpecialEffect). This likely represents the output of a processing step, possibly related to inferring or verifying effect dependencies without relying on traditional React memoization mechanisms.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/infer-deps-on-retry.expect.md#_snippet_1

LANGUAGE: javascript
CODE:
```
// @inferEffectDependencies @panicThreshold(none)
import { useRef } from "react";
import { useSpecialEffect } from "shared-runtime";

/**
 * The retry pipeline disables memoization features, which means we need to
 * provide an alternate implementation of effect dependencies which does not
 * rely on memoization.
 */
function useFoo(t0) {
  const { cond } = t0;
  const ref = useRef();
  const derived = cond ? ref.current : makeObject();
  useSpecialEffect(
    () => {
      log(derived);
    },
    [derived],
    [derived],
  );
  return ref;
}
```

----------------------------------------

TITLE: Sequence Component Transformation with React Compiler Runtime
DESCRIPTION: Transforms the `sequence` function component using React's compiler runtime for memoization. It imports `_c` from `react/compiler-runtime` and utilizes it to cache the results of expressions using `Symbol.for("react.memo_cache_sentinel")`. This optimization aims to avoid redundant computations during component rendering, potentially improving performance by storing and reusing the previously computed values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequence-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function sequence(props) {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (Math.max(1, 2), foo());
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let x = t0;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    while ((foo(), true)) {
      x = (foo(), 2);
    }
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

function foo() {}

```

----------------------------------------

TITLE: Reactivity Handling in React Component with Compiler Runtime
DESCRIPTION: The snippet uses a compiler runtime function `_c` in JavaScript to support reactivity in the `Component` function. It checks and updates the state of `x` based on changing prop values, using an internal `$` array to track and react to state changes. The setup is similar to the previous snippet but includes reactivity checks and updates for enhanced performance and accuracy during renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-forin-collection.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  for (const key in props.values) {
    const i = parseInt(key, 10);
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { values: { "12": true } },
    { values: { "12": true } },
    { values: { "1": true } },
    { values: { "1": true } },
    { values: { "12": true } },
    { values: { "1": true } },
    { values: { "12": true } },
    { values: { "1": true } },
  ],
};
```

----------------------------------------

TITLE: Handling React Memo Cache Sentinel JavaScript
DESCRIPTION: This snippet imports a function and handles memo cache using React's compiler runtime. It checks for a sentinel value and conditionally initializes an array, assigns it to an object, mutates it, and stores it in a cache. The function returns an object from cache based on conditions. Requires the 'react/compiler-runtime' import, and effective management of memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let y;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [];
    y = {};
    y.x = x;
    mutate(x);
    $[0] = y;
  } else {
    y = $[0];
  }
  return y;
}

```

----------------------------------------

TITLE: React Compiler Runtime with Component in JavaScript
DESCRIPTION: This code snippet defines a React functional component augmented by 'react/compiler-runtime' to manage component state with memoization. It optimizes rendering by caching results of operations using symbolic placeholders, reducing unnecessary computations when values are unchanged. This version complements 'shared-runtime' methods with additional runtime-specific state handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-captures-arg0.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useIdentity, Stringify } from "shared-runtime";

/**
 * TODO: Note that this `Array.from` is inferred to be mutating its first
 * argument. This is because React Compiler's typing system does not yet support
 * annotating a function with a set of argument match cases + distinct
 * definitions (polymorphism)
 *
 * In this case, we should be able to infer that the `Array.from` call is
 * not mutating its 0th argument.
 * The 0th argument should be typed as having `effect:Mutate` only when
 * (1) it might be a mutable iterable or
 * (2) the 1st argument might mutate its callee
 */
function Component(t0) {
  const $ = _c(10);
  const { value } = t0;
  let t1;
  let t2;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = { value: "foo" };
    t2 = { value: "bar" };
    $[0] = t1;
    $[1] = t2;
  } else {
    t1 = $[0];
    t2 = $[1];
  }
  let t3;
  if ($[2] !== value) {
    t3 = [t1, t2, { value }];
    $[2] = value;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const arr = t3;
  useIdentity();
  let t4;
  if ($[4] !== arr) {
    t4 = Array.from(arr);
    $[4] = arr;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  const derived = t4;
  let t5;
  if ($[6] !== derived) {
    t5 = derived.at(-1);
    $[6] = derived;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  let t6;
  if ($[8] !== t5) {
    t6 = <Stringify>{t5}</Stringify>;
    $[8] = t5;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  return t6;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 5 }],
  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with added memoization logic. Includes runtime checks to prevent unnecessary re-renders and optimized state management using compiler-generated variables.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-maybe-mutate-context-in-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as React from "react";
import { useContext } from "react";
import { mutate } from "shared-runtime";

const FooContext = React.createContext({ current: null });

function Component(props) {
  const $ = _c(5);
  const Foo = useContext(FooContext);
  let t0;
  if ($[0] !== Foo.current) {
    t0 = () => {
      mutate(Foo.current);
    };
    $[0] = Foo.current;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onClick = t0;
  let t1;
  if ($[2] !== onClick || $[3] !== props.children) {
    t1 = <div onClick={onClick}>{props.children}</div>;
    $[2] = onClick;
    $[3] = props.children;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ children: <div>Hello</div> }],
};
```

----------------------------------------

TITLE: React Component with Compiler Runtime Memoization
DESCRIPTION: This snippet shows the compiled version of the React component `Component` utilizing `react/compiler-runtime`'s internal memoization through the `_c` function. It achieves similar memoization behavior as the `useMemo` version but leverages the compiler for optimized performance. It uses an array `$` to store previously computed values and compares them before recomputing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-conditional-access-alloc.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useMemo } from "react";
import { identity } from "shared-runtime";

function Component(t0) {
  const $ = _c(5);
  const { propA, propB } = t0;
  let t1;

  const t2 = propB?.x.y;
  let t3;
  if ($[0] !== t2) {
    t3 = identity(t2);
    $[0] = t2;
    $[1] = t3;
  } else {
    t3 = $[1];
  }
  let t4;
  if ($[2] !== propA || $[3] !== t3) {
    t4 = { value: t3, other: propA };
    $[2] = propA;
    $[3] = t3;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  t1 = t4;
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ propA: 2, propB: { x: { y: [] } } }],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the React component with explicit memoization cache handling. Uses Symbol.for('react.memo_cache_sentinel') for cache validation and implements manual dependency checking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-maybe-modify-free-variable-preserve-memoization-guarantee.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees
import { useCallback } from "react";
import {
  identity,
  makeObject_Primitives,
  mutate,
  useHook,
} from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = makeObject_Primitives();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const free = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = makeObject_Primitives();
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const free2 = t1;
  const part = free2.part;
  useHook();
  let t2;
  if ($[2] !== props.value) {
    t2 = () => {
      const x = makeObject_Primitives();
      x.value = props.value;
      mutate(x, free, part);
    };
    $[2] = props.value;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const callback = t2;

  mutate(free, part);
  return callback;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Optimized React Compiler Output for Optional Chaining
DESCRIPTION: This snippet shows the compiled and optimized version of the 'useFoo' hook. It demonstrates how the React compiler handles optional chaining and implements memoization for improved performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-optional-chains.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

/**
 * identity(...)?.toString() is the outer optional, and prop?.value is the inner
 * one.
 * Note that prop?.
 */
function useFoo(t0) {
  const $ = _c(15);
  const { prop1, prop2, prop3, prop4, prop5, prop6 } = t0;
  let t1;
  if ($[0] !== prop1?.value) {
    t1 = identity(prop1?.value)?.toString();
    $[0] = prop1?.value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  let t2;
  if ($[2] !== prop2?.inner.value) {
    t2 = identity(prop2?.inner.value)?.toString();
    $[2] = prop2?.inner.value;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const y = t2;
  let t3;
  if ($[4] !== prop3 || $[5] !== prop4?.inner) {
    t3 = prop3?.fn(prop4?.inner.value).toString();
    $[4] = prop3;
    $[5] = prop4?.inner;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const z = t3;
  let t4;
  if ($[7] !== prop5 || $[8] !== prop6?.inner) {
    t4 = prop5?.fn(prop6?.inner.value)?.toString();
    $[7] = prop5;
    $[8] = prop6?.inner;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  const zz = t4;
  let t5;
  if ($[10] !== x || $[11] !== y || $[12] !== z || $[13] !== zz) {
    t5 = [x, y, z, zz];
    $[10] = x;
    $[11] = y;
    $[12] = z;
    $[13] = zz;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  return t5;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [
    {
      prop1: null,
      prop2: null,
      prop3: null,
      prop4: null,
      prop5: null,
      prop6: null,
    },
  ],

  sequentialRenders: [
    {
      prop1: null,
      prop2: null,
      prop3: null,
      prop4: null,
      prop5: null,
      prop6: null,
    },
    {
      prop1: { value: 2 },
      prop2: { inner: { value: 3 } },
      prop3: { fn: identity },
      prop4: { inner: { value: 4 } },
      prop5: { fn: identity },
      prop6: { inner: { value: 4 } },
    },
    {
      prop1: { value: 2 },
      prop2: { inner: { value: 3 } },
      prop3: { fn: identity },
      prop4: { inner: { value: 4 } },
      prop5: { fn: identity },
      prop6: { inner: { value: undefined } },
    },
    {
      prop1: { value: 2 },
      prop2: { inner: { value: undefined } },
      prop3: { fn: identity },
      prop4: { inner: { value: undefined } },
      prop5: { fn: identity },
      prop6: { inner: { value: undefined } },
    },
    {
      prop1: { value: 2 },
      prop2: {},
      prop3: { fn: identity },
      prop4: {},
      prop5: { fn: identity },
      prop6: { inner: { value: undefined } },
    },
  ],
};
```

----------------------------------------

TITLE: Compiled React Function with Memoization
DESCRIPTION: Compiler-transformed version that adds caching using a closure array ($), implements early returns using symbols, and preserves mutation semantics. Includes block-level scoping and conditional value tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scope-starts-within-cond.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

/**
 * Similar fixture to `align-scopes-nested-block-structure`, but
 * a simpler case.
 */
function useFoo(cond) {
  const $ = _c(3);
  let s;
  let t0;
  if ($[0] !== cond) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      if (cond) {
        s = {};
      } else {
        t0 = null;
        break bb0;
      }

      mutate(s);
    }
    $[0] = cond;
    $[1] = t0;
    $[2] = s;
  } else {
    t0 = $[1];
    s = $[2];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return s;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: Compiled React Component Output
DESCRIPTION: The compiled version of the component using React's compiler runtime. It shows how the destructuring is transformed into more verbose conditional checks with caching mechanism using the _c compiler helper.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const { x: t0 } = props.y;
  let t1;
  if ($[0] !== t0) {
    t1 = t0 === undefined ? { y: "default" } : t0;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const { y } = t1;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled React Component with Console Logging and Object Mutation
DESCRIPTION: This is the compiled version of the React component. It uses React's compiler runtime and implements caching logic. The component achieves the same functionality as the input version but with optimized and transformed code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-call-evaluation-order.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Should print A, B, arg, original
function Component() {
  const $ = _c(1);
  const changeF = _temp2;
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = { f: _temp3 };

    (console.log("A"), x)[(console.log("B"), "f")](
      (changeF(x), console.log("arg"), 1),
    );
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}
function _temp3() {
  return console.log("original");
}
function _temp2(o) {
  o.f = _temp;
}
function _temp() {
  return console.log("new");
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized React Hook with Change Variable Codegen
DESCRIPTION: This snippet shows the optimized version of the 'useFoo' hook. It uses the '_c' function from 'react/compiler-runtime' to implement memoization, improving performance by avoiding unnecessary calls to 'identity'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableChangeVariableCodegen
import { identity } from "shared-runtime";

const $ = "module_$";
const t0 = "module_t0";
const c_0 = "module_c_0";
function useFoo(props) {
  const $0 = _c(2);
  const c_00 = $0[0] !== props.value;
  let t1;
  if (c_00) {
    t1 = identity(props.value);
    $0[0] = props.value;
    $0[1] = t1;
  } else {
    t1 = $0[1];
  }
  const results = t1;
  console.log($);
  console.log(t0);
  console.log(c_0);
  return results;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ value: 0 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: This is the compiled and optimized version of the React component. It includes performance enhancements such as memoization of function references and conditional re-computations based on dependency changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-freeze-function-expressions.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableTransitivelyFreezeFunctionExpressions
function Component(props) {
  const $ = _c(9);
  const { data, loadNext, isLoadingNext } =
    usePaginationFragment(props.key).items ?? [];
  let t0;
  if ($[0] !== data.length || $[1] !== loadNext) {
    t0 = () => {
      if (data.length === 0) {
        return;
      }

      loadNext();
    };
    $[0] = data.length;
    $[1] = loadNext;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const loadMoreWithTiming = t0;
  let t1;
  let t2;
  if ($[3] !== isLoadingNext || $[4] !== loadMoreWithTiming) {
    t1 = () => {
      if (isLoadingNext) {
        return;
      }

      loadMoreWithTiming();
    };
    t2 = [isLoadingNext, loadMoreWithTiming];
    $[3] = isLoadingNext;
    $[4] = loadMoreWithTiming;
    $[5] = t1;
    $[6] = t2;
  } else {
    t1 = $[5];
    t2 = $[6];
  }
  useEffect(t1, t2);
  let t3;
  if ($[7] !== data) {
    t3 = data.map(_temp);
    $[7] = data;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  const items = t3;
  return items;
}
function _temp(x) {
  return x;
}
```

----------------------------------------

TITLE: Defining Component with Optimized Checks - JavaScript
DESCRIPTION: This snippet introduces a more optimized version of the previous component, utilizing React's compiler runtime for internal state management. It contains a block control statement to check and update the state based on conditions. Like the previous snippet, it also exports the same FIXTURE_ENTRYPOINT, providing configuration options for the component with specific parameters and an identifier.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-inlining-block-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a, b) {
  const $ = _c(2);
  let t0;
  bb0: {
    if (a) {
      let t1;
      if ($[0] !== b) {
        t1 = { b };
        $[0] = b;
        $[1] = t1;
      } else {
        t1 = $[1];
      }
      t0 = t1;
      break bb0;
    }
    t0 = undefined;
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: React Compiler Transformed Function with Memoization
DESCRIPTION: The same function after being processed by the React compiler, which adds memoization using a Symbol-based cache sentinel. This optimization prevents recreating the array and object on each call by storing and reusing the previously created object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let y;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [];
    y = {};
    y.x = x;
    $[0] = y;
  } else {
    y = $[0];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Exporting a React fixture entry point in Javascript
DESCRIPTION: This code snippet exports a constant named `FIXTURE_ENTRYPOINT`, which is an object that defines a React fixture. It specifies the function to be used (`foo`), the parameters to be passed to the function, and whether the function is a component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-sibling-phis.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled FBT Output Implementation
DESCRIPTION: Compiled JavaScript output showing how FBT transforms the plural handling into optimized code. Includes caching mechanism for repeated renders and complex plural logic handling through nested conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/bug-fbt-plural-multiple-mixed-call-tag.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function useFoo(t0) {
  const $ = _c(3);
  const { apples, bananas } = t0;
  let t1;
  if ($[0] !== apples || $[1] !== bananas) {
    t1 = (
      <div>
        {fbt._(
          {
            "*": {
              "*": "{number of apples} apples and {number of bananas} bananas",
            },
            _1: { _1: "{number of apples} apple and 1 banana" },
          },
          [
            fbt._plural(apples),
            fbt._plural(bananas, "number of bananas"),
            fbt._param("number of apples", apples),
          ],
          { hk: "2xXrUW" },
        )}
      </div>
    );
    $[0] = apples;
    $[1] = bananas;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ apples: 1, bananas: 2 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component that includes React's compiler runtime memoization logic to optimize re-renders and state management. Uses an array to cache previous values and implement value comparison.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-in-sequence.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(5);
  let a = props.x;
  let b;
  let c;
  let d;
  if (props.cond) {
    d = ((b = a), a++, (c = a), ++a);
  }
  let t0;
  if ($[0] !== a || $[1] !== b || $[2] !== c || $[3] !== d) {
    t0 = [a, b, c, d];
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = d;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ x: 2, cond: true }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining Function 'bar' with React Compiler Runtime in JavaScript
DESCRIPTION: This snippet defines an enhanced version of the function 'bar' that utilizes React's compiler runtime. It initializes a state variable with 'a', checks its value, and either initializes a new object or retrieves an existing one. The function returns 'y' from its internal state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function bar(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = [a];
    y = {};

    y = x[0];
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: ["TodoAdd"],
};
```

----------------------------------------

TITLE: React Compiler-Optimized Version with Memoization
DESCRIPTION: The transformed version of the useFoo hook processed by React's compiler. It includes memoization using an array ($) to track state between renders and avoid unnecessary calculations, changing label to bb0 and implementing dependency tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-poisons-outer-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(5);
  const { input, cond } = t0;
  let x;
  if ($[0] !== cond || $[1] !== input) {
    x = [];
    bb0: {
      if (cond) {
        break bb0;
      }
      let t1;
      if ($[3] !== input.a.b) {
        t1 = identity(input.a.b);
        $[3] = input.a.b;
        $[4] = t1;
      } else {
        t1 = $[4];
      }
      x.push(t1);
    }
    $[0] = cond;
    $[1] = input;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiler-transformed version of the component that includes memoization logic using an array of cached values. The code checks for prop changes and reuses cached functions and render results when possible.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-expression-prototype-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props) {
    t0 = function () {
      return <div>{props.name}</div>;
    };
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const f = t0;
  let t1;
  if ($[2] !== f) {
    t1 = f.call();
    $[2] = f;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Jason" }],
};
```

----------------------------------------

TITLE: Enhanced Component with React Compiler Runtime
DESCRIPTION: This snippet imports a function from the React compiler runtime and defines a component function that incorporates state management by checking input parameters against a stored state array. It either creates a new state object or retrieves an existing one, while still allowing for internal property manipulation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-indirect-mutate-alias-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let x;
  if ($[0] !== a) {
    x = { a };

    const q = x;
    (function () {
      q.b = 1;
    })();
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [2],
};
```

----------------------------------------

TITLE: Optimized Functional Component with React Compiler - JavaScript
DESCRIPTION: This snippet optimizes the previous component using React's experimental compiler runtime for efficient rendering. It handles state-like behavior through a cached approach to minimize unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/non-null-assertion.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
interface ComponentProps {
  name?: string;
}

function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.name) {
    t0 = props.name.toUpperCase();
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Alice" }],
};

```

----------------------------------------

TITLE: Utilizing Compiler Runtime in React Component (JavaScript)
DESCRIPTION: This snippet defines a React component using the `react/compiler-runtime` for memoization and returns an object representing component state. It checks for a memoized sentinel and conditionally sets state values. The snippet requires React's compiler runtime library and outputs cached state values based on a custom memoization mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-constant-propagation.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { a: 0, b: 0, c: 2, d: 2, e: 0 };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Code with Memoization for Effect Dependencies
DESCRIPTION: The compiled output of the React component, showing how the compiler handles memoization and dependency tracking. It uses a cache mechanism to store the object and effect callback, and explicitly includes the object in the dependency array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/nonreactive-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect } from "react";
import { makeObject_Primitives, print } from "shared-runtime";

/**
 * Note that `obj` is currently added to the effect dependency array, even
 * though it's non-reactive due to memoization.
 *
 * This is a TODO in effect dependency inference. Note that we cannot simply
 * filter out non-reactive effect dependencies, as some non-reactive (by data
 * flow) values become reactive due to scope pruning. See the
 * `infer-effect-deps/pruned-nonreactive-obj` fixture for why this matters.
 *
 * Realizing that this `useEffect` should have an empty dependency array
 * requires effect dependency inference to be structured similarly to memo
 * dependency inference.
 * Pass 1: add all potential dependencies regardless of dataflow reactivity
 * Pass 2: (todo) prune non-reactive dependencies
 *
 * Note that instruction reordering should significantly reduce scope pruning
 */
function NonReactiveDepInEffect() {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = makeObject_Primitives();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const obj = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => print(obj);
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  useEffect(t1, [obj]);
}
```

----------------------------------------

TITLE: React Compiler Optimized Component with Memoization
DESCRIPTION: An enhanced version of the component using React compiler runtime for memoization and cache management. Implements a caching mechanism to optimize rendering performance
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-member-expression-tag-grouping.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const maybeMutable = new MaybeMutable();
    t0 = <Foo.Bar>{maybeMutate(maybeMutable)}</Foo.Bar>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This code represents the compiled version of the React component, leveraging the `react/compiler-runtime` to memoize portions of the virtual DOM tree. The `_c` function is used to store and retrieve previously rendered `div` elements based on the `props.value` and `x` variables.  `useHook()` is used to prevent certain memoizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useHook } from "shared-runtime";

function Component(props) {
  const $ = _c(6);
  const o = {};
  let t0;
  if ($[0] !== props.value) {
    t0 = <div>{props.value}</div>;
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  useHook();
  o.value = props.value;
  let t1;
  if ($[2] !== x) {
    t1 = <div>{x}</div>;
    $[2] = x;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const y = t1;
  let t2;
  if ($[4] !== y) {
    t2 = <div>{y}</div>;
    $[4] = y;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "sathya" }],
};

```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the Component function, likely produced by a React compiler. It includes memoization and more explicit destructuring logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-assignment-array-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  if (props.cond) {
    const [t0] = props.y;
    let t1;
    if ($[0] !== t0) {
      t1 = t0 === undefined ? ["default"] : t0;
      $[0] = t0;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    [x] = t1;
  } else {
    x = props.fallback;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiler-Optimized React Component with Memoization
DESCRIPTION: The compiler-optimized version of the Component that includes memoization logic using React's compiler runtime. It caches derived values and component outputs to prevent unnecessary recalculations when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-map-known-mutate-shape.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify, useIdentity } from "shared-runtime";

/**
 * Also see repro-array-map-known-nonmutate-Boolean, which calls a global
 * function that does *not* mutate its operands.
 */
function Component(t0) {
  const $ = _c(7);
  const { value } = t0;
  const arr = [
    new Set([["foo", 2]]).values(),
    new Set([["bar", 4]]).values(),
    [["baz", value]],
  ];

  useIdentity(null);
  const derived = arr.map(Object.fromEntries);
  let t1;
  if ($[0] !== derived) {
    t1 = derived.at(0);
    $[0] = derived;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== derived) {
    t2 = derived.at(-1);
    $[2] = derived;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1 || $[5] !== t2) {
    t3 = (
      <Stringify>
        {t1}
        {t2}
      </Stringify>
    );
    $[4] = t1;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 5 }],
  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],
};
```

----------------------------------------

TITLE: Defining a Memoized Component Function - JavaScript
DESCRIPTION: In this snippet, a more complex React component function is defined that utilizes the '_c' function from 'react/compiler-runtime' to create a caching mechanism for the component. It checks if the cache is empty and defines a function 'x' accordingly. The final output is a potentially memoized component function which does not require any parameters or external dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/function-declaration-redeclare.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  let x;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = function x() {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component Output
DESCRIPTION: Compiled version of the FBT component showing how the JSX and FBT syntax is transformed into runtime function calls. Includes caching logic for optimized rendering performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-newline.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.name) {
    t0 = fbt._(
      "Hello {a really long description that got split into multiple lines}",
      [
        fbt._param(
          "a really long description that got split into multiple lines",

          props.name,
        ),
      ],
      { hk: "1euPUp" },
    );
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const element = t0;
  let t1;
  if ($[2] !== element) {
    t1 = element.toString();
    $[2] = element;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Jason" }],
};
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This code presents the compiled version of the React component. It uses the '_c' function from 'react/compiler-runtime' to memoize intermediate values and optimize rendering. The compiler replaces the original component with a more efficient version that avoids unnecessary re-renders by checking if the props have changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-overlapping-scopes-store-const-used-later.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify, makeObject_Primitives } from "shared-runtime";

function Component(props) {
  const $ = _c(6);
  let t0;
  if ($[0] !== props.count) {
    t0 = [props.count];
    $[0] = props.count;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const array = t0;
  const x = makeObject_Primitives();
  let t1;
  if ($[2] !== array) {
    t1 = <div>{array}</div>;
    $[2] = array;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const element = t1;
  console.log(x);
  let t2;
  if ($[4] !== element) {
    t2 = <div>{element}</div>;
    $[4] = element;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ count: 42 }],
};
```

----------------------------------------

TITLE: Optimized State Management in React Component with JavaScript
DESCRIPTION: Optimizes a React component function `Component` using `react/compiler-runtime` and shared runtime. Utilizes caching strategies to reduce redundant computations and manages state mutations efficiently. It adjusts state depending on input object and is structured to efficiently handle repeated renders. Inputs are parameter objects; outputs are state representations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-receiver-computed-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  const { a } = t0;
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};
    const f0 = function () {
      const a_0 = y;
      a_0.x = x;
    };

    f0();
    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 2 }],
  sequentialRenders: [{ a: 2 }, { a: 2 }, { a: 3 }],
};

```

----------------------------------------

TITLE: React Compiler Runtime Transformed Function
DESCRIPTION: Compiler-generated version of the function with added memoization using _c runtime helper, tracking changes and optimizing return value
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(a) {
  const $ = _c(4);
  const d = a++;
  const e = ++a;
  let t0;
  if ($[0] !== a || $[1] !== d || $[2] !== e) {
    t0 = [a, d, e];
    $[0] = a;
    $[1] = d;
    $[2] = e;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [2],
  isComponent: false
};
```

----------------------------------------

TITLE: React Component Implementation
DESCRIPTION: The implementation code for the React component showing the runtime behavior without type annotations. Demonstrates the same identity function processing with a test fixture.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-as-number.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @enableUseTypeAnnotations
import { identity } from "shared-runtime";

function Component(props) {
  const x = identity(props.id);
  const y = x as number;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 42 }],
};
```

----------------------------------------

TITLE: React Compiler Error for Unpreservable Memoization
DESCRIPTION: The error output from React Compiler showing it cannot optimize the component because the existing manual memoization through useMemo cannot be preserved. The error pinpoints the exact location of the problematic useMemo call.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-dropped-infer-always-invalidating.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  13 |   x.push(props);
  14 |
> 15 |   return useMemo(() => [x], [x]);
     |          ^^^^^^^^^^^^^^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (15:15)
  16 | }
  17 |
  18 | export const FIXTURE_ENTRYPOINT = {
```

----------------------------------------

TITLE: Complex Component Initialization with React Runtime Checks
DESCRIPTION: This snippet introduces a more complex version of the React component utilizing runtime checks and caching. It integrates the useState hook and special '$structuralCheck' functions for verifying structural integrity during rerenders. This approach helps optimize performance by checking changes only when necessary, and it accounts for the component's internal caching behavior along with handling memoization using Symbol.for and other React runtime utilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useState-pruned-dependency-change-detect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { $structuralCheck } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @enableChangeDetectionForDebugging
import { useState } from "react";

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = f(props.x);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const [x] = useState(t0);
  let t1;
  {
    t1 = <div>{x}</div>;
    let condition = $[1] !== x;
    if (!condition) {
      let old$t1 = $[2];
      $structuralCheck(old$t1, t1, "t1", "Component", "cached", "(6:6)");
    }
    $[1] = x;
    $[2] = t1;
    if (condition) {
      t1 = <div>{x}</div>;
      $structuralCheck($[2], t1, "t1", "Component", "recomputed", "(6:6)");
      t1 = $[2];
    }
  }
  return t1;
}

```

----------------------------------------

TITLE: Compiled React Component with Memoization Strategy
DESCRIPTION: The React compiler's output that transforms the original component to include memoization. It adds a caching mechanism that stores and reuses previously computed values when inputs haven't changed, optimizing re-renders by avoiding unnecessary object creation and JSX evaluation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-within-jsx.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import {
  Stringify,
  makeObject_Primitives,
  mutateAndReturn,
} from "shared-runtime";

/**
 * In this example, the `<Stringify ... />` JSX block mutates then captures obj.
 * As JSX expressions freeze their values, we know that `obj` and `myDiv` cannot
 * be mutated past this.
 * This set of mutable range + scopes is an edge case because the JSX expression
 * references values in two scopes.
 * - (freeze) the result of `mutateAndReturn`
 *   this is a mutable value with a mutable range starting at `makeObject()`
 * - (mutate) the lvalue storing the result of `<Stringify .../>`
 *   this is a immutable value and so gets assigned a different scope
 *
 * obj@0 = makeObj();                         scope@0
 * if (cond) {                               |
 *   $1@0 = mutate(obj@0);                   |
 *   myDiv@1 = JSX $1@0          <- scope@1  |
 * }                                         
 *
 * Coincidentally, the range of `obj` is extended by alignScopesToBlocks to *past*
 * the end of the JSX instruction. As we currently alias identifier mutableRanges to
 * scope ranges, this `freeze` reference is perceived as occurring during the mutable
 * range of `obj` (even though it is after the last mutating reference).
 *
 * This case is technically safe as `myDiv` correctly takes `obj` as a dependency. As
 * a result, developers can never observe myDiv can aliasing a different value generation
 * than `obj` (e.g. the invariant `myDiv.props.value === obj` always holds).
 */
function useFoo(t0) {
  const $ = _c(3);
  const { data } = t0;
  let obj;
  let myDiv = null;
  if (data.cond) {
    if ($[0] !== data.cond1) {
      obj = makeObject_Primitives();
      if (data.cond1) {
        myDiv = <Stringify value={mutateAndReturn(obj)} />;
      }
      $[0] = data.cond1;
      $[1] = obj;
      $[2] = myDiv;
    } else {
      obj = $[1];
      myDiv = $[2];
    }
  }
  return myDiv;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ data: { cond: true, cond1: true } }],
  sequentialRenders: [
    { data: { cond: true, cond1: true } },
    { data: { cond: true, cond1: true } },
  ],
};
```

----------------------------------------

TITLE: React Component Implementation with String Directives
DESCRIPTION: Alternative syntax version of the React component showing memo directives with double quotes. Functionally identical to the previous snippet but uses different string notation for the directives.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-no-memo-module-scope-usememo-function-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @compilationMode(all)
"use no memo";

function TestComponent({ x }) {
  "use memo";
  return <Button>{x}</Button>;
}
```

----------------------------------------

TITLE: Encoding String Table Example in React DevTools
DESCRIPTION: Example showing how the string table for component names is encoded in typed arrays. This demonstrates how 'Foo' and 'Bar' would be encoded with their string lengths and UTF codepoints.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
[
  8,   // string table length
  3,   // encoded display name size
  70,  // "F"
  111, // "o"
  111, // "o"
  3,   // encoded display name size
  66,  // "B"
  97,  // "a"
  114, // "r"
]
```

----------------------------------------

TITLE: Exporting Simple Function as Fixture Entrypoint in JavaScript
DESCRIPTION: This snippet initializes and exports an object 'FIXTURE_ENTRYPOINT' in JavaScript after defining a function 'f' which simply returns the integer 1. The object has properties for the function, parameter list, and a boolean indicating if it's a component. This showcases basic function definition and export syntax in JavaScript, highlighting the export of simple default return functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function f() {
  return 1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Implementing a Counter Function with Export for React Testing
DESCRIPTION: Defines a 'foo' function that increments a counter from 1 to 10 using a while loop, then returns the final value. The function is exported via FIXTURE_ENTRYPOINT with metadata indicating it's not a React component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-while.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  while (x < 10) {
    x = x + 1;
  }

  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  while (x < 10) {
    x = x + 1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Reinstalling Dependencies After React Changes
DESCRIPTION: Command to reinstall dependencies after making changes to React and rebuilding it. This ensures the Fizz fixtures use the updated React build.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/fizz/README.md#2025-04-21_snippet_1

LANGUAGE: bash
CODE:
```
yarn
```

----------------------------------------

TITLE: Installing eslint-plugin-react-compiler via npm
DESCRIPTION: Command to install the eslint-plugin-react-compiler as a dev dependency. This plugin enhances the linting of React code by using the React compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/eslint-plugin-react-compiler/README.md#2025-04-21_snippet_1

LANGUAGE: sh
CODE:
```
npm install eslint-plugin-react-compiler --save-dev
```

----------------------------------------

TITLE: Refreshing dependencies after React changes
DESCRIPTION: Command to refresh dependencies after making changes to React and rebuilding it.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr2/README.md#2025-04-21_snippet_1

LANGUAGE: shell
CODE:
```
yarn
```

----------------------------------------

TITLE: React Compiler Error Message
DESCRIPTION: The error message displayed by the React compiler when encountering the hoisting issue. It indicates that it expected the identifier 'hasErrors' to be initialized before use, pointing to line 9 where the function is called.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-named-function-with-shadowed-local-same-name.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
   7 |     return hasErrors;
   8 |   }
>  9 |   return hasErrors();
     |          ^^^^^^^^^ Invariant: [hoisting] Expected value for identifier to be initialized. hasErrors_0$14 (9:9)
  10 | }
  11 |
```

----------------------------------------

TITLE: Original React Hook Implementation
DESCRIPTION: Original implementation of a custom React hook that creates and mutates an object based on input parameters. The hook takes an object with 'a' and 'b' properties and returns a mutated object structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-store-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';
function useHook({a, b}) {
  let y = {a};
  let x = {b};
  x['y'] = y;
  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{a: 2, b: 3}],
  sequentialRenders: [
    {a: 2, b: 3},
    {a: 2, b: 3},
    {a: 3, b: 3},
  ],
};
```

----------------------------------------

TITLE: Defining a Basic React Component - JavaScript
DESCRIPTION: This snippet showcases a simple React component function named 'Component' that takes props. It initializes an empty object 'x' and converts it to a number 'y'. The function returns an array containing both 'x' and 'y'. No external dependencies are required. The expected inputs are the component props, and the output is an array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-Number.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {};
  const y = Number(x);
  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Defining and Managing React Component Reactivity - JavaScript
DESCRIPTION: This snippet defines a React component function that takes props and performs state manipulation to achieve reactive behavior. The component uses arrays to interleave state changes, thereby introducing reactivity by monitoring control values. No external dependencies other than React are required. Inputs include props with a 'cond' property, and outputs are reactive states represented by variable 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-switch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a and b are independent but their mutations are interleaved, so
  // they get grouped in a reactive scope. this means that a becomes
  // reactive since it will effectively re-evaluate based on a reactive
  // input
  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(null);

  // Downstream consumer of a, which initially seems non-reactive except
  // that a becomes reactive, per above
  const c = [a];

  let x;
  switch (c[0][0]) {
    case true: {
      x = 1;
      break;
    }
    default: {
      x = 2;
    }
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `c[0]` which becomes reactive via
  // being interleaved with `b`.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};

```

----------------------------------------

TITLE: React Component with useIdentity Hook
DESCRIPTION: This code defines a React component named `useFoo` which leverages the `useIdentity` hook from the `shared-runtime` library. The component creates a Set, gets its values, and then returns the maximum value from the set. A fixture entry point is also exported for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-spread-argument-mutable-iterator.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useIdentity} from 'shared-runtime';

function useFoo() {
  const it = new Set([1, 2]).values();
  useIdentity();
  return Math.max(...it);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{}],
  sequentialRenders: [{}, {}],
};

```

----------------------------------------

TITLE: React Component Definition with Multiplication Assignment
DESCRIPTION: This code defines a React functional component named `foo`. The component takes `props` as input, initializes a variable `x` to 0, and enters a while loop that continues as long as `x` is greater than `props.min` and less than `props.max`. Inside the loop, `x` is multiplied by 2 and assigned back to x. Finally, the component returns the final value of `x`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-logical.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let x = 0;
  while (x > props.min && x < props.max) {
    x = x * 2;
  }
  return x;
}
```

----------------------------------------

TITLE: React Component Definition (Input)
DESCRIPTION: This JavaScript code defines a React component named `component` that takes two arguments, `a` and `b`. It creates two local objects `y` and `z`, where `y` contains `b` and `z` contains `a`. It also defines a function `x` that updates the value of `z.a` and accesses `y.b`. Finally, it returns the object `z`. The `FIXTURE_ENTRYPOINT` specifies the component function, parameters, and component name.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate-3.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a, b) {
  let y = {b};
  let z = {a};
  let x = function () {
    z.a = 2;
    y.b;
  };
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Implementing React Component with Conditional Array Initialization in JavaScript
DESCRIPTION: A React component that conditionally initializes an array based on props, then mutates it by pushing an object. This demonstrates how array mutability affects memoization in React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-array-push-consecutive-phis.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

function Component(props) {
  const x = {};
  let y;
  if (props.cond) {
    if (props.cond2) {
      y = [props.value];
    } else {
      y = [props.value2];
    }
  } else {
    y = [];
  }
  // This should be inferred as `<store> y` s.t. `x` can still
  // be independently memoized. *But* this also must properly
  // extend the mutable range of the array literals in the
  // if/else branches
  y.push(x);

  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, cond2: true, value: 42}],
  sequentialRenders: [
    {cond: true, cond2: true, value: 3.14},
    {cond: true, cond2: true, value: 42},
    {cond: true, cond2: true, value: 3.14},
    {cond: true, cond2: false, value2: 3.14},
    {cond: true, cond2: false, value2: 42},
    {cond: true, cond2: false, value2: 3.14},
    {cond: false},
    {cond: false},
  ],
};
```

----------------------------------------

TITLE: React useFoo Hook - Initial Input
DESCRIPTION: This is the initial implementation of the `useFoo` hook. It conditionally pushes `props.foo` to an array `x` based on `props.cond`. The `@enablePropagateDepsInHIR` directive suggests that this code will be transformed by the React compiler to optimize dependency tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-ternary-destruction.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond ? (({x} = {x: {}}), ([x] = [[]]), x.push(props.foo)) : null;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};

```

----------------------------------------

TITLE: Defining React Test Fixture Code (JavaScript)
DESCRIPTION: Refactored version of the test fixture where variables are declared with 'const' instead of 'let'. The function 'foo' and FIXTURE_ENTRYPOINT remain functionally the same, configuring a test for a 'TodoAdd' component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-while.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const x = [];
  const y = [];
  while (c) {
    y.push(b);
    x.push(a);
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining a React Component with Hook and Fixture Testing - JavaScript
DESCRIPTION: Similar to its previously defined counterpart, this React Component uses the useHook function to influence the instance memory and property assignment. It showcases a consistent structural design to the prior snippet, defining the use of hooks and Export scaffold in a concise JavaScript manner. The FIXTURE_ENTRYPOINT serves as a test scaffold, using similar parameters to reflect the test-oriented design template of the code sample.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prune-scopes-whose-deps-invalidate-new.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useHook } from "shared-runtime";

function Component(props) {
  const x = new Foo();
  useHook();
  x.value = props.value;

  const y = { x };
  return { y };
}

class Foo {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: "sathya" }],
};
```

----------------------------------------

TITLE: Downloading Experimental Build for DevTools
DESCRIPTION: Command for downloading the latest experimental build of React from CI for DevTools development. This is an alternative to building dependencies from source.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/README.md#2025-04-21_snippet_9

LANGUAGE: shell
CODE:
```
./scripts/release/download-experimental-build.js
```

----------------------------------------

TITLE: Checking Out Pre-Built React
DESCRIPTION: Checkout the latest version of React using a CI build from the main branch.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_2

LANGUAGE: sh
CODE:
```
cd <react-repo>

cd scripts/release
yarn install

./download-experimental-build.js --commit=main
```

----------------------------------------

TITLE: Initializing Component with Shared Runtime in JavaScript
DESCRIPTION: This snippet defines a function, `component`, that mutates and returns an object using properties from its parameters. It imports `mutate` from the `shared-runtime` module and structures objects using scoped variables. The snippet requires a runtime capable of handling imports and basic JavaScript operations like object mutation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
const {mutate} = require('shared-runtime');

function component(foo, bar) {
  let x = {foo};
  let y = {bar};
  (function () {
    let a = {y};
    let b = x;
    a.x = b;
  })();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['foo', 'bar'],
};
```

----------------------------------------

TITLE: Updated Hook Function with Compiler Runtime - JavaScript
DESCRIPTION: This snippet showcases an updated implementation of the 'useHook' function leveraging the 'react/compiler-runtime'. It encapsulates state management within the helper method and makes use of conditionals to ensure that mutations reflect changes in parameter 'a'. The 'mutate' function is again employed to handle 'b', returning the most current state of 'a'. The 'FIXTURE_ENTRYPOINT' structure remains consistent for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-renamed-ref.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function useHook(t0) {
  const $ = _c(2);
  const { a, b } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = { a };
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const z = t1;

  const z_0 = { b };

  mutate(z_0);
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ a: 2, b: 3 }],
  sequentialRenders: [
    { a: 2, b: 3 },
    { a: 2, b: 3 },
    { a: 2, b: 4 },
    { a: 3, b: 4 },
  ],
};

```

----------------------------------------

TITLE: Transformed React Component
DESCRIPTION: This snippet represents the transformed version of the `Component` after possible optimization. The `useMemo` hook has been removed, directly assigning `props.value` to a local variable `t0` and then assigning `t0` to `x` before returning it. The `FIXTURE_ENTRYPOINT` remains the same, defining test configurations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-labeled-statement-unconditional-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let t0;

  t0 = props.value;
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Optimized version of the component with memoized function dependencies and cached values. Uses compiler runtime utilities to manage state and prevent unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/functionexprconditional-access.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableTreatFunctionDepsAsConditional
function Component(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.bar) {
    t0 = function getLength() {
      return props.bar.length;
    };
    $[0] = props.bar;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const getLength = t0;
  let t1;
  if ($[2] !== getLength || $[3] !== props.bar) {
    t1 = props.bar && getLength();
    $[2] = getLength;
    $[3] = props.bar;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}
```

----------------------------------------

TITLE: Implementing React Function Component with Invoke Utility in JavaScript
DESCRIPTION: This code snippet defines a React function component 'useFoo' that uses an 'invoke' utility from a shared runtime. It creates an empty object, passes it to the 'invoke' function, and logs the result. The component is then exported as part of a fixture entrypoint object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-return-expression.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {invoke} from 'shared-runtime';

function useFoo() {
  const x = {};
  const result = invoke(() => x);
  console.log(result);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
  isComponent: false,
};
```

LANGUAGE: javascript
CODE:
```
import { invoke } from "shared-runtime";

function useFoo() {
  const x = {};
  const result = invoke(() => x);
  console.log(result);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing a Counter Function with Direct Assignment in JavaScript
DESCRIPTION: Defines a function 'foo' that initializes a variable to 1, increments it 10 times using direct assignment (x = x + 1), and returns the final value. The function is exported as part of a fixture entrypoint configuration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  for (let i = 0; i < 10; i++) {
    x = x + 1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining a Component with Reactive State Management - JavaScript
DESCRIPTION: This snippet enhances the `Component` to manage reactive state using a custom `c` function from the `react/compiler-runtime`. The same logic to determine `x` is applied, but it also tracks the previous value of `x` for reactivity. The component returns the reactive output based on value changes from the props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-forof-collection.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  for (const i of props.values) {
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { values: [12] },
    { values: [12] },
    { values: [1] },
    { values: [1] },
    { values: [12] },
    { values: [1] },
    { values: [12] },
    { values: [1] },
  ],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that manipulates multiple variables through sequence operations based on a conditional prop. Shows the pre-compiled version of the component logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-in-sequence.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let a = props.x;
  let b;
  let c;
  let d;
  if (props.cond) {
    d = ((b = a), a++, (c = a), ++a);
  }
  return [a, b, c, d];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{x: 2, cond: true}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining React Component with Array Mutation (JavaScript)
DESCRIPTION: This snippet defines a React component that creates an array, mutates it using a map function, and renders the results. It demonstrates potential issues with function calls that capture their callee when applying an operand.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/repro-array-map-capture-mutate-bug.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutateAndReturn, Stringify, useIdentity} from 'shared-runtime';

/**
 * Copy of repro-array-map-capture-mutate-bug, showing that the same issue applies to any
 * function call which captures its callee when applying an operand.
 */
function Component({value}) {
  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];
  useIdentity(null);
  const derived = arr.map(mutateAndReturn);
  return (
    <Stringify>
      {derived.at(0)}
      {derived.at(-1)}
    </Stringify>
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 5}],
  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}],
};
```

----------------------------------------

TITLE: Output: Compiled React Hook with Dependency Tracking
DESCRIPTION: The compiled version of the React hook that implements efficient dependency tracking. It uses the React compiler-runtime to track dependencies and memorize results based on props.a and cond values, avoiding unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // When an unconditional dependency `props.a` is the subpath of a conditional
// dependency `props.a.b`, we can safely overestimate and only track `props.a`
// as a dependency

import { identity } from "shared-runtime";

// ordering of accesses should not matter
function useConditionalSuperpath2(t0) {
  const $ = _c(3);
  const { props, cond } = t0;
  let x;
  if ($[0] !== cond || $[1] !== props.a) {
    x = {};
    if (identity(cond)) {
      x.b = props.a.b;
    }

    x.a = props.a;
    $[0] = cond;
    $[1] = props.a;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}
```

----------------------------------------

TITLE: Implementing useFoo Component with Memoization and Mutation in React
DESCRIPTION: This snippet defines a React component 'useFoo' that demonstrates memoization and mutation. It includes logic to handle potential aliasing issues and throws an error if unexpected behavior occurs. The component takes an object with 'a' and 'b' properties as input and returns an array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonmutating-capture-in-unsplittable-memo-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate} from 'shared-runtime';

/**
 * Currently, InferReactiveScopeVariables do not ensure that maybe-aliased
 * values get assigned the same reactive scope. This is safe only when an
 * already-constructed value is captured, e.g.
 * ```js
 * const x = makeObj();   mutable range of x
 * mutate(x);            
 *                       <-- after this point, we can produce a canonical version
 *                           of x for all following aliases
 * const y = [];
 * y.push(x);            <-- y captures x
 * ```
 *
 * However, if a value is captured/aliased during its mutable range and the
 * capturing container is separately memoized, it becomes difficult to guarantee
 * that all aliases refer to the same value.
 *
 */
function useFoo({a, b}) {
  const x = {a};
  const y = {};
  mutate(x);
  const z = [identity(y), b];
  mutate(y);

  if (z[0] !== y) {
    throw new Error('oh no!');
  }
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: 2, b: 3}],
  sequentialRenders: [
    {a: 2, b: 3},
    {a: 4, b: 3},
  ],
};
```

----------------------------------------

TITLE: React Compiler Runtime Memoization Implementation
DESCRIPTION: Advanced implementation showing React compiler's runtime memoization technique using _c function for tracking and conditionally updating function references
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback-cross-context.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useFoo(t0) {
  const $ = _c(13);
  const { arr1, arr2 } = t0;
  // Memoization logic with runtime tracking
  let t1;
  if ($[0] !== arr1[0]) {
    t1 = (e) => arr1[0].value + e.value;
    $[0] = arr1[0];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  // Additional memoization and conditional re-computation
  // ...
}
```

----------------------------------------

TITLE: Enhanced Memoization with Compiler Runtime
DESCRIPTION: This snippet enhances memoization in a React component with compiler-runtime utilities. It checks cached inputs/output to avoid redundant computations, using shared-runtime's ValidateMemoization to ensure validity. Achieves memoization through React compiler-runtime transformations and tests with fixed input values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression-as-memo-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import { identity, ValidateMemoization } from "shared-runtime";
import { useMemo } from "react";

function Component(t0) {
  const $ = _c(7);
  const { arg } = t0;

  arg?.items.edges?.nodes;
  let t1;
  let t2;
  if ($[0] !== arg?.items.edges?.nodes) {
    t2 = arg?.items.edges?.nodes.map(identity);
    $[0] = arg?.items.edges?.nodes;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const data = t1;

  const t3 = arg?.items.edges?.nodes;
  let t4;
  if ($[2] !== t3) {
    t4 = [t3];
    $[2] = t3;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] !== data || $[5] !== t4) {
    t5 = <ValidateMemoization inputs={t4} output={data} />;
    $[4] = data;
    $[5] = t4;
    $[6] = t5;
  } else {
    t5 = $[6];
  }
  return t5;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arg: null }],
  sequentialRenders: [
    { arg: null },
    { arg: null },
    { arg: { items: { edges: null } } },
    { arg: { items: { edges: null } } },
    { arg: { items: { edges: { nodes: [1, 2, "hello"] } } } },
    { arg: { items: { edges: { nodes: [1, 2, "hello"] } } } },
  ],
};

```

----------------------------------------

TITLE: Optimized React Component with Memoization (JavaScript)
DESCRIPTION: This snippet shows the compiler-optimized version of the 'Foo' component. It replaces the useMemo hook with a more efficient implementation using React's compiler runtime, preserving memoization guarantees while potentially improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-dep-array-literal-access.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";
import { makeArray } from "shared-runtime";

// We currently only recognize "hoistable" values (e.g. variable reads
// and property loads from named variables) in the source depslist.
// This makes validation logic simpler and follows the same constraints
// from the eslint react-hooks-deps plugin.
function Foo(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props) {
    t0 = makeArray(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  let t1;
  let t2;
  if ($[2] !== x[0]) {
    t2 = [x[0]];
    $[2] = x[0];
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  t1 = t2;
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ val: 1 }],
};
```

----------------------------------------

TITLE: React Compiler-Optimized Function with Memoization
DESCRIPTION: An optimized version of the function using React compiler runtime (_c) for memoization. Implements caching mechanisms to prevent unnecessary re-renders and improve performance by tracking component state changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function f(a, b) {
  const $ = _c(3);
  let t0;
  if ($[0] !== a.length || $[1] !== b) {
    const x = [];
    if (a.length === 1) {
      if (b) {
        x.push(b);
      }
    }

    t0 = <div>{x}</div>;
    $[0] = a.length;
    $[1] = b;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the Component function. It uses memoization to avoid unnecessary array creations and imports a compiler runtime function for optimization. The FIXTURE_ENTRYPOINT remains the same.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-logical.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(6);
  let t0;
  if ($[0] !== props.a) {
    t0 = [props.a];
    $[0] = props.a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const a = t0;
  let t1;
  if ($[2] !== props.b) {
    t1 = [props.b];
    $[2] = props.b;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const b = t1;
  let t2;
  if ($[4] !== props.c) {
    t2 = [props.c];
    $[4] = props.c;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const c = t2;
  return (a && b) || c;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized React Component Implementation in JavaScript
DESCRIPTION: This snippet presents an optimized version of the React component. Unnecessary operations have been removed, and it directly assigns and returns the 'i' prop value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-unused-prefix-update.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let i;

  i = props.i;
  return i;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ i: 42 }],
};
```

----------------------------------------

TITLE: Using react-compiler-runtime with React Components
DESCRIPTION: This code snippet enhances the previous component using the 'react-compiler-runtime' to manage rendering optimally. It introduces memoization to cache the output of the component, improving performance by avoiding unnecessary re-renders. The code exports the same component structure as a fixture entry point without additional parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/target-flag.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react-compiler-runtime"; // @target="18"

function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div>Hello world</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};

```

----------------------------------------

TITLE: Defining React Component with Memoization and Freeze - JavaScript
DESCRIPTION: This code snippet utilizes the 'react/compiler-runtime' library to define a more complex React component. It initializes a variable using the library's functionality, conditionally sets up an array depending on cache sentinel, and applies 'useFreeze' to manage the state of the array 'a'. It demonstrates advanced React features including memoization and manual array management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hooks-freeze-arguments.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const a = t0;
  useFreeze(a);
  useFreeze(a);
  call(a);
  return a;
}

function useFreeze(x) {}
function call(x) {}
```

----------------------------------------

TITLE: React Component without Flow Type Suppression
DESCRIPTION: Clean version of the same React component without Flow type suppression comments, showing the base implementation of the component and fixture export.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/no-flow-bailout-unrelated.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @enableFlowSuppressions

function useX() {}

function Foo(props) {
  useX();
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization: Javascript
DESCRIPTION: The snippet illustrates how to optimize a React component function by implementing memoization through React's compiler runtime. It effectively reduces re-computation by caching computations based on input changes. Dependencies include 'react/compiler-runtime' for memoization support, and it requires consistent property inputs for accuracy.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-at-closure.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(7);
  let t0;
  if ($[0] !== props.x) {
    t0 = foo(props.x);
    $[0] = props.x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  let t1;
  if ($[2] !== props || $[3] !== x) {
    t1 = function () {
      const arr = [...bar(props)];
      return arr.at(x);
    };
    $[2] = props;
    $[3] = x;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const fn = t1;
  let t2;
  if ($[5] !== fn) {
    t2 = fn();
    $[5] = fn;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const fnResult = t2;
  return fnResult;
}

```

----------------------------------------

TITLE: React Component Input with arrayPush
DESCRIPTION: Defines a React component, `useFoo`, which accepts an object with properties `a` and `b` as input. It creates an object with property `a` and then pushes the value of `b` onto the keys of this object using `arrayPush` from `shared-runtime`. Finally, it exports a `FIXTURE_ENTRYPOINT` which provides the component function and its params.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/shapes-object-key.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {arrayPush} from 'shared-runtime';

function useFoo({a, b}) {
  const obj = {a};
  arrayPush(Object.keys(obj), b);
  return obj;
}
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: 2, b: 3}],
};

```

----------------------------------------

TITLE: Compiled React Counter Component with Optimizations
DESCRIPTION: Optimized version of the counter component with compiler-runtime modifications. Implements memoization and conditional rendering based on state changes using compiler-generated variables and checks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-reordering.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableInstructionReordering
import { useState } from "react";
import { Stringify } from "shared-runtime";

function Component() {
  const $ = _c(7);
  const [state, setState] = useState(0);
  let t0;
  let t1;
  if ($[0] !== state) {
    t0 = (
      <button data-testid="button" onClick={() => setState(state + 1)}>
        increment
      </button>
    );
    t1 = <span>{state}</span>;
    $[0] = state;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = <Stringify text="Counter" />;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t0 || $[5] !== t1) {
    t3 = (
      <div>
        {t2}
        {t1}
        {t0}
      </div>
    );
    $[4] = t0;
    $[5] = t1;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Compiled React Component with FBT Optimization
DESCRIPTION: The compiled output of the FBT component after React's compiler transformation. It shows how the compiler optimizes rendering by memoizing translations based on prop changes using an internal state array (_c) to avoid unnecessary rerenders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-jsxtext.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Foo(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.value) {
    t0 = fbt._(
      { "0": "hello {value},", "1": "goodbye {value}," },
      [
        fbt._enum(props.value ? "0" : "1", { "0": "hello", "1": "goodbye" }),
        fbt._param(
          "value",

          props.value,
        ),
      ],
      { hk: "Ri5kJ" },
    );
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ value: 1 }],
  sequentialRenders: [{ value: 1 }, { value: 0 }],
};
```

----------------------------------------

TITLE: Compiled FBT Component Output
DESCRIPTION: Shows the compiled JavaScript output of the FBT component with runtime optimization for parameter caching and internationalization handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-preserve-whitespace-subtree.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

/**
 * Note that fbt whitespace rules apply to the entire fbt subtree,
 * not just direct children of fbt elements.
 * (e.g. here, the JSXText children of the span element also use
 * fbt whitespace rules)
 */

function Foo(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.name) {
    t0 = fbt._(
      "{=m0}",
      [
        fbt._implicitParam(
          "=m0",
          <span key={props.name}>
            {fbt._(
              "{user name really long description for prettier} !",
              [
                fbt._param(
                  "user name really long description for prettier",

                  props.name,
                ),
              ],
              { hk: "rdgIJ" },
            )}
          </span>,
        ),
      ],
      { hk: "32Ufy5" },
    );
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ name: "Jason" }],
};
```

----------------------------------------

TITLE: Optimized Function Implementation in JavaScript
DESCRIPTION: Optimized version of 'foo' function that eliminates redundant assignments. The function only assigns parameter 'c' to variable 'x' before returning it, improving efficiency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-reassign.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let x;

  x = c;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Exporting Fixture Entry Point
DESCRIPTION: This snippet exports a constant FIXTURE_ENTRYPOINT that holds the reference to the useFoo function, initial parameters, and a series of test cases with various object states to validate its behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-in-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{obj: null, objIsNull: true}],
  sequentialRenders: [
    {obj: null, objIsNull: true},
    {obj: {a: 2}, objIsNull: false},
    // check we preserve nullthrows
    {obj: {a: undefined}, objIsNull: false},
    {obj: undefined, objIsNull: false},
    {obj: {a: undefined}, objIsNull: false},
  ],
};
```

----------------------------------------

TITLE: Fixture Entrypoint Configuration
DESCRIPTION: Defines a test fixture with function and predefined input parameters for testing and evaluation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [
    [1, 2],
    [2, 3],
  ],
};
```

----------------------------------------

TITLE: Test Configuration for React Hook
DESCRIPTION: Defines the test configuration for the React hook, specifying initial parameters and a series of sequential renders with different prop values to verify behavior with null, undefined, and valid object values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order2.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useConditionalSuperpath2,
  params: [{ props: { a: null }, cond: false }],
  sequentialRenders: [
    { props: { a: null }, cond: false },
    { props: { a: {} }, cond: true },
    { props: { a: { b: 3 } }, cond: true },
    { props: {}, cond: false },
    // test that we preserve nullthrows
    { props: { a: { b: undefined } }, cond: true },
    { props: { a: undefined }, cond: true },
  ],
};
```

----------------------------------------

TITLE: Compiled useEffect and useState React Component - JavaScript
DESCRIPTION: This snippet is a compiled version of a React component using useState and useEffect. It includes memoization techniques and checks symbol values to conditionally assign an effect handler. The function _temp defines the update logic for the state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-setState-in-useEffect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @logger @validateNoSetStateInPassiveEffects
import { useEffect, useState } from "react";

function Component() {
  const $ = _c(1);
  const [state, setState] = useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setState(_temp);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(t0);
  return state;
}
function _temp(s) {
  return s + 1;
}

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Transformed version of the component with memoization logic added by the React compiler. Uses Symbol.for('react.memo_cache_sentinel') to implement caching of the generated session ID object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-nested-scopes.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { getNumber } = require("shared-runtime");

function Component(props) {
  const $ = _c(1);
  let x;
  if (props.cond) {
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = { session_id: getNumber() };
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    x = t0;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the Foo component with memoization logic using React's compiler runtime. Implements cache checking using Symbol.for('react.memo_cache_sentinel') to optimize rendering performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-logical-no-sequence.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    true && (x = []);
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: React Class Component with Invalid useState Hook Usage
DESCRIPTION: This code demonstrates an attempt to use the `useState` hook within a class component's `render` method. React hooks can only be used inside functional components or custom hooks, not within class components. This code is expected to fail in a proper React environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.invalid.invalid-rules-of-hooks-8303403b8e4c.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @skip
// Passed but should have failed

class ClassComponentWithHook extends React.Component {
  render() {
    React.useState();
  }
}

```

----------------------------------------

TITLE: Invalid React Error
DESCRIPTION: This error message indicates that the code is attempting to modify a variable defined outside of the component or hook. This can lead to unexpected side effects and make it difficult to reason about the component's behavior. React enforces restrictions on directly modifying external variables to maintain predictable state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.store-property-in-global.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  2 |
  3 | function Foo() {
> 4 |   wat.test = 1;
    |   ^^^ InvalidReact: Writing to a variable defined outside a component or hook is not allowed. Consider using an effect (4:4)
  5 |   return wat;
  6 | }
  7 |

```

----------------------------------------

TITLE: Implementing waitForCommitToBeReady for React Reconciler in JavaScript
DESCRIPTION: This method is called after all suspendInstance calls are complete. It determines if a commit can happen immediately or if it needs to be suspended. It returns null for immediate commits or a function for suspended commits.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
waitForCommitToBeReady() {
  // Return null if the commit can happen immediately
  // Or return a function: (initiateCommit: Function) => Function
  // if the commit must be suspended
}
```

----------------------------------------

TITLE: Defining React Components and Fixture Entrypoint
DESCRIPTION: This snippet defines two React components (Component and Component2) as empty fragments. It also sets display names for both components and exports a FIXTURE_ENTRYPOINT object with the Component function, empty params, and sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-preserves-function-properties.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @gating

export default function Component() {
  return <></>;
}

export function Component2() {
  return <></>;
}

Component.displayName = 'Component ONE';
Component2.displayName = 'Component TWO';

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [{}],
};
```

----------------------------------------

TITLE: Enhanced React Component with State Management
DESCRIPTION: This snippet enhances the 'useFoo' function to include internal state management for efficient rendering. It uses a caching mechanism to avoid unnecessary re-computation by checking previous dependency values before rendering the Stringify component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/todo-infer-function-uncond-optionals-hoisted.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR

import { Stringify } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(2);
  const { a } = t0;
  let t1;
  if ($[0] !== a.b?.c.d?.e) {
    t1 = <Stringify fn={() => a.b?.c.d?.e} shouldInvokeFns={true} />;
    $[0] = a.b?.c.d?.e;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: null }],
  sequentialRenders: [
    { a: null },
    { a: { b: null } },
    { a: { b: { c: { d: null } } } },
    { a: { b: { c: { d: { e: 4 } } } } },
  ],
};

```

----------------------------------------

TITLE: Transformed JavaScript function foo with memoization
DESCRIPTION: This snippet shows the transformed `foo` function. It imports `_c` from `react/compiler-runtime`, likely used for memoization. The function checks if the input `a` is different from the previously stored value (`$[0]`). If it is, it recomputes the value, stores it in `$[1]`, and updates `$[0]`. Otherwise, it returns the cached value from `$[1]`. This effectively memoizes the function's result based on the input `a`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a) {
  const $ = _c(2);
  let x;
  if ($[0] !== a) {
    x = {};
    if (a) {
      const y = {};
      x.y = y;
    } else {
      const z = {};
      x.z = z;
    }

    mutate(x);
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: Defining a Memoized React Component - JavaScript
DESCRIPTION: This snippet defines a more complex React component named 'Component' that uses a memoization cache via React's compiler runtime. It checks if the first cached value is a sentinel and assigns a new object if so; otherwise, it directly retrieves the cached value. The snippet returns a memoized array. The input parameters include component props, and the output is a memoized array containing the component state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/globals-Number.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  const y = Number(x);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [x, y];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Original Function Implementation in JavaScript
DESCRIPTION: Initial implementation of a function that manipulates an array based on props conditions, without explicit memoization
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let x = [];
  x.push(props.bar);
  if (props.cond) {
    x = {};
    x = [];
    x.push(props.foo);
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Defining Original React Component with Dynamic Context
DESCRIPTION: This snippet shows the original React component that creates a dynamic context object based on props. It uses a constant SCALE and the identity function from a shared runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-non-reactive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

const SCALE = 2;

function Component(props) {
  const key = SCALE;
  const context = {
    [key]: identity([props.value]),
  };
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{key: 'Sathya', value: 'Compiler'}],
};
```

----------------------------------------

TITLE: Compiled useFoo Function with Memoization (React Compiler)
DESCRIPTION: This JavaScript code shows the compiled version of the `useFoo` function, optimized by the React compiler. It imports the `_c` function for memoization. The compiled function uses an array `$` to store previous input values and the result of the function. If the inputs `input.a.b` and `max` have not changed, it retrieves the previously computed result from `$`. Otherwise, it re-executes the logic and stores the new inputs and result in `$` for future memoization. It includes the same `FIXTURE_ENTRYPOINT` object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/jump-target-within-scope-loop-break.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(t0) {
  const $ = _c(3);
  const { input, max } = t0;
  let x;
  if ($[0] !== input.a.b || $[1] !== max) {
    x = [];
    let i = 0;
    while (true) {
      i = i + 1;
      if (i > max) {
        break;
      }
    }

    x.push(i);
    x.push(input.a.b);
    $[0] = input.a.b;
    $[1] = max;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { a: { b: 2 } }, max: 8 }],
  sequentialRenders: [
    { input: { a: { b: 2 } }, max: 8 },
    // preserve nullthrows
    { input: null, max: 8 },
    { input: {}, max: 8 },
    { input: { a: { b: null } }, max: 8 },
    { input: { a: null }, max: 8 },
    { input: { a: { b: 3 } }, max: 8 },
  ],
};

```

----------------------------------------

TITLE: Compiled JavaScript with React Compiler Runtime
DESCRIPTION: This code snippet shows the compiled output of the previous hoisting example using React's compiler runtime. The `_c` function (aliased as `c`) from `react/compiler-runtime` is used to manage the memoization and caching of the `foo` function. It demonstrates how React handles hoisting during compilation and optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-simple-const-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```javascript
import { c as _c } from "react/compiler-runtime";
function hoisting() {
  const $ = _c(1);
  let foo;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    foo = () => bar + baz;

    const bar = 3;
    const baz = 2;
    $[0] = foo;
  } else {
    foo = $[0];
  }
  return foo();
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```
```

----------------------------------------

TITLE: Optimized Component Props Handling - JavaScript
DESCRIPTION: This enhanced JavaScript function 'Component' uses an imported module from 'react/compiler-runtime' for optimized state handling. It checks for changes in props and updates its internal state accordingly while caching result values to avoid unnecessary re-renders. The code illustrates efficient state management techniques in a React-like infrastructure while employing hooks-like caching for performance improvements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-cascading-eliminated-phis.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(7);
  let x = 0;
  let values;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d ||
    $[4] !== x
  ) {
    values = [];
    const y = props.a || props.b;
    values.push(y);
    if (props.c) {
      x = 1;
    }

    values.push(x);
    if (props.d) {
      x = 2;
    }

    values.push(x);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = x;
    $[5] = values;
    $[6] = x;
  } else {
    values = $[5];
    x = $[6];
  }
  return values;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 0, b: 1, c: true, d: true }],
  sequentialRenders: [
    { a: 0, b: 1, c: true, d: true },
    { a: 4, b: 1, c: true, d: true },
    { a: 4, b: 1, c: false, d: true },
    { a: 4, b: 1, c: false, d: false },
  ],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the React component using memoization techniques. It uses the '_c' function from 'react/compiler-runtime' to create a cache and optimize re-renders based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/functionexpr-conditional-access-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableTreatFunctionDepsAsConditional
import { Stringify } from "shared-runtime";

function Component(t0) {
  const $ = _c(7);
  const { props } = t0;
  let t1;
  if ($[0] !== props) {
    t1 = () => props.a.b;
    $[0] = props;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const f = t1;
  let t2;
  if ($[2] !== f || $[3] !== props) {
    t2 = props == null ? _temp : f;
    $[2] = f;
    $[3] = props;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== t2) {
    t3 = <Stringify f={t2} />;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}
function _temp() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ props: null }],
};
```

----------------------------------------

TITLE: React Component with Optimized Conditional Logic in JavaScript
DESCRIPTION: This snippet demonstrates an optimized React component setup leveraging 'compiler-runtime' support using cache for condition evaluations. It still depends on 'makeObject_Primitives' for object creation, caching previous prop values using a Symbol mechanics to avoid redundant evaluations. Outputs an object based on the latest conditions utilizing cached states.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-mutated-in-consequent-alternate-both-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeObject_Primitives } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.cond || $[1] !== props.value) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const object = makeObject_Primitives();
      if (props.cond) {
        object.value = 1;
        t0 = object;
        break bb0;
      } else {
        object.value = props.value;
        t0 = object;
        break bb0;
      }
    }
    $[0] = props.cond;
    $[1] = props.value;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: false, value: [0, 1, 2] }],
};
```

----------------------------------------

TITLE: Transpiled React Component with Conditional Property Access (Code)
DESCRIPTION: This code represents the transpiled version of the React component `Foo`, likely generated by a compiler like React Compiler. It utilizes `react/compiler-runtime` to optimize rendering by memoizing the `Stringify` component based on the props `a` and `shouldReadA`.  This optimization prevents unnecessary re-renders when the input props are unchanged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/infer-function-cond-access-not-hoisted.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Foo(t0) {
  const $ = _c(3);
  const { a, shouldReadA } = t0;
  let t1;
  if ($[0] !== a || $[1] !== shouldReadA) {
    t1 = (
      <Stringify
        fn={() => {
          if (shouldReadA) {
            return a.b.c;
          }
          return null;
        }}
        shouldInvokeFns={true}
      />
    );
    $[0] = a;
    $[1] = shouldReadA;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ a: null, shouldReadA: true }],
  sequentialRenders: [
    { a: null, shouldReadA: true },
    { a: null, shouldReadA: false },
    { a: { b: { c: 4 } }, shouldReadA: true },
  ],
};
```

----------------------------------------

TITLE: React Compiler Runtime Integration in JavaScript
DESCRIPTION: Illustrates an optimized React component using React's compiler runtime. It manages state with a cache-like mechanism and ensures efficient rendering of the Foo element by leveraging transformed syntax.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-callback-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(4);
  const [count, setCount] = useState(0);
  let t0;
  if ($[0] !== count) {
    t0 = () => setCount(count + 1);
    $[0] = count;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const increment = t0;
  let t1;
  if ($[2] !== increment) {
    t1 = <Foo onClick={increment} />;
    $[2] = increment;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

```

----------------------------------------

TITLE: Optimizing CaptureNotMutate with React Compiler Runtime
DESCRIPTION: This optimized version of the CaptureNotMutate component uses React's compiler runtime for memoization. It introduces caching mechanisms to avoid unnecessary recalculations and function calls based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-capture-returned-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";

function CaptureNotMutate(props) {
  const $ = _c(5);
  let t0;
  if ($[0] !== props.x) {
    t0 = foo(props.x);
    $[0] = props.x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const idx = t0;
  let aliasedElement;
  if ($[2] !== idx || $[3] !== props.el) {
    const element = bar(props.el);

    const fn = function () {
      const arr = { element };
      return arr[idx];
    };

    aliasedElement = fn();
    mutate(aliasedElement);
    $[2] = idx;
    $[3] = props.el;
    $[4] = aliasedElement;
  } else {
    aliasedElement = $[4];
  }
  return aliasedElement;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization - JavaScript
DESCRIPTION: This code snippet shows the compiled and optimized version of the React component. It uses memoization to avoid unnecessary reassignments and computations, improving performance for sequential renders with the same props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reactive-explicit-control-flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { invoke } from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  const { shouldReassign } = t0;
  let x;
  if ($[0] !== shouldReassign) {
    x = null;
    const reassign = () => {
      if (shouldReassign) {
        x = 2;
      }
    };

    invoke(reassign);
    $[0] = shouldReassign;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ shouldReassign: true }],
  sequentialRenders: [{ shouldReassign: false }, { shouldReassign: true }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Logic
DESCRIPTION: Compiled version of the React component showing the implementation of memoization using cache array and conditional value updates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/use-memo-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  "use memo";
  const $ = _c(4);
  let t0;
  if ($[0] !== props.foo) {
    t0 = [props.foo];
    $[0] = props.foo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  let t1;
  if ($[2] !== x) {
    t1 = <div x={x}>"foo"</div>;
    $[2] = x;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ foo: 1 }],
  isComponent: true,
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: The compiler-optimized version of the component using React's compiler runtime for memoization. It includes caching mechanism to prevent unnecessary recreations of functions and objects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutate-captured-arg-separately.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    y = function () {
      m(x);
    };

    let x;
    x = { a };
    m(x);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

function m(x) {}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [{ name: "Jason" }],
};
```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the previous function using React's compiler runtime. It implements the same destructuring logic but with improved performance and memoization techniques.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(5);
  let d;
  let g;
  let n;
  let o;
  const [t0, t1] = a;
  d = t0;
  const [t2] = t1;
  const { e: t3 } = t2;
  ({ f: g } = t3);
  const { l: t4, o: t5 } = b;
  const { m: t6 } = t4;
  const [t7] = t6;
  [n] = t7;
  o = t5;
  let t8;
  if ($[0] !== d || $[1] !== g || $[2] !== n || $[3] !== o) {
    t8 = { d, g, n, o };
    $[0] = d;
    $[1] = g;
    $[2] = n;
    $[3] = o;
    $[4] = t8;
  } else {
    t8 = $[4];
  }
  return t8;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Error Handling in Fire Function Invocation
DESCRIPTION: This snippet illustrates the error encountered when the fire function is called with multiple arguments instead of a single expression. This highlights potential pitfalls in usage, providing insight into the expected input format for the fire method.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-multiple-args.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
   7 |   };
   8 |   useEffect(() => {
>  9 |     fire(foo(bar), baz);
     |     ^^^^^^^^^^^^^^^^^^^ InvalidReact: Cannot compile `fire`. fire() can only take in a single call expression as an argument but received multiple arguments (9:9)
  10 |   });
  11 |
  12 |   return null;

```

----------------------------------------

TITLE: Compiled useMemo Hook with React Compiler
DESCRIPTION: This is the compiled version of the `useFoo` hook using `react/compiler-runtime`. It optimizes the `useMemo` call by potentially reducing the dependency list. The compiler replaces the standard `useMemo` with a custom `_c` function that manages the memoization cache.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-fewer-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";

// It's correct to produce memo blocks with fewer deps than source
function useFoo(a, b) {
  const $ = _c(2);
  let t0;
  let t1;
  if ($[0] !== a) {
    t1 = [a];
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [1, 2],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet shows the compiled version of the React component, utilizing 'react/compiler-runtime' for memoization and optimization. It takes props 'a' and 'b', checks if they have changed since the last render using the compiler's cache ('_c'), and re-executes the component logic only if there are changes. The compiled component effectively caches the result based on input props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function Component(t0) {
  const $ = _c(3);
  const { a, b } = t0;
  let t1;
  if ($[0] !== a || $[1] !== b) {
    const z = { a };
    const y = { b: { b } };
    const x = function () {
      z.a = 2;
      mutate(y.b);
    };

    x();
    t1 = [y, z];
    $[0] = a;
    $[1] = b;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 2, b: 3 }],
  sequentialRenders: [
    { a: 2, b: 3 },
    { a: 2, b: 3 },
    { a: 4, b: 3 },
    { a: 4, b: 5 },
  ],
};

```

----------------------------------------

TITLE: Defining Function foo with React Compiler Runtime
DESCRIPTION: This snippet modifies the foo function to incorporate React's compiler runtime, aiming to optimize the function's performance by tracking state using compiler runtime cache. Dependencies include the react/compiler-runtime. The function accepts parameters x and y, and adds caching logic to reduce redundant calculations, especially for recursive scenarios, based on the state of x. It returns an array with the computed value of y multiplied by 10, utilizing caching for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
export default function foo(x, y) {
  const $ = _c(4);
  if (x) {
    let t0;
    if ($[0] !== y) {
      t0 = foo(false, y);
      $[0] = y;
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    return t0;
  }

  const t0 = y * 10;
  let t1;
  if ($[2] !== t0) {
    t1 = [t0];
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

```

----------------------------------------

TITLE: Implementing React Memoization Cache in Component - JavaScript
DESCRIPTION: This JavaScript snippet extends a React component with an implementation that introduces a memoization cache for improved reactivity using the '_c' function from 'react/compiler-runtime'. It manages an internal reactive state with Symbol for recognizing memo cache sentinel values. Inputs/outputs resemble the basic component, and it's crucial to include 'react/compiler-runtime' as a dependency to utilize the caching mechanism effectively.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-if.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);

  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(null);

  const c = [a];

  let x;
  if (c[0][0]) {
    x = 1;
  } else {
    x = 2;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};
```

----------------------------------------

TITLE: Optimized React Component using Compiler-Runtime in JavaScript
DESCRIPTION: This snippet shows an optimized version of the Component using React's compiler-runtime. It implements memoization to avoid unnecessary re-computations and improve performance. The component logic remains the same, but with added caching mechanisms.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-object-pattern-within-rest.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(6);
  let t0;
  let y;
  if ($[0] !== props.value) {
    [y, ...t0] = props.value;
    $[0] = props.value;
    $[1] = t0;
    $[2] = y;
  } else {
    t0 = $[1];
    y = $[2];
  }
  const { z } = t0;
  let t1;
  if ($[3] !== y || $[4] !== z) {
    t1 = [y, z];
    $[3] = y;
    $[4] = z;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: ["y", { z: "z!" }] }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Logic
DESCRIPTION: The compiled version of the React component showing the internal memoization implementation. Contains detailed caching logic using a compiler-generated array for storing memoized values and dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-log.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { typedLog, ValidateMemoization } from "shared-runtime";

export function Component(t0) {
  const $ = _c(17);
  const { a, b } = t0;
  let t1;
  let t2;
  if ($[0] !== a) {
    t2 = { a };
    $[0] = a;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const item1 = t1;
  let t3;
  let t4;
  if ($[2] !== b) {
    t4 = { b };
    $[2] = b;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  t3 = t4;
  const item2 = t3;
  typedLog(item1, item2);
  let t5;
  if ($[4] !== a) {
    t5 = [a];
    $[4] = a;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] !== item1 || $[7] !== t5) {
    t6 = <ValidateMemoization inputs={t5} output={item1} />;
    $[6] = item1;
    $[7] = t5;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  if ($[9] !== b) {
    t7 = [b];
    $[9] = b;
    $[10] = t7;
  } else {
    t7 = $[10];
  }
  let t8;
  if ($[11] !== item2 || $[12] !== t7) {
    t8 = <ValidateMemoization inputs={t7} output={item2} />;
    $[11] = item2;
    $[12] = t7;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  let t9;
  if ($[14] !== t6 || $[15] !== t8) {
    t9 = (
      <>
        {t6}
        {t8}
      </>
    );
    $[14] = t6;
    $[15] = t8;
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  return t9;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 0, b: 0 }],
  sequentialRenders: [
    { a: 0, b: 0 },
    { a: 1, b: 0 },
    { a: 1, b: 1 },
    { a: 1, b: 2 },
    { a: 2, b: 2 },
    { a: 3, b: 2 },
    { a: 0, b: 0 },
  ],
};
```

----------------------------------------

TITLE: Enhanced Memoization Logic in React Component Using Compiler Runtime - JavaScript
DESCRIPTION: This snippet is an advanced version of the React component, which integrates the use of a compiler runtime for aggressive memoization. It includes conditional rendering based on cached execution paths via a component-internal cache. Dependencies include the React library and 'react/compiler-runtime'. The component renders based on whether the entity is set and manages internal state changes efficiently.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-nonescaping-invoked-callback-escaping-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
import { useCallback } from "react";

function Component(t0) {
  const $ = _c(9);
  const { entity, children } = t0;
  let t1;
  if ($[0] !== entity) {
    t1 = () => entity != null;
    $[0] = entity;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const showMessage = t1;

  const shouldShowMessage = showMessage();
  let t2;
  if ($[2] !== shouldShowMessage) {
    t2 = <div>{shouldShowMessage}</div>;
    $[2] = shouldShowMessage;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== children) {
    t3 = <div>{children}</div>;
    $[4] = children;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== t2 || $[7] !== t3) {
    t4 = (
      <div>
        {t2}
        {t3}
      </div>
    );
    $[6] = t2;
    $[7] = t3;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      entity: { name: "Sathya" },
      children: [<div key="gsathya">Hi Sathya!</div>],
    },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimizations
DESCRIPTION: The compiled version of the React component that includes runtime optimizations and caching mechanism using the compiler runtime utilities. Implements the same functionality with performance improvements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-default-array-with-unary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const [t0] = props.value;
  let t1;
  if ($[0] !== t0) {
    t1 = t0 === undefined ? [-1, 1] : t0;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: [] }],
};
```

----------------------------------------

TITLE: Transformed React Component with useFire
DESCRIPTION: This code presents the transformed version of the React component using the `useFire` hook and compiler-runtime. The compiler has replaced the direct `fire` call with a `useFire` hook and a conditional update to trigger the effect only when necessary, optimizing performance by memoizing the handler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/rewrite-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c, useFire } from "react/compiler-runtime"; // @enableFire
import { fire } from "react";

function Component(props) {
  const $ = _c(4);
  const foo = _temp;
  const t0 = useFire(foo);
  let t1;
  let t2;
  if ($[0] !== props || $[1] !== t0) {
    t1 = () => {
      t0(props);
    };
    t2 = [t0, props];
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = t2;
  } else {
    t1 = $[2];
    t2 = $[3];
  }
  useEffect(t1, t2);
  return null;
}
function _temp(props_0) {
  console.log(props_0);
}

```

----------------------------------------

TITLE: Enhanced Component Logic in React with State Management
DESCRIPTION: This snippet imports a method from the React compiler runtime and uses it to manage component state. It retains the logic of optional chaining while caching the output to avoid redundant calculations, allowing for optimized rendering based on props equality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-call-chained.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    t0 = call?.(props.a)?.(props.b)?.(props.c);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: React Component with Memoization using compiler-runtime
DESCRIPTION: This code defines a React component optimized with memoization using `react/compiler-runtime`. It aims to prevent unnecessary re-renders by caching the element based on the `width` prop. It uses `shared-runtime`'s `shallowCopy` function. The component checks if the `width` prop has changed, and only recreates the element if it has, storing the result in a cache for future use.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-freeze.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { jsx as _jsx } from "react/jsx-runtime";
import { shallowCopy } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  let element;
  if ($[0] !== props.width) {
    const childprops = { style: { width: props.width } };
    element = _jsx("div", { childprops, children: '"hello world"' });
    shallowCopy(childprops);
    $[0] = props.width;
    $[1] = element;
  } else {
    element = $[1];
  }
  return element;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: Memoized React Component using Compiler Runtime
DESCRIPTION: This snippet shows the compiled version of the React component, leveraging `react/compiler-runtime` for memoization.  It caches values associated with props `a`, `b`, and `cond` to avoid re-computation when the props haven't changed. `Symbol.for("react.early_return_sentinel")` is used to signal that the component returned early and needs to be re-evaluated during the next render if props have changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/early-return-nested-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(7);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const x = [];
      if (props.cond) {
        x.push(props.a);
        if (props.b) {
          let t1;
          if ($[4] !== props.b) {
            t1 = [props.b];
            $[4] = props.b;
            $[5] = t1;
          } else {
            t1 = $[5];
          }
          const y = t1;
          x.push(y);
          t0 = x;
          break bb0;
        }

        t0 = x;
        break bb0;
      } else {
        let t1;
        if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
          t1 = foo();
          $[6] = t1;
        } else {
          t1 = $[6];
        }
        t0 = t1;
        break bb0;
      }
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.cond;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, a: 42, b: 3.14 }],
};

```

----------------------------------------

TITLE: Optimized React Hook with Compiler Runtime and Mutation
DESCRIPTION: This code snippet represents an optimized version of the `useFoo` React hook using `react/compiler-runtime` for memoization and `shared-runtime` for mutation.  The hook conditionally updates the value of `x` based on whether the props have changed, using a memoized array `$`. This approach aims to prevent unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    x = [];
    x.push(props.bar);
    if (props.cond) {
      x = [];
      x.push(props.foo);
    } else {
      x = [];
      x.push(props.bar);
    }

    mutate(x);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ bar: "bar", foo: "foo", cond: true }],
  sequentialRenders: [
    { bar: "bar", foo: "foo", cond: true },
    { bar: "bar", foo: "foo", cond: true },
    { bar: "bar", foo: "foo", cond: false },
  ],
};

```

----------------------------------------

TITLE: React Compiler Optimized Implementation
DESCRIPTION: Compiler-optimized version using React's compiler runtime for memoization. Uses an array to cache the previous value of 'a' and its corresponding object, reducing unnecessary object creation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-if-else.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c, d) {
  const $ = _c(2);
  someObj();
  let x;
  if ($[0] !== a) {
    if (a) {
      x = someObj();
    } else {
      x = someObj();
    }

    x.f = 1;
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimizations
DESCRIPTION: Compiled output showing the transformed component with compiler runtime optimizations. Includes memoization logic to prevent unnecessary re-renders and compiler-specific runtime imports.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-foreach-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutateAndReturn, Stringify, useIdentity } from "shared-runtime";

function Component(t0) {
  const $ = _c(2);
  const { value } = t0;
  const arr = [{ value: "foo" }, { value: "bar" }, { value }];
  useIdentity();
  const derived = new Set(arr).forEach(mutateAndReturn);
  let t1;
  if ($[0] !== derived) {
    t1 = <Stringify>{[...derived]}</Stringify>;
    $[0] = derived;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 5 }],
  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }, { value: 7 }],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that creates an object with a computed property name based on props.foo. Includes an export of FIXTURE_ENTRYPOINT for component configuration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-string-literal-key.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const x = {['foo']: props.foo};
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Compiling React Component with Optimizations in JavaScript
DESCRIPTION: This snippet demonstrates the compiled version of the React component. It includes compiler runtime imports, constant declarations, and memoization logic for optimized performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-return-type-inference.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  const x = foo();
  const y = foo();
  if (x > y) {
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = foo();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const z_0 = t0;
  return z_0;
}
```

----------------------------------------

TITLE: Using Cached Value in useFoo - JavaScript
DESCRIPTION: This version of 'useFoo' enhances the previous implementation by introducing caching logic with the React compiler runtime. It checks if a cached value exists before calling 'getNumber', storing the result for future calls. This approach improves performance by reducing unnecessary calls to the shared runtime function, while still accounting for errors in the process. The function is still set up to be exported as a fixture, maintaining the same structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/empty-catch-statement.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { getNumber } from "shared-runtime";

function useFoo() {
  const $ = _c(1);
  try {
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = getNumber();
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    return t0;
  } catch {}
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Optimized version after React compiler processing, introducing memoization using Symbol.for() and compiler runtime utilities. Shows how React transforms the code to improve performance through caching.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-field-load-binary-op.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { u: makeSomePrimitive(), v: makeSomePrimitive() };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  const u = x.u;
  const v = x.v;
  if (u > v) {
  }

  const z = x.v;
  return z;
}
```

----------------------------------------

TITLE: Using Compiler Runtime in useFoo Hook
DESCRIPTION: This snippet demonstrates another implementation of the useFoo hook using the React compiler runtime for internal state management. It checks incoming parameters for changes and utilizes a sentinel symbol to manage early return states.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/return-in-scope.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(t0) {
  const $ = _c(4);
  const { obj, objIsNull } = t0;
  let t1;
  let x;
  if ($[0] !== obj || $[1] !== objIsNull) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      if (objIsNull) {
        t1 = undefined;
        break bb0;
      }

      x.push(obj.b);
    }
    $[0] = obj;
    $[1] = objIsNull;
    $[2] = t1;
    $[3] = x;
  } else {
    t1 = $[2];
    x = $[3];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization Optimizations
DESCRIPTION: The compiled output of the component with React's compiler optimizations. It introduces memoization using Symbol.for("react.memo_cache_sentinel") to prevent unnecessary recalculations and instantiations on re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/new-does-not-mutate-class.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

class Foo {}
function Component(t0) {
  const $ = _c(6);
  const { val } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = identity(Foo);
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const MyClass = t1;
  let t2;
  if ($[1] !== val) {
    t2 = [val];
    $[1] = val;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const x = t2;
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = new MyClass();
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const y = t3;
  let t4;
  if ($[4] !== x) {
    t4 = [x, y];
    $[4] = x;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ val: 0 }],
};
```

----------------------------------------

TITLE: Optimized: React Compiler Runtime Function
DESCRIPTION: Compiler-optimized version of the function using React's compiler runtime with memoization and early return sentinel pattern
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-return-in-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useFoo(t0) {
  const $ = _c(4);
  const { obj, objIsNull } = t0;
  let t1;
  let x;
  if ($[0] !== obj || $[1] !== objIsNull) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      if (objIsNull) {
        t1 = undefined;
        break bb0;
      } else {
        x.push(obj.a);
      }

      x.push(obj.b);
    }
    $[0] = obj;
    $[1] = objIsNull;
    $[2] = t1;
    $[3] = x;
  } else {
    t1 = $[2];
    x = $[3];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return x;
}
```

----------------------------------------

TITLE: Transformed React Hook with Compiler-Managed Memoization
DESCRIPTION: This snippet shows the transformed version of the `useFoo` hook, likely produced by a React compiler. It manages memoization using a cache (`_c`) and checks for a sentinel value (`Symbol.for("react.memo_cache_sentinel")`) to determine if the array and the derived function need to be recomputed. The `FIXTURE_ENTRYPOINT` remains the same, exporting the hook for use.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useCallback-infer-read-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees
import { useCallback } from "react";
import { sum } from "shared-runtime";

function useFoo() {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [1, 2, 3];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const val = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => sum(...val);
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};

```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the React component using the compiler-runtime. It implements memoization to avoid unnecessary re-renders and uses a more efficient rendering approach.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    const items = [];
    for (const key in props) {
      items.push(<div key={key}>{key}</div>);
    }

    t0 = <div>{items}</div>;
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ hello: null, world: undefined, "!": true }],
  sequentialRenders: [
    { a: null, b: null, c: null },
    { lauren: true, mofei: true, sathya: true, jason: true },
  ],
};
```

----------------------------------------

TITLE: Transformed React Component with Memoization
DESCRIPTION: Compiler-transformed version of the component with added memoization logic. Uses a cache system to store and retrieve previously computed values, preventing unnecessary recalculations when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-reassign-to-variable-without-mutable-range.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @debug
function Component(a, b) {
  const $ = _c(11);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let x = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let y = t1;
  if ($[2] !== a || $[3] !== b) {
    const z = foo(a);
    if (FLAG) {
      x = bar(z);
      let t2;
      if ($[6] !== b) {
        t2 = baz(b);
        $[6] = b;
        $[7] = t2;
      } else {
        t2 = $[7];
      }
      y = t2;
    }
    $[2] = a;
    $[3] = b;
    $[4] = x;
    $[5] = y;
  } else {
    x = $[4];
    y = $[5];
  }
  let t2;
  if ($[8] !== x || $[9] !== y) {
    t2 = [x, y];
    $[8] = x;
    $[9] = y;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  return t2;
}
```

----------------------------------------

TITLE: Original Hook Implementation
DESCRIPTION: Implementation of a React hook that creates a log array based on loop iterations. Takes an 'end' parameter and builds log entries with markers @A, @B, and @C based on loop conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unlabeled-break-within-label-loop.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useHook(end) {
  const log = [];
  for (let i = 0; i < end + 1; i++) {
    log.push(`${i} @A`);
    bb0: {
      if (i === end) {
        break;
      }
      log.push(`${i} @B`);
    }
    log.push(`${i} @C`);
  }
  return log;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [1],
};
```

----------------------------------------

TITLE: React Compiler-Optimized Component with Memoization
DESCRIPTION: The compiled version of the component that uses React compiler runtime to memoize calculations. It caches the result of 'bar()' when the inputs haven't changed, preventing unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-load-primitive-as-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const a = foo();

  const t0 = a[props.a] + 1;
  let t1;
  if ($[0] !== t0) {
    t1 = bar(t0);
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const b = t1;
  return b;
}
```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the React component using React's compiler runtime. It implements memoization and caching techniques to improve rendering performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-dont-memoize-array-with-capturing-map-after-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useState } from "react";
import { mutate } from "shared-runtime";

function Component(props) {
  const $ = _c(5);
  const x = [{ ...props.value }];
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  useEffect(_temp, t0);
  const onClick = () => {
    console.log(x.length);
  };

  let y;

  const t1 = x.map((item) => {
    y = item;
    return <span key={item.id}>{item.text}</span>;
  });
  const t2 = mutate(y);
  let t3;
  if ($[1] !== onClick || $[2] !== t1 || $[3] !== t2) {
    t3 = (
      <div onClick={onClick}>
        {t1}
        {t2}
      </div>
    );
    $[1] = onClick;
    $[2] = t1;
    $[3] = t2;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  return t3;
}
function _temp() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: { id: 0, text: "Hello!" } }],
  isComponent: true,
};
```

----------------------------------------

TITLE: Optimized JavaScript Function 'foo' with React Compiler
DESCRIPTION: This snippet shows the optimized 'foo' function, transformed by the React Compiler Runtime. It utilizes the `_c` function for memoization. The function checks if the input parameters have changed since the last execution. If they haven't, it returns the cached result; otherwise, it executes the function logic, caches the result, and returns it. The `FIXTURE_ENTRYPOINT` remains the same, pointing to this optimized `foo`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inverted-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c, d) {
  const $ = _c(5);
  let y;
  if ($[0] !== a || $[1] !== b || $[2] !== c || $[3] !== d) {
    y = [];
    bb0: if (a) {
      if (b) {
        y.push(c);
        break bb0;
      }

      y.push(d);
    }
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = d;
    $[4] = y;
  } else {
    y = $[4];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: The compiler-optimized version of the same component that adds memoization to improve performance. It uses a caching mechanism from react/compiler-runtime to avoid redundant calculations and object creations based on dependency tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-global-object.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, sum } from "shared-runtime";

// Check that we correctly resolve type and effect lookups on the javascript
// global object.
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.b) {
    t0 = identity(props.b);
    $[0] = props.b;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const neverAliasedOrMutated = t0;
  const primitiveVal1 = Math.max(props.a, neverAliasedOrMutated);

  const primitiveVal3 = globalThis.globalThis.NaN;

  sum(primitiveVal1, Infinity, primitiveVal3);
  let t1;
  if ($[2] !== primitiveVal1) {
    t1 = { primitiveVal1, primitiveVal2: Infinity, primitiveVal3 };
    $[2] = primitiveVal1;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1, b: 2 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Conditional Rendering with ReactForgetFeatureFlag in JavaScript
DESCRIPTION: This snippet conditionally defines the ErrorView component based on the isForgetEnabled_Fixtures flag. If enabled, the component uses a cached result for rendering with checksum verification. The snippet highlights advanced React feature flags and dynamic adjustments in rendering and exporting patterns.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/arrow-function-expr-gating-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
import { Stringify } from "shared-runtime";
const ErrorView = isForgetEnabled_Fixtures()
  ? (t0) => {
      const $ = _c(2);
      const { error } = t0;
      let t1;
      if ($[0] !== error) {
        t1 = <Stringify error={error} />;
        $[0] = error;
        $[1] = t1;
      } else {
        t1 = $[1];
      }
      return t1;
    }
  : ({ error, _retry }) => <Stringify error={error}></Stringify>;

export default ErrorView;

export const FIXTURE_ENTRYPOINT = {
  fn: eval("ErrorView"),
  params: [{}],
};

```

----------------------------------------

TITLE: Optimized React Component with Compiler-Generated Memo Blocks
DESCRIPTION: This snippet presents an optimized version of the 'MyApp' component with compiler-generated memo blocks. It uses the '_c' function from 'react/compiler-runtime' to create and manage memo blocks, ensuring proper dependency tracking and optimization of reactive and non-reactive variables.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-pruned-scope-leaks-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import invariant from "invariant";
import {
  makeObject_Primitives,
  mutate,
  sum,
  useIdentity,
} from "shared-runtime";

/**
 * Here, `z`'s original memo block is removed due to the inner hook call.
 * However, we also infer that `z` is non-reactive, so by default we would create
 * the memo block for `thing = [y, z]` as only depending on `y`.
 *
 * This could then mean that `thing[1]` and `z` may not refer to the same value,
 * since z recreates every time but `thing` doesn't correspondingly invalidate.
 *
 * The fix is to consider pruned memo block outputs as reactive, since they will
 * recreate on every render. This means `thing` depends on both y and z.
 */
function MyApp(t0) {
  const $ = _c(6);
  const { count } = t0;
  const z = makeObject_Primitives();
  const x = useIdentity(2);
  let t1;
  if ($[0] !== count || $[1] !== x) {
    t1 = sum(x, count);
    $[0] = count;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const y = t1;
  mutate(z);
  let t2;
  if ($[3] !== y || $[4] !== z) {
    t2 = [y, z];
    $[3] = y;
    $[4] = z;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const thing = t2;
  if (thing[1] !== z) {
    invariant(false, "oh no!");
  }
  return thing;
}

export const FIXTURE_ENTRYPOINT = {
  fn: MyApp,
  params: [{ count: 2 }],
  sequentialRenders: [{ count: 2 }, { count: 2 }, { count: 3 }],
};
```

----------------------------------------

TITLE: Compiled React Function with Caching
DESCRIPTION: Transformed version of the function using React compiler runtime utilities to implement caching mechanism for improved performance. Uses _c utility for managing cached values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-mutated-after-if-else-with-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c, d) {
  const $ = _c(2);
  someObj();
  let x;
  if ($[0] !== a) {
    if (a) {
      const y = someObj();
      const z = y;
      x = z;
    } else {
      x = someObj();
    }

    x.f = 1;
    $[0] = a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: Original Function Implementation in JavaScript
DESCRIPTION: A JavaScript function that creates an array and an object, establishes a reference, mutates the object, and returns it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const x = [];
  const y = {};
  y.x = x;
  mutate(y);
  return y;
}
```

----------------------------------------

TITLE: React Compiler-Transformed Component with Memoization
DESCRIPTION: The compiler-transformed version of the component with added memoization logic. It uses React's compiler runtime to cache the result of shallowCopy when props haven't changed, avoiding unnecessary computation on re-renders while maintaining the console logging operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/console-readonly.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { shallowCopy } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    t0 = shallowCopy(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;

  console.log(x);
  console.info(x);
  console.warn(x);
  console.error(x);
  console.trace(x);
  console.table(x);
  global.console.log(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1, b: 2 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Transformed Function with Renamed Label
DESCRIPTION: This code snippet shows the transformed version of the original function where the label name has been changed from 'label' to 'bb0'. The function maintains the same logic of breaking out of nested blocks when condition c is true, but uses a different label identifier.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/complex-while.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  bb0: if (a) {
    while (b) {
      if (c) {
        break bb0;
      }
    }
  }
  return c;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Importing and Defining Helper Functions for Fixtures
DESCRIPTION: Example showing how to import shared helper functions or define custom helpers within a fixture file. Custom helpers can use the "use no forget" directive to exempt them from transformation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/snap/src/sprout/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
// test.js
import { addOne } from 'shared-runtime';

function customHelper(val1, val2) {
  // This directive is important, as helper functions don't
  // always follow the rules of React.
  "use no forget";
  // ...
}

// ...
```

----------------------------------------

TITLE: Defining a Function with React Compiler Runtime
DESCRIPTION: This snippet defines an enhanced version of the `bar` function that integrates with React's compiler runtime. It uses a hook pattern to maintain state across invocations, checking if the input has changed and updating the output accordingly. The exported constant remains similar, providing a structure for taking parameters for tests.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-2-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function bar(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = [a];
    y = {};

    y = x[0][1];
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [["val1", "val2"]],
  isComponent: false,
};
```

----------------------------------------

TITLE: Initializing Conditional Dependency Promotion in React Hook
DESCRIPTION: A function that demonstrates runtime dependency tracking and conditional access promotion, using identity checks and nested object properties
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/promote-uncond.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function usePromoteUnconditionalAccessToDependency(props, other) {
  const x = {};
  x.a = props.a.a.a;
  if (identity(other)) {
    x.c = props.a.b.c;
  }
  return x;
}
```

LANGUAGE: javascript
CODE:
```
function usePromoteUnconditionalAccessToDependency(props, other) {
  const $ = _c(4);
  let x;
  if ($[0] !== other || $[1] !== props.a.a.a || $[2] !== props.a.b) {
    x = {};
    x.a = props.a.a.a;
    if (identity(other)) {
      x.c = props.a.b.c;
    }
    $[0] = other;
    $[1] = props.a.a.a;
    $[2] = props.a.b;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that initializes an array, performs mutation in a do-while loop, and returns the mutated array. The loop contains a break statement making it execute only once.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-early-unconditional-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [1, 2, 3];
  do {
    mutate(x);
    break;
  } while (props.cond);
  return x;
}
```

----------------------------------------

TITLE: Input React Component with Loop
DESCRIPTION: Initial implementation of a React component with a for loop and fixture setup for testing. The component includes a basic loop structure with props.count parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  for (let i = 0; i < props.count; i++) {
    return;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Optimizing Component Reactivity with React Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the previous component utilizing a React compiler runtime hook for reactivity. It includes logic for updating output based on changes to the input prop `cond`. The component retains its reactive nature and handles caching of values through compiler-specific constructs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-switch-case-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  bb0: switch (props.cond) {
    case true: {
      x = 1;
      break bb0;
    }
    case false: {
      x = 2;
      break bb0;
    }
    default: {
      x = 3;
    }
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { cond: true },
    { cond: true },
    { cond: false },
    { cond: false },
    { cond: true },
    { cond: false },
    { cond: true },
    { cond: false },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized Memoization
DESCRIPTION: The compiled version of the React component showing how the compiler transforms useMemo calls into an efficient caching system. It uses a cache array (_c2) to store dependencies and memoized values, implementing manual dependency checking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/existing-variables-with-c-name.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c2 } from "react/compiler-runtime";
import { useMemo, useState } from "react";
import { ValidateMemoization } from "shared-runtime";

function Component(props) {
  const $ = _c2(7);
  const [state] = useState(0);

  const c = state;
  const _c = c;
  const __c = _c;
  const c1 = __c;
  const $c = c1;
  let t0;
  let t1;
  if ($[0] !== $c) {
    t1 = [$c];
    $[0] = $c;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const array = t0;
  let t2;
  if ($[2] !== state) {
    t2 = [state];
    $[2] = state;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== array || $[5] !== t2) {
    t3 = <ValidateMemoization inputs={t2} output={array} />;
    $[4] = array;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}, {}],
};
```

----------------------------------------

TITLE: Traversing Tree to Find Element at Index N in React DevTools
DESCRIPTION: Completes the algorithm for finding the Nth element by traversing the tree starting from the first child of the containing root. It navigates by comparing weights until it finds the element at the desired index.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_11

LANGUAGE: javascript
CODE:
```
let currentElement = this._idToElement.get(firstChildID);
let currentWeight = rootWeight;
while (index !== currentWeight) {
  for (let i = 0; i < currentElement.children.length; i++) {
    const childID = currentElement.children[i];
    const child = this._idToElement.get(childID);
    const { weight } = child;
    if (index <= currentWeight + weight) {
      currentWeight++;
      currentElement = child;
      break;
    } else {
      currentWeight += weight;
    }
  }
}
```

----------------------------------------

TITLE: Compiler-Optimized React Hook Implementation
DESCRIPTION: The compiler-optimized version of the hook with memoization using an array cache ($). Includes checks to prevent unnecessary recreations of arrays and map entries.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/map-constructor.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

function useHook(t0) {
  const $ = _c(7);
  const { el1, el2 } = t0;
  let s;
  if ($[0] !== el1 || $[1] !== el2) {
    s = new Map();
    let t1;
    if ($[3] !== el1) {
      t1 = makeArray(el1);
      $[3] = el1;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    s.set(el1, t1);
    let t2;
    if ($[5] !== el2) {
      t2 = makeArray(el2);
      $[5] = el2;
      $[6] = t2;
    } else {
      t2 = $[6];
    }
    s.set(el2, t2);
    $[0] = el1;
    $[1] = el2;
    $[2] = s;
  } else {
    s = $[2];
  }
  return s.size;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ el1: 1, el2: "foo" }],
  sequentialRenders: [
    { el1: 1, el2: "foo" },
    { el1: 2, el2: "foo" },
  ],
};
```

----------------------------------------

TITLE: Defining a React Component with Compilation Mode Inference
DESCRIPTION: A React function component that is skipped during compilation because it doesn't call any hooks or use JSX. The '@compilationMode(infer)' directive instructs the compiler to infer how to handle this component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-skip-components-without-hooks-or-jsx.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
// This component is skipped bc it doesn't call any hooks or
// use JSX:
function Component(props) {
  return render();
}
```

----------------------------------------

TITLE: Initializing Reactive Component with Conditional Logic
DESCRIPTION: A React component that demonstrates complex reactivity through array mutations and nested control flow. Shows how React's compiler tracks reactive dependencies across different code paths and array manipulations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  // a and b are independent but their mutations are interleaved, so
  // they get grouped in a reactive scope. this means that a becomes
  // reactive since it will effectively re-evaluate based on a reactive
  // input
  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(10);

  // Downstream consumer of a, which initially seems non-reactive except
  // that a becomes reactive, per above
  const c = [a];

  let x;
  for (let i = 0; i < c[0][0]; i++) {
    x = 1;
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" value `c[0]` which becomes reactive via
  // being interleaved with `b`.
  // Therefore x should be treated as reactive too.
  return [x];
}
```

----------------------------------------

TITLE: React Compiler Runtime Memoized Function
DESCRIPTION: Enhanced function implementation using React compiler runtime for memoization, with conditional rendering and state caching
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-4-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function bar(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = [a];
    y = {};

    y = x[0].a[1];
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [{ a: ["val1", "val2"] }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Optimizations
DESCRIPTION: Compiled version of the React component with internal optimizations. Shows how useCallback is transformed and includes additional caching logic for rendered elements using compiler runtime utilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-call-second-function-which-captures-maybe-mutable-value-dont-preserve-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees:false @enableTransitivelyFreezeFunctionExpressions:false
import { useCallback } from "react";
import {
  identity,
  logValue,
  makeObject_Primitives,
  useHook,
} from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  const object = makeObject_Primitives();

  useHook();

  const log = () => {
    logValue(object);
  };

  const onClick = () => {
    log();
  };

  identity(object);
  let t0;
  if ($[0] !== onClick) {
    t0 = <div onClick={onClick} />;
    $[0] = onClick;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Initializing Memoized React Function Component with Array Mapping
DESCRIPTION: A React function component using compiler runtime optimization to memoize array mapping functions and prevent unnecessary re-renders
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback-cross-context.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function useFoo({arr1, arr2}) {
  const cb1 = e => arr1[0].value + e.value;
  const getArrMap1 = () => arr1.map(cb1);
  const cb2 = e => arr2[0].value + e.value;
  const getArrMap2 = () => arr1.map(cb2);
  return (
    <Stringify
      getArrMap1={getArrMap1}
      getArrMap2={getArrMap2}
      shouldInvokeFns={true}
    />
  );
}
```

----------------------------------------

TITLE: Optimizing useFoo for Performance in React
DESCRIPTION: The second implementation of the useFoo function adds optimizations using internal state to minimize recomputation. It maintains state across calls, using a symbol to handle early returns and manages inputs and outputs efficiently. Dependencies include 'react/compiler-runtime' for terms and identity function from 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/reduce-if-exhaustive-nonpoisoned-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(9);
  const { input, hasAB, returnNull } = t0;
  let t1;
  let x;
  if ($[0] !== hasAB || $[1] !== input.a || $[2] !== returnNull) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      if (!hasAB) {
        let t2;
        if ($[5] !== input.a) {
          t2 = identity(input.a);
          $[5] = input.a;
          $[6] = t2;
        } else {
          t2 = $[6];
        }
        x.push(t2);
        if (!returnNull) {
          t1 = null;
          break bb0;
        }
      } else {
        let t2;
        if ($[7] !== input.a.b) {
          t2 = identity(input.a.b);
          $[7] = input.a.b;
          $[8] = t2;
        } else {
          t2 = $[8];
        }
        x.push(t2);
      }
    }
    $[0] = hasAB;
    $[1] = input.a;
    $[2] = returnNull;
    $[3] = t1;
    $[4] = x;
  } else {
    t1 = $[3];
    x = $[4];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { b: 1 }, hasAB: false, returnNull: false }],
};

```

----------------------------------------

TITLE: Using React Compiler Runtime in Hoisting Function
DESCRIPTION: This snippet incorporates React's compiler runtime to manage memoization and variable scoping more dynamically by checking for a cache sentinel. It defines a hoisting function that relies on React's internal caching mechanism to optimize performance while maintaining variable isolation. Dependencies: 'react/compiler-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-const-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function hoisting() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const qux = () => {
      let result;

      result = foo();
      return result;
    };

    const foo = () => bar + baz;

    const bar = 3;
    const baz = 2;
    t0 = qux();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Optimized Counter Function in JavaScript
DESCRIPTION: An optimized version of the counter function that removes the unnecessary x variable. The function increments only the y variable until reaching the maximum value specified in props, then returns y.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dce-loop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let y = 0;
  while (y < props.max) {
    y++;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{ max: 10 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Counter Component
DESCRIPTION: The compiled version of the counter component showing how React transforms the code with memoization, compiler runtime imports, and optimization techniques. Includes implementation of memo cache sentinel and state management.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/arrow-expr-directive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  "use strict";
  const $ = _c(3);

  const [count, setCount] = React.useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      "worklet";

      setCount(_temp);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const update = t0;
  let t1;
  if ($[1] !== count) {
    t1 = <button onClick={update}>{count}</button>;
    $[1] = count;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
function _temp(count_0) {
  return count_0 + 1;
}
```

----------------------------------------

TITLE: Setting up and running React SSR fixtures in development mode
DESCRIPTION: Commands to set up and run the server-side rendering fixtures in development mode with hot reloading after building React locally.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr2/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
cd fixtures/ssr2
yarn
yarn start
```

----------------------------------------

TITLE: Compiled React.forwardRef Output
DESCRIPTION: Compiled version of the component showing React's internal caching mechanism using Symbol.for() and compiler runtime utilities. Implements memo caching for the div element.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-function-forwardRef.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
React.forwardRef((props) => {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
});
```

----------------------------------------

TITLE: Exporting a Function Configuration Object
DESCRIPTION: This code exports a constant named `FIXTURE_ENTRYPOINT`, which is an object. This object contains metadata about the function `foo`, including the function itself (`fn`), an array of parameter names (`params`), and a flag indicating that it's a component (`isComponent`). This configuration allows the function to be easily integrated and tested within a React environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Original JavaScript Function
DESCRIPTION: This snippet presents the original JavaScript function `foo`. It initializes three objects (a, b, c), reassigns them in a circular fashion (a = b; b = c; c = a), then calls `mutate` with `a` and `b`. Finally, it returns `c`. The purpose is to illustrate a scenario where the React compiler might apply optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-alias.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function mutate() {}
function foo() {
  let a = {};
  let b = {};
  let c = {};
  a = b;
  b = c;
  c = a;
  mutate(a, b);
  return c;
}
```

----------------------------------------

TITLE: Advanced React Component Export with Memoization
DESCRIPTION: In this JavaScript snippet, a React component is defined using an imported compiler runtime function '_c'. It checks if memoization is necessary, reuses existing values or initializes them, and returns the values. It exports the component configuration for external use, with parameters and component identity included. This setup facilitates advanced rendering logic within React applications.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-arrayexpression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [1, 2];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Optimizations
DESCRIPTION: Compiled version of the React component showing the implementation of memoization caching. Uses Symbol.for('react.memo_cache_sentinel') to check and maintain cached values for refs and callbacks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-multiple-callbacks-modifying-same-ref-preserve-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees
import { useCallback, useRef } from "react";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { inner: null };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const ref = useRef(t0);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (event) => {
      ref.current.inner = event.target.value;
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const onChange = t1;
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      ref.current.inner = null;
    };
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const onReset = t2;
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = <input onChange={onChange} onReset={onReset} />;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: This snippet shows the compiled output of the `f` component using React's compiler runtime. It uses `_c` from `react/compiler-runtime` to memoize the rendered `div` element. The component efficiently reuses the memoized element on subsequent renders unless the input dependencies change. `useReducer` hook is still used.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useReducer-returned-dispatcher-is-non-reactive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useReducer } from "react";

function f() {
  const $ = _c(1);
  const [, dispatch] = useReducer();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const onClick = () => {
      dispatch();
    };

    t0 = <div onClick={onClick} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: [],
  isComponent: true,
};

```

----------------------------------------

TITLE: Creating a Conditional Object Component in React (Input Version)
DESCRIPTION: A React component that creates an object with the makeObject_Primitives utility and conditionally sets its value property based on props.cond. The component returns an object with either a value of 1 or the provided props.value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/object-mutated-in-consequent-alternate-both-return.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
import {makeObject_Primitives} from 'shared-runtime';

function Component(props) {
  const object = makeObject_Primitives();
  if (props.cond) {
    object.value = 1;
    return object;
  } else {
    object.value = props.value;
    return object;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: false, value: [0, 1, 2]}],
};
```

----------------------------------------

TITLE: Unconditional Dependency in Switch Statement Input - JavaScript
DESCRIPTION: A test case function demonstrating props.a.b as an unconditional dependency accessed in all branches of a switch statement. This input code will be processed by React's compiler to optimize reactive scoping.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-exhaustive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths

import {identity} from 'shared-runtime';

function useCondDepInSwitch(props, other) {
  const x = {};
  switch (identity(other)) {
    case 1:
      x.a = props.a.b;
      break;
    case 2:
      x.b = props.a.b;
      break;
    default:
      x.c = props.a.b;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInSwitch,
  params: [{a: {b: 2}}, 2],
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization in JavaScript
DESCRIPTION: By importing a compiler-runtime utility, this snippet applies memoization to optimize performance. It checks cache using react.memo_cache_sentinel and updates it with object data. Dependencies involve 'react/compiler-runtime', and the function effectively caches object creation to avoid unnecessary rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/call-args-destructuring-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = makeObject();
    x.foo(([x] = makeObject()));
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

```

----------------------------------------

TITLE: Compiled and Memoized Array Manipulation Function in JavaScript
DESCRIPTION: This is the compiled version of the useFoo function, optimized by the React compiler. It implements memoization to avoid unnecessary recalculations and preserves the order of evaluation. The function uses a closure array for caching previous results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/evaluation-order-mutate-call-after-dependency-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * Test that we preserve order of evaluation on the following case scope@0
 * ```js
 * // simplified HIR
 * scope@0
 *    ...
 *    $0 = arr.length
 *    $1 = arr.push(...)
 *
 * scope@1 <-- here we should depend on $0 (the value of the property load before the
 *             mutable call)
 *   [$0, $1]
 * ```
 */
function useFoo(source) {
  const $ = _c(6);
  let t0;
  let t1;
  if ($[0] !== source) {
    const arr = [1, 2, 3, ...source];
    t0 = arr.length;
    t1 = arr.push(0);
    $[0] = source;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t0 || $[4] !== t1) {
    t2 = [t0, t1];
    $[3] = t0;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [[5, 6]],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler-Runtime Caching
DESCRIPTION: This snippet shows an optimized version of the 'foo' function using React's compiler-runtime. It implements caching mechanisms to avoid unnecessary recalculations and re-renders, improving performance for repeated calls with the same parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/escape-analysis-jsx-child.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(9);
  let x;
  if ($[0] !== a || $[1] !== b || $[2] !== c) {
    x = [];
    if (a) {
      let y;
      if ($[4] !== b || $[5] !== c) {
        y = [];
        if (b) {
          y.push(c);
        }
        $[4] = b;
        $[5] = c;
        $[6] = y;
      } else {
        y = $[6];
      }
      let t0;
      if ($[7] !== y) {
        t0 = <div>{y}</div>;
        $[7] = y;
        $[8] = t0;
      } else {
        t0 = $[8];
      }
      x.push(t0);
    }
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized useHook Implementation with Memoization in JavaScript
DESCRIPTION: This snippet presents an optimized version of the 'useHook' function with memoization. It uses the React compiler runtime for caching and only recalculates when input parameters change, improving performance for repeated renders with the same inputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-add-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

function useHook(t0) {
  const $ = _c(5);
  const { el1, el2 } = t0;
  let s;
  if ($[0] !== el1 || $[1] !== el2) {
    s = new Set();
    const arr = makeArray(el1);
    s.add(arr);

    arr.push(el2);
    let t1;
    if ($[3] !== el2) {
      t1 = makeArray(el2);
      $[3] = el2;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    s.add(t1);
    $[0] = el1;
    $[1] = el2;
    $[2] = s;
  } else {
    s = $[2];
  }
  return s.size;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ el1: 1, el2: "foo" }],
  sequentialRenders: [
    { el1: 1, el2: "foo" },
    { el1: 2, el2: "foo" },
  ],
};
```

----------------------------------------

TITLE: Compiled React Runtime Version
DESCRIPTION: Compiled version using React's compiler runtime that implements memoization using a Symbol sentinel. The function caches its result and only recomputes when necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/chained-assignment-expressions.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let z;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = { x: 0 };
    const y = { z: 0 };
    z = { z: 0 };
    x.x = x.x + (y.y = y.y * 1);
    z.z = z.z + (y.y = y.y * (x.x = x.x & 3));
    $[0] = z;
  } else {
    z = $[0];
  }
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Code with Memoization and Caching
DESCRIPTION: This snippet shows the compiled version of the previous code, including React compiler optimizations. It introduces memoization using Symbol.for("react.memo_cache_sentinel") and caches the result of the testFunction.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-lifetime-loops.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function mutate(x, y) {
  "use no forget";
  if (x != null) {
    x.value = (x.value ?? 0) + 1;
  }
  if (y != null) {
    y.value = (y.value ?? 0) + 1;
  }
}
function cond(x) {
  "use no forget";
  return x.value > 5;
}

function testFunction(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    let a = {};
    let b = {};
    let c = {};
    let d = {};
    while (true) {
      const z = a;
      a = b;
      b = c;
      c = d;
      d = z;
      mutate(a, b);
      if (cond(a)) {
        break;
      }
    }
    if (a) {
    }
    if (b) {
    }
    if (c) {
    }
    if (d) {
    }

    mutate(d, null);
    t0 = { a, b, c, d };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: testFunction,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiler-Transformed Component with Memoization
DESCRIPTION: The React compiler-transformed version of the component that implements memoization. It uses a cache sentinel to determine if object creation is needed or if a previously cached result can be returned.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/alias-nested-member-path-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const z = [];
    const y = {};
    y.z = z;
    x = {};
    x.y = y;
    mutate(x.y.z);
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiler-optimized version of the React component that implements automatic memoization for the context-dependent callback and rendered elements. Uses a closure array ($) to store and compare memoized values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-read-context-in-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createContext, useContext } from "react";

const FooContext = createContext({ current: null });

function Component(props) {
  const $ = _c(5);
  const foo = useContext(FooContext);
  let t0;
  if ($[0] !== foo.current) {
    t0 = () => {
      console.log(foo.current);
    };
    $[0] = foo.current;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onClick = t0;
  let t1;
  if ($[2] !== onClick || $[3] !== props.children) {
    t1 = <div onClick={onClick}>{props.children}</div>;
    $[2] = onClick;
    $[3] = props.children;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ children: <div>Hello</div> }],
};
```

----------------------------------------

TITLE: Optimized Function with React Compiler Runtime Memoization
DESCRIPTION: Enhanced version of the function using React's compiler runtime for caching and optimization, with conditional re-computation and state tracking
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function bar(a, b) {
  const $ = _c(3);
  let y;
  if ($[0] !== a || $[1] !== b) {
    const x = [a, b];
    y = {};
    let t;
    t = {};
    const f0 = function () {
      y = x[0][1];
      t = x[1][0];
    };

    f0();
    $[0] = a;
    $[1] = b;
    $[2] = y;
  } else {
    y = $[2];
  }
  return y;
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Basic React component that conditionally creates an object with a session ID using getNumber() function. The component takes props with a condition flag and returns the created object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-nested-scopes.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {getNumber} = require('shared-runtime');

function Component(props) {
  let x;
  // Two scopes: one for `getNumber()`, one for the object literal.
  // Neither has dependencies so they should merge
  if (props.cond) {
    x = {session_id: getNumber()};
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true}],
};
```

----------------------------------------

TITLE: React Compiler-Optimized Component Implementation in JavaScript
DESCRIPTION: The transformed version of the component function using React compiler runtime. It implements memoization through the _c helper function to avoid recreating objects when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let t0;
  if ($[0] !== a) {
    t0 = { a: { a } };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Component with Memoization
DESCRIPTION: This code shows the compiled React component with memoization applied using `react/compiler-runtime`. The `_c` function is used to cache the result of `obj.method()`, preventing redundant computations during re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-method-shorthand.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const obj = {
      method() {
        return 1;
      },
    };

    t0 = obj.method();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ x: 1 }, { a: 2 }, { b: 2 }],
};

```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: This snippet shows the compiled version of the React component. It uses the `react/compiler-runtime` to optimize the component's rendering. The compiled code includes memoization and caching of the onClick handler and the JSX elements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-property-in-callback-passed-to-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender
import { useRef } from "react";

function Component() {
  const $ = _c(2);
  const ref = useRef(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      if (ref.current !== null) {
        ref.current.value = "";
      }
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onClick = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (
      <>
        <input ref={ref} />
        <button onClick={onClick} />
      </>
    );
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]
};

```

----------------------------------------

TITLE: React Compiler Transformed Version with Memoization
DESCRIPTION: The compiled version of the useFoo hook that implements memoization to avoid recalculation when inputs haven't changed. It uses the React compiler runtime functions to store and retrieve previous values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/break-in-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(t0) {
  const $ = _c(3);
  const { obj, objIsNull } = t0;
  let x;
  if ($[0] !== obj || $[1] !== objIsNull) {
    x = [];
    bb0: {
      if (objIsNull) {
        break bb0;
      }

      x.push(obj.a);
    }
    $[0] = obj;
    $[1] = objIsNull;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ obj: null, objIsNull: true }],
  sequentialRenders: [
    { obj: null, objIsNull: true },
    { obj: { a: 2 }, objIsNull: false },
    // check we preserve nullthrows
    { obj: { a: undefined }, objIsNull: false },
    { obj: undefined, objIsNull: false },
    { obj: { a: undefined }, objIsNull: false },
  ],
};
```

----------------------------------------

TITLE: React Component Compiled Output
DESCRIPTION: Compiled version of the React component with added memoization logic. Uses compiler runtime utilities and implements caching mechanism to avoid unnecessary re-renders when props.value hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutation-during-jsx-construction.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, mutate, mutateAndReturnNewValue } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  let element;
  if ($[0] !== props.value) {
    const key = {};

    element = <div key={mutateAndReturnNewValue(key)}>{props.value}</div>;

    mutate(key);
    $[0] = props.value;
    $[1] = element;
  } else {
    element = $[1];
  }
  return element;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Compiling React Component with Optimized Caching in JavaScript
DESCRIPTION: This snippet is an optimized version of a React component using compiler runtime optimizations. It implements caching mechanisms to store properties and rendered outputs to minimize recalculations. The component still retrieves a nested group label but uses indexed caching for performance improvements. Dependencies include React and compiler-runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/idx-no-outlining.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @customMacros(idx)

function Component(props) {
  var _ref2;
  const $ = _c(4);
  let t0;
  if ($[0] !== props) {
    var _ref;

    t0 =
      (_ref = props) != null
        ? (_ref = _ref.group) != null
          ? _ref.label
          : _ref
        : _ref;
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const groupName = t0;
  let t1;
  if ($[2] !== groupName) {
    t1 = <div>{groupName}</div>;
    $[2] = groupName;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};

```

----------------------------------------

TITLE: React Compiler Runtime Memoization Implementation
DESCRIPTION: Enhanced version of the function with React compiler runtime memoization and caching mechanism, using _c for tracking object references
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function TestDepsSubpathOrder1(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.a) {
    x = {};
    x.b = props.a.b;
    x.a = props.a;
    x.c = props.a.b.c;
    $[0] = props.a;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}
```

----------------------------------------

TITLE: Optimized React Component 'Foo' with Memoization
DESCRIPTION: This snippet shows the compiled and optimized version of the 'Foo' component. It uses the React compiler runtime to implement memoization, caching the result of the component's computation for improved performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-array-access-member-expr-captured.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_NUMBER0, invoke } from "shared-runtime";

function Foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [{ value: 0 }, { value: 1 }, { value: 2 }];

    const foo = () => x[CONST_NUMBER0].value;

    t0 = invoke(foo);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Advanced Stringify Component Usage with Conditional Renders - JavaScript
DESCRIPTION: This snippet features an advanced implementation of the Stringify component within a React function, useFoo, which employs conditional rendering based on input properties. Dependencies include react/compiler-runtime and shared-runtime. It requires structured inputs to avoid TypeErrors and manages state updates for efficient rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-hoisted.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```

import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR

import { Stringify } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(2);
  const { a } = t0;
  let t1;
  if ($[0] !== a.b.c) {
    t1 = <Stringify fn={() => a.b.c} shouldInvokeFns={true} />;
    $[0] = a.b.c;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: null }],
  sequentialRenders: [{ a: null }, { a: { b: { c: 4 } } }],
};

```

----------------------------------------

TITLE: React Compiler-Optimized Hook with Memoization
DESCRIPTION: The compiler-transformed version of the useFoo hook that implements memoization using React's compiler runtime. It tracks previous values of x, y, and z and returns a cached object when inputs haven't changed, avoiding unnecessary object creation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-phi-nodes.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(setOne) {
  const $ = _c(4);
  let x;
  let y;
  let z;
  if (setOne) {
    x = y = z = 1;
  } else {
    x = 2;
    y = 3;
    z = 5;
  }
  let t0;
  if ($[0] !== x || $[1] !== y || $[2] !== z) {
    t0 = { x, y, z };
    $[0] = x;
    $[1] = y;
    $[2] = z;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [true],
};
```

----------------------------------------

TITLE: React Compiler Transformed Component with Memoization
DESCRIPTION: The transformed version of the component uses React compiler-runtime for memoization. It introduces a cache mechanism with sentinel values to avoid recalculating values when the component re-renders, optimizing performance by preserving references.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/chained-assignment-context-variable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

function Component() {
  const $ = _c(3);
  let x;
  let y;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    y = x = {};

    const foo = () => {
      x = makeArray();
    };

    foo();
    $[0] = x;
    $[1] = y;
  } else {
    x = $[0];
    y = $[1];
  }
  let t0;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [y, x];
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This code shows the compiled version of the React component, utilizing `react/compiler-runtime` for memoization. It introduces variables and conditional logic to cache and reuse values based on prop changes and previous computations. The component uses a mutable array `$` to store intermediate values for memoization, improving performance by avoiding unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-object-expression-computed-key-modified-during-after-construction-hoisted-sequence-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, mutate } from "shared-runtime";

/**
 * Bug: copy of error.todo-object-expression-computed-key-modified-during-after-construction-sequence-expr
 * with the mutation hoisted to a named variable instead of being directly
 * inlined into the Object key.
 *
 * Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok) [{"[object Object]":[42]},{"wat0":"joe","wat1":"joe"}]
 *   [{"[object Object]":[42]},{"wat0":"joe","wat1":"joe"}]
 *   Forget:
 *   (kind: ok) [{"[object Object]":[42]},{"wat0":"joe","wat1":"joe"}]
 *   [{"[object Object]":[42]},{"wat0":"joe","wat1":"joe","wat2":"joe"}]
 */
function Component(props) {
  const $ = _c(8);
  let key;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    key = {};
    t0 = (mutate(key), key);
    $[0] = key;
    $[1] = t0;
  } else {
    key = $[0];
    t0 = $[1];
  }
  const tmp = t0;
  let t1;
  if ($[2] !== props.value) {
    t1 = identity([props.value]);
    $[2] = props.value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== t1) {
    t2 = { [tmp]: t1 };
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const context = t2;

  mutate(key);
  let t3;
  if ($[6] !== context) {
    t3 = [context, key];
    $[6] = context;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
  sequentialRenders: [{ value: 42 }, { value: 42 }],
};

```

----------------------------------------

TITLE: React Compiler Transformed JavaScript Function
DESCRIPTION: The compiled version of the same function after React's compiler processes it. It uses the compiler runtime, implements memoization with Symbol.for(), and optimizes the code by removing unused variables and simplifying the logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for-of.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(cond) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const items = t0;
  for (const item of items) {
    if (cond) {
    }
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Transformed JavaScript Function
DESCRIPTION: This snippet presents the transformed JavaScript function `foo`, presumably by the React compiler. It utilizes the `_c` function from `react/compiler-runtime` which likely implements a memoization cache.  The function checks if the cache is empty, and if so, executes the original logic while storing the results in the cache; otherwise, it retrieves the results from the cache. The `mutate` function remains unchanged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function mutate() {}
function foo() {
  const $ = _c(2);
  let a;
  let c;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    let b = {};
    c = {};
    a = b;
    b = c;
    c = a;
    mutate(a, b);
    $[0] = c;
    $[1] = a;
  } else {
    c = $[0];
    a = $[1];
  }
  return c;
}
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This is the compiled version of the `Foo` component, leveraging the `react/compiler-runtime` for optimization. It uses the `_c` function for memoization of intermediate values based on prop changes. It checks if `props.a` has changed and only re-calculates `bar(props.a)` if necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/optional-member-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.a) {
    t0 = bar(props.a);
    $[0] = props.a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  const y = x?.b;

  const z = useBar(y);
  return z;
}
```

----------------------------------------

TITLE: Optimized Memoization in React with useIdentity
DESCRIPTION: This snippet provides an optimized version of the Foo component by caching state transitions using a compiler runtime. Through memoization techniques, the component enhances performance by reusing previously computed values. It requires react/compiler-runtime and takes an object with val1 as a parameter. It returns a JSX element, ensuring minimized component re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-call-freezes-captured-memberexpr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useIdentity, Stringify, identity } from "shared-runtime";

function Foo(t0) {
  const $ = _c(9);
  const { val1 } = t0;
  let t1;
  if ($[0] !== val1) {
    t1 = { inner: val1 };
    $[0] = val1;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  let t2;
  if ($[2] !== x.inner) {
    t2 = () => x.inner;
    $[2] = x.inner;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const cb = useIdentity(t2);
  let t3;
  if ($[4] !== x) {
    t3 = identity(x);
    $[4] = x;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const copy = t3;
  let t4;
  if ($[6] !== cb || $[7] !== copy) {
    t4 = <Stringify copy={copy} cb={cb} shouldInvokeFns={true} />;
    $[6] = cb;
    $[7] = copy;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ val1: 1 }],
  sequentialRenders: [{ val1: 1 }, { val1: 1 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Transformations
DESCRIPTION: The compiled output of the test component showing how React's compiler transforms useMemo calls into explicit cache checks using Symbol.for("react.memo_cache_sentinel"). This demonstrates the internal implementation of React's memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fast-refresh-dont-refresh-const-changes-prod.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
import { useEffect, useMemo, useState } from "react";
import { ValidateMemoization } from "shared-runtime";

let pretendConst = 0;

function unsafeResetConst() {
  pretendConst = 0;
}

function unsafeUpdateConst() {
  pretendConst += 1;
}

function Component() {
  const $ = _c(2);
  useState(_temp);

  unsafeUpdateConst();
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [{ pretendConst }];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  t0 = t1;
  const value = t0;
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = <ValidateMemoization inputs={[]} output={value} />;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  return t2;
}
function _temp() {
  unsafeResetConst();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Enhanced Component with React Compiler Runtime - JavaScript
DESCRIPTION: This snippet enhances the previous React component with compiler runtime functionalities to manage state. It checks for changes in props to decide whether to mutate an internal state. The 'props' parameter retains the same functionality, being critical for determining if a re-render is necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-object-captured-with-reactive-mutated.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { mutate } = require("shared-runtime");

function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.y) {
    const x = {};
    const y = props.y;
    const z = [x, y];
    mutate(z);

    t0 = [x];
    $[0] = props.y;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ y: 42 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Inferred Effect Dependencies
DESCRIPTION: The compiled output of the PrunedNonReactive component after React compiler has processed it. The compiler has transformed the code to properly handle the effect dependencies, adding obj.value as a dependency and implementing memoization for the effect callback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/pruned-nonreactive-obj.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useIdentity, mutate, makeObject } from "shared-runtime";
import { useEffect } from "react";

/**
 * When a semantically non-reactive value has a pruned scope (i.e. the object
 * identity becomes reactive, but the underlying value it represents should be
 * constant), the compiler can choose to either
 * - add it as a dependency (and rerun the effect)
 * - not add it as a dependency
 *
 * We keep semantically non-reactive values in both memo block and effect
 * dependency arrays to avoid versioning invariants e.g. `x !== y.aliasedX`.
 * ```js
 * function Component() {
 *   // obj is semantically non-reactive, but its memo scope is pruned due to
 *   // the interleaving hook call
 *   const obj = {};
 *   useHook();
 *   write(obj);
 *
 *   const ref = useRef();
 *
 *   // this effect needs to be rerun when obj's referential identity changes,
 *   // because it might alias obj to a useRef / mutable store.
 *   useEffect(() => ref.current = obj, ???);
 *
 *   // in a custom hook (or child component), the user might expect versioning
 *   // invariants to hold
 *   useHook(ref, obj);
 * }
 *
 * // defined elsewhere
 * function useHook(someRef, obj) {
 *   useEffect(
 *     () => assert(someRef.current === obj),
 *     [someRef, obj]
 *   );
 * }
 * ```
 */
function PrunedNonReactive() {
  const $ = _c(2);
  const obj = makeObject();
  useIdentity(null);
  mutate(obj);
  let t0;
  if ($[0] !== obj.value) {
    t0 = () => print(obj.value);
    $[0] = obj.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  useEffect(t0, [obj.value]);
}
```

----------------------------------------

TITLE: Compiled React Component Definition
DESCRIPTION: This code shows the compiled version of the `Component` after it has been processed by the React compiler. It uses `_c` from `react/compiler-runtime` to create a cache for the `div` element. It also calls `useCustomHook` with the string "hello".
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_5

LANGUAGE: javascript
CODE:
```
function Component() {
  const $ = _c(1);
  useCustomHook("hello");
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div>Hello</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled React Component with Cache Optimization
DESCRIPTION: Compiled version of the React component showing cache implementation details. Includes optimization logic for preventing unnecessary recalculations and managing component state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-reordering-depslist-controlflow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import { Stringify } from "shared-runtime";

function Foo(t0) {
  const $ = _c(9);
  const { arr1, arr2, foo } = t0;
  let t1;
  let val1;
  if ($[0] !== arr1 || $[1] !== arr2 || $[2] !== foo) {
    const x = [arr1];

    let y;
    y = [];
    let t2;
    let t3;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
      t3 = { x: 2 };
      $[5] = t3;
    } else {
      t3 = $[5];
    }
    t2 = t3;
    val1 = t2;

    foo ? (y = x.concat(arr2)) : y;
    t1 = (() => [y])();
    $[0] = arr1;
    $[1] = arr2;
    $[2] = foo;
    $[3] = t1;
    $[4] = val1;
  } else {
    t1 = $[3];
    val1 = $[4];
  }
  const val2 = t1;
  let t2;
  if ($[6] !== val1 || $[7] !== val2) {
    t2 = <Stringify val1={val1} val2={val2} />;
    $[6] = val1;
    $[7] = val2;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ arr1: [1, 2], arr2: [3, 4], foo: true }],
  sequentialRenders: [
    { arr1: [1, 2], arr2: [3, 4], foo: true },
    { arr1: [1, 2], arr2: [3, 4], foo: false },
  ],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows an optimized version of the 'useFoo' component using memoization techniques. It imports a compiler runtime function and implements caching logic to avoid unnecessary recomputation of nested functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rename-source-variables-nested-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableChangeVariableCodegen
import { identity } from "shared-runtime";

const $ = "module_$";
const t0 = "module_t0";
const c_0 = "module_c_0";
function useFoo(props) {
  const $0 = _c(4);
  const c_00 = $0[0] !== props.value;
  let t1;
  if (c_00) {
    t1 = () => {
      const b = () => {
        const c = () => {
          console.log($);
          console.log(t0);
          console.log(c_0);
          return identity(props.value);
        };
        return c;
      };
      return b;
    };
    $0[0] = props.value;
    $0[1] = t1;
  } else {
    t1 = $0[1];
  }
  const a = t1;
  const c_2 = $0[2] !== a;
  let t2;
  if (c_2) {
    t2 = a()()();
    $0[2] = a;
    $0[3] = t2;
  } else {
    t2 = $0[3];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: React Compiler Runtime Optimized Object Processing
DESCRIPTION: Compiled version of the useFoo function with added memoization and runtime optimization using React compiler runtime. Includes dynamic caching and conditional value extraction.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-maybe-null-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useFoo(maybeNullObject) {
  const $ = _c(4);
  let y;
  if ($[0] !== maybeNullObject) {
    y = [];
    try {
      let t0;
      if ($[2] !== maybeNullObject.value.inner) {
        t0 = identity(maybeNullObject.value.inner);
        $[2] = maybeNullObject.value.inner;
        $[3] = t0;
      } else {
        t0 = $[3];
      }
      y.push(t0);
    } catch {
      y.push("null");
    }
    $[0] = maybeNullObject;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}
```

----------------------------------------

TITLE: Optimizing React Component with Memoization and Compiler Runtime
DESCRIPTION: This snippet shows an optimized version of the Component using React's compiler runtime for memoization. It caches rendered content based on props to avoid unnecessary re-renders, improving performance for repeated renders with the same props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-loop-with-value-block-initializer.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const TOTAL = 10;
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.items || $[1] !== props.start) {
    const items = [];
    for (let i = props.start ?? 0; i < props.items.length; i++) {
      const item = props.items[i];
      items.push(<div key={item.id}>{item.value}</div>);
    }

    t0 = <div>{items}</div>;
    $[0] = props.items;
    $[1] = props.start;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      start: null,
      items: [
        { id: 0, value: "zero" },
        { id: 1, value: "one" },
      ],
    },
  ],

  sequentialRenders: [
    {
      start: 1,
      items: [
        { id: 0, value: "zero" },
        { id: 1, value: "one" },
      ],
    },
    {
      start: 2,
      items: [
        { id: 0, value: "zero" },
        { id: 1, value: "one" },
      ],
    },
    {
      start: 0,
      items: [
        { id: 0, value: "zero" },
        { id: 1, value: "one" },
        { id: 2, value: "two" },
      ],
    },
    {
      start: 1,
      items: [
        { id: 0, value: "zero" },
        { id: 1, value: "one" },
        { id: 2, value: "two" },
      ],
    },
  ],
};
```

----------------------------------------

TITLE: Defining React Component with Mathematical Operations in JavaScript
DESCRIPTION: This snippet defines a React component that uses the Stringify component to display an array of values resulting from various mathematical and bitwise operations. It demonstrates operations like bitwise OR, AND, XOR, left shift, right shift, unsigned right shift, exponentiation, and modulus.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-bit-ops.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function foo() {
  return (
    <Stringify
      value={[
        123.45 | 0,
        123.45 & 0,
        123.45 ^ 0,
        123 << 0,
        123 >> 0,
        123 >>> 0,
        123.45 | 1,
        123.45 & 1,
        123.45 ^ 1,
        123 << 1,
        123 >> 1,
        123 >>> 1,
        3 ** 2,
        3 ** 2.5,
        3.5 ** 2,
        2 ** (3 ** 0.5),
        4 % 2,
        4 % 2.5,
        4 % 3,
        4.5 % 2,
      ]}
    />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiler Transformation of Effect with Dynamic Ref Dependency - JavaScript
DESCRIPTION: This is the React Compiler-transformed version of the `Component`. It uses the `_c` helper for state caching. The initial values for `useRef` might be cached. The compiler analyzes the usage of `derived` within the effect callback and infers `derived` as a dependency for `useEffect`, ensuring the effect is re-run only when the specific ref assigned to `derived` changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-ref-ternary.expect.md#_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useRef, useEffect } from "react";
import { print, mutate } from "shared-runtime";

function Component(t0) {
  const $ = _c(4);
  const { cond } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const arr = useRef(t1);
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = [];
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const other = useRef(t2);

  const derived = cond ? arr : other;
  let t3;
  if ($[2] !== derived) {
    t3 = () => {
      mutate(derived.current);
      print(derived.current);
    };
    $[2] = derived;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  useEffect(t3, [derived]);
  return arr;
}
```

----------------------------------------

TITLE: Optimized React Component with Memo Caching
DESCRIPTION: This snippet shows an optimized version of the React component using memo caching. It imports a compiler runtime function and implements caching for the onClick handler and the rendered JSX.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-mutating-ref-in-callback-passed-to-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validateRefAccessDuringRender
import { useRef } from "react";

function Component() {
  const $ = _c(2);
  const ref = useRef(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      if (ref.current !== null) {
        ref.current = "";
      }
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onClick = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (
      <>
        <input ref={ref} />
        <button onClick={onClick} />
      </>
    );
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Components with Memoization using React Compiler Runtime
DESCRIPTION: This snippet shows the compiled version of the four React components using React's compiler runtime. It demonstrates how the components are optimized for performance with memoization techniques, including the use of a cache array and early return checks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conditional-early-return.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; /**
 * props.b does *not* influence `a`
 */
function ComponentA(props) {
  const $ = _c(5);
  let a_DEBUG;
  let t0;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.d) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      a_DEBUG = [];
      a_DEBUG.push(props.a);
      if (props.b) {
        t0 = null;
        break bb0;
      }

      a_DEBUG.push(props.d);
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.d;
    $[3] = a_DEBUG;
    $[4] = t0;
  } else {
    a_DEBUG = $[3];
    t0 = $[4];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return a_DEBUG;
}

/**
 * props.b *does* influence `a`
 */
function ComponentB(props) {
  const $ = _c(5);
  let a;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d
  ) {
    a = [];
    a.push(props.a);
    if (props.b) {
      a.push(props.c);
    }

    a.push(props.d);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = a;
  } else {
    a = $[4];
  }
  return a;
}

/**
 * props.b *does* influence `a`, but only in a way that is never observable
 */
function ComponentC(props) {
  const $ = _c(6);
  let a;
  let t0;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d
  ) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      a = [];
      a.push(props.a);
      if (props.b) {
        a.push(props.c);
        t0 = null;
        break bb0;
      }

      a.push(props.d);
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = a;
    $[5] = t0;
  } else {
    a = $[4];
    t0 = $[5];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return a;
}

/**
 * props.b *does* influence `a`
 */
function ComponentD(props) {
  const $ = _c(6);
  let a;
  let t0;
  if (
    $[0] !== props.a ||
    $[1] !== props.b ||
    $[2] !== props.c ||
    $[3] !== props.d
  ) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      a = [];
      a.push(props.a);
      if (props.b) {
        a.push(props.c);
        t0 = a;
        break bb0;
      }

      a.push(props.d);
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.c;
    $[3] = props.d;
    $[4] = a;
    $[5] = t0;
  } else {
    a = $[4];
    t0 = $[5];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: ComponentA,
  params: [{ a: 1, b: false, d: 3 }],
};
```

----------------------------------------

TITLE: Compiler-Optimized React Component
DESCRIPTION: The compiler-transformed version of the React component with memoization optimizations. Uses array-based caching to prevent unnecessary recalculations and re-renders of values and components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useContext-read-context-in-callback-if-condition.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createContext, useContext } from "react";
import { Stringify } from "shared-runtime";

const FooContext = createContext({ current: true });

function Component(props) {
  const $ = _c(6);
  const foo = useContext(FooContext);
  let t0;
  if ($[0] !== foo.current) {
    t0 = () => {
      if (foo.current) {
        return {};
      } else {
        return null;
      }
    };
    $[0] = foo.current;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const getValue = t0;
  let t1;
  if ($[2] !== getValue) {
    t1 = getValue();
    $[2] = getValue;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const value = t1;
  let t2;
  if ($[4] !== value) {
    t2 = <Stringify value={value} />;
    $[4] = value;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component that includes React's memoization logic using Symbol.for('react.memo_cache_sentinel'). The map operation is extracted into a separate function for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-map-mutable-array-mutating-lambda.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [];
    const y = x.map(_temp);
    t0 = [x, y];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp(item) {
  item.updated = true;
  return item;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Optimizations
DESCRIPTION: The compiled version of the component with added memoization and state tracking using React's compiler runtime. Implements caching of computed values and renders to avoid unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/component.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(8);
  const items = props.items;
  const maxItems = props.maxItems;
  let renderedItems;
  if ($[0] !== items || $[1] !== maxItems) {
    renderedItems = [];
    const seen = new Set();
    const max = Math.max(0, maxItems);
    for (let i = 0; i < items.length; i = i + 1, i) {
      const item = items.at(i);
      if (item == null || seen.has(item)) {
        continue;
      }

      seen.add(item);
      renderedItems.push(<div>{item}</div>);
      if (renderedItems.length >= max) {
        break;
      }
    }
    $[0] = items;
    $[1] = maxItems;
    $[2] = renderedItems;
  } else {
    renderedItems = $[2];
  }

  const count = renderedItems.length;
  let t0;
  if ($[3] !== count) {
    t0 = <h1>{count} Items</h1>;
    $[3] = count;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  let t1;
  if ($[5] !== renderedItems || $[6] !== t0) {
    t1 = (
      <div>
        {t0}
        {renderedItems}
      </div>
    );
    $[5] = renderedItems;
    $[6] = t0;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: Advanced implementation using React compiler runtime with optimized nested function handling, state tracking, and fire event mechanism
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/deep-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c, useFire } from "react/compiler-runtime"; // @enableFire\nimport { fire } from "react";\n\nfunction Component(props) {\n  const $ = _c(3);\n  const foo = _temp;\n  const t0 = useFire(foo);\n  let t1;\n  if ($[0] !== props || $[1] !== t0) {\n    t1 = () => {\n      const nested = function nested() {\n        const nestedAgain = function nestedAgain() {\n          const nestedThrice = function nestedThrice() {\n            t0(props);\n          };\n\n          nestedThrice();\n        };\n\n        nestedAgain();\n      };\n\n      nested();\n    };\n    $[0] = props;\n    $[1] = t0;\n    $[2] = t1;\n  } else {\n    t1 = $[2];\n  }\n  useEffect(t1);\n  return null;\n}\nfunction _temp(props_0) {\n  console.log(props_0);\n}\n
```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime
DESCRIPTION: This snippet shows the optimized version of the Component using React's compiler runtime. It implements memoization to avoid unnecessary re-renders and computations when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-compound-test.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let ret;
  if ($[0] !== props) {
    const x = [1, 2, 3];
    ret = [];
    do {
      const item = x.pop();
      ret.push(item * 2);
    } while (x.length && props.cond);
    $[0] = props;
    $[1] = ret;
  } else {
    ret = $[1];
  }
  return ret;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Conditional State Management in React with JavaScript
DESCRIPTION: This snippet redefines the useFoo function, integrating React's compiler-runtime to conditionally manage state and rendering. Dependencies include "react/compiler-runtime" and "shared-runtime". The function checks and updates state only when necessary, optimizing performance by reducing unnecessary operations. It accepts an object with properties "bar", "foo", and "cond" as input, aiming to minimize changes to component state unless conditions explicitly change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR\nimport { mutate } from "shared-runtime";\n\nfunction useFoo(props) {\n  const $ = _c(4);\n  let x;\n  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {\n    x = [];\n    x.push(props.bar);\n    if (props.cond) {\n      x = [];\n      x.push(props.foo);\n    }\n\n    mutate(x);\n    $[0] = props.bar;\n    $[1] = props.cond;\n    $[2] = props.foo;\n    $[3] = x;\n  } else {\n    x = $[3];\n  }\n  return x;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: useFoo,\n  params: [{ bar: "bar", foo: "foo", cond: true }],\n  sequentialRenders: [\n    { bar: "bar", foo: "foo", cond: true },\n    { bar: "bar", foo: "foo", cond: true },\n    { bar: "bar", foo: "foo", cond: false },\n  ],\n};\n
```

----------------------------------------

TITLE: Compiled React Version with Memoization
DESCRIPTION: Compiled version of the function using React's compiler runtime with memoization logic. Uses Symbol.for() to implement caching mechanism for the returned object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-non-identifier-object-keys.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { "a.b": 1, "a\b": 2, "a/b": 3, "a+b": 4, "a b": 5 };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the Foo component that includes memoization logic using React compiler runtime. It uses a Symbol-based cache sentinel to determine whether to compute or reuse the previous value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-conditional.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    true ? (x = []) : (x = {});
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with FBT Internationalization
DESCRIPTION: This snippet shows the compiled output of the React component using FBT. It demonstrates how FBT translates the internationalized strings and optimizes the component for performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-with-jsx-element-content.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Component(t0) {
  const $ = _c(4);
  const { name, data, icon } = t0;
  let t1;
  if ($[0] !== data || $[1] !== icon || $[2] !== name) {
    t1 = (
      <Text type="body4">
        {fbt._(
          "{item author}{icon}{=m2}",
          [
            fbt._param(
              "item author",

              <Text type="h4">{name}</Text>,
            ),
            fbt._param(
              "icon",

              icon,
            ),
            fbt._implicitParam(
              "=m2",
              <Text type="h4">
                {fbt._("{item details}", [fbt._param("item details", data)], {
                  hk: "4jLfVq",
                })}
              </Text>,
            ),
          ],
          { hk: "2HLm2j" },
        )}
      </Text>
    );
    $[0] = data;
    $[1] = icon;
    $[2] = name;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: Compiled and optimized version of the component that implements memoization using a cache array ($). Prevents unnecessary recreations of the context object when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-member.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, mutate, mutateAndReturn } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  let context;
  if ($[0] !== props.value) {
    const key = { a: "key" };
    context = { [key.a]: identity([props.value]) };

    mutate(key);
    $[0] = props.value;
    $[1] = context;
  } else {
    context = $[1];
  }
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows the compiled version of the Component function, incorporating React's compiler runtime for memoization. It uses a Symbol-based cache sentinel to determine whether to recompute or return cached values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-lifetime-with-aliasing.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function mutate(x, y) {
  "use no forget";
  if (!Array.isArray(x.value)) {
    x.value = [];
  }
  x.value.push(y);
  if (y != null) {
    y.value = x;
  }
}

function Component(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = {};
    const b = [a];
    const c = {};
    const d = { c };

    x = {};
    x.b = b;
    const y = mutate(x, d);
    if (a) {
    }
    if (b) {
    }
    if (c) {
    }
    if (d) {
    }
    if (y) {
    }

    mutate(x, null);
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with added memoization logic using Symbol.for('react.memo_cache_sentinel'). Includes compiler runtime imports and maintains the same error handling pattern.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { throwErrorWithMessage } = require("shared-runtime");

function Component(props) {
  const $ = _c(1);
  let x;
  try {
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = throwErrorWithMessage("oops");
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    x = t0;
  } catch {
    x = null;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows the compiled and optimized version of the React component. It implements memoization techniques to improve performance by caching computed values and minimizing re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-consecutive-scopes-objects.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useState } from "react";
import { Stringify } from "shared-runtime";

function Component(props) {
  const $ = _c(11);
  const [state, setState] = useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { component: Stringify, props: { text: "Counter" } };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== state) {
    t1 = { component: "span", props: { children: [state] } };
    $[1] = state;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== state) {
    t2 = () => setState(state + 1);
    $[3] = state;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = ["increment"];
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== t2) {
    t4 = {
      component: "button",
      props: { "data-testid": "button", onClick: t2, children: t3 },
    };
    $[6] = t2;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== t1 || $[9] !== t4) {
    t5 = [t0, t1, t4];
    $[8] = t1;
    $[9] = t4;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  return t5;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Re-Implementing useFoo with React Compiler Runtime
DESCRIPTION: This code imports '_c' from 'react/compiler-runtime' and re-defines the function 'useFoo' with added state tracking using '_c' to track changes and optimize array assembly operations. The implementation targets efficient conditional processing dependent on input changes with emphasis on object referencing and avoiding unnecessary computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-unpoisoned/throw-before-scope-starts.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { arrayPush } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(2);
  const { input, cond } = t0;
  if (cond) {
    throw new Error("throw with error!");
  }
  let x;
  if ($[0] !== input.a.b) {
    x = [];
    arrayPush(x, input.a.b);
    $[0] = input.a.b;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { a: { b: 2 } }, cond: false }],
  sequentialRenders: [
    { input: null, cond: true },
    { input: { a: { b: 2 } }, cond: false },
    { input: null, cond: true },
    // preserve nullthrows
    { input: {}, cond: false },
    { input: { a: { b: null } }, cond: false },
    { input: { a: null }, cond: false },
    { input: { a: { b: 3 } }, cond: false },
  ],
};

```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimization
DESCRIPTION: Transformed version of the component using React compiler runtime with memoization optimization for the filter operation. Includes separate filter predicate function and same test fixture.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/noAlias-filter-on-array-prop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.items) {
    t0 = props.items.filter(_temp);
    $[0] = props.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const filtered = t0;
  return filtered;
}
function _temp(item) {
  return item != null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      items: [
        { a: true },
        null,
        true,
        false,
        null,
        "string",
        3.14,
        null,
        [null],
      ],
    },
  ],
};
```

----------------------------------------

TITLE: Implementing Memoization and Conditional Rendering - React - JavaScript
DESCRIPTION: This snippet illustrates an enhanced version of the 'Foo' component that incorporates memoization using a cache sentinel. It conditionally checks if the cache is available and processes data accordingly, ensuring efficient rendering while maintaining the same structure as the previous snippet.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoist-destruct.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const foo = function foo() {
      return (
        <div>
          {a} {z} {y}
        </div>
      );
    };

    const [t1, t2] = [1, { x: 2 }];
    const a = t1;
    const { x: t3, y: t4 } = t2;
    const z = t3;
    const y = t4 === undefined ? 10 : t4;
    t0 = foo();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};

```

----------------------------------------

TITLE: Compiled React Component with Optimizations
DESCRIPTION: Compiled output showing the same component with added compiler optimizations including memoization logic and runtime imports.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagate-global-phis.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_STRING0, CONST_STRING1, Text } from "shared-runtime";

function useFoo() {
  "use no forget";
  return { tab: CONST_STRING1 };
}

function Test() {
  const $ = _c(2);
  const { tab } = useFoo();
  const currentTab = tab === CONST_STRING0 ? CONST_STRING0 : CONST_STRING1;
  let t0;
  if ($[0] !== currentTab) {
    t0 = <Text value={currentTab} />;
    $[0] = currentTab;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Compiled React Component with FBT Memoization
DESCRIPTION: The compiler-transformed version of the component that uses memoization to optimize rendering. It tracks previous props values and caches rendered output to avoid unnecessary re-renders of internationalized content.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-params.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Component(props) {
  const $ = _c(7);
  let t0;
  if ($[0] !== props.name) {
    t0 = fbt._("Hello {user name}", [fbt._param("user name", props.name)], {
      hk: "2zEDKF",
    });
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== props.actions) {
    t1 = fbt._(
      "{actions|response}",
      [fbt._param("actions|response", props.actions)],
      { hk: "1cjfbg" },
    );
    $[2] = props.actions;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== t0 || $[5] !== t1) {
    t2 = (
      <div>
        {t0}
        {t1}
      </div>
    );
    $[4] = t0;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Initializing Inefficient Loop Function in JavaScript
DESCRIPTION: This snippet defines a function 'foo' with an infinite loop and exports it as part of a FIXTURE_ENTRYPOINT object. The function initializes two variables and contains a while loop that never terminates.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-while.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 100;
  let y = 0;
  while (x < 10) {
    y += 1;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized React Component with Conditional Refs in JavaScript
DESCRIPTION: This snippet provides an optimized version, using a caching mechanism for component rendering by utilizing variables such as '$'. It mimics the earlier React component using conditional refs, but improves performance by reducing unnecessary renders through caching previous computations. Dependencies are imported similarly from React libraries. It processes inputs and renders based on cached refs, reducing render overhead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-ref.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useRef } from "react";
import { Stringify } from "shared-runtime";

/**
 * Fixture showing that Ref types may be reactive.
 * We should always take a dependency on ref values (the outer box) as
 * they may be reactive. Pruning should be done in
 * `pruneNonReactiveDependencies`
 */
function Component(t0) {
  const $ = _c(4);
  const { cond } = t0;
  const ref1 = useRef(1);
  const ref2 = useRef(2);
  const ref = cond ? ref1 : ref2;
  let t1;
  if ($[0] !== ref) {
    t1 = () => ref.current;
    $[0] = ref;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const cb = t1;
  let t2;
  if ($[2] !== cb) {
    t2 = <Stringify cb={cb} shouldInvokeFns={true} />;
    $[2] = cb;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
  sequentialRenders: [{ cond: true }, { cond: false }],
};
```

----------------------------------------

TITLE: Implementing a React Test Fixture with Conditional Logic
DESCRIPTION: A JavaScript function with conditional logic that modifies variables based on conditions, along with an exported FIXTURE_ENTRYPOINT configuration that defines test parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-complex-multiple-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  let y = 2;
  if (y === 2) {
    x = 3;
  }

  if (y === 3) {
    x = 5;
  }
  y = x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized React Component with State Checking (JavaScript)
DESCRIPTION: This snippet enhances the `foo` function with state caching using the `react/compiler-runtime` import. It checks previous inputs to optimize re-rendering, making use of a cache array `$` to store previous values and DOM elements, reducing unnecessary updates. The `FIXTURE_ENTRYPOINT` object is also included, providing the function `foo` along with parameters and component metadata.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes-if.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(8);
  let x;
  if ($[0] !== a || $[1] !== b || $[2] !== c) {
    x = [];
    if (a) {
      let y;
      if ($[4] !== b) {
        y = [];
        y.push(b);
        $[4] = b;
        $[5] = y;
      } else {
        y = $[5];
      }
      let t0;
      if ($[6] !== y) {
        t0 = <div>{y}</div>;
        $[6] = y;
        $[7] = t0;
      } else {
        t0 = $[7];
      }
      x.push(t0);
    } else {
      x.push(c);
    }
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React Compiler Optimized Output with Memoization
DESCRIPTION: The React compiler's transformed output that adds memoization for performance optimization. It imports the compiler runtime and uses a memoization technique to avoid recalculating values when the input props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-call-spread.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.method) {
    t0 = foo[props.method](...props.a, null, ...props.b);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.method;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  const x = t0;
  return x;
}
```

----------------------------------------

TITLE: Object Property Manipulation with Dynamic Keys in JavaScript
DESCRIPTION: Function that creates a new object using spread operator, then assigns properties using dynamic keys. Used in combination with a test fixture export for a TodoAdd component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-computed-access-assignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const x = {...a};
  x[b] = c[b];
  x[1 + 2] = c[b * 4];
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Compiler-Transformed Component with Memoization
DESCRIPTION: The compiler-transformed version of the same component, now with memoization logic added. It uses a cache sentinel symbol to check if the computation needs to be performed or if a cached value can be used instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/conflicting-dollar-sign-variable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $0 = _c(1);
  let t0;
  if ($0[0] === Symbol.for("react.memo_cache_sentinel")) {
    const $ = identity("jQuery");
    t0 = identity([$]);
    $0[0] = t0;
  } else {
    t0 = $0[0];
  }
  const t0$0 = t0;
  return t0$0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization in JavaScript
DESCRIPTION: This snippet shows the compiled version of the React component 'Test'. It implements memoization using a custom compiler runtime from React. The component uses a Symbol-based cache sentinel for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ts-instantiation-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity, invoke } from "shared-runtime";

function Test() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = invoke(identity, "test");
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const str = t0;
  return str;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Test,
  params: [],
};
```

----------------------------------------

TITLE: Testing React Compiler Memoization with Context Variables in JavaScript
DESCRIPTION: This code demonstrates a test case where React Compiler cannot preserve memoization guarantees. It shows how capturing values in context variables creates mutable ranges that prevent optimization, specifically when useMemo is used within these ranges.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-unmemoized-callback-captured-in-context-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {ValidateMemoization, useHook} from 'shared-runtime';

function UnmemoizedCallbackCapturedInContextVariable({cond1, cond2}) {
  // The return value is captured by `x` which is a context variable, which
  // extends a's range to include the call instruction. This prevents the entire
  // range from being memoized
  const a = useHook();
  // Because b is also part of that same mutable range, it can't be memoized either
  const b = useMemo(() => ({}), []);

  // Conditional assignment without a subsequent mutation normally doesn't create a mutable
  // range, but in this case we're reassigning a context variable
  let x;
  if (cond1) {
    x = a;
  } else if (cond2) {
    x = b;
  } else {
    return null;
  }

  const f = () => {
    return x;
  };
  const result = f();

  return <ValidateMemoization inputs={[cond1, cond2]} output={result} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: UnmemoizedCallbackCapturedInContextVariable,
  params: [{cond1: true, cond2: false}],
  sequentialRenders: [
    {cond1: true, cond2: true},
    {cond1: false, cond2: true},
    {cond1: false, cond2: true}, // fails sprout bc memoization is not preserved
    {cond1: false, cond2: false},
  ],
};
```

----------------------------------------

TITLE: Compiled React Components with Optimization Logic
DESCRIPTION: This snippet shows the compiled version of the React components. It includes optimization logic based on the 'use forget' directive, using the isForgetEnabled_Fixtures flag to conditionally apply optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-test-export-default-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating @compilationMode(annotation)
const Bar = isForgetEnabled_Fixtures()
  ? function Bar(props) {
      "use forget";
      const $ = _c(2);
      let t0;
      if ($[0] !== props.bar) {
        t0 = <div>{props.bar}</div>;
        $[0] = props.bar;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : function Bar(props) {
      "use forget";
      return <div>{props.bar}</div>;
    };
export default Bar;

function NoForget(props) {
  return <Bar>{props.noForget}</Bar>;
}
const Foo = isForgetEnabled_Fixtures()
  ? function Foo(props) {
      "use forget";
      const $ = _c(2);
      let t0;
      if ($[0] !== props.bar) {
        t0 = <Foo>{props.bar}</Foo>;
        $[0] = props.bar;
        $[1] = t0;
      } else {
        t0 = $[1];
      }
      return t0;
    }
  : function Foo(props) {
      "use forget";
      return <Foo>{props.bar}</Foo>;
    };

export const FIXTURE_ENTRYPOINT = {
  fn: eval("Bar"),
  params: [{ bar: 2 }],
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization
DESCRIPTION: Compiled version of the hook with added memoization logic using React's compiler runtime. It includes dependency tracking and caching mechanism to prevent unnecessary recalculations when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/computed-store-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";
function useHook(t0) {
  const $ = _c(3);
  const { a, b } = t0;
  let x;
  if ($[0] !== a || $[1] !== b) {
    const y = { a };
    x = { b };
    x.y = y;
    mutate(x);
    $[0] = a;
    $[1] = b;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ a: 2, b: 3 }],
  sequentialRenders: [
    { a: 2, b: 3 },
    { a: 2, b: 3 },
    { a: 3, b: 3 },
  ],
};
```

----------------------------------------

TITLE: Transformed Implementation of useRelayData Hook
DESCRIPTION: Transformed version of the useRelayData hook with destructured parameters. This version includes the same functionality but with modified parameter handling and formatting.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/relay-transitive-mixeddata.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useFragment } from "shared-runtime";

/**
 * React compiler should infer that the returned value is a primitive and avoid
 * memoizing it.
 */
function useRelayData(t0) {
  "use memo";
  const { query, idx } = t0;

  const data = useFragment("", query);
  return data.a[idx].toString();
}

export const FIXTURE_ENTRYPOINT = {
  fn: useRelayData,
  params: [{ query: "", idx: 0 }],
  sequentialRenders: [
    { query: "", idx: 0 },
    { query: "", idx: 0 },
    { query: "", idx: 1 },
  ],
};
```

----------------------------------------

TITLE: Labeled Break in Switch Statement in JavaScript
DESCRIPTION: This JavaScript code defines a function 'foo' that uses a switch statement with labeled breaks. The switch statement evaluates the value '1' and immediately breaks out of the switch statement using the label 'bb0' in both cases. The 'FIXTURE_ENTRYPOINT' exports the 'foo' function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-switch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  bb0: switch (1) {
    case 1: {
      break bb0;
    }
    case 2: {
      break bb0;
    }
    default: {
    }
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Rendering Button List in React (Compiled Version)
DESCRIPTION: This is the compiled version of the React component, optimized for performance. It includes memoization techniques to avoid unnecessary re-renders and computations. The core functionality remains the same as the input version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-undefined-expression-of-jsxexpressioncontainer.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { StaticText1, Stringify, Text } from "shared-runtime";

function Component(props) {
  const $ = _c(6);
  const { buttons } = props;
  let nonPrimaryButtons;
  if ($[0] !== buttons) {
    [, ...nonPrimaryButtons] = buttons;
    $[0] = buttons;
    $[1] = nonPrimaryButtons;
  } else {
    nonPrimaryButtons = $[1];
  }
  let t0;
  if ($[2] !== nonPrimaryButtons) {
    t0 = nonPrimaryButtons.map(_temp);
    $[2] = nonPrimaryButtons;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  const renderedNonPrimaryButtons = t0;
  let t1;
  if ($[4] !== renderedNonPrimaryButtons) {
    t1 = <StaticText1>{renderedNonPrimaryButtons}</StaticText1>;
    $[4] = renderedNonPrimaryButtons;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}
function _temp(buttonProps, i) {
  return (
    <Stringify
      {...buttonProps}
      key={`button-${i}`}
      style={
        i % 2 === 0 ? styles.leftSecondaryButton : styles.rightSecondaryButton
      }
    />
  );
}

const styles = {
  leftSecondaryButton: { left: true },
  rightSecondaryButton: { right: true },
};

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [
    {
      buttons: [
        {},
        { type: "submit", children: ["Submit!"] },
        { type: "button", children: ["Reset"] },
      ],
    },
  ],
};
```

----------------------------------------

TITLE: Compiled React Hook with Compiler Runtime
DESCRIPTION: This snippet presents the compiled version of the `useFoo` React hook, leveraging `react/compiler-runtime` for optimization. It includes dependency tracking using the `_c` function. The compiled hook uses a state array (`$`) to cache values and minimize re-renders by tracking changes to `props.bar`, `props.cond`, and `props.foo`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-ternary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function useFoo(props) {
  const $ = _c(6);
  let x;
  if ($[0] !== props.bar) {
    x = [];
    x.push(props.bar);
    $[0] = props.bar;
    $[1] = x;
  } else {
    x = $[1];
  }
  if ($[2] !== props.bar || $[3] !== props.cond || $[4] !== props.foo) {
    props.cond ? ((x = []), x.push(props.foo)) : ((x = []), x.push(props.bar));
    $[2] = props.bar;
    $[3] = props.cond;
    $[4] = props.foo;
    $[5] = x;
  } else {
    x = $[5];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};

```

----------------------------------------

TITLE: Optimized React Component with Flow Types
DESCRIPTION: A React component function that uses compiler runtime optimization (_c) and Flow type checking. The function memoizes rendering of a div element based on the numeric baz property value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/parse-flow-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(propVal) {
  const $ = _c(2);
  const t0 = (propVal.baz: number);
  let t1;
  if ($[0] !== t0) {
    t1 = <div>{t0}</div>;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Compiled React Component With Caching
DESCRIPTION: Compiled version of the component that implements memoization using Symbol.for() checks and a cache array. Adds optimization for repeated computations and rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/allow-locals-named-like-hooks.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeObject_Primitives, Stringify } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  const useFeature = makeObject_Primitives();
  let x;
  if (useFeature) {
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = [useFeature + useFeature].push(-useFeature);
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    x = t0;
  }

  const y = useFeature;
  const z = useFeature.useProperty;
  let t0;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <Stringify val={useFeature}>
        {x}
        {y}
        {z}
      </Stringify>
    );
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiler-optimized version of the component using React's memo cache sentinel for performance optimization. Implements the same array transformation logic with caching mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-destructure.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = [];
    const items = [{ v: 0 }, { v: 1 }, { v: 2 }];
    for (const { v } of items) {
      x.push(v * 2);
    }
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiler-optimized version of the component using memo cache sentinel pattern for performance. Implements memoization to prevent unnecessary handler recreation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/concise-arrow-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  const [, setX] = useState(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const handler = (v) => setX(v);
    t0 = <Foo handler={handler} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: React Compiler Output for Reactive Component
DESCRIPTION: This code shows the transformed React component generated by the React compiler.  It utilizes `_c` from "react/compiler-runtime" for memoization. The compiler memoizes the returned array based on the value of `x`, ensuring that the component only re-renders when `x` changes, optimizing performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-for-update.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  for (let i = 0; i < 10; i = i + props.update, i) {
    if (i > 0 && i % 2 === 0) {
      x = 2;
    } else {
      x = 1;
    }
  }
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { update: 2 },
    { update: 2 },
    { update: 1 },
    { update: 1 },
    { update: 2 },
    { update: 1 },
    { update: 2 },
    { update: 1 },
  ],
};
```

----------------------------------------

TITLE: Optimized React Component (Code)
DESCRIPTION: This code snippet demonstrates the optimized React component after constant propagation.  The original conditional assignments are replaced with a direct return of the constant value "ok". This simplification is possible because the initial value of 'a' is known, and the conditions are always met, leading to a deterministic outcome.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/sequentially-constant-progagatable-if-test-conditions.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component() {
  return "ok";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: React Compiler Optimized useFoo Hook with Memoization
DESCRIPTION: Compiler-optimized version of the useFoo hook with memoization using React's compiler-runtime. The compiled code caches previous values in the $ array to avoid recalculations when props haven't changed, improving performance through dependency tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-unconditional-ternary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function useFoo(props) {
  const $ = _c(6);
  let x;
  if ($[0] !== props.bar) {
    x = [];
    x.push(props.bar);
    $[0] = props.bar;
    $[1] = x;
  } else {
    x = $[1];
  }
  if ($[2] !== props.bar || $[3] !== props.cond || $[4] !== props.foo) {
    props.cond ? ((x = []), x.push(props.foo)) : ((x = []), x.push(props.bar));
    $[2] = props.bar;
    $[3] = props.cond;
    $[4] = props.foo;
    $[5] = x;
  } else {
    x = $[5];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};
```

----------------------------------------

TITLE: Error Handling for Unreachable Code in React Component - JavaScript
DESCRIPTION: This snippet shows an error that arises when an unreachable function declaration 'Foo' is detected within the 'Component'. It addresses the limitation of the current compilation process in recognizing hoisted functions that are placed in unreachable code paths within React components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoisted-function-in-unreachable-code.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  4 |
  5 |   // This is unreachable from a control-flow perspective, but it gets hoisted
> 6 |   function Foo() {}
    |   ^^^^^^^^^^^^^^^^^ Todo: Support functions with unreachable code that may contain hoisted declarations (6:6)
  7 | }
  8 |

```

----------------------------------------

TITLE: Function Export with Entry Point in JavaScript
DESCRIPTION: This snippet shows a simplified version of a function definition and export in JavaScript. The function Foo returns a numeric literal (0) and is then used as the function part of the FIXTURE_ENTRYPOINT constant, which is exported with empty parameters. No dependencies are required, and the function does not take any parameters, returning a static value instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ignore-inner-interface-types.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Foo() {
  return 0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};

```

----------------------------------------

TITLE: React Ref Access Error
DESCRIPTION: This code snippet represents the error output from React. It indicates that the `current` property of a ref is being accessed during render, which is not allowed in React. The error message suggests using `useRef` instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.repro-ref-mutable-range.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   9 |   mutate(value);
  10 |   if (CONST_TRUE) {
> 11 |     return <Stringify ref={identity(ref)} />;
     |                                     ^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (11:11)
  12 |   }
  13 |   return value;
  14 | }

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component with added memoization logic using compiler runtime. Includes caching of props and return values for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-object-method-returns-caught-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { throwInput } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props) {
    const object = {
      foo() {
        try {
          throwInput([props.value]);
        } catch (t1) {
          const e = t1;
          return e;
        }
      },
    };

    t0 = object.foo();
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: React Compiler-Transformed Function with Memoization
DESCRIPTION: The transformed version of the 'foo' function with React compiler optimizations. It uses memoization via an array created by '_c(4)' to cache parameters and results, preventing unnecessary recalculations when inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/extend-scopes-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(4);
  let x;
  if ($[0] !== a || $[1] !== b || $[2] !== c) {
    x = [];
    if (a) {
      if (b) {
        if (c) {
          x.push(0);
        }
      }
    }
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = x;
  } else {
    x = $[3];
  }
  if (x.length) {
    return x;
  }
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized Component Function with Memoization - JavaScript
DESCRIPTION: This code snippet is an optimized definition of the 'Component' function that includes memoization using a compiler runtime. It checks previous values to prevent unnecessary computations and updates. It also handles rendering through JSX that leverages the cached results. Required dependencies include 'react/compiler-runtime' and 'shared-runtime'. This functionality focuses on efficiency by minimizing re-renders based on property comparisons.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-global-property-load-cached.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import * as SharedRuntime from "shared-runtime";
import { makeArray } from "shared-runtime";

/**
 * Here, we don't need to memoize SharedRuntime.Stringify as it is a PropertyLoad
 * off of a global.
 * TODO: in PropagateScopeDeps (hir), we should produce a sidemap of global rvals
 * and avoid adding them to `temporariesUsedOutsideDefiningScope`.
 */
function Component(t0) {
  const $ = _c(6);
  const { num } = t0;
  let T0;
  let t1;
  if ($[0] !== num) {
    const arr = makeArray(num);

    T0 = SharedRuntime.Stringify;
    t1 = arr.push(num);
    $[0] = num;
    $[1] = T0;
    $[2] = t1;
  } else {
    T0 = $[1];
    t1 = $[2];
  }
  let t2;
  if ($[3] !== T0 || $[4] !== t1) {
    t2 = <T0 value={t1} />;
    $[3] = T0;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ num: 2 }],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler-Runtime and Memoization
DESCRIPTION: This snippet shows an optimized version of the component using React's compiler-runtime. It implements memoization for better performance and separates the onEvent function into a standalone _temp function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-into-function-expressions.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify, identity } from "shared-runtime";

function Component(props) {
  const $ = _c(1);

  const onEvent = _temp;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Stringify onEvent={onEvent} shouldInvokeFns={true} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  return identity(42);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows the optimized version of the Component function, using React's compiler runtime for improved performance. It implements memoization to avoid unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-alias-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.name) {
    t0 = { name: props.name };
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const user = t0;
  return user;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Mofei" }],
};
```

----------------------------------------

TITLE: Compiled React Component with Context Memoization
DESCRIPTION: This is the compiled version of the `App` component, utilizing a compiler runtime (`react/compiler-runtime`). It memoizes the `Bar` component based on the `bar` and `foo` context values. It utilizes an array `$` to store previous values and the rendered component to prevent re-renders if the context values haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-nested-destructuring.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @lowerContextAccess
function App() {
  const $ = _c(3);
  const { joe: t0, bar } = useContext(MyContext);
  const { foo } = t0;
  let t1;
  if ($[0] !== bar || $[1] !== foo) {
    t1 = <Bar foo={foo} bar={bar} />;
    $[0] = bar;
    $[1] = foo;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

```

----------------------------------------

TITLE: Optimizing useFoo using Compiler Runtimes in JavaScript
DESCRIPTION: An enhanced version of the useFoo function introduces caching via the react/compiler-runtime. Dependencies include shared-runtime for array operations. This snippet optimizes rendering by tracking previous inputs to minimize processing. Parameters include 'cond', 'foo', and 'bar', with output arrays adjusting based on these properties, intended for optimized re-renders and state tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/ssa-renaming-unconditional-ternary-with-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { arrayPush } from "shared-runtime";
function useFoo(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props.bar || $[1] !== props.cond || $[2] !== props.foo) {
    x = [];
    x.push(props.bar);
    props.cond ? ((x = []), x.push(props.foo)) : ((x = []), x.push(props.bar));
    arrayPush(x, 4);
    $[0] = props.bar;
    $[1] = props.cond;
    $[2] = props.foo;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: false, foo: 2, bar: 55 }],
  sequentialRenders: [
    { cond: false, foo: 2, bar: 55 },
    { cond: false, foo: 3, bar: 55 },
    { cond: true, foo: 3, bar: 55 },
  ],
};
```

----------------------------------------

TITLE: Optimizing React Component Function with Compiler-Runtime in JavaScript
DESCRIPTION: This snippet shows an optimized version of the 'foo' function using React's compiler-runtime. It implements memoization to avoid unnecessary recalculations and improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dependencies.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(x, y, z) {
  const $ = _c(3);
  const items = [z];
  items.push(x);
  let items2;
  if ($[0] !== x || $[1] !== y) {
    items2 = [];
    if (x) {
      items2.push(y);
    }
    $[0] = x;
    $[1] = y;
    $[2] = items2;
  } else {
    items2 = $[2];
  }
  if (y) {
    items.push(x);
  }
  return items2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Input React Component with Decrement Operations
DESCRIPTION: A simple React component function that takes an array parameter and performs both post-decrement and pre-decrement operations. Returns an array containing the modified values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-4.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component([b]) {
  let f = b--;
  let g = --b;
  return [b, f, g];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [[3]],
  isComponent: false,
};
```

----------------------------------------

TITLE: Simple Return Implementation in React Test Fixture
DESCRIPTION: A simplified test fixture that logs a message and returns a constant value. Exports the same FIXTURE_ENTRYPOINT structure for consistency in testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  console.log("foo");
  return -6;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Displaying Error in JavaScript Syntax
DESCRIPTION: This snippet contains a JavaScript error message output during compilation, highlighting syntax issues in the React component. It emphasizes the need for supporting non-trivial 'for..of' initializations. No specific inputs or outputs are associated other than displaying diagnostic error information during development.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-of-loop-with-context-variable-iterator.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
   6 |   // NOTE: `item` is a context variable because it's reassigned and also referenced
   7 |   // within a closure, the `onClick` handler of each item
>  8 |   for (let item of props.data) {
     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>  9 |     item = item ?? {}; // reassignment to force a context variable
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 10 |     items.push(
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 11 |       <div key={item.id} onClick(() => data.set(item))>
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 12 |         {item.id}
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 13 |       </div>
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 14 |     );
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 15 |   }
     | ^^^^ Todo: Support non-trivial for..of inits (8:15)
  16 |   return <div>{items}</div>;
  17 | }
  18 |
```

----------------------------------------

TITLE: Example React Component Fixture with FIXTURE_ENTRYPOINT
DESCRIPTION: Example of a React component fixture with the required FIXTURE_ENTRYPOINT export. This demonstrates how to set up a component for testing with Sprout.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/snap/src/sprout/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// test.js
function MyComponent(props) {
  return <div>{props.a + props.b}</div>;
}
export const FIXTURE_ENTRYPOINT = {
  fn: MyComponent,
  params: [{a: "hello ", b: "world"}],
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiled version of the React component with added optimization using memoization through array-based caching. The compiler introduces variables to track prop changes and memoize callback creation and execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/try-catch-within-function-expression-returns-caught-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { throwInput } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props) {
    t0 = () => {
      try {
        throwInput([props.value]);
      } catch (t1) {
        const e = t1;
        return e;
      }
    };
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const callback = t0;
  let t1;
  if ($[2] !== callback) {
    t1 = callback();
    $[2] = callback;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Defining and Invoking Functions in JavaScript
DESCRIPTION: This snippet shows how to define a normal function that can call another function. It demonstrates the concept of function invocation within other functions, which is a fundamental aspect of JavaScript programming.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-347b0dae66f1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because functions can call functions.
function normalFunctionWithNormalFunction() {
  doSomething();
}

```

----------------------------------------

TITLE: Function Definition in JavaScript
DESCRIPTION: This snippet defines a simple JavaScript function `foo` that creates an object, passes it to a recursive call of itself, mutates the returned object, and finally returns the original object. This demonstrates object handling and mutation in JavaScript.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/store-via-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const x = {};
  const y = foo(x);
  y.mutate();
  return x;
}

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Optimized version with compiler runtime integration. Implements memoization checks for component renders and props changes using a cache array.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/renaming-jsx-tag-lowercase.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify, identity, useIdentity } from "shared-runtime";

function Foo(t0) {
  const $ = _c(9);
  const x = {};
  const y = {};
  useIdentity(0);

  const T0 = Stringify;
  const t1 = identity(y);
  let t2;
  if ($[0] !== T0 || $[1] !== t1) {
    t2 = <T0 value={t1} />;
    $[0] = T0;
    $[1] = t1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const T1 = Stringify;
  const t3 = identity(x);
  let t4;
  if ($[3] !== T1 || $[4] !== t3) {
    t4 = <T1 value={t3} />;
    $[3] = T1;
    $[4] = t3;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  let t5;
  if ($[6] !== t2 || $[7] !== t4) {
    t5 = (
      <>
        {t2}
        {t4}
      </>
    );
    $[6] = t2;
    $[7] = t4;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  return t5;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: TypeScript Error for Optional Chaining in Function Arguments
DESCRIPTION: This is the error output generated by the TypeScript compiler, showing a problem with using optional chaining (`value?.x`) in the arguments of the createArray function. The error specifically mentions an 'Unexpected terminal kind `optional` for optional fallthrough block'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-optional-call-chain-in-optional.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  1 | function useFoo(props: {value: {x: string; y: string} | null}) {
  2 |   const value = props.value;
> 3 |   return createArray(value?.x, value?.y)?.join(', ');
    |                      ^^^^^^^^ Todo: Unexpected terminal kind `optional` for optional fallthrough block (3:3)
  4 | }
  5 |
  6 | function createArray<T>(...args: Array<T>): Array<T> {
```

----------------------------------------

TITLE: Defining Transformed Test Function with Infinite Loop in JavaScript
DESCRIPTION: A transformed version of the 'foo' function that creates an explicit infinite loop using a constant variable and true condition. This version is likely the result of an optimization or transformation process.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for-trivial-update.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  for (const i = 0; true; 0) {
    x = x + 1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization
DESCRIPTION: The compiled version of the useFoo hook with automatic memoization added by React Compiler. It includes render counting in development, dependency tracking, and result caching to avoid redundant calculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-emit-imports-same-source.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import {
  makeReadOnly,
  shouldInstrument,
  useRenderCounter,
} from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @enableEmitFreeze @enableEmitInstrumentForget

function useFoo(props) {
  if (DEV && shouldInstrument)
    useRenderCounter("useFoo", "/codegen-emit-imports-same-source.ts");
  const $ = _c(2);
  let t0;
  if ($[0] !== props.x) {
    t0 = foo(props.x);
    $[0] = props.x;
    $[1] = __DEV__ ? makeReadOnly(t0, "useFoo") : t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Publish Stable Release Script
DESCRIPTION: This script publishes a stable release to NPM, typically using the `latest` tag. It can optionally also include the `next` tag, allowing the current release to be available under both. This script follows the preparation of the release using `prepare-release-from-npm`.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_5

LANGUAGE: shell
CODE:
```
scripts/release/publish.js --tags latest
```

LANGUAGE: shell
CODE:
```
scripts/release/publish.js --tags latest next
```

----------------------------------------

TITLE: Test Fixture for Sequential Rendering Scenarios
DESCRIPTION: Defines a test fixture with multiple input scenarios to validate the behavior of useFoo function under different array conditions
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ arr1: [], arr2: [] }],
  sequentialRenders: [
    { arr1: [], arr2: [] },
    { arr1: [], arr2: null },
    { arr1: [{ value: 1 }, { value: 2 }], arr2: [{ value: -1 }] },
  ],
};
```

----------------------------------------

TITLE: Optimized React Component with Fragment & Memoization (JavaScript)
DESCRIPTION: This JavaScript code snippet defines a React component that uses 'shared-runtime' and React's memoization to optimize the rendering of user data. The use of caching via a special array '$' minimizes unnecessary re-renders based on the 'user.timeline.posts.edges.nodes'. The code involves dependency on 'react/compiler-runtime'. The component processes 'props.user', performs caching of posts data, and returns a memoized list of <Post> components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/readonly-object-method-calls.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useFragment } from "shared-runtime";

function Component(props) {
  const $ = _c(5);
  const user = useFragment(
    graphql`
      fragment Component_user on User {
        name
      }
    `,
    props.user,
  );
  let posts;
  if ($[0] !== user.timeline.posts.edges.nodes) {
    posts = user.timeline.posts.edges.nodes.map(_temp);
    let t0;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = {};
      $[2] = t0;
    } else {
      t0 = $[2];
    }
    posts.push(t0);
    $[0] = user.timeline.posts.edges.nodes;
    $[1] = posts;
  } else {
    posts = $[1];
  }
  const count = posts.length;
  foo(count);
  let t0;
  if ($[3] !== posts) {
    t0 = <>{posts}</>;
    $[3] = posts;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  return t0;
}
function _temp(node) {
  return <Post post={node} />;
}

```

----------------------------------------

TITLE: Optimized Closure Implementation in JavaScript for React
DESCRIPTION: This snippet shows an optimized version of the 'foo' function. It eliminates the closure by moving the inner function outside and directly using the value 42. It maintains the same functionality and exports the same fixture entry point.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-into-function-expression-primitive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  const f = _temp;

  f();
  return 42;
}
function _temp() {
  console.log(42);
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component with FBT Parameter - Compiled
DESCRIPTION: Compiled version of the React component showing how FBT transforms the JSX syntax. Includes memoization logic using compiler runtime and parameter handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-with-jsx-fragment-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  let t0;
  if ($[0] !== props.text) {
    t0 = (
      <Foo
        value={fbt._(
          "{value}%",
          [fbt._param("value", <>{identity(props.text)}</>)],
          { hk: "10F5Cc" },
        )}
      />
    );
    $[0] = props.text;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled: React Component with Compiler Runtime
DESCRIPTION: Compiler-transformed version of the React component with runtime optimization and memoization tracking
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-simple-preserved.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingManualUseMemo
import { useMemo } from "react";

function Component(t0) {
  const $ = _c(5);
  const { a } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = () => [a];
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = [];
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const x = useMemo(t1, t2);
  let t3;
  if ($[3] !== x) {
    t3 = <div>{x}</div>;
    $[3] = x;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 42 }],
  isComponent: true,
};
```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: This code presents the compiled version of the React component using the React compiler runtime. It leverages the '_c' function from 'react/compiler-runtime' to optimize the component's execution. The compiler runtime uses an array ($) to memoize values, improving performance by avoiding unnecessary re-computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-1.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(4);
  let t0;
  if ($[0] !== a) {
    t0 = { a };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  let t1;
  if ($[2] !== z) {
    t1 = function () {
      console.log(z);
    };
    $[2] = z;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const x = t1;
  return x;
}
```

----------------------------------------

TITLE: Optimized Function Definition with Compiler Runtime in JavaScript
DESCRIPTION: This code snippet provides an optimized version of the function 'bar', utilizing the 'react/compiler-runtime' for performance improvement. The function checks previous input parameters to avoid redundant calculations and uses a caching mechanism with an array-like structure, improving efficiency. It exports the function with associated parameters for testing, requiring the 'react/compiler-runtime' import.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-3-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function bar(a, b) {
  const $ = _c(3);
  let y;
  if ($[0] !== a || $[1] !== b) {
    const x = [a, b];
    y = {};
    let t;
    t = {};

    y = x[0][1];
    t = x[1][0];
    $[0] = a;
    $[1] = b;
    $[2] = y;
  } else {
    y = $[2];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [
    [1, 2],
    [2, 3],
  ],
};
```

----------------------------------------

TITLE: React Compiler Runtime Component with Memoization
DESCRIPTION: An optimized version of the React component using compiler runtime for efficient state tracking and re-rendering, with conditional rendering and memoization techniques
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function Component(t0) {
  const $ = _c(3);
  const { foo, bar } = t0;
  let y;
  if ($[0] !== bar || $[1] !== foo) {
    const x = { foo };
    y = { bar };
    const f0 = function () {
      const a = [y];
      const b = x;

      a[0].x = b;
    };

    f0();
    mutate(y.x);
    $[0] = bar;
    $[1] = foo;
    $[2] = y;
  } else {
    y = $[2];
  }
  return y;
}
```

----------------------------------------

TITLE: Reactive Component Implementation with React Compiler Runtime
DESCRIPTION: This snippet uses the React Compiler Runtime to optimize the reactivity of component state. It introduces a compiled form of the `Component` function, employing runtime checks to prevent unnecessary state updates. This illustrates advanced techniques in managing render performance in React components, using the React Compiler as a dependency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-via-mutation-switch.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);

  const x = [];
  if (props.cond) {
    x.push(1);
  }

  let y = false;
  switch (x[0]) {
    case 1: {
      y = true;
    }
  }
  let t0;
  if ($[0] !== y) {
    t0 = [y];
    $[0] = y;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { cond: true },
    { cond: true },
    { cond: false },
    { cond: false },
    { cond: true },
    { cond: false },
    { cond: true },
    { cond: false },
  ],
};

```

----------------------------------------

TITLE: Defining Fixture Function in React JavaScript
DESCRIPTION: This snippet imports a constant from a shared runtime and defines a function that constructs an array using this constant and provided properties. The function is then exported as a part of a fixture entry point to be used in React components. The main dependencies are 'shared-runtime' and knowledge of function export in ES6.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/holey-array-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_STRING0} from 'shared-runtime';

function t(props) {
  let x = [, CONST_STRING0, props];
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: t,
  params: [{a: 1, b: 2}],
  isComponent: false,
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet shows the compiled version of the `Foo` React component, likely generated by a compiler like React Compiler. It uses `_c` from `react/compiler-runtime` for memoization of intermediate values and function results. This aims to optimize rendering by reusing previously computed values when inputs remain the same.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-optional-hoists-other-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR

import { identity, makeArray, Stringify, useIdentity } from "shared-runtime";

function Foo(t0) {
  const $ = _c(8);
  const { a, cond } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = () => [a, a.b?.c.d];
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const fn = t1;
  useIdentity(null);
  let arr;
  if ($[2] !== a.b?.c.e || $[3] !== cond) {
    arr = makeArray();
    if (cond) {
      arr.push(identity(a.b?.c.e));
    }
    $[2] = a.b?.c.e;
    $[3] = cond;
    $[4] = arr;
  } else {
    arr = $[4];
  }
  let t2;
  if ($[5] !== arr || $[6] !== fn) {
    t2 = <Stringify fn={fn} arr={arr} shouldInvokeFns={true} />;
    $[5] = arr;
    $[6] = fn;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{ a: null, cond: true }],
  sequentialRenders: [
    { a: null, cond: true },
    { a: { b: { c: { d: 5 } } }, cond: true },
    { a: { b: null }, cond: false },
  ],
};

```

----------------------------------------

TITLE: Compiled React Component with Mutable Object and Function Expression
DESCRIPTION: This is the compiled version of the React component, generated potentially by a compiler like React Compiler. It utilizes the `_c` helper from `react/compiler-runtime` for memoization and optimization. The logic regarding mutable object manipulation and function expression dependency remains similar, but the structure is transformed to leverage compiler optimizations. This code illustrates how the original component's logic is adapted for efficient execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/aliased-nested-scope-fn-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableTransitivelyFreezeFunctionExpressions:false
import {
  Stringify,
  mutate,
  identity,
  setPropertyByKey,
  shallowCopy,
} from "shared-runtime";
/**
 * Function expression version of `aliased-nested-scope-truncated-dep`.
 * 
 * In this fixture, the output would be invalid if propagateScopeDeps did not
 * avoid adding MemberExpression dependencies which would other evaluate during
 * the mutable ranges of their base objects.
 * This is different from `aliased-nested-scope-truncated-dep` which *does*
 * produce correct output regardless of MemberExpression dependency truncation.
 * 
 * Note while other expressions evaluate inline, function expressions *always*
 * represent deferred evaluation. This means that
 * (1) it's always safe to reorder function expression creation until its
 *     earliest potential invocation
 * (2) it's invalid to eagerly evaluate function expression dependencies during
 *     their respective mutable ranges.
 */

function Component(t0) {
  const $ = _c(2);
  const { prop } = t0;
  let t1;
  if ($[0] !== prop) {
    const obj = shallowCopy(prop);

    const aliasedObj = identity(obj);

    const getId = () => obj.id;

    mutate(aliasedObj);
    setPropertyByKey(aliasedObj, "id", prop.id + 1);

    t1 = <Stringify getId={getId} shouldInvokeFns={true} />;
    $[0] = prop;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ prop: { id: 1 } }],
  sequentialRenders: [
    { prop: { id: 1 } },
    { prop: { id: 1 } },
    { prop: { id: 2 } },
  ],
};

```

----------------------------------------

TITLE: Transformed: React Compiler Optimized Component
DESCRIPTION: Compiler-transformed version of the component using runtime memoization and conditional re-computation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-functiondecl-hoisting.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Foo(t0) {
  const $ = _c(6);
  const { value } = t0;
  let bar;
  let result;
  if ($[0] !== value) {
    result = bar();
    bar = function bar() {
      return { value };
    };
    $[0] = value;
    $[1] = bar;
    $[2] = result;
  } else {
    bar = $[1];
    result = $[2];
  }
  let t1;
  if ($[3] !== bar || $[4] !== result) {
    t1 = <Stringify result={result} fn={bar} shouldInvokeFns={true} />;
    $[3] = bar;
    $[4] = result;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}
```

----------------------------------------

TITLE: Optimized VideoTab Component with React Compiler Runtime
DESCRIPTION: An enhanced version of the VideoTab component using React compiler runtime for memoization and cached rendering
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-current-optional-field-no-added-to-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function VideoTab() {
  const $ = _c(1);
  const ref = useRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = () => {
      ref.current?.x;
    };

    t0 = <VideoList videos={x} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimized Property Access in React Component with Compiler Caching
DESCRIPTION: This enhanced version of the 'useFoo' function uses a React compiler runtime for caching to minimize redundant calculations. It checks for changes in nested properties and updates accordingly, leveraging optional chaining for safety.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR

function useFoo(t0) {
  const $ = _c(2);
  const { a } = t0;
  let x;
  if ($[0] !== a.b.c.d.e) {
    x = [];
    x.push(a?.b.c?.d.e);
    x.push(a.b?.c.d?.e);
    $[0] = a.b.c.d.e;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: null }],
  sequentialRenders: [
    { a: null },
    { a: null },
    { a: {} },
    { a: { b: { c: { d: { e: 42 } } } } },
    { a: { b: { c: { d: { e: 43 } } } } },
    { a: { b: { c: { d: { e: undefined } } } } },
    { a: { b: undefined } },
  ],
};
```

----------------------------------------

TITLE: Performance Optimized Rendering Component - React - JavaScript
DESCRIPTION: This snippet imports React's compiler-runtime to optimize rendering. It defines a React component that utilizes memoization techniques to cache computed values, thus reducing redundant calculations. The component checks for a sentinel value to determine whether to recalculate rendering time and only updates the output if necessary.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/timers.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const start = performance.now();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = Date.now();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const now = t0;
  const time = performance.now() - start;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (
      <div>
        rendering took
        {time} at {now}
      </div>
    );
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Conditional Dependencies with React Compiler in JavaScript
DESCRIPTION: The 'useFoo' function leverages a caching mechanism provided by the React compiler to efficiently handle state changes. It imports a special hook from 'react/compiler-runtime' and processes the 'screen' parameter to conditionally return specific strings. Dependencies include the identity function from 'shared-runtime' and a compiler hook imported as '_c'. The input is an object containing a 'screen' property, and the function uses cached values to optimize performance. Outputs depend on the state of 'screen.title_text'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/merge-uncond-optional-chain-and-cond.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { identity } from "shared-runtime";

/**
 * Very contrived text fixture showing that it's technically incorrect to merge
 * a conditional dependency (e.g. dep.path in `cond ? dep.path : ...`) and an
 * unconditionally evaluated optional chain (`dep?.path`).
 *
 *
 * when screen is non-null, useFoo returns { title: null } or "(not null)"
 * when screen is null, useFoo throws
 */
function useFoo(t0) {
  const $ = _c(2);
  const { screen } = t0;
  let t1;
  if ($[0] !== screen) {
    t1 =
      screen?.title_text != null
        ? "(not null)"
        : identity({ title: screen.title_text });
    $[0] = screen;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ screen: null }],
  sequentialRenders: [{ screen: { title_bar: undefined } }, { screen: null }],
};
```

----------------------------------------

TITLE: Running the React Attribute Behavior Fixture
DESCRIPTION: Command to build React in UMD development mode and run the attribute behavior fixture. This allows developers to test and compare attribute handling between different React versions.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/attribute-behavior/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
yarn build --type=UMD_DEV react/index,react-dom && cd fixtures/attribute-behavior && yarn install && yarn dev
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Compiled and optimized version of the React component with memoization and caching logic implemented through compiler runtime. Includes optimized fragment handling and event callback memoization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-mixed-scope-declarations-and-locals.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useFragment } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  const post = useFragment(
    graphql`
      fragment F on T {
        id
      }
    `,
    props.post,
  );
  let t0;
  if ($[0] !== post) {
    const allUrls = [];

    const { media, comments, urls } = post;
    let t1;
    if ($[2] !== comments.length) {
      t1 = (e) => {
        if (!comments.length) {
          return;
        }

        console.log(comments.length);
      };
      $[2] = comments.length;
      $[3] = t1;
    } else {
      t1 = $[3];
    }
    const onClick = t1;

    allUrls.push(...urls);
    t0 = <Media media={media} onClick={onClick} />;
    $[0] = post;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Defining a Functional Component with Compiler Runtime - JavaScript
DESCRIPTION: The second snippet imports a compiler runtime from React and defines a more complex version of the 'bar' function. It utilizes a state-like mechanism to store a value based on an input and conditionally updates the output based on the argument passed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function bar(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = [a];
    y = {};
    const f0 = function () {
      y = x[0][1];
    };

    f0();
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [["val1", "val2"]],
  isComponent: false,
};
```

----------------------------------------

TITLE: Utilizing Shared Runtime in React Component
DESCRIPTION: This snippet defines the useFoo function, which manages state and performs conditional reading of object properties using shared runtime utils like shallowCopy and mutate. Dependencies include shared-runtime and modules for deep copying and modifying objects. It takes an object as input and returns a JSX component conditionally based on the input properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-cond-access-local-var.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR

import {shallowCopy, mutate, Stringify} from 'shared-runtime';

function useFoo({
  a,
  shouldReadA,
}: {
  a: {b: {c: number}; x: number};
  shouldReadA: boolean;
}) {
  const local = shallowCopy(a);
  mutate(local);
  return (
    <Stringify
      fn={() => {
        if (shouldReadA) return local.b.c;
        return null;
      }}
      shouldInvokeFns={true}
    />
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: null, shouldReadA: true}],
  sequentialRenders: [
    {a: null, shouldReadA: true},
    {a: null, shouldReadA: false},
    {a: {b: {c: 4}}, shouldReadA: true},
  ],
};

```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Input source code showing a React function component that creates an array with logging functionality. Uses makeArray and print utilities from shared-runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray, print} from 'shared-runtime';

function useTest() {
  return makeArray<number | void>(
    print(1),
    (function foo() {
      print(2);
      return 2;
    })(),
  );
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [],
};
```

----------------------------------------

TITLE: Compiler-Transformed React Component with Memoization Logic
DESCRIPTION: The compiler-optimized version of the React component that implements memoization logic explicitly. It uses a cache array to store computed values and dependencies, avoiding unnecessary recalculations when inputs haven't changed. This demonstrates how React's compiler transforms useMemo hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-modify-global-in-callback-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";

const someGlobal = { value: 0 };

function Component(t0) {
  const $ = _c(4);
  const { value } = t0;
  let t1;
  if ($[0] !== value) {
    t1 = () => {
      someGlobal.value = value;
    };
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const onClick = t1;
  let t2;
  let t3;
  if ($[2] !== onClick) {
    t3 = <div onClick={onClick}>{someGlobal.value}</div>;
    $[2] = onClick;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  t2 = t3;
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 0 }],
  sequentialRenders: [
    { value: 1 },
    { value: 1 },
    { value: 42 },
    { value: 42 },
    { value: 0 },
  ],
};
```

----------------------------------------

TITLE: Implementing Object Mutation and Condition Checking in JavaScript
DESCRIPTION: This snippet defines functions for mutating objects and checking conditions, along with a test function that demonstrates object aliasing and mutation. It's designed to test React compiler behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mutable-lifetime-loops.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function mutate(x, y) {
  'use no forget';
  if (x != null) {
    x.value = (x.value ?? 0) + 1;
  }
  if (y != null) {
    y.value = (y.value ?? 0) + 1;
  }
}
function cond(x) {
  'use no forget';
  return x.value > 5;
}

function testFunction(props) {
  let a = {};
  let b = {};
  let c = {};
  let d = {};
  while (true) {
    let z = a;
    a = b;
    b = c;
    c = d;
    d = z;
    mutate(a, b);
    if (cond(a)) {
      break;
    }
  }

  // all of these tests are seemingly readonly, since the values are never directly
  // mutated again. but they are all aliased by `d`, which is later modified, and
  // these are therefore mutable references:
  if (a) {
  }
  if (b) {
  }
  if (c) {
  }
  if (d) {
  }

  mutate(d, null);
  return {a, b, c, d};
}

export const FIXTURE_ENTRYPOINT = {
  fn: testFunction,
  params: [{}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Input version of a React component that creates a Set from an array, applies mutations, and renders the result through a Stringify component. Uses useIdentity hook and handles dynamic value props.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-foreach-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutateAndReturn, Stringify, useIdentity} from 'shared-runtime';

function Component({value}) {
  const arr = [{value: 'foo'}, {value: 'bar'}, {value}];
  useIdentity();
  const derived = new Set(arr).forEach(mutateAndReturn);
  return <Stringify>{[...derived]}</Stringify>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 5}],
  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}, {value: 7}],
};
```

----------------------------------------

TITLE: Original JavaScript Function with Nested Conditionals
DESCRIPTION: A JavaScript function 'foo' that creates an array and conditionally pushes a value based on three parameters. The function returns the array if it has elements, otherwise null.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/extend-scopes-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let x = [];
  if (a) {
    if (b) {
      if (c) {
        x.push(0);
      }
    }
  }
  if (x.length) {
    return x;
  }
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized Destructuring
DESCRIPTION: This snippet shows the compiled version of the React component. It uses React's compiler runtime for optimized rendering. The compiled code implements the same functionality as the input, but with additional checks and caching mechanisms for performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-with-typecast-as-default-value.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const [t0] = props.y;
  let t1;
  if ($[0] !== t0) {
    t1 = t0 === undefined ? ([]: Array<number>) : t0;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ y: [] }],
};
```

----------------------------------------

TITLE: React Component with Compiled Memoization
DESCRIPTION: Implements a React functional component using React Compiler runtime with automatic memoization and cache management using compiler runtime symbols
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-effect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Foo() {
  const ref = useCustomRef();

  useEffect(() => {
    ref.current?.click();
  }, []);

  return <div>foo</div>;
}
```

----------------------------------------

TITLE: Using Destructuring and Symbols in React Component Function
DESCRIPTION: This JavaScript snippet uses destructuring and memoization with symbols within a React component-related function. It imports a function from 'react/compiler-runtime' and checks for a specific symbol to manage cached component data. The function outputs a destructured value and is exported for use in other modules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-string-literal-invalid-identifier-property-key.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { "data-foo-bar": 1 };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const { "data-foo-bar": t } = t0;
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Inferred Effect Dependencies
DESCRIPTION: The compiled version of the component with React compiler optimizations applied. The compiler has detected that 'arr' depends on 'propVal' and automatically added it to the dependency array. It also includes memoization logic to prevent unnecessary recreations of the array and effect callback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/reactive-variable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @inferEffectDependencies
import { useEffect } from "react";
import { print } from "shared-runtime";

function ReactiveVariable(t0) {
  const $ = _c(4);
  const { propVal } = t0;
  let t1;
  if ($[0] !== propVal) {
    t1 = [propVal];
    $[0] = propVal;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const arr = t1;
  let t2;
  if ($[2] !== arr) {
    t2 = () => print(arr);
    $[2] = arr;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  useEffect(t2, [arr]);
}
```

----------------------------------------

TITLE: Compiler-Optimized React Component with Memoization
DESCRIPTION: The transformed version of the App component with the @lowerContextAccess directive applied. The React compiler has added memoization to avoid recreating the Bar component when its props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo.lower-context-access-destructure-multiple.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @lowerContextAccess
function App() {
  const $ = _c(3);
  const context = useContext(MyContext);
  const { foo } = context;
  const { bar } = context;
  let t0;
  if ($[0] !== bar || $[1] !== foo) {
    t0 = <Bar foo={foo} bar={bar} />;
    $[0] = bar;
    $[1] = foo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
```

----------------------------------------

TITLE: React Compiler Transformed Hook with Memoization
DESCRIPTION: The React Compiler transformed version of the hook that implements memoization based on prop dependencies. It tracks props.a as the dependency and uses an array for memoization state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/superpath-order1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // When an unconditional dependency `props.a` is the subpath of a conditional
// dependency `props.a.b`, we can safely overestimate and only track `props.a`
// as a dependency

import { identity } from "shared-runtime";

// ordering of accesses should not matter
function useConditionalSuperpath1(t0) {
  const $ = _c(3);
  const { props, cond } = t0;
  let x;
  if ($[0] !== cond || $[1] !== props.a) {
    x = {};
    x.a = props.a;
    if (identity(cond)) {
      x.b = props.a.b;
    }
    $[0] = cond;
    $[1] = props.a;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useConditionalSuperpath1,
  params: [{ props: { a: null }, cond: false }],
  sequentialRenders: [
    { props: { a: null }, cond: false },
    { props: { a: {} }, cond: true },
    { props: { a: { b: 3 } }, cond: true },
    { props: {}, cond: false },
    // test that we preserve nullthrows
    { props: { a: { b: undefined } }, cond: true },
    { props: { a: undefined }, cond: true },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component that includes React's internal memoization logic using compiler-runtime. Implements caching mechanism to avoid recreating the return array if inputs haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-array-pattern.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(foo, ...t0) {
  const $ = _c(3);
  const [bar] = t0;
  let t1;
  if ($[0] !== bar || $[1] !== foo) {
    t1 = [foo, bar];
    $[0] = bar;
    $[1] = foo;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["foo", ["bar", "baz"]],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with added memoization logic using the _c compiler runtime. Implements caching for computed values to optimize performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-var-array_.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.id) {
    t0 = makeArray(props.id);
    $[0] = props.id;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  let t1;
  if ($[2] !== x) {
    t1 = x.at(0);
    $[2] = x;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const y = t1;
  return y;
}

function makeArray(x) {
  const $ = _c(2);
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 42 }],
};
```

----------------------------------------

TITLE: Error during Code Generation
DESCRIPTION: This snippet demonstrates an error encountered during code generation.  The error arises when attempting to use the return value of `items.push(5)` directly within the arguments of `Math.max`. The error message indicates that the `property` of `MethodCall` must be an unpromoted, unmemoized MemberExpression.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-nested-method-calls-lower-property-load-into-temporary.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  4 | function Component({}) {
  5 |   const items = makeArray(0, 1, 2, null, 4, false, 6);
> 6 |   const max = Math.max(2, items.push(5), ...other);
    |               ^^^^^^^^ Invariant: [Codegen] Internal error: MethodCall::property must be an unpromoted + unmemoized MemberExpression. Got a `Identifier` (6:6)
  7 |   return max;
  8 | }
  9 |
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with memoization cache implementation. Shows how the compiler transforms useCallback and component rendering with cache sentinel checks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-ref-in-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useCallback, useRef } from "react";

function Foo() {
  const $ = _c(2);
  const ref = useRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => ref.current;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const s = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <A r={s} />;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

function A(t0) {
  const $ = _c(1);
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <div />;
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled output showing how React transforms the component to include memoization using Symbol.for('react.memo_cache_sentinel'). Implements caching logic to avoid unnecessary recomputation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/codegen-inline-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray, print } from "shared-runtime";

function useTest() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const t1 = print(1);
    let t2;

    print(2);
    t2 = 2;
    t0 = makeArray(t1, t2);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useTest,
  params: [],
};
```

----------------------------------------

TITLE: Compiler-Optimized React Component
DESCRIPTION: The compiler-transformed version of the component using React's memo cache sentinel for optimization. It implements caching logic to avoid recreating and mutating the array on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/do-while-early-unconditional-break.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = [1, 2, 3];

    mutate(x);
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}
```

----------------------------------------

TITLE: React Component with Compiler Runtime Memoization (Output)
DESCRIPTION: Demonstrates the optimized `Component` function using `react/compiler-runtime`. It uses `_c` to create a cache ($) and checks if the cache is empty. If it is, the component renders and caches the result. Subsequent calls reuse the cached result, improving performance. This snippet relies on `react/compiler-runtime` and assumes `MaybeMutable` and `maybeMutate` are defined elsewhere.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/builtin-jsx-tag-lowered-between-mutations.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const maybeMutable = new MaybeMutable();
    t0 = <div>{maybeMutate(maybeMutable)}</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet presents the compiler-optimized version of the component. It introduces memoization to avoid unnecessary recalculations and uses a special _c function for caching. The optimized version aims to improve performance while maintaining the same functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-expression-computed-key-non-reactive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

const SCALE = 2;

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.value) {
    t0 = identity([props.value]);
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = { [SCALE]: t0 };
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const context = t1;
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ key: "Sathya", value: "Compiler" }],
};
```

----------------------------------------

TITLE: Optimized React Component Implementation
DESCRIPTION: This snippet shows an optimized version of the Component, likely generated by a React compiler. It uses memoization techniques to minimize re-renders and improve performance, while maintaining the same functionality as the original component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture-namespace-import.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useMemo } from "react";
import * as SharedRuntime from "shared-runtime";

export function Component(t0) {
  const $ = _c(27);
  const { a, b } = t0;
  let t1;
  let t2;
  if ($[0] !== a) {
    t2 = { a };
    $[0] = a;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const item1 = t1;
  let t3;
  let t4;
  if ($[2] !== b) {
    t4 = { b };
    $[2] = b;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  t3 = t4;
  const item2 = t3;
  let t5;
  let items;
  if ($[4] !== item1 || $[5] !== item2) {
    items = [];
    SharedRuntime.typedArrayPush(items, item1);
    SharedRuntime.typedArrayPush(items, item2);
    $[4] = item1;
    $[5] = item2;
    $[6] = items;
  } else {
    items = $[6];
  }
  t5 = items;
  const items_0 = t5;
  let t6;
  if ($[7] !== a) {
    t6 = [a];
    $[7] = a;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  if ($[9] !== items_0[0] || $[10] !== t6) {
    t7 = <SharedRuntime.ValidateMemoization inputs={t6} output={items_0[0]} />;
    $[9] = items_0[0];
    $[10] = t6;
    $[11] = t7;
  } else {
    t7 = $[11];
  }
  let t8;
  if ($[12] !== b) {
    t8 = [b];
    $[12] = b;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  let t9;
  if ($[14] !== items_0[1] || $[15] !== t8) {
    t9 = <SharedRuntime.ValidateMemoization inputs={t8} output={items_0[1]} />;
    $[14] = items_0[1];
    $[15] = t8;
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  let t10;
  if ($[17] !== a || $[18] !== b) {
    t10 = [a, b];
    $[17] = a;
    $[18] = b;
    $[19] = t10;
  } else {
    t10 = $[19];
  }
  let t11;
  if ($[20] !== items_0 || $[21] !== t10) {
    t11 = <SharedRuntime.ValidateMemoization inputs={t10} output={items_0} />;
    $[20] = items_0;
    $[21] = t10;
    $[22] = t11;
  } else {
    t11 = $[22];
  }
  let t12;
  if ($[23] !== t11 || $[24] !== t7 || $[25] !== t9) {
    t12 = (
      <>
        {t7}
        {t9}
        {t11}
      </>
    );
    $[23] = t11;
    $[24] = t7;
    $[25] = t9;
    $[26] = t12;
  } else {
    t12 = $[26];
  }
  return t12;
}
```

----------------------------------------

TITLE: Optimized and Transformed React Component
DESCRIPTION: This snippet shows the optimized and transformed version of the React component. It uses the '_c' function from 'react/compiler-runtime' for memoization and implements efficient rendering of child components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/maybe-mutate-object-in-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { mutate } = require("shared-runtime");

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const object = {};

    t0 = () => {
      mutate(object);
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onClick = t0;
  let t1;
  if ($[1] !== props.children) {
    t1 = <Foo callback={onClick}>{props.children}</Foo>;
    $[1] = props.children;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Foo(t0) {
  const { children } = t0;
  return children;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ children: <div>Hello</div> }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Logic
DESCRIPTION: Compiled version of the React component showing the implementation of memoization cache using Symbols and conditional rendering. Includes compiler-specific optimizations and caching mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-nested-property.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useCallback, useRef } from "react";

// Identical to useCallback-set-ref-nested-property-preserve-memoization,
// but with a different set of compiler flags
function Component(t0) {
  const $ = _c(3);
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = { inner: null };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const ref = useRef(t1);
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (event) => {
      ref.current.inner = event.target.value;
    };
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const onChange = t2;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = <input onChange={onChange} />;
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Custom Ref and Callback Implementation
DESCRIPTION: This snippet shows the compiled and optimized version of the custom ref and callback implementation. It includes compiler-specific optimizations and memoization techniques.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-useCallback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableTreatRefLikeIdentifiersAsRefs @validatePreserveExistingMemoizationGuarantees
import { useRef, useCallback } from "react";

function useCustomRef() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { click: _temp };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return useRef(t0);
}
function _temp() {}

function Foo() {
  const $ = _c(2);
  const customRef = useCustomRef();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      customRef.current?.click();
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onClick = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <button onClick={onClick} />;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This is the compiled version of the `Component` function using the React compiler. It demonstrates memoization and optimization techniques, using `_c` for component creation and state management. The code includes checks to avoid re-rendering if the props haven't changed, improving performance by caching previous results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-dup-key-diff-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableJsxOutlining
function Component(t0) {
  const $ = _c(7);
  const { arr } = t0;
  const x = useX();
  let t1;
  if ($[0] !== arr || $[1] !== x) {
    let t2;
    if ($[3] !== x) {
      t2 = (i, id) => {
        const T0 = _temp;
        return <T0 i={i + "i"} k={i + "j"} key={id} x={x} />;
      };
      $[3] = x;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    t1 = arr.map(t2);
    $[0] = arr;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = <>{t1}</>;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
function _temp(t0) {
  const $ = _c(8);
  const { i: i, k: k, x: x } = t0;
  let t1;
  if ($[0] !== i) {
    t1 = <Baz i={i} />;
    $[0] = i;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== k) {
    t2 = <Foo k={k} />;
    $[2] = k;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1 || $[5] !== t2 || $[6] !== x) {
    t3 = (
      <Bar x={x}>
        {t1}
        {t2}
      </Bar>
    );
    $[4] = t1;
    $[5] = t2;
    $[6] = x;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
}

function Bar(t0) {
  const $ = _c(3);
  const { x, children } = t0;
  let t1;
  if ($[0] !== children || $[1] !== x) {
    t1 = (
      <>
        {x}
        {children}
      </>
    );
    $[0] = children;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Baz(t0) {
  const { i } = t0;
  return i;
}

function Foo(t0) {
  const { k } = t0;
  return k;
}

function useX() {
  return "x";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arr: ["foo", "bar"] }],
};

```

----------------------------------------

TITLE: Defining Native Log Function without Compiler Runtime
DESCRIPTION: This snippet defines the 'getNativeLogFunction' which returns a custom logging function based on the provided log level. It processes log messages, adjusts log levels based on specific conditions, and handles multiple arguments appropriately.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-param-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function getNativeLogFunction(level) {
  return function () {
    let str;
    if (arguments.length === 1 && typeof arguments[0] === 'string') {
      str = arguments[0];
    } else {
      str = Array.prototype.map
        .call(arguments, function (arg) {
          return inspect(arg, {
            depth: 10,
          });
        })
        .join(', ');
    }
    const firstArg = arguments[0];
    let logLevel = level;
    if (
      typeof firstArg === 'string' &&
      firstArg.slice(0, 9) === 'Warning: ' &&
      logLevel >= LOG_LEVELS.error
    ) {
      logLevel = LOG_LEVELS.warn;
    }
    if (global.__inspectorLog) {
      global.__inspectorLog(
        INSPECTOR_LEVELS[logLevel],
        str,
        [].slice.call(arguments),
        INSPECTOR_FRAMES_TO_SKIP
      );
    }
    if (groupStack.length) {
      str = groupFormat('', str);
    }
    global.nativeLoggingHook(str, logLevel);
  };
}

```

----------------------------------------

TITLE: Defining and Exporting JavaScript Function with Unusual Loop
DESCRIPTION: This snippet defines a function 'foo' with a loop that will never execute, and exports a fixture object for testing. The function initializes a variable, contains a non-executing loop, and returns the initialized value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-for.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let y = 0;
  for (const x = 100; x < 10; x) {
    y = y + 1;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized React Component with Fire and Memoization - JavaScript
DESCRIPTION: This snippet defines a more optimized version of a React component that uses memoization to prevent unnecessary reassignments of functions and additional calls to fire. It tracks previous values and conditions before executing effects.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/shared-hook-calls.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c, useFire } from "react/compiler-runtime"; // @enableFire
import { fire } from "react";

function Component(t0) {
  const $ = _c(9);
  const { bar, baz } = t0;
  let t1;
  if ($[0] !== bar) {
    t1 = () => {
      console.log(bar);
    };
    $[0] = bar;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const foo = t1;
  const t2 = useFire(foo);
  const t3 = useFire(baz);
  let t4;
  if ($[2] !== bar || $[3] !== t2 || $[4] !== t3) {
    t4 = () => {
      t2(bar);
      t3(bar);
    };
    $[2] = bar;
    $[3] = t2;
    $[4] = t3;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  useEffect(t4);
  let t5;
  if ($[6] !== bar || $[7] !== t2) {
    t5 = () => {
      t2(bar);
    };
    $[6] = bar;
    $[7] = t2;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  useEffect(t5);
  return null;
}

```

----------------------------------------

TITLE: Running ESLint Tests with Yarn
DESCRIPTION: This shell script snippet provides commands to set up and test the eslint-plugin-react-hooks with ESLint version 7. It includes changing the directory to the appropriate fixture and uses yarn to install dependencies, build the project, and run the linter. There are no specific dependencies mentioned outside of yarn and an appropriate ESLint version.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/eslint-v7/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
cd fixtures/eslint-v7
yarn
yarn build
yarn lint
```

----------------------------------------

TITLE: React Compiler Transformed Function with Memoization
DESCRIPTION: The output JavaScript code after React compiler processing, showing how the function is transformed to use memoization. It employs a cache sentinel symbol to check if the computation has been done before, storing and retrieving the result accordingly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let y;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [];
    y = {};
    y.x = x;
    mutate(y);
    $[0] = y;
  } else {
    y = $[0];
  }
  return y;
}
```

----------------------------------------

TITLE: React Rendering Mutation Error
DESCRIPTION: An error message indicating that updating an object previously used in JSX rendering is not permitted in React, suggesting moving the mutation before JSX rendering
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-computed-store-to-frozen-value.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  3 |   // freeze
  4 |   <div>{x}</div>;
> 5 |   x[0] = true;
    |   ^ InvalidReact: Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX (5:5)
  6 |   return x;
  7 | }
```

----------------------------------------

TITLE: Implementing React Fixture with Empty Function
DESCRIPTION: Defines an empty function 'foo' and exports it as a fixture entrypoint. The configuration specifies it's not a React component and has no parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimizations
DESCRIPTION: The compiled version of the component using React compiler runtime with memoization optimization. Includes Symbol-based cache checking for improved performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/meta-isms/repro-cx-namespace-nesting.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeArray } from "shared-runtime";

function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const items = makeArray("foo", "bar", "", null, "baz", false, "merp");
    const classname = cx.namespace(...items.filter(isNonEmptyString));
    t0 = <div className={classname}>Ok</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function isNonEmptyString(s) {
  return typeof s === "string" && s.trim().length !== 0;
}

const cx = {
  namespace(...items) {
    return items.join(" ");
  },
};

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Implementing Triple Nested While Loops with Static Return in React Test Fixture
DESCRIPTION: This code defines a JavaScript function 'foo' with triple nested while loops without any internal operations. The function always returns 0 and is exported as a test fixture entrypoint with a 'TodoAdd' component parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-loops-no-reassign.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @xonly
function foo(a, b, c) {
  while (a) {
    while (b) {
      while (c) {}
    }
  }
  return 0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Creating Object with Special Character Properties - Input Version
DESCRIPTION: Original function that creates and returns an object with property names containing special characters like dots, backslashes, slashes, plus signs and spaces.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-non-identifier-object-keys.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {
  return {
    'a.b': 1,
    'a\b': 2,
    'a/b': 3,
    'a+b': 4,
    'a b': 5,
  };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Fixture Entrypoint Configuration
DESCRIPTION: A configuration object for a React fixture, specifying the function, parameters, and component identifier. Used for testing or component initialization purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-partial-reassignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd"
};
```

----------------------------------------

TITLE: Creating a Simple React Component with String Content
DESCRIPTION: Defines a React component 'Foo' that renders a div containing a comma character, along with an export for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-jsxtext-stringliteral-distinction.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {
  return <div> {', '}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Memoizing Components with React Compiler Runtime - JavaScript
DESCRIPTION: This snippet imports from 'react/compiler-runtime' to handle component memoization. It defines the 'Component' function to manipulate array reactivity using special compiler symbols. Dependencies include React, and 'props' with a 'cond' property. The memoization logic checks for a sentinel symbol to cache component outputs, returning a memoized 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-while.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);

  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(null);

  const c = [a];

  let x;
  while (c[0][0]) {
    x = 1;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};

```

----------------------------------------

TITLE: Exporting FIXTURE_ENTRYPOINT for React Component Testing
DESCRIPTION: This code exports a FIXTURE_ENTRYPOINT object that contains the Component function, parameters, and a flag indicating it's a component. This is likely used for testing or fixture setup in the React project.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dominator.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Compiled React Function with Memoization
DESCRIPTION: Compiled version of the function that includes React's memoization logic using Symbol.for() check. Uses compiler runtime utilities and implements caching mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations-complex-lvalue-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let a;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    a = [[1]];
    const first = a.at(0);
    first.set(0, 2);
    $[0] = a;
  } else {
    a = $[0];
  }
  return a;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing fire in React Component using JavaScript
DESCRIPTION: This code defines a React functional component that uses the 'fire' function to log props. It incorporates useEffect but causes an error due to invalid argument spread for the fire function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-spread.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = () => {
    console.log(props);
  };
  useEffect(() => {
    fire(...foo);
  });

  return null;
}

```

----------------------------------------

TITLE: Defining React Component 'Foo' with Conditional Assignment
DESCRIPTION: This snippet defines a React functional component 'Foo' that conditionally assigns an empty array to variable 'x'. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-logical.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo(props) {
  let x;
  true && ((x = []), null);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: React Component with new.target
DESCRIPTION: This code snippet defines a React component that attempts to access `new.target` within a function `foo` and pass it as a value to the `Stringify` component. The `Stringify` component (imported from `shared-runtime`) is used to render the value of `new.target`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-new-target-meta-property.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify} from 'shared-runtime';

function foo() {
  const nt = new.target;
  return <Stringify value={nt} />;
}

```

----------------------------------------

TITLE: Compiled React Component with Memoization Logic
DESCRIPTION: This snippet shows the compiled version of the React component with detailed memoization logic. It uses a cache array ($) to store previous values and conditionally updates variables and renders components based on changed inputs. The compilation adds granular memoization checks for optimal performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dont-merge-if-dep-is-inner-declaration-of-previous-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { ValidateMemoization } from "shared-runtime";

// Achieving Forget's level of memoization precision in this example isn't possible with useMemo
// without significantly altering the code, so disable the non-Forget evaluation of this fixture.
// @disableNonForgetInSprout
function Component(t0) {
  const $ = _c(25);
  const { a, b, c } = t0;
  let x;
  let y;
  if ($[0] !== a || $[1] !== b || $[2] !== c) {
    x = [];
    if (a) {
      let t1;
      if ($[5] !== b) {
        t1 = [b];
        $[5] = b;
        $[6] = t1;
      } else {
        t1 = $[6];
      }
      y = t1;
    }

    x.push(c);
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = x;
    $[4] = y;
  } else {
    x = $[3];
    y = $[4];
  }
  let t1;
  if ($[7] !== y) {
    t1 = [y];
    $[7] = y;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  const z = t1;
  let t2;
  if ($[9] !== a || $[10] !== b || $[11] !== c) {
    t2 = [a, b, c];
    $[9] = a;
    $[10] = b;
    $[11] = c;
    $[12] = t2;
  } else {
    t2 = $[12];
  }
  let t3;
  if ($[13] !== t2 || $[14] !== x) {
    t3 = <ValidateMemoization inputs={t2} output={x} />;
    $[13] = t2;
    $[14] = x;
    $[15] = t3;
  } else {
    t3 = $[15];
  }
  let t4;
  if ($[16] !== a || $[17] !== b) {
    t4 = [a, b];
    $[16] = a;
    $[17] = b;
    $[18] = t4;
  } else {
    t4 = $[18];
  }
  let t5;
  if ($[19] !== t4 || $[20] !== z) {
    t5 = <ValidateMemoization inputs={t4} output={z} />;
    $[19] = t4;
    $[20] = z;
    $[21] = t5;
  } else {
    t5 = $[21];
  }
  let t6;
  if ($[22] !== t3 || $[23] !== t5) {
    t6 = (
      <>
        {t3}
        {t5}
      </>
    );
    $[22] = t3;
    $[23] = t5;
    $[24] = t6;
  } else {
    t6 = $[24];
  }
  return t6;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: false, b: null, c: 0 }],
  sequentialRenders: [
    { a: false, b: null, c: 0 },
    { a: false, b: null, c: 1 },
    { a: true, b: 0, c: 1 },
    { a: true, b: 1, c: 1 },
  ],
};
```

----------------------------------------

TITLE: Compiled Output of useBar Hook
DESCRIPTION: React compiler-generated code showing the memoized implementation of the useBar hook. Includes compiler runtime imports and memoization logic using an array-based cache system.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-spread-mutable-iterator.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";

function useBar(t0) {
  "use memo";
  const $ = _c(2);
  const { arg } = t0;
  let t1;
  if ($[0] !== arg) {
    const s = new Set([1, 5, 4]);
    const mutableIterator = s.values();

    t1 = [arg, ...mutableIterator];
    $[0] = arg;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useBar,
  params: [{ arg: 3 }],
  sequentialRenders: [{ arg: 3 }, { arg: 3 }, { arg: 4 }],
};
```

----------------------------------------

TITLE: React Compiler Output with Memoization Logic
DESCRIPTION: The transformed output from React's compiler showing how memoization is implemented. It uses a cache sentinel and tracks dependencies to avoid recreating objects when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-type-inference-property-store.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @debug
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  let t1;
  if ($[1] !== props.a || $[2] !== props.cond) {
    let y;
    if (props.cond) {
      y = {};
    } else {
      y = { a: props.a };
    }

    y.x = x;

    t1 = [x, y];
    $[1] = props.a;
    $[2] = props.cond;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: false, a: "a!" }],
};
```

----------------------------------------

TITLE: Compiled React Components with Memoization (Output)
DESCRIPTION: Transformed React components with memoization applied using the React compiler runtime. The code uses the '_c' function to create a cache array and checks if values are already computed using a special Symbol. This optimization prevents redundant recursive calculations on re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/recursive-function-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component1() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = callback(10);
    function callback(x_0) {
      if (x_0 == 0) {
        return null;
      }
      return callback(x_0 - 1);
    }
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    function callback(x) {
      if (x == 0) {
        return null;
      }
      return callback(x - 1);
    }

    t0 = callback(10);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Compiled React Code with Reactive Dependency Tracking - JavaScript
DESCRIPTION: The compiled output from React's compiler showing how it optimizes the component by tracking props.a.b as a dependency. It uses the _c function from react/compiler-runtime to memoize calculations based on dependency changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/cfg-switch-exhaustive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths

import { identity } from "shared-runtime";

function useCondDepInSwitch(props, other) {
  const $ = _c(3);
  let x;
  if ($[0] !== other || $[1] !== props.a.b) {
    x = {};
    bb0: switch (identity(other)) {
      case 1: {
        x.a = props.a.b;
        break bb0;
      }
      case 2: {
        x.b = props.a.b;
        break bb0;
      }
      default: {
        x.c = props.a.b;
      }
    }
    $[0] = other;
    $[1] = props.a.b;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useCondDepInSwitch,
  params: [{ a: { b: 2 } }, 2],
};
```

----------------------------------------

TITLE: React Component with useMemo - Compiled Output
DESCRIPTION: Compiled version of the React component showing how useMemo is transformed into explicit memoization checks using compiler runtime utilities. Demonstrates the internal implementation of memoization caching.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/optional-member-expression-inverted-optionals-parallel-paths.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies @enablePropagateDepsInHIR
import { ValidateMemoization } from "shared-runtime";
function Component(props) {
  const $ = _c(2);
  let t0;

  const x$0 = [];
  x$0.push(props?.a.b?.c.d?.e);
  x$0.push(props.a?.b.c?.d.e);
  t0 = x$0;
  let t1;
  if ($[0] !== props.a.b.c.d.e) {
    t1 = <ValidateMemoization inputs={[props.a.b.c.d.e]} output={x} />;
    $[0] = props.a.b.c.d.e;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Defining Component with Context Variable Mutation in JavaScript
DESCRIPTION: This snippet defines a function Component that accepts an object with properties foo and bar, demonstrating state management through mutation. It uses the makeArray function to alter the context of a variable y. The primary functionality revolves around capturing local variables and managing state effectively using shared utilities from 'shared-runtime'. It takes an object with properties foo and bar as input and returns the modified y object. Key dependency includes 'shared-runtime'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-capturing-func-maybealias-captured-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray, mutate} from 'shared-runtime';

/**
 * Bug repro:
 * Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok)
 *   {"bar":4,"x":{"foo":3,"wat0":"joe"}}
 *   {"bar":5,"x":{"foo":3,"wat0":"joe"}}
 *   Forget:
 *   (kind: ok)
 *   {"bar":4,"x":{"foo":3,"wat0":"joe"}}
 *   {"bar":5,"x":{"foo":3,"wat0":"joe","wat1":"joe"}}
 *
 * Fork of `capturing-func-alias-captured-mutate`, but instead of directly
 * aliasing `y` via `[y]`, we make an opaque call.
 *
 * Note that the bug here is that we don't infer that `a = makeArray(y)`
 * potentially captures a context variable into a local variable. As a result,
 * we don't understand that `a[0].x = b` captures `x` into `y` -- instead, we're
 * currently inferring that this lambda captures `y` (for a potential later
 * mutation) and simply reads `x`.
 *
 * Concretely `InferReferenceEffects.hasContextRefOperand` is incorrectly not
 * used when we analyze CallExpressions.
 */
function Component({foo, bar}: {foo: number; bar: number}) {
  let x = {foo};
  let y: {bar: number; x?: {foo: number}} = {bar};
  const f0 = function () {
    let a = makeArray(y); // a = [y]
    let b = x;
    // this writes y.x = x
    a[0].x = b;
  };
  f0();
  mutate(y.x);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{foo: 3, bar: 4}],
  sequentialRenders: [
    {foo: 3, bar: 4},
    {foo: 3, bar: 5},
  ],
};
```

----------------------------------------

TITLE: Defining a Simple Function - JavaScript
DESCRIPTION: The first snippet defines a simple function 'bar' that takes an argument, creates an array and an object, and returns a value contained in the array. It doesn't use any external libraries or dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function bar(a) {
  let x = [a];
  let y = {};
  const f0 = function () {
    y = x[0][1];
  };
  f0();

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: [['val1', 'val2']],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized React Compiler Output for Object Destructuring and Array Creation
DESCRIPTION: This snippet shows the React compiler's optimized version of the 'foo' function. It uses memoization techniques to cache the object and resulting array, potentially improving performance in repeated calls.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-mixed-property-key-types.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(2);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { "data-foo-bar": 1, a: 2, data: 3 };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const { "data-foo-bar": x, a: y, data: z } = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [x, y, z];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Error Message related to fire and useEffect
DESCRIPTION: This error message indicates an issue with the dependency array used in conjunction with the `fire` function within a `useEffect` hook. Specifically, it arises when you attempt to use the spread operator (`...`) with `fire` and effect dependencies, signaling that an array literal must be used.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-rewrite-deps-spread.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  13 |       fire(foo(props));
  14 |     },
> 15 |     ...deps
     |        ^^^^ Invariant: Cannot compile `fire`. You must use an array literal for an effect dependency array when that effect uses `fire()` (15:15)
  16 |   );
  17 |
  18 |   return null;
```

----------------------------------------

TITLE: React Compiler Output for useMakeCallback Hook with Optimized Memoization
DESCRIPTION: The React compiler's output for the useMakeCallback hook, showing how it implements memoization for nested callbacks. The compiler adds cache checks to avoid recreating functions when dependencies haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/assume-invoked/function-with-conditional-callsite-in-another-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper } from "shared-runtime";

/**
 * (Given that the returned lambda is assumed to be invoked, see
 * return-function)
 *
 * If lambda A conditionally calls lambda B, optimistically assume that property
 * loads from lambda B has the same hoistability of ones from lambda A. This
 * helps optimize components / hooks that create and chain many helper
 * functions.
 *
 * Type systems and code readability encourage developers to colocate length and
 * null checks values in the same function as where values are used. i.e.
 * developers are unlikely to write the following code.
 * ```js
 * function useFoo(obj, objNotNullAndHasElements) {
 *   // ...
 *   const get0th = () => obj.arr[0].value;
 *   return () => objNotNullAndHasElements ? get0th : undefined;
 * }
 * ```
 *
 * In Meta code, this assumption helps reduce the number of memo dependency
 * deopts.
 */
function useMakeCallback(t0) {
  const $ = _c(6);
  const { obj, cond, setState } = t0;
  let t1;
  if ($[0] !== obj.value || $[1] !== setState) {
    t1 = () => setState(obj.value);
    $[0] = obj.value;
    $[1] = setState;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const cb = t1;
  let t2;
  if ($[3] !== cb || $[4] !== cond) {
    t2 = () => (cond ? cb() : undefined);
    $[3] = cb;
    $[4] = cond;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}

const setState = (arg: number) => {
  "use no memo";
  return arg;
};
export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useMakeCallback),
  params: [{ obj: { value: 1 }, cond: true, setState }],
  sequentialRenders: [
    { obj: { value: 1 }, cond: true, setState },
    { obj: { value: 2 }, cond: true, setState },
  ],
};
```

----------------------------------------

TITLE: Memoized React Component with Conditional Array Manipulation (Code)
DESCRIPTION: This code snippet shows a memoized version of the React component.  It uses `react/compiler-runtime`'s `_c` function for memoization. It conditionally initializes `y` and then pushes `x` into it. The memoization logic caches and reuses previous renders based on `props.cond`, `props.cond2`, `props.value`, and `props.value2`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-array-push-consecutive-phis.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
import { makeArray } from "shared-runtime";

function Component(props) {
  const $ = _c(6);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  let t1;
  if (
    $[1] !== props.cond ||
    $[2] !== props.cond2 ||
    $[3] !== props.value ||
    $[4] !== props.value2
  ) {
    let y;
    if (props.cond) {
      if (props.cond2) {
        y = [props.value];
      } else {
        y = [props.value2];
      }
    } else {
      y = [];
    }

    y.push(x);

    t1 = [x, y];
    $[1] = props.cond;
    $[2] = props.cond2;
    $[3] = props.value;
    $[4] = props.value2;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, cond2: true, value: 42 }],
  sequentialRenders: [
    { cond: true, cond2: true, value: 3.14 },
    { cond: true, cond2: true, value: 42 },
    { cond: true, cond2: true, value: 3.14 },
    { cond: true, cond2: false, value2: 3.14 },
    { cond: true, cond2: false, value2: 42 },
    { cond: true, cond2: false, value2: 3.14 },
    { cond: false },
    { cond: false },
  ],
};

```

----------------------------------------

TITLE: Compiled: React Compiler Memoized Implementation
DESCRIPTION: Compiled version of the function with React Compiler's memoization logic. It uses the _c runtime function to track changes to props.a.b and props.a.c separately, only recreating the object when those values change.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-nonoverlap-direct.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Test that we can track non-overlapping dependencies separately.
// (not needed for correctness but for dependency granularity)
function TestNonOverlappingTracked(props) {
  const $ = _c(3);
  let x;
  if ($[0] !== props.a.b || $[1] !== props.a.c) {
    x = {};
    x.b = props.a.b;
    x.c = props.a.c;
    $[0] = props.a.b;
    $[1] = props.a.c;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: TestNonOverlappingTracked,
  params: [{ a: { b: 2, c: 3 } }],
};
```

----------------------------------------

TITLE: React Component with Unknown Hooks Implementation
DESCRIPTION: A React component implementation demonstrating the use of unknown hooks where Forget bailout behavior occurs when detecting potential mutations to immutable values. The component chains two unknown hooks together, passing props through the first hook and its result to the second hook.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unknown-hooks-do-not-assert.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Forget currently bails out when it detects a potential mutation (Effect.Mutate)
// to an immutable value. This should not apply to unknown / untyped hooks.
function Component(props) {
  const x = useUnknownHook1(props);
  const y = useUnknownHook2(x);
  return y;
}
```

----------------------------------------

TITLE: React Component Compiled Output
DESCRIPTION: Compiled version of the component with React compiler runtime optimizations, implementing memoization using an internal state array and explicit value tracking.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/context-variable-reactive-implicit-control-flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { conditionalInvoke } from "shared-runtime";

// same as context-variable-reactive-explicit-control-flow.js, but make
// the control flow implicit

function Component(t0) {
  const $ = _c(2);
  const { shouldReassign } = t0;
  let x;
  if ($[0] !== shouldReassign) {
    x = null;
    const reassign = () => {
      x = 2;
    };

    conditionalInvoke(shouldReassign, reassign);
    $[0] = shouldReassign;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ shouldReassign: true }],
  sequentialRenders: [{ shouldReassign: false }, { shouldReassign: true }],
};
```

----------------------------------------

TITLE: Compiled React Set Operations with Memoization
DESCRIPTION: Compiled version of the Set operations hook with React's memoization implementation. Shows how React internally handles caching of values and Set operations using compiler runtime utilities.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/global-types/set-constructor-arg.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const MODULE_LOCAL = new Set([4, 5, 6]);
function useFoo(t0) {
  const $ = _c(15);
  const { propArr } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [1, 2, 3];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let s1;
  if ($[1] !== propArr[0]) {
    s1 = new Set(t1);
    s1.add(propArr[0]);
    $[1] = propArr[0];
    $[2] = s1;
  } else {
    s1 = $[2];
  }
  let s2;
  let s3;
  if ($[3] !== propArr[1] || $[4] !== propArr[2]) {
    s2 = new Set(MODULE_LOCAL.values());
    s2.add(propArr[1]);

    s3 = new Set(s2.values());
    s3.add(propArr[2]);
    $[3] = propArr[1];
    $[4] = propArr[2];
    $[5] = s2;
    $[6] = s3;
  } else {
    s2 = $[5];
    s3 = $[6];
  }
  let s4;
  if ($[7] !== propArr[3] || $[8] !== s3) {
    s4 = new Set(s3);
    s4.add(propArr[3]);
    $[7] = propArr[3];
    $[8] = s3;
    $[9] = s4;
  } else {
    s4 = $[9];
  }
  let t2;
  if ($[10] !== s1 || $[11] !== s2 || $[12] !== s3 || $[13] !== s4) {
    t2 = [s1, s2, s3, s4];
    $[10] = s1;
    $[11] = s2;
    $[12] = s3;
    $[13] = s4;
    $[14] = t2;
  } else {
    t2 = $[14];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ propArr: [7, 8, 9] }],
  sequentialRenders: [{ propArr: [7, 8, 9] }, { propArr: [7, 8, 10] }],
};
```

----------------------------------------

TITLE: Compiler-Optimized React Component
DESCRIPTION: The compiler-optimized version of the component that implements memoization using React's compiler runtime. It caches the computed array using a Symbol-based sentinel value to avoid recalculation on subsequent renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-simple.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = [];
    const items = [0, 1, 2];
    for (const ii of items) {
      x.push(ii * 2);
    }
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimizing React Component with Memoization - JavaScript
DESCRIPTION: This snippet enhances a React component with memoization to prevent unnecessary re-renders based on prop values. It utilizes the React compiler runtime for caching and early return logic, allowing it to optimize performance. The code checks if input properties have changed and manages state accordingly, providing an expected output from various prop combinations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/early-return-nested-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(7);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b || $[2] !== props.cond) {
    t0 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const x = [];
      if (props.cond) {
        x.push(props.a);
        if (props.b) {
          let t1;
          if ($[4] !== props.b) {
            t1 = [props.b];
            $[4] = props.b;
            $[5] = t1;
          } else {
            t1 = $[5];
          }
          const y = t1;
          x.push(y);
          t0 = x;
          break bb0;
        }

        t0 = x;
        break bb0;
      } else {
        let t1;
        if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
          t1 = foo();
          $[6] = t1;
        } else {
          t1 = $[6];
        }
        t0 = t1;
        break bb0;
      }
    }
    $[0] = props.a;
    $[1] = props.b;
    $[2] = props.cond;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  if (t0 !== Symbol.for("react.early_return_sentinel")) {
    return t0;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true, a: 42, b: 3.14 }],
};
```

----------------------------------------

TITLE: Reactive Store Implementation in React Component
DESCRIPTION: Utilizes a custom reactive store to manage component state through the React `compiler-runtime`. It represents a variation of managing component reactivity by incorporating runtime-specific optimizations, potentially for memoization or state caching. Dependencies include the `react/compiler-runtime` module for accessing `_c`. Input is through props while outputs handle a reactive state store managed via the `$` symbol. The logic further iterates over an array and checks reactivity through conditional caching.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-from-interleaved-reactivity-for-init.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);

  const a = [];
  const b = [];
  b.push(props.cond);
  a.push(0);

  const c = [a];

  let x;
  for (let i = c[0][0]; i < 10; i++) {
    x = 1;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [x];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: true }],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This is the compiled version of the React component, showcasing how React Compiler handles the `Array.from` transformation and memoizes intermediate values. The code uses the `_c` function from `react/compiler-runtime` for memoization. The `_temp` function is the callback passed to Array.from. Dependencies: `_c` from `react/compiler-runtime`, `useIdentity`, `Stringify` from `shared-runtime`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-arg1-captures-arg0.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useIdentity, Stringify } from "shared-runtime";

/**
 * TODO: Note that this `Array.from` is inferred to be mutating its first
 * argument. This is because React Compiler's typing system does not yet support
 * annotating a function with a set of argument match cases + distinct
 * definitions (polymorphism).
 *
 * In this case, we should be able to infer that the `Array.from` call is
 * not mutating its 0th argument.
 * The 0th argument should be typed as having `effect:Mutate` only when
 * (1) it might be a mutable iterable or
 * (2) the 1st argument might mutate its callee
 */
function Component(t0) {
  const $ = _c(10);
  const { value } = t0;
  let t1;
  let t2;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = { value: "foo" };
    t2 = { value: "bar" };
    $[0] = t1;
    $[1] = t2;
  } else {
    t1 = $[0];
    t2 = $[1];
  }
  let t3;
  if ($[2] !== value) {
    t3 = [t1, t2, { value }];
    $[2] = value;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const arr = t3;
  useIdentity();
  let t4;
  if ($[4] !== arr) {
    t4 = Array.from(arr, _temp);
    $[4] = arr;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  const derived = t4;
  let t5;
  if ($[6] !== derived) {
    t5 = derived.at(-1);
    $[6] = derived;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  let t6;
  if ($[8] !== t5) {
    t6 = <Stringify>{t5}</Stringify>;
    $[8] = t5;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  return t6;
}
function _temp(x, idx) {
  return { ...x, id: idx };
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 5 }],
  sequentialRenders: [{ value: 5 }, { value: 6 }, { value: 6 }],
};

```

----------------------------------------

TITLE: Managing React Component Dependencies Using Compiler Runtime in JavaScript
DESCRIPTION: This snippet utilizes a more complex implementation for a React component by importing the `react/compiler-runtime` to manage reactive dependencies. It checks changes in `props.a?.b` to update internal state efficiently. It requires an environment with the appropriate runtime libraries available for import and execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/conditional-member-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```javascript
import { c as _c } from "react/compiler-runtime"; // To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a` as a dependency (since `props.a.b` is
// a conditional dependency, i.e. gated behind control flow)

function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.a?.b) {
    x = [];
    x.push(props.a?.b);
    $[0] = props.a?.b;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: null }],
};

```
```

----------------------------------------

TITLE: React Compiler-Optimized Function with Memoization
DESCRIPTION: The compiler-transformed version of useFoo with memoization applied. It uses React's compiler runtime to cache computation results and implement early returns. The optimized version maintains functionality while reducing redundant calculations across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/reduce-if-nonexhaustive-poisoned-deps1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(11);
  const { input, cond, hasAB } = t0;
  let t1;
  let x;
  if ($[0] !== cond || $[1] !== hasAB || $[2] !== input) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      if (cond) {
        if (!hasAB) {
          t1 = null;
          break bb0;
        } else {
          let t2;
          if ($[5] !== input.a.b) {
            t2 = identity(input.a.b);
            $[5] = input.a.b;
            $[6] = t2;
          } else {
            t2 = $[6];
          }
          x.push(t2);
        }
        let t2;
        if ($[7] !== input.a.b) {
          t2 = identity(input.a.b);
          $[7] = input.a.b;
          $[8] = t2;
        } else {
          t2 = $[8];
        }
        x.push(t2);
      } else {
        let t2;
        if ($[9] !== input.a.b) {
          t2 = identity(input.a.b);
          $[9] = input.a.b;
          $[10] = t2;
        } else {
          t2 = $[10];
        }
        x.push(t2);
      }
    }
    $[0] = cond;
    $[1] = hasAB;
    $[2] = input;
    $[3] = t1;
    $[4] = x;
  } else {
    t1 = $[3];
    x = $[4];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { b: 1 }, cond: true, hasAB: false }],
  sequentialRenders: [
    { input: { a: { b: 1 } }, cond: true, hasAB: true },
    { input: null, cond: true, hasAB: false },
    // preserve nullthrows
    { input: { a: { b: undefined } }, cond: true, hasAB: true },
    { input: { a: null }, cond: true, hasAB: true },
    { input: { a: { b: undefined } }, cond: true, hasAB: true },
  ],
};
```

----------------------------------------

TITLE: Compiled React Runtime Optimization
DESCRIPTION: Compiled version of the code that implements caching mechanism using React compiler runtime. It creates a cache array and only creates new objects when the values change, improving performance by avoiding unnecessary object allocations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/obj-literal-cached-in-if-else.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c, d) {
  const $ = _c(4);
  let x;
  if (someVal) {
    let t0;
    if ($[0] !== b) {
      t0 = { b };
      $[0] = b;
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    x = t0;
  } else {
    let t0;
    if ($[2] !== c) {
      t0 = { c };
      $[2] = c;
      $[3] = t0;
    } else {
      t0 = $[3];
    }
    x = t0;
  }
  return x;
}
```

----------------------------------------

TITLE: Mutating State in React Component - JavaScript
DESCRIPTION: This snippet defines a React component that mutates an object based on props input. It utilizes a shared runtime for state mutation, allowing reactivity tied to the component's properties. The main parameters include 'props' which supplies a 'y' value and integrates into an internal mutable structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-dependency-object-captured-with-reactive-mutated.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {mutate} = require('shared-runtime');

function Component(props) {
  const x = {};
  const y = props.y;
  const z = [x, y];
  mutate(z);
  // x's object identity can change bc it co-mutates with z, which is reactive via props.y
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{y: 42}],
};
```

----------------------------------------

TITLE: React Compiler Error for Disabled ESLint Rule
DESCRIPTION: Error message indicating that React Compiler skipped optimizing the component due to disabled ESLint rule react-hooks/exhaustive-deps
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.sketchy-code-exhaustive-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  4 |     () => {
  5 |       item.push(1);
> 6 |     }, // eslint-disable-next-line react-hooks/exhaustive-deps
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: React Compiler has skipped optimizing this component because one or more React ESLint rules were disabled. React Compiler only works when your components follow all the rules of React, disabling them may result in unexpected or incorrect behavior. eslint-disable-next-line react-hooks/exhaustive-deps (6:6)
  7 |     []
  8 |   );
  9 |
```

----------------------------------------

TITLE: Compiled React Component with Compiler Runtime
DESCRIPTION: This code shows the compiled version of the React component, utilizing React's compiler runtime for potential performance optimizations. The component uses _c from "react/compiler-runtime", memoizing the rendering result. This memoization helps avoid unnecessary re-renders of the <Foo> component improving performance when the props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-passing-refs-as-props.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(1);
  const ref = useRef(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <Foo ref={ref} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: The compiled version of the component with React runtime optimizations. Shows how array destructuring is transformed into direct property access with caching mechanism.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-array-default.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const [t0] = props.y;
  let t1;
  if ($[0] !== t0) {
    t1 = t0 === undefined ? ["default"] : t0;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const [x] = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled Memoization Function with React Compiler Runtime
DESCRIPTION: Optimized version of useFoo function using React's compiler runtime to manage memoization with explicit cache and dependency tracking
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-invoke-prop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";

function useFoo(t0) {
  const $ = _c(2);
  const { callback } = t0;
  let t1;
  let t2;
  if ($[0] !== callback) {
    t2 = new Array(callback());
    $[0] = callback;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [
    {
      callback: () => {
        "use no forget";
        return [1, 2, 3];
      },
    },
  ],
};
```

----------------------------------------

TITLE: Compiled React Component Implementation
DESCRIPTION: Compiled version of the component with React runtime optimizations, including memoization of the spread object using the _c compiler runtime function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-break.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  let x;
  let t0;
  if ($[0] !== props.value) {
    t0 = { ...props.value };
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const object = t0;
  for (const y in object) {
    if (y === "break") {
      break;
    }

    x = object[y];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  // should return 'a'
  params: [{ a: "a", break: null, c: "C!" }],
};
```

----------------------------------------

TITLE: Defining React Component with Computed Property Key
DESCRIPTION: A React component that creates an object with a computed property key using mutateAndReturn function. The component takes props, creates an empty object as a key, and then uses mutateAndReturn on that key as a computed property name in a context object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-mutate-key-while-constructing-object.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate, mutateAndReturn} from 'shared-runtime';

function Component(props) {
  const key = {};
  const context = {
    [mutateAndReturn(key)]: identity([props.value]),
  };
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: React Compiler Runtime Transformation
DESCRIPTION: Shows the compiled version of the React component with explicit memoization cache management using compiler runtime symbols and temporary variables
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-like-name-in-effect.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
function useCustomRef() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { click: _temp };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return useRef(t0);
}
```

----------------------------------------

TITLE: React Compiler-Transformed Component with Memoization
DESCRIPTION: The compiler-transformed version of the component with added memoization. The React compiler has added a cache array ($) and conditionals to prevent unnecessary recalculations when inputs haven't changed, optimizing the component's performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-nested-member-expr-in-nested-func.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(4);
  let t0;
  if ($[0] !== a) {
    t0 = { a: { a } };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  let t1;
  if ($[2] !== z.a.a) {
    t1 = function () {
      (function () {
        console.log(z.a.a);
      })();
    };
    $[2] = z.a.a;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Publish Release Script
DESCRIPTION: This script publishes a release to NPM using specified tags. It's the final step in making a release available to the public after it has been prepared using other scripts. The `--tags` argument determines which channels (e.g., next, experimental, latest) the release will be published to.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_1

LANGUAGE: shell
CODE:
```
scripts/release/publish.js --tags next
```

----------------------------------------

TITLE: Using Compiler Runtime with React Component in JavaScript
DESCRIPTION: This snippet defines the same 'Component' using React's compiler runtime functionality. It introduces a reactive variable '$' to track changes in props and leverage efficient state updates. The component's internal logic ensures that reactivity is maintained, especially when 'a' and 'c' change in response to 'b'. Dependencies include React's compiler runtime module.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-analysis-interleaved-reactivity.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(6);
  let a;
  let t0;
  if ($[0] !== props.b) {
    a = {};
    const b = [];
    b.push(props.b);
    a.a = null;

    t0 = [a];
    $[0] = props.b;
    $[1] = a;
    $[2] = t0;
  } else {
    a = $[1];
    t0 = $[2];
  }
  const c = t0;
  let t1;
  if ($[3] !== a || $[4] !== c) {
    t1 = [c, a];
    $[3] = a;
    $[4] = c;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: useRef Hook with React Compiler Runtime
DESCRIPTION: This code shows how `useRef` is transformed when the React compiler runtime is enabled. It imports `_c` from the `react/compiler-runtime` and uses it to memoize the callback.  The compiler runtime manages caching of the returned value of the hook using `Symbol.for("react.memo_cache_sentinel")` to optimize performance by avoiding re-creation on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/allow-ref-type-cast-in-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useRef } from "react";

function useArrayOfRef() {
  const $ = _c(1);
  const ref = useRef(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const callback = (value) => {
      ref.current = value;
    };

    t0 = [callback];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0 as const;
}

export const FIXTURE_ENTRYPOINT = {
  fn: () => {
    useArrayOfRef();
    return "ok";
  },

  params: [{}]
};

```

----------------------------------------

TITLE: Validating Iterator Semantics in React using JavaScript
DESCRIPTION: This snippet demonstrates the use of React components and hooks to validate the behavior of iterators based on their mutability. It uses 'ValidateMemoization' to check for compilation-only changes. The 'useFoo' function represents a higher-order structure for managing and testing input changes while leveraging memoization as part of React's shared runtime environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/todo-granular-iterator-semantics.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useIdentity, ValidateMemoization} from 'shared-runtime';

/**
 * Fixture for granular iterator semantics:
 * 1. ConditionallyMutate the iterator itself, depending on whether the iterator
 *    is a mutable iterator.
 * 2. Capture effect on elements within the iterator.
 */
function Validate({x, input}) {
  'use no memo';
  return (
    <>
      <ValidateMemoization inputs={[]} output={x[0]} onlyCheckCompiled={true} />
      <ValidateMemoization
        inputs={[input]}
        output={x[1]}
        onlyCheckCompiled={true}
      />
    </>
  );
}
function useFoo(input) {
  'use memo';
  /**
   * We should be able to memoize {} separately from `x`.
   */
  const x = Array.from([{}]);
  useIdentity();
  x.push([input]);
  return <Validate x={x} input={input} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [1],
};

```

----------------------------------------

TITLE: React Compiler-Transformed Function with Memoization
DESCRIPTION: The compiler-transformed version of the original React function. It uses a cache array for memoization to avoid recalculating values when inputs haven't changed, dramatically improving performance by preventing unnecessary re-renders and computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reassignment-separate-scopes.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(10);
  let t0;
  let x;
  if ($[0] !== a) {
    x = [];
    if (a) {
      x.push(a);
    }

    t0 = <div>{x}</div>;
    $[0] = a;
    $[1] = t0;
    $[2] = x;
  } else {
    t0 = $[1];
    x = $[2];
  }
  const y = t0;
  bb0: switch (b) {
    case 0: {
      if ($[3] !== b) {
        x = [];
        x.push(b);
        $[3] = b;
        $[4] = x;
      } else {
        x = $[4];
      }
      break bb0;
    }
    default: {
      if ($[5] !== c) {
        x = [];
        x.push(c);
        $[5] = c;
        $[6] = x;
      } else {
        x = $[6];
      }
    }
  }
  let t1;
  if ($[7] !== x || $[8] !== y) {
    t1 = (
      <div>
        {y}
        {x}
      </div>
    );
    $[7] = x;
    $[8] = y;
    $[9] = t1;
  } else {
    t1 = $[9];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled: React Component with Compiler Runtime
DESCRIPTION: The compiled version of the component that includes the React compiler runtime. It shows how the component is transformed with additional caching logic for performance optimization while maintaining the same functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reanimated-shared-value-writes.expect.md#2025-04-22_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableCustomTypeDefinitionForReanimated
import { useSharedValue } from "react-native-reanimated";

/**
 * https://docs.swmansion.com/react-native-reanimated/docs/2.x/api/hooks/useSharedValue/
 *
 * Test that shared values are treated as ref-like, i.e. allowing writes outside
 * of render
 */
function SomeComponent() {
  const $ = _c(2);
  const sharedVal = useSharedValue(0);
  let t0;
  if ($[0] !== sharedVal) {
    t0 = (
      <Button
        onPress={() => (sharedVal.value = Math.random())}
        title="Randomize"
      />
    );
    $[0] = sharedVal;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Using React Compiler Runtime for Enhanced Functionality - JavaScript
DESCRIPTION: This snippet defines a more complex version of the 'bar' function, utilizing the React compiler runtime to manage state and input checks. The function returns an internal state based on input while tracking changes, and is exported similarly as a fixture entry point.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function bar(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = [a];
    y = {};
    const f0 = function () {
      y = x[0];
    };

    f0();
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: React State Mutation Error
DESCRIPTION: Error message highlighting the incorrect attempt to directly mutate state returned from useReducer, which should be updated using the dispatch function
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.modify-useReducer-state.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  3 | function Foo() {
  4 |   let [state, setState] = useReducer({foo: 1});
> 5 |   state.foo = 1;
    |   ^^^^^ InvalidReact: Mutating a value returned from 'useReducer()', which should not be mutated. Use the dispatch function to update instead (5:5)
  6 |   return state;
  7 | }
```

----------------------------------------

TITLE: Compiled React Implementation with Block Fallthrough
DESCRIPTION: Compiled version of the fixture with explicit block handling, memoization, and early returns. Implements the same logic but with compiler-specific optimizations and block labeling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-nested-block-structure.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(4);
  const { cond1, cond2 } = t0;
  let s;
  let t1;
  if ($[0] !== cond1 || $[1] !== cond2) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      if (cond1) {
        s = {};
      } else {
        t1 = null;
        break bb0;
      }
      if (cond2) {
        mutate(s);
      }
    }
    $[0] = cond1;
    $[1] = cond2;
    $[2] = t1;
    $[3] = s;
  } else {
    t1 = $[2];
    s = $[3];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return s;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond1: true, cond2: false }],
  sequentialRenders: [
    { cond1: true, cond2: false },
    { cond1: true, cond2: false },
    { cond1: true, cond2: true },
    { cond1: true, cond2: true },
    { cond1: false, cond2: true },
  ],
};
```

----------------------------------------

TITLE: Initializing Mutated Object Context in React Component
DESCRIPTION: Creates a dynamic object context with mutated keys using identity and mutate utility functions from shared runtime. The component demonstrates experimental key generation and mutation techniques.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-modified-during-after-construction-sequence-expr.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate, mutateAndReturn} from 'shared-runtime';

function Component(props) {
  const key = {};
  const context = {
    [(mutate(key), key)]: identity([props.value]),
  };
  mutate(key);
  return context;
}
```

----------------------------------------

TITLE: React Compiler Runtime Memoized Function
DESCRIPTION: Transformed version of the original function using React compiler runtime, introducing memoization and cache management with symbol-based sentinel check.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate-alias.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let y;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = {};
    y = a;
    const x = [];

    y.x = x;

    mutate(a);
    $[0] = y;
  } else {
    y = $[0];
  }
  return y;
}
```

----------------------------------------

TITLE: Calculating Sum with Conditional Increments in JavaScript
DESCRIPTION: This function 'foo' takes props as input, performs a loop with conditional increments, and returns a calculated sum. It uses props.min, props.max, props.cond, and props.increment for loop control.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-logical.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let y = 0;
  for (
    let x = 0;
    x > props.min && x < props.max;
    x += props.cond ? props.increment : 2
  ) {
    x *= 2;
    y += x;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Transformed Hoisting Function with React Compiler Runtime
DESCRIPTION: This snippet shows the transformed `hoisting` function using React's compiler runtime (`_c`). It uses a memoization technique to avoid re-executing the conditional block if the `cond` value hasn't changed.  This version also utilizes a temporary function `_temp` to handle the `bar` function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-let-declaration-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function hoisting(cond) {
  const $ = _c(2);
  let items;
  if ($[0] !== cond) {
    items = [];
    if (cond) {
      const foo = () => {
        items.push(bar());
      };

      let bar;
      bar = _temp;
      foo();
    }
    $[0] = cond;
    $[1] = items;
  } else {
    items = $[1];
  }
  return items;
}
function _temp() {
  return true;
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [true],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This snippet shows the optimized version of the Component function using React's compiler runtime. It implements memoization to avoid unnecessary array creation. The FIXTURE_ENTRYPOINT is preserved for consistency with the input version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rest-param-with-identifier.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(foo, ...t0) {
  const $ = _c(3);
  const bar = t0;
  let t1;
  if ($[0] !== bar || $[1] !== foo) {
    t1 = [foo, bar];
    $[0] = bar;
    $[1] = foo;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["foo", "bar", "baz"],
};
```

----------------------------------------

TITLE: Compiled React Hook Implementation
DESCRIPTION: Compiled output of the React hook showing optimization with memoization using an array for storing previous condition and log values. Maintains same functionality with additional runtime optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unlabeled-break-within-label-switch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { CONST_STRING0 } from "shared-runtime";

function useHook(cond) {
  const $ = _c(2);
  let log;
  if ($[0] !== cond) {
    log = [];
    bb0: switch (CONST_STRING0) {
      case CONST_STRING0: {
        log.push(`@A`);
        if (cond) {
          break bb0;
        }

        log.push(`@B`);

        log.push(`@C`);
      }
    }
    $[0] = cond;
    $[1] = log;
  } else {
    log = $[1];
  }
  return log;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [true],
};
```

----------------------------------------

TITLE: Compiled React Component with React Compiler Runtime
DESCRIPTION: This code represents the compiled version of the React component, utilizing React's compiler runtime. It uses the `_c` function to memoize values and optimize rendering. The component checks if the props have changed and updates the internal state accordingly before rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-on-context-variable.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let x;
  if ($[0] !== props) {
    const f = () => {
      if (props.cond) {
        x = 1;
      } else {
        x = 2;
      }
    };

    const f2 = identity(f);
    f2();
    $[0] = props;
    $[1] = x;
  } else {
    x = $[1];
  }
  let t0;
  if ($[2] !== x) {
    t0 = [x];
    $[2] = x;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { cond: true },
    { cond: true },
    { cond: false },
    { cond: false },
    { cond: true },
    { cond: false },
    { cond: true },
    { cond: false },
  ],
};

```

----------------------------------------

TITLE: Compiled React Component with Runtime Optimization
DESCRIPTION: Compiler-transformed version of the React component with memoization and runtime tracking of component state and renders
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-maybemutates-arg0.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutateAndReturn, Stringify, useIdentity } from "shared-runtime";

function Component(t0) {
  const $ = _c(7);
  const { value } = t0;
  const arr = [{ value: "foo" }, { value: "bar" }, { value }];
  useIdentity();
  const derived = Array.from(arr).map(mutateAndReturn);
  let t1;
  if ($[0] !== derived) {
    t1 = derived.at(0);
    $[0] = derived;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== derived) {
    t2 = derived.at(-1);
    $[2] = derived;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1 || $[5] !== t2) {
    t3 = (
      <Stringify>
        {t1}
        {t2}
      </Stringify>
    );
    $[4] = t1;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}
```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime in JavaScript
DESCRIPTION: This snippet shows an optimized version of the React component using the React compiler runtime. It implements memoization to avoid unnecessary recalculations and object creations, potentially improving performance in React applications.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-variable-in-nested-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(4);
  let t0;
  if ($[0] !== a) {
    t0 = { a };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  let t1;
  if ($[2] !== z) {
    t1 = function () {
      (function () {
        console.log(z);
      })();
    };
    $[2] = z;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Fixture Entry Point Export
DESCRIPTION: This code exports a constant named FIXTURE_ENTRYPOINT, which is an object containing the component function, its parameters ('TodoAdd'), and a flag indicating that it's a component ('TodoAdd'). This is likely used for testing and demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-1.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet shows the compiled version of the Component function. It includes memoization logic using Symbol.for("react.memo_cache_sentinel") and imports a compiler runtime function. The FIXTURE_ENTRYPOINT object remains unchanged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/multi-directive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  "use foo";
  "use bar";
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = <div>"foo"</div>;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: true,
};
```

----------------------------------------

TITLE: React Component with React Compiler Runtime Transformation
DESCRIPTION: This code represents the transformed React component after being processed by the React compiler runtime. The `_c` function is used to manage reactivity. The compiler runtime introduces a state variable `$` to track the value of `b` and update the component when `b` changes. The compiler also uses temporary variable `t0` for storing and returning the result based on changes of the reactive values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactivity-via-readonly-alias-of-mutable-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(2);
  const x = [];
  const y = x;

  const z = [y];

  y.push(props.input);

  const a = [z];

  let b = 0;
  if (a[0][0][0] === 42) {
    b = 1;
  }
  let t0;
  if ($[0] !== b) {
    t0 = [b];
    $[0] = b;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    { input: 42 },
    { input: 42 },
    { input: "sathya" },
    { input: "sathya" },
    { input: 42 },
    { input: "sathya" },
    { input: 42 },
    { input: "sathya" },
  ],
};
```

----------------------------------------

TITLE: Exporting Component Metadata
DESCRIPTION: This code exports a constant named `FIXTURE_ENTRYPOINT`. This constant is an object containing metadata about the `foo` component, including a reference to the component's function (`fn`), an array of parameters (`params`), and the component's name (`isComponent`). This metadata can be used for testing or other tooling that needs to understand the structure and behavior of the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-logical.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component with useFire hook
DESCRIPTION: This code defines a React component that uses the 'useFire' hook to execute a function 'foo' on every render. The 'foo' function logs the value of the 'prop1' prop. The useEffect hook is used to call 't1' (which is the fired function) with 'prop1'. Also, the prop1.value is being incremented on every render.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/bailout-validate-prop-write.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { useFire } from "react/compiler-runtime"; // @enableFire @panicThreshold(none)
import { fire } from "react";

function Component(t0) {
  const { prop1 } = t0;
  const foo = () => {
    console.log(prop1);
  };
  const t1 = useFire(foo);

  useEffect(() => {
    t1(prop1);
  });
  prop1.value = prop1.value + 1;
}

```

----------------------------------------

TITLE: Fixture Entry Point with Sample Data
DESCRIPTION: Defines a constant named `FIXTURE_ENTRYPOINT` that provides sample data for the `Component2` component.  It includes a `params` array containing an object with an `items` array, which holds sample item data (id and name). This is a common pattern for providing initial data to React components for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlining-in-func-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component2,
  params: [
    {
      items: [
        {id: 2, name: 'foo'},
        {id: 3, name: 'bar'},
      ],
    },
  ],
};
```

----------------------------------------

TITLE: Running React Compiler Playground Tests
DESCRIPTION: Commands for installing Playwright browser dependencies and running the test suite.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/README.md#2025-04-21_snippet_2

LANGUAGE: sh
CODE:
```
# Install playwright browser binaries
$ npx playwright install --with-deps
# Run tests
$ yarn test
```

----------------------------------------

TITLE: Empty React Hook Function Implementation
DESCRIPTION: A minimal React hook function with no implementation, showcasing a basic function structure without any specific logic or return value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-4f6c78a14bf7.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useUnreachable() {}
```

----------------------------------------

TITLE: React Compiler-Transformed Function with Memoization
DESCRIPTION: The compiler-transformed version of the original function. It uses memoization via Symbol.for('react.memo_cache_sentinel') and pre-evaluates the boolean expressions and conditional statements at compile time for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-unary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <Stringify
        value={{
          _b: "baz",
          b0: false,
          n0: true,
          n1: false,
          n2: false,
          n3: !-1,
          s0: true,
          s1: false,
          s2: false,
          u: !undefined,
          n: true,
        }}
      />
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Build Release Locally Script
DESCRIPTION: This script creates a "next" build from the current local Git revision. It's an escape hatch, allowing releases without CI verification, but without automated unit tests.  Uncommitted changes are not included as it archives the React repo.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_9

LANGUAGE: shell
CODE:
```
scripts/release/build-release-locally.js
```

----------------------------------------

TITLE: Compiled React Component with React Compiler Runtime
DESCRIPTION: This is the compiled version of the React component, utilizing React's compiler runtime for optimization. The code uses `_c` to create a cache and memoize the onChange handler, the useEffect callback, and the rendered JSX element. It avoids redundant computations by storing values in the cache, improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ref-in-effect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  const ref = useRef(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (e) => {
      const newValue = e.target.value ?? ref.current;
      ref.current = newValue;
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onChange = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      console.log(ref.current);
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  useEffect(t1);
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = <Foo onChange={onChange} />;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}

```

----------------------------------------

TITLE: React Compiler-Transformed Function with Memoization
DESCRIPTION: The compiler-transformed version of the function uses React's compiler runtime to cache computation results. It tracks previous parameter values and only recomputes when inputs change, improving performance by avoiding unnecessary recreations of arrays.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-within-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(7);
  let x;
  if ($[0] !== a || $[1] !== b || $[2] !== c) {
    x = [];
    if (a) {
      let y;
      if ($[4] !== b || $[5] !== c) {
        y = [];
        if (b) {
          y.push(c);
        }
        $[4] = b;
        $[5] = c;
        $[6] = y;
      } else {
        y = $[6];
      }

      x.push(y);
    }
    $[0] = a;
    $[1] = b;
    $[2] = c;
    $[3] = x;
  } else {
    x = $[3];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized Component Calculation with React (JavaScript)
DESCRIPTION: This optimized version of the React component employs memoization to store previously computed results, reducing repetitive calculations. It utilizes react/compiler-runtime for optimization. Input outputs remain similar to the basic version and the optimizations ensure fewer recalculations by caching previous parameter states.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-reassigned-loop-force-scopes-enabled.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from \"react/compiler-runtime\"; // @enableForest\nfunction Component(t0) {\n  const $ = _c(5);\n  const { base, start, increment, test } = t0;\n  let value;\n  if ($[0] !== base || $[1] !== increment || $[2] !== start || $[3] !== test) {\n    value = base;\n    for (let i = start; i < test; i = i + increment, i) {\n      value = value + i;\n    }\n    $[0] = base;\n    $[1] = increment;\n    $[2] = start;\n    $[3] = test;\n    $[4] = value;\n  } else {\n    value = $[4];\n  }\n  return <div>{value}</div>;\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: Component,\n  params: [{ base: 0, start: 0, test: 10, increment: 1 }],\n  sequentialRenders: [\n    { base: 0, start: 1, test: 10, increment: 1 },\n    { base: 0, start: 0, test: 10, increment: 2 },\n    { base: 2, start: 0, test: 10, increment: 2 },\n    { base: 0, start: 0, test: 11, increment: 2 },\n  ],\n};\n
```

----------------------------------------

TITLE: Compiled React Hook with React Compiler Runtime
DESCRIPTION: This is the compiled version of the `useFoo` hook, employing `react/compiler-runtime`'s `_c` function for memoization. The compiled hook uses an array `$` to store memoized values based on input parameters like `value` and `cond`. This optimization aims to reduce re-renders by caching intermediate calculations and state values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/hoist-deps-diff-ssa-instance.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { makeObject_Primitives, setPropertyByKey } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(10);
  const { value, cond } = t0;
  let x;
  if ($[0] !== cond) {
    x = makeObject_Primitives();
    if (cond) {
      setPropertyByKey(x, "a", null);
    } else {
      setPropertyByKey(x, "a", { b: 2 });
    }
    $[0] = cond;
    $[1] = x;
  } else {
    x = $[1];
  }
  let y;
  if ($[2] !== cond || $[3] !== x) {
    y = [];
    if (!cond) {
      y.push(x.a.b);
    }
    $[2] = cond;
    $[3] = x;
    $[4] = y;
  } else {
    y = $[4];
  }
  if ($[5] !== value) {
    x = makeObject_Primitives();
    setPropertyByKey(x, "a", { b: value });
    $[5] = value;
    $[6] = x;
  } else {
    x = $[6];
  }
  let t1;
  if ($[7] !== x.a.b || $[8] !== y) {
    t1 = [y, x.a.b];
    $[7] = x.a.b;
    $[8] = y;
    $[9] = t1;
  } else {
    t1 = $[9];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ value: 3, cond: true }],
  sequentialRenders: [
    { value: 3, cond: true },
    { value: 3, cond: false },
  ],
};

```

----------------------------------------

TITLE: Optimized React Component with Caching
DESCRIPTION: Optimized version of the component using React compiler runtime for caching. Implements memoization to prevent unnecessary recreations of arrays and objects based on prop changes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-properties.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(7);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b) {
    t0 = [props.a, props.b, "hello"];
    $[0] = props.a;
    $[1] = props.b;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const a = t0;
  const x = a.length;
  const y = a.push;
  let t1;
  if ($[3] !== a || $[4] !== x || $[5] !== y) {
    t1 = { a, x, y, z: a.concat };
    $[3] = a;
    $[4] = x;
    $[5] = y;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: [1, 2], b: 2 }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Memo Cache
DESCRIPTION: Compiled version of the component that implements memo caching using Symbol.for() check. Includes compiler runtime imports and cache sentinel validation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-break.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const x = t0;
  for (const item of [1, 2]) {
    break;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Error: Invalid React Ref Access During Render
DESCRIPTION: This error message highlights a critical rule in React: you should not access or modify ref values during the render phase. The provided traceback pinpoints the exact line of code that violates this rule. The error message includes a link to the React documentation to explain why modifying ref values during render is forbidden.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.ref-initialization-linear.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   6 |   if (r.current == null) {
   7 |     r.current = 42;
>  8 |     r.current = 42;
     |     ^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (8:8)
   9 |   }
  10 | }
  11 |
```

----------------------------------------

TITLE: React Compiler Transformed Output with Memoization
DESCRIPTION: The transformed code by React Compiler implements memoization to avoid recreating the JSX element on every render. It uses a special cache mechanism through the compiler runtime and extracts the JSX creation into a separate function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-into-function-expression-global.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);

  const getJSX = _temp;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = getJSX();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const result = t0;
  return result;
}
function _temp() {
  return <Child x={GLOBAL_IS_X} />;
}
```

----------------------------------------

TITLE: Error Message for Local FBT Variable
DESCRIPTION: This error message indicates that there is an issue with using a local variable named 'fbt'. It suggests that support for such variables needs to be implemented or handled differently.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/error.todo-locally-require-fbt.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  1 | function Component(props) {
> 2 |   const fbt = require('fbt');
    |         ^^^ Todo: Support local variables named "fbt" (2:2)
  3 |
  4 |   return <fbt desc="Description">{'Text'}</fbt>;
  5 | }
```

----------------------------------------

TITLE: React Component Definition with Invoke
DESCRIPTION: This snippet defines a React component `Foo` that initializes an array `x` of objects with a `value` property. It also defines a function `foo` that accesses an element in `x` based on a given parameter and returns its `value`. Finally, it uses the `invoke` function to call `foo` with the argument `1` and returns the result.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-array-access-member-expr-param.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
```javascript
import {invoke} from 'shared-runtime';

function Foo() {
  const x = [{value: 0}, {value: 1}, {value: 2}];
  const foo = (param: number) => {
    return x[param].value;
  };

  return invoke(foo, 1);
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}]
};

```
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the component with added memoization logic. Implements caching for computed values and props using a sentinel pattern to track changes and avoid unnecessary recalculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/mege-consecutive-scopes-dont-merge-with-different-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { getNumber, identity } = require("shared-runtime");

function Component(props) {
  const $ = _c(6);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = getNumber();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props.id) {
    t1 = identity(props.id);
    $[1] = props.id;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = ["static"];
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1) {
    t3 = { a: t0, b: t1, c: t2 };
    $[4] = t1;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 42 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: The compiled version of the component using React's compiler runtime for optimization. Implements memoization using Symbol.for('react.memo_cache_sentinel') to cache rendered results and avoid unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nonreactive-noescaping-dependency-can-inline-into-consuming-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <div
        className={stylex(
          flags.feature("feature-name") ? styles.featureNameStyle : null,
        )}
      />
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimized useSupportsTouchEvent Hook Implementation in React
DESCRIPTION: This snippet presents an optimized version of the useSupportsTouchEvent hook. It removes the useMemo wrapper and uses a label-based control flow to improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-preds-undefined-try-catch-return-primitive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions

import { useMemo } from "react";

const checkforTouchEvents = true;
function useSupportsTouchEvent() {
  let t0;
  bb0: {
    if (checkforTouchEvents) {
      try {
        document.createEvent("TouchEvent");
        t0 = true;
        break bb0;
      } catch {
        t0 = false;
        break bb0;
      }
    }
    t0 = undefined;
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useSupportsTouchEvent,
  params: [],
};
```

----------------------------------------

TITLE: Conditional Value Assignment Function in JavaScript
DESCRIPTION: A function that assigns a value based on nested conditional checks. It takes multiple parameters and returns a value conditionally assigned based on the input conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-partial-reassignment.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d, e) {
  let x = null;
  if (a) {
    x = b;
  } else {
    if (c) {
      x = d;
    }
  }
  return x;
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component function that conditionally returns different values based on props. It has a potential performance issue with a non-memoized array being returned.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/partial-early-return-within-reactive-scope.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = [];
  let y = null;
  if (props.cond) {
    x.push(props.a);
    // oops no memo!
    return x;
  } else {
    y = foo();
    if (props.b) {
      return;
    }
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, a: 42}],
};
```

----------------------------------------

TITLE: Optimized React Code After Constant Propagation
DESCRIPTION: The optimized output code shows the result of constant propagation where 'x' has been completely removed and its final value (4) is directly returned. The code demonstrates proper handling of the scoping bug.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-across-objectmethod-def.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { identity } from "shared-runtime";

// repro for context identifier scoping bug, in which x was
// inferred as a context variable.

function Component() {
  const obj = { method() {} };

  identity(obj);
  return 4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized Compiler Output
DESCRIPTION: Transformed and optimized version of the component with memoization using an array-based caching mechanism for computed values
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/allow-props-named-like-hooks.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Component(t0) {
  const $ = _c(8);
  const { useFeature } = t0;
  let x;
  if (useFeature) {
    const t1 = useFeature + useFeature;
    let t2;
    if ($[0] !== t1 || $[1] !== useFeature) {
      t2 = [t1].push(-useFeature);
      $[0] = t1;
      $[1] = useFeature;
      $[2] = t2;
    } else {
      t2 = $[2];
    }
    x = t2;
  }

  const y = useFeature;
  const z = useFeature.useProperty;
  let t1;
  if ($[3] !== useFeature || $[4] !== x || $[5] !== y || $[6] !== z) {
    t1 = (
      <Stringify val={useFeature}>
        {x}
        {y}
        {z}
      </Stringify>
    );
    $[3] = useFeature;
    $[4] = x;
    $[5] = y;
    $[6] = z;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ useFeature: { useProperty: true } }],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: This snippet shows the optimized version of the 'Foo' component using React's compiler runtime. It implements memoization to cache the empty array, potentially improving performance in subsequent renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/memoize-value-block-value-sequence.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Foo(props) {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    (x = []), null;
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
};
```

----------------------------------------

TITLE: Forget-Optimized React Component
DESCRIPTION: Presents the transformed React component after applying Forget optimization. It uses `react/compiler-runtime` to memoize the component's output based on changes in `props.a.b`. The optimized version avoids re-rendering unless `props.a.b` changes, improving performance. `_c` from `react/compiler-runtime` is the Forget compiler runtime.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/memberexpr-join-optional-chain.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a.b` or a subpath as a dependency.
//
// (1) Since the reactive block producing x unconditionally read props.a.<...>,
//     reading `props.a.b` outside of the block would still preserve nullthrows
//     semantics of source code
// (2) Technically, props.a, props.a.b, and props.a.b.c are all reactive deps.
//     However, `props.a?.b` is only dependent on whether `props.a` is nullish,
//     not its actual value. Since we already preserve nullthrows on `props.a`,
//     we technically do not need to add `props.a` as a dependency.

function Component(props) {
  const $ = _c(2);
  let x;
  if ($[0] !== props.a.b) {
    x = [];
    x.push(props.a?.b);
    x.push(props.a.b.c);
    $[0] = props.a.b;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: { b: { c: 1 } } }],
};

```

----------------------------------------

TITLE: Original React Component Function Input
DESCRIPTION: Original function implementation that creates an object, renders it in a div, and processes it through a method call. Contains JSX and demonstrates typical React component patterns.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/method-call-fn-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  // Construct and freeze x
  const x = makeObject(a);
  <div>{x}</div>;

  // y should depend on `x` and `b`
  const method = x.method;
  const y = method.call(x, b);
  return y;
}
```

----------------------------------------

TITLE: React Compiler Runtime Memoized Function
DESCRIPTION: Optimized version using React compiler runtime to cache and retrieve computed values, implementing memoization pattern with Symbol-based cache sentinel
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let y;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [];
    y = { x };
    y.x.push([]);
    $[0] = y;
  } else {
    y = $[0];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component Compiled Output
DESCRIPTION: This code shows the compiled version of the React component. It imports `_c` from `react/compiler-runtime`. The component uses `_c` to potentially memoize the result of the rendering. It checks if a memoized value exists and reuses it or renders the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-call-jsx.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {}

function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = [];
    const b = {};
    foo(a, b);

    foo(a, b);
    t0 = <div a={a} b={b} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

```

----------------------------------------

TITLE: Original Function Definition with Nested Functions
DESCRIPTION: Initial implementation of Foo function with nested function and closure creating an empty object
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/nested-function-with-param-as-captured-dep.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {
  return (function t() {
    let x = {};
    return function a(x = () => {}) {
      return x;
    };
  })();
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Minimal React Test Fixture with Empty Function
DESCRIPTION: A simplified JavaScript test fixture with an empty function implementation and an exported FIXTURE_ENTRYPOINT configuration that specifies test parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-complex-multiple-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining React Component with Stringify and Identity Functions
DESCRIPTION: This snippet defines a React component that uses the Stringify component and an identity function. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-into-function-expressions.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {Stringify, identity} from 'shared-runtime';

function Component(props) {
  const x = 42;
  const onEvent = () => {
    return identity(x);
  };
  return <Stringify onEvent={onEvent} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that conditionally creates an array based on props and demonstrates memoization patterns. The component uses a special compiler directive @enablePropagateDepsInHIR for dependency propagation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/phi-type-inference-array-push.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enablePropagateDepsInHIR
function Component(props) {
  const x = {};
  let y;
  if (props.cond) {
    y = [props.value];
  } else {
    y = [];
  }
  // This should be inferred as `<store> y` s.t. `x` can still
  // be independently memoized. *But* this also must properly
  // extend the mutable range of the array literals in the
  // if/else branches
  y.push(x);

  return [x, y];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{cond: true, value: 42}],
  sequentialRenders: [
    {cond: true, value: 3.14},
    {cond: false, value: 3.14},
    {cond: true, value: 42},
  ],
};
```

----------------------------------------

TITLE: Implementing React Component with Infinite Loop and Export (Modified Version)
DESCRIPTION: This code defines a React component function with an infinite loop due to a constant loop variable. It also exports a fixture entrypoint object for testing purposes, with slight modifications from the input version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-empty-update.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  for (const i = 0; 0 < props.count; ) {
    x = x + 0;
    if (x > 10) {
      break;
    }
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Creating Invalid Component Tag Test in React
DESCRIPTION: This code creates a test fixture that demonstrates warning differences between regular React and Forget mode when using an incorrectly cased component tag. It intentionally uses a lowercase 'invalidtag' element to trigger specific warning messages about component casing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-lowercase-localvar.expect.md#2025-04-22_snippet_0

LANGUAGE: javascript
CODE:
```
import {Throw} from 'shared-runtime';

/**
 * Note: this is disabled in the evaluator due to different devmode errors.
 * Found differences in evaluator results
 *  Non-forget (expected):
 *  (kind: ok) <invalidtag val="[object Object]"></invalidtag>
 *  logs: ['Warning: <%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.%s','invalidTag']
 *
 *  Forget:
 *  (kind: ok) <invalidtag val="[object Object]"></invalidtag>
 *  logs: [
 *   'Warning: <%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.%s','invalidTag',
 *   'Warning: The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.%s','invalidTag',
 *  ]
 */
function useFoo() {
  const invalidTag = Throw;
  /**
   * Need to be careful to not parse `invalidTag` as a localVar (i.e. render
   * Throw). Note that the jsx transform turns this into a string tag:
   * `jsx("invalidTag"...
   */
  return <invalidTag val={{val: 2}} />;
}
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: Initializing React Component with Fire Method
DESCRIPTION: A React functional component importing an experimental `fire` method and attempting to invoke it within a useEffect hook. The code demonstrates an invalid usage that results in a compilation error.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-not-call.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = () => {
    console.log(props);
  };
  useEffect(() => {
    fire(props);
  });

  return null;
}
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: A React component that generates an array of div elements based on a prop value 'b'. The component uses a while loop to create 10 div elements when a global condition is true.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-missing-dependency-if-within-while.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const someGlobal = true;
export default function Component(props) {
  const {b} = props;
  const items = [];
  let i = 0;
  while (i < 10) {
    if (someGlobal) {
      items.push(<div key={i}>{b}</div>);
      i++;
    }
  }
  return <>{items}</>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{b: 42}],
  sequentialRenders: [
    {b: 0},
    {b: 0},
    {b: 42},
    {b: 42},
    {b: 0},
    {b: 42},
    {b: 0},
    {b: 42},
  ],
};
```

----------------------------------------

TITLE: Utilizing React Compiler Runtime in Component - JavaScript
DESCRIPTION: Illustrates how a React component can be enhanced with a compiler runtime, showing the usage of memoization for optimizing performance. The component uses a 'foo' function and maintains a cache using the 'react.memo_cache_sentinel' symbol to decide re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-call-jsx-2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @Pass runMutableRangeAnalysis
function foo() {}

function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const a = [];
    const b = {};
    foo(a, b);
    if (foo()) {
    }

    foo(a, b);
    t0 = <div a={a} b={b} />;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Component Fixture Export for Testing
DESCRIPTION: Export configuration for testing the component with a sample parameter. Defines the component function and test parameters with a name value.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call-complex-param-value.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Sathya" }],
};
```

----------------------------------------

TITLE: Exporting Fixture Entry Point for Testing - JavaScript
DESCRIPTION: This snippet exports a constant 'FIXTURE_ENTRYPOINT' which contains the 'useFoo' function, initialization parameters, and a series of sequential renders to emulate different scenarios for testing the function's robustness against diverse input structures.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-sequential-optional-chain-nonnull.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: null}],
  sequentialRenders: [
    {a: null},
    {a: null},
    {a: {}},
    {a: {b: {c: {d: {e: 42}}}}},
    {a: {b: {c: {d: {e: 43}}}}},
    {a: {b: {c: {d: {e: undefined}}}}},
    {a: {b: undefined}},
  ],
};
```

----------------------------------------

TITLE: Exporting React Component as FIXTURE_ENTRYPOINT
DESCRIPTION: This code exports the 'Foo' component as part of an object assigned to 'FIXTURE_ENTRYPOINT'. This object configures the component for use in a fixture or testing setup. It includes the component function itself, the component's parameters, and the component's name.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Exporting Fixture Entry Point - JavaScript
DESCRIPTION: This snippet exports a constant 'FIXTURE_ENTRYPOINT' which is an object containing the component function, an array of parameters, and an indication of the component's name. This structure is likely intended for use in tests or examples where the component needs to be instantiated with specific parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-conditional.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Test Fixture for Component Rendering Scenarios
DESCRIPTION: Test fixture defining multiple render scenarios to validate React compiler's memoization and function tracking behavior across different input states
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inner-function/nullable-objects/array-map-named-callback-cross-context.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{arr1: [], arr2: []}],
  sequentialRenders: [
    {arr1: [], arr2: []},
    {arr1: [], arr2: null},
    {arr1: [{value: 1}, {value: 2}], arr2: [{value: -1}]},
  ],
};
```

----------------------------------------

TITLE: React Compiler Error for Memoization Preservation Issue
DESCRIPTION: This is the error output from React Compiler when processing the above code. It shows that the compiler has skipped optimizing the component because it cannot preserve the manual memoization, as the 'x' dependency may be mutated later.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-overlap-scopes.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  21 |   const result = useMemo(() => {
  22 |     return [Math.max(x[1], a)];
> 23 |   }, [a, x]);
     |          ^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This dependency may be mutated later, which could cause the value to change unexpectedly (23:23)
  24 |   arrayPush(y, 3);
  25 |   return {result, y};
  26 | }
```

----------------------------------------

TITLE: React Component Code with arrayPush and Compiler Runtime
DESCRIPTION: This is the compiled code for the `useFoo` component using the React compiler runtime.  It imports `_c` from `react/compiler-runtime` and `arrayPush` from `shared-runtime`. The function `useFoo` takes an object `t0` as input, extracts properties `a` and `b`, creates an object with property `a`, and pushes the value of `b` onto the keys of this object using `arrayPush`. It exports `FIXTURE_ENTRYPOINT` containing the function and parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/shapes-object-key.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { arrayPush } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(2);
  const { a, b } = t0;
  let t1;
  if ($[0] !== a) {
    t1 = { a };
    $[0] = a;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const obj = t1;
  arrayPush(Object.keys(obj), b);
  return obj;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: 2, b: 3 }],
};

```

----------------------------------------

TITLE: Enhanced React Component with Compiler Runtime
DESCRIPTION: This snippet imports specific runtime compiler utilities to optimize component performance and manage memoization. The 'Component' function manipulates component state utilizing 'shallowCopy' and 'throwErrorWithMessage' while enhancing performance with compiler-specific symbols and caching mechanisms. It validates and updates state against props, optimizing execution through conditional caching. The component prepares for React memoization using a compiler runtime and exports 'FIXTURE_ENTRYPOINT' with params for testing scenarions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/try-catch-mutate-outer-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
const { shallowCopy, throwErrorWithMessage } = require("shared-runtime");

function Component(props) {
  const $ = _c(5);
  let x;
  if ($[0] !== props) {
    x = [];
    try {
      let t0;
      if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
        t0 = throwErrorWithMessage("oops");
        $[2] = t0;
      } else {
        t0 = $[2];
      }
      x.push(t0);
    } catch {
      let t0;
      if ($[3] !== props.a) {
        t0 = shallowCopy({ a: props.a });
        $[3] = props.a;
        $[4] = t0;
      } else {
        t0 = $[4];
      }
      x.push(t0);
    }
    $[0] = props;
    $[1] = x;
  } else {
    x = $[1];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 1 }],
};

```

----------------------------------------

TITLE: Initializing React Component with Compiler Runtime - JavaScript
DESCRIPTION: This function defines a more complex React component that utilizes the 'react/compiler-runtime' to manage reactivity. It checks if the prop has changed and reuses an existing array for output if it hasn't. The expected input is a 'props' object containing a key 'a', and it outputs an array with the value of 'a'. It also maintains state for optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/iife-return-modified-later.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let t0;
  let items;
  if ($[0] !== props.a) {
    t0 = [];
    items = t0;

    items.push(props.a);
    $[0] = props.a;
    $[1] = items;
    $[2] = t0;
  } else {
    items = $[1];
    t0 = $[2];
  }
  return items;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: {} }],
};
```

----------------------------------------

TITLE: Creating Component with Shared Runtime - JavaScript
DESCRIPTION: This snippet defines the `useComponentFactory` function that takes an object with a `name` property and returns the result of invoking a callback function. It utilizes the `invoke` function from 'shared-runtime' for dynamic functionality and stringifies the output within a component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-lowercase-localvar-memberexpr-in-lambda.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import * as SharedRuntime from 'shared-runtime';
import {invoke} from 'shared-runtime';
function useComponentFactory({name}) {
  const localVar = SharedRuntime;
  const cb = () => <localVar.Stringify>hello world {name}</localVar.Stringify>;
  return invoke(cb);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useComponentFactory,
  params: [{name: 'sathya'}],
};
```

----------------------------------------

TITLE: Using React Compiler Runtime for Component Memoization
DESCRIPTION: This JavaScript snippet demonstrates the usage of the React compiler runtime to define a component that handles memoization through function parameter manipulation. It introduces a cache mechanism, utilizing temporary functions for changing the behavior of 'f'. The expected inputs and outputs include console logs showing 'A', 'arg', and 'original'. The snippet is reliant on the 'react/compiler-runtime' library.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-call-evaluation-order.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // Should print A, arg, original

function Component() {
  const $ = _c(1);
  const changeF = _temp2;
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = { f: _temp3 };

    (console.log("A"), x).f((changeF(x), console.log("arg"), 1));
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}
function _temp3() {
  return console.log("original");
}
function _temp2(o) {
  o.f = _temp;
}
function _temp() {
  return console.log("new");
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Component Implementation with Internal State Management - JavaScript
DESCRIPTION: This snippet showcases a more complex version of the 'Component' function that integrates internal state management through the '_c' function from 'react/compiler-runtime'. It optimizes rendering based on input changes and caching of previously generated outputs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-duplicate-prop.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableJsxOutlining
function Component(t0) {
  const $ = _c(7);
  const { arr } = t0;
  const x = useX();
  let t1;
  if ($[0] !== arr || $[1] !== x) {
    let t2;
    if ($[3] !== x) {
      t2 = (i, id) => {
        const T0 = _temp;
        return <T0 i={i} i1={i} key={id} x={x} />;
      };
      $[3] = x;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    t1 = arr.map(t2);
    $[0] = arr;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = <>{t1}</>;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
function _temp(t0) {
  const $ = _c(8);
  const { i: i, i1: i1, x: x } = t0;
  let t1;
  if ($[0] !== i) {
    t1 = <Baz i={i} />;
    $[0] = i;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== i1) {
    t2 = <Foo i={i1} />;
    $[2] = i1;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1 || $[5] !== t2 || $[6] !== x) {
    t3 = (
      <Bar x={x}>
        {t1}
        {t2}
      </Bar>
    );
    $[4] = t1;
    $[5] = t2;
    $[6] = x;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  return t3;
}

function Bar(t0) {
  const $ = _c(3);
  const { x, children } = t0;
  let t1;
  if ($[0] !== children || $[1] !== x) {
    t1 = (
      <>
        {x}
        {children}
      </>
    );
    $[0] = children;
    $[1] = x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

function Baz(t0) {
  const { i } = t0;
  return i;
}

function Foo(t0) {
  const { i } = t0;
  return i;
}

function useX() {
  return "x";
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ arr: ["foo", "bar"] }],
};
```

----------------------------------------

TITLE: Publishing Current Contents of Build to NPM in Shell
DESCRIPTION: This script publishes the contents of the build directory to NPM. It updates the specified tags to match without verifying the contents beforehand. It can be run with a `--dry` flag to simulate the NPM publish step without executing it. The output includes instructions for tagging the commit and updating the CHANGELOG.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_12

LANGUAGE: sh
CODE:
```
scripts/release/publish.js --tags latest next
```

----------------------------------------

TITLE: Babel Transform for Error Message Rewriting
DESCRIPTION: Babel transformation pass that rewrites detailed error messages to compact error IDs for production and minified builds.
SOURCE: https://github.com/facebook/react/blob/main/scripts/error-codes/README.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
// transform-error-messages.js
const transformErrorMessages = (babel) => {
  // Rewrite error messages to IDs
}
```

----------------------------------------

TITLE: Defining a Function and Exporting a Fixture in Javascript
DESCRIPTION: This JavaScript snippet defines a function `foo` that takes two arguments, `a` and `b`.  It contains a while loop that immediately breaks. The function then returns `b`.  The snippet also exports a constant `FIXTURE_ENTRYPOINT` which is an object that configures the function `foo` as a fixture, specifying its parameter as 'TodoAdd' and component as 'TodoAdd'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/while-break.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  while (a) {
    break;
  }
  return b;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Handling Errors in React Hook Accessing Ref During Render
DESCRIPTION: This snippet includes the error messages generated when attempting to access the '.current' property of a ref during the rendering phase. The error indicates that manipulating ref values directly within the component render is not permissible in React, providing links to the React documentation for further guidance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.capture-ref-for-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  10 |   };
  11 |   const moveLeft = {
> 12 |     handler: handleKey('left')(),
     |              ^^^^^^^^^^^^^^^^^ InvalidReact: This function accesses a ref value (the `current` property), which may not be accessed during render. (https://react.dev/reference/react/useRef) (12:12)

InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (12:12)

InvalidReact: This function accesses a ref value (the `current` property), which may not be accessed during render. (https://react.dev/reference/react/useRef) (15:15)

InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (15:15)
  13 |   };
  14 |   const moveRight = {
  15 |     handler: handleKey('right')(),
```

----------------------------------------

TITLE: Defining Hoisting Function in JavaScript
DESCRIPTION: This snippet defines a simple hoisting function that demonstrates variable scoping and returns a computation based on two local variables 'bar' and 'baz'. It utilizes a nested function structure to compute and return the value of 'foo'. The function is initialized correctly outside of the temporal dead zone (TDZ) and allows the variable 'result' to be returned. Dependencies: None.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-nested-const-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function hoisting() {
  const qux = () => {
    let result;
    {
      result = foo();
    }
    return result;
  };
  const foo = () => {
    return bar + baz;
  };
  const bar = 3;
  const baz = 2;
  return qux(); // OK: called outside of TDZ
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Component with Props Dependent Caching in React (JavaScript)
DESCRIPTION: This snippet imports a compiler runtime function and defines a component that optimizes rendering by caching results based on the input props. It checks if the props have changed and updates the cached value accordingly, enhancing performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/property-call-spread.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] !== props.a || $[1] !== props.b) {
    t0 = foo.bar(...props.a, null, ...props.b);
    $[0] = props.a;
    $[1] = props.b;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const x = t0;
  return x;
}
```

----------------------------------------

TITLE: Defining Basic Log Function - JavaScript
DESCRIPTION: This snippet defines a logging function named 'log' with no parameters or functionality. It serves as a placeholder for later implementation of logging logic. No dependencies are required.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-shadowing.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function log() {}
```

----------------------------------------

TITLE: Original JavaScript Function 'foo'
DESCRIPTION: This snippet defines the original 'foo' function, which takes four arguments (a, b, c, d) and returns an array 'y'. The logic within the function involves conditional checks based on 'a' and 'b' to push either 'c' or 'd' into the array. A label is used to potentially break out of the conditional block.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/inverted-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  let y = [];
  label: if (a) {
    if (b) {
      y.push(c);
      break label;
    }
    y.push(d);
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Build Error for Variable Declaration Handling
DESCRIPTION: Indicates a build-time todo item related to handling variable declaration kinds, specifically for 'var' declarations in the build process.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-hoisting-simple-var-declaration.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   5 |   }
   6 |   const result = addOne(2);
>  7 |   var a = 1;
     |   ^^^^^^^^^^ Todo: (BuildHIR::lowerStatement) Handle var kinds in VariableDeclaration (7:7)
   8 |
   9 |   return result; // OK: returns NaN. The code is semantically wrong but technically correct
  10 | }
```

----------------------------------------

TITLE: Transformed React Component with Compiler Runtime
DESCRIPTION: This is the transformed code of the React component using the React compiler runtime.  It shows how the compiler optimizes the component using memoization and caching to avoid unnecessary re-renders and re-creations of functions and elements.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-nested-property-preserve-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees
import { useCallback, useRef } from "react";

function Component(props) {
  const $ = _c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { inner: null };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const ref = useRef(t0);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (event) => {
      ref.current.inner = event.target.value;
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const onChange = t1;
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = <input onChange={onChange} />;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}]],
};

```

----------------------------------------

TITLE: Compiled React Hook Implementation
DESCRIPTION: Compiled version of the hook using React compiler runtime with memoization optimizations. Includes state tracking using compiler-generated array for caching previous values and conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/object-literal-method-in-ternary-consequent.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { createHookWrapper } from "shared-runtime";

function useHook(t0) {
  const $ = _c(3);
  const { isCond, value } = t0;
  let t1;
  if ($[0] !== isCond || $[1] !== value) {
    t1 = isCond
      ? {
          getValue() {
            return value;
          },
        }
      : 42;
    $[0] = isCond;
    $[1] = value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: createHookWrapper(useHook),
  params: [{ isCond: true, value: 0 }],
};
```

----------------------------------------

TITLE: Compiled React Hook with Compiler Runtime
DESCRIPTION: This code defines a React hook, `useFoo`, and uses the `react/compiler-runtime` to optimize re-renders. It uses a compiler runtime cache (`_c`) to store the previous input and output, and only re-calculates if the input `bar` has changed. The `FIXTURE_ENTRYPOINT` exports the hook and example parameters for automated testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hook-declaration-basic.flow.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
export default function useFoo(bar) {
  const $ = _c(2);
  let t0;
  if ($[0] !== bar) {
    t0 = [bar];
    $[0] = bar;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [42],
};

```

----------------------------------------

TITLE: Enhanced StoreLandingUnseenGiftModalContainer with React Runtime
DESCRIPTION: This snippet enhances the StoreLandingUnseenGiftModalContainer by integrating it with React's compiler-runtime for memoization. It checks if the input parameter 'a' has changed since the last render, and utilizes caching for performance improvement. It returns the status of the gift using the gifts ID.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-skip-computed-path.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function StoreLandingUnseenGiftModalContainer(a) {
  const $ = _c(2);
  let t0;
  if ($[0] !== a) {
    const giftsSeen = { a };
    t0 = ((gift) => (gift.id ? giftsSeen[gift.id] : false))();
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: StoreLandingUnseenGiftModalContainer,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimizing React Component Rendering with Caching in JavaScript
DESCRIPTION: This snippet enhances a React component by incorporating a caching mechanism using an array to track changes in props and reuse previously rendered outputs. It demonstrates an advanced rendering optimization technique within React by comparing current props with cached values, thereby reducing unnecessary re-rendering and improving performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/switch.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(8);
  let t0;
  let y;
  if ($[0] !== props.p0 || $[1] !== props.p2 || $[2] !== props.p3) {
    const x = [];
    switch (props.p0) {
      case true: {
        x.push(props.p2);
        x.push(props.p3);
      }
      case false: {
        y = x;
      }
    }

    t0 = <Component data={x} />;
    $[0] = props.p0;
    $[1] = props.p2;
    $[2] = props.p3;
    $[3] = t0;
    $[4] = y;
  } else {
    t0 = $[3];
    y = $[4];
  }
  const child = t0;
  y.push(props.p4);
  let t1;
  if ($[5] !== child || $[6] !== y) {
    t1 = <Component data={y}>{child}</Component>;
    $[5] = child;
    $[6] = y;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  return t1;
}

```

----------------------------------------

TITLE: Using Memoization in React Functional Component Rendering
DESCRIPTION: This snippet showcases a more complex implementation of the Component which utilizes the memoization technique with React's compiler-runtime. It improves performance by reducing the number of times component content is recalculated and re-rendered by caching previous values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-string-attribute-non-ascii.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <Post
        author="potetotes"
        text={
          "in addition to understanding JavaScript semantics and the rules of React, the compiler team also understands \u0BA4\u0BAE\u0BBF\u0BB4\u0BCD, \u4E2D\u6587, \u65E5\u672C\u8A9E, \uD55C\uAD6D\uC5B4 and i think that\u2019s pretty cool"
        }  
      />
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

function Post(t0) {
  const $ = _c(7);
  const { author, text } = t0;
  let t1;
  if ($[0] !== author) {
    t1 = <h1>{author}</h1>;
    $[0] = author;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== text) {
    t2 = <span>{text}</span>;
    $[2] = text;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1 || $[5] !== t2) {
    t3 = (
      <div>
        {t1}
        {t2}
      </div>
    );
    $[4] = t1;
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This is the compiled version of the component with React's compiler-runtime memoization applied. It shows how the compiler creates a memoization cache ($) and uses it to store and retrieve values across renders, handling the object mutation scenario carefully.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-access-in-mutable-range.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // x.a.b was accessed unconditionally within the mutable range of x.
// As a result, we cannot infer anything about whether `x` or `x.a`
// may be null. This means that it's not safe to hoist reads from x
// (e.g. take `x.a` or `x.a.b` as a dependency).

import { identity, makeObject_Primitives, setProperty } from "shared-runtime";

function Component(t0) {
  const $ = _c(8);
  const { cond, other } = t0;
  let x;
  if ($[0] !== cond || $[1] !== other) {
    x = makeObject_Primitives();
    setProperty(x, { b: 3, other }, "a");
    identity(x.a.b);
    if (!cond) {
      x.a = null;
    }
    $[0] = cond;
    $[1] = other;
    $[2] = x;
  } else {
    x = $[2];
  }
  let t1;
  if ($[3] !== cond || $[4] !== x) {
    t1 = identity(cond) && x.a.b;
    $[3] = cond;
    $[4] = x;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== t1) {
    t2 = [t1];
    $[6] = t1;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  const y = t2;
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: false }],
  sequentialRenders: [
    { cond: false },
    { cond: false },
    { cond: false, other: 8 },
    { cond: true },
    { cond: true },
  ],
};
```

----------------------------------------

TITLE: Initial Input Function with Object Property Access
DESCRIPTION: JavaScript function demonstrating object property access and dependency tracking in nested objects
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-subpath-order3.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function TestDepsSubpathOrder3(props) {
  let x = {};
  x.c = props.a.b.c;
  x.a = props.a;
  x.b = props.a.b;
  return x;
}
```

----------------------------------------

TITLE: Compiled Output with React Compiler Optimizations
DESCRIPTION: The compiled version of the hook function after React Compiler transformation. It implements memoization to maintain reference stability of the returned array, ensuring the same array reference is returned if the state hasn't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-functions-hook-with-hook-call.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
function useStateValue(props) {
  const $ = _c(2);
  const [state] = useState(null);
  let t0;
  if ($[0] !== state) {
    t0 = [state];
    $[0] = state;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
```

----------------------------------------

TITLE: Optimized Key Command Hook with Memoization - JavaScript
DESCRIPTION: This code snippet illustrates an enhanced version of the useKeyCommand hook, utilizing React's internal caching mechanism via memoization. It checks a memo cache symbol and updates the key commands accordingly. This approach is designed to prevent unnecessary recalculations and optimize performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture-ref-for-later-mutation.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useRef } from "react";
import { addOne } from "shared-runtime";

function useKeyCommand() {
  const $ = _c(1);
  const currentPosition = useRef(0);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const handleKey = (direction) => () => {
      const position = currentPosition.current;
      const nextPosition = direction === "left" ? addOne(position) : position;
      currentPosition.current = nextPosition;
    };

    const moveLeft = { handler: handleKey("left") };

    const moveRight = { handler: handleKey("right") };

    t0 = [moveLeft, moveRight];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useKeyCommand,
  params: [],
};

```

----------------------------------------

TITLE: Transformed Component with Separate Function Declaration
DESCRIPTION: Compiled version of the component where the arrow function default is transformed into a separate function declaration _temp. Uses undefined check for parameter assignment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/default-param-with-empty-callback.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(t0) {
  const x = t0 === undefined ? _temp : t0;
  return x;
}
function _temp() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Advanced React Component with Compiler Runtime Optimization
DESCRIPTION: Enhanced version of the FancyButton component using React compiler runtime for memoization and performance optimization, with conditional rendering based on prop changes
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.bail.rules-of-hooks-e9f9bac89f8f.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
const FancyButton = React.forwardRef((props, ref) => {
  const $ = _c(3);
  useHook();
  let t0;
  if ($[0] !== props || $[1] !== ref) {
    t0 = <button {...props} ref={ref} />;
    $[0] = props;
    $[1] = ref;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
});
```

----------------------------------------

TITLE: Optimized React Component with Caching
DESCRIPTION: Optimized version with compiler runtime integration and caching mechanism using array $_c. Implements memoization for props.items.edges and length calculations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/memberexpr-join-optional-chain2.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePropagateDepsInHIR
function Component(props) {
  const $ = _c(5);
  let x;
  if ($[0] !== props.items?.edges || $[1] !== props.items?.length) {
    x = [];
    x.push(props.items?.length);
    let t0;
    if ($[3] !== props.items?.edges) {
      t0 = props.items?.edges?.map?.(render)?.filter?.(Boolean) ?? [];
      $[3] = props.items?.edges;
      $[4] = t0;
    } else {
      t0 = $[4];
    }
    x.push(t0);
    $[0] = props.items?.edges;
    $[1] = props.items?.length;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ items: { edges: null, length: 0 } }],
};
```

----------------------------------------

TITLE: Reproducing React Context Variable Inference Bug - Input Version
DESCRIPTION: The input code demonstrates a bug where 'x' was incorrectly inferred as a context variable. It shows a component that initializes 'x', creates an object, updates 'x', and returns its value, which should be 4 after optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-prop-across-objectmethod-def.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity} from 'shared-runtime';

// repro for context identifier scoping bug, in which x was
// inferred as a context variable.

function Component() {
  let x = 2;
  const obj = {
    method() {},
  };
  x = 4;
  identity(obj);
  // constant propagation should return 4 here
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Transpiled React Function with Data Attribute Handling
DESCRIPTION: This snippet shows the transpiled version of the 'foo' function, where the object destructuring is converted to a more compatible format. It also includes the 'FIXTURE_ENTRYPOINT' constant, which is used for testing or fixture setup.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-param-string-literal-key-invalid-identifier.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(t0) {
  const { "data-foo-bar": dataTestID } = t0;
  return dataTestID;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{ "data-foo-bar": {} }],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Logic
DESCRIPTION: The React compiler output for the component, showing how the memoization is implemented. It includes the compiler-runtime logic that tracks dependencies and handles memoized values across renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/context-var-granular-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { throwErrorWithMessage, ValidateMemoization } from "shared-runtime";

/**
 * Context variables are local variables that (1) have at least one reassignment
 * and (2) are captured into a function expression. These have a known mutable
 * range: from first declaration / assignment to the last direct or aliased,
 * mutable reference.
 *
 * This fixture validates that forget can take granular dependencies on context
 * variables when the reference to a context var happens *after* the end of its
 * mutable range.
 */
function Component(t0) {
  const $ = _c(10);
  const { cond, a } = t0;
  let contextVar;
  if ($[0] !== a || $[1] !== cond) {
    if (cond) {
      contextVar = { val: a };
    } else {
      contextVar = {};
      throwErrorWithMessage("");
    }
    $[0] = a;
    $[1] = cond;
    $[2] = contextVar;
  } else {
    contextVar = $[2];
  }
  let t1;
  if ($[3] !== contextVar) {
    t1 = { cb: () => contextVar.val * 4 };
    $[3] = contextVar;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const cb = t1;

  const t2 = cond ? a : undefined;
  let t3;
  if ($[5] !== t2) {
    t3 = [t2];
    $[5] = t2;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  let t4;
  if ($[7] !== cb || $[8] !== t3) {
    t4 = (
      <ValidateMemoization inputs={t3} output={cb} onlyCheckCompiled={true} />
    );
    $[7] = cb;
    $[8] = t3;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  return t4;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: false, a: undefined }],
  sequentialRenders: [
    { cond: true, a: 2 },
    { cond: true, a: 2 },
  ],
};
```

----------------------------------------

TITLE: React Fixture Entrypoint Configuration
DESCRIPTION: Test fixture defining the function, initial parameters, and sequential rendering scenarios for the compiler transformation
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-nested-function-uncond-access-local-var.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ a: null }],
  sequentialRenders: [{ a: null }, { a: { b: { c: 4 } } }]
};
```

----------------------------------------

TITLE: Fixture Entrypoint Configuration
DESCRIPTION: An exported constant that defines a fixture configuration for the foo function, specifying the function reference, parameters, and component association for testing or configuration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-partial-phi.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd"
};
```

----------------------------------------

TITLE: Using Conditional Type Inference in React
DESCRIPTION: This snippet defines a function 'useFoo' that utilizes type inference to handle different input conditions by modifying an object based on the 'cond' parameter. It manages type propagation through unexpected behavior in TypeScript and Flow. Import dependencies include 'mutate' for changing internal state and 'arrayPush' for handling non-primitive scenarios. Key parameters include 'cond' (a boolean for condition checking) and 'value' (a number to be manipulated based on the type of 'x.value'). It is crucial to note that the inference may behave inconsistently across different type systems.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-type-inference-control-flow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {arrayPush, CONST_NUMBER0, mutate} from 'shared-runtime';

/**
 * Repro for bug in our type inference system. We currently propagate inferred
 * types through control flow / potential type guards. Note that this is
 * inconsistent with both Flow and Typescript.
 * https://flow.org/try/#1N4Igxg9gdgZglgcxALlAIwIZoKYBsD6uEEAztvhgE6UYCe+JADpdhgCYowa5kA0I2KAFcAtiRQAXSkOz9sADwxgJ+NPTbYuQ3BMnTZA+Y2yU4IwRO4A6SFBIrGVDGM7c+h46fNRLuKxJIGWh8MeT0ZfhYlCStpHzNsFBAMIQkIEQwJODAQfiEyfBE4eWw2fDgofDBMsAALfAA3KjgsXGxxZC4eAw0G-GhcWn9aY3wWZldu-g1mbGqJUoBaCRHEzrcDEgBrbAk62kXhXFxJ923d-cPRHEpTgyEoMDaqZdW7vKgoOfaSKgOKpqmDA+d4gB5fMA-P6LCCMLLQbiLOoYCqgh6-GDYRYIXYLSgkRZkCR4jpddwPfJLZjpOBkO4AX34kA0SRWxgABAAxYjsgC87OAAB0oOzReythU2Mh2YKQNyILLeMKxeymrgZNLhCIbsL6QBuYVs7DsgBCVD5AuVYolUClMpAZsoiqtorVGvZWpuSqg9OFMAeyjg0HZdTmW3lAAp5NKAPJoABWcwkAEppWZGLg4O12fJ2bSuTyhSKxSwJEJKCKAOQ2tiVvMi3MAMkbOasNb5vP5svlsoNPuFfoD8JFGQqUel8vZAB9TVReCHoHa0MRnlBUwWIJbi6K4DB2RHbGxk1uVSrd-uAIShsDh4hR5PHoun5-siS1SgQADuHuw34AotQECUBGsqysmfYvuyvrbqepblg2EFitBKpwRWOZ9vSuQgA0JgkEGUBJBk9gmCA9JAA
 * https://www.typescriptlang.org/play/?#code/C4TwDgpgBAYg9nKBeKBvAUFLUDWBLAOwBMAuKAInjnIBpNsA3AQwBsBXCMgtgWwCMIAJ3QBfANzpQkKACEmg5GnpZ8xMuTmDayqM3aco3fkLoj0AMzYEAxsDxwCUawAsI1nFQAUADzJw+AFZuwACUZEwAzhFCwBFQ3lB4cVRK2InmUJ4AhJ4A5KpEuYmOCQBkpfEAdAXISCiUCOQhIalp2MDOgnAA7oYQvQCigl2CnuRWEN6QthBETTpmZhZWtvaOPEyEPmQpAD6y8jRODqRQfAgsEEwEYbAIrVh4GZ7WJy0Ybdgubh4IPiEST5YQQQYBsQQlQHYMxpEFgiHxCQiIA
 */
function useFoo({cond, value}: {cond: boolean; value: number}) {
  const x = {value: cond ? CONST_NUMBER0 : []};
  mutate(x);

  const xValue = x.value;
  let result;
  if (typeof xValue === 'number') {
    result = xValue + 1; //               (1) here we infer xValue is a primitive
  } else {
    result = arrayPush(xValue, value); // (2) and propagate it to all other xValue references
  }

  return result;
}
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: true}],
  sequentialRenders: [
    {cond: false, value: 2},
    {cond: false, value: 3},
  ],
};
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { arrayPush, CONST_NUMBER0, mutate } from "shared-runtime";

/**
 * Repro for bug in our type inference system. We currently propagate inferred
 * types through control flow / potential type guards. Note that this is
 * inconsistent with both Flow and Typescript.
 * https://flow.org/try/#1N4Igxg9gdgZglgcxALlAIwIZoKYBsD6uEEAztvhgE6UYCe+JADpdhgCYowa5kA0I2KAFcAtiRQAXSkOz9sADwxgJ+NPTbYuQ3BMnTZA+Y2yU4IwRO4A6SFBIrGVDGM7c+h46fNRLuKxJIGWh8MeT0ZfhYlCStpHzNsFBAMIQkIEQwJODAQfiEyfBE4eWw2fDgofDBMsAALfAA3KjgsXGxxZC4eAw0G-GhcWn9aY3wWZldu-g1mbGqJUoBaCRHEzrcDEgBrbAk62kXhXFxJ923d-cPRHEpTgyEoMDaqZdW7vKgoOfaSKgOKpqmDA+d4gB5fMA-P6LCCMLLQbiLOoYCqgh6-GDYRYIXYLSgkRZkCR4jpddwPfJLZjpOBkO4AX34kA0SRWxgABAAxYjsgC87OAAB0oOzReythU2Mh2YKQNyILLeMKxeymrgZNLhCIbsL6QBuYVs7DsgBCVD5AuVYolUClMpAZsoiqtorVGvZWpuSqg9OFMAeyjg0HZdTmW3lAAp5NKAPJoABWcwkAEppWZGLg4O12fJ2bSuTyhSKxSwJEJKCKAOQ2tiVvMi3MAMkbOasNb5vP5svlsoNPuFfoD8JFGQqUel8vZAB9TVReCHoHa0MRnlBUwWIJbi6K4DB2RHbGxk1uVSrd-uAIShsDh4hR5PHoun5-siS1SgQADuHuw34AotQECUBGsqysmfYvuyvrbqepblg2EFitBKpwRWOZ9vSuQgA0JgkEGUBJBk9gmCA9JAA
 * https://www.typescriptlang.org/play/?#code/C4TwDgpgBAYg9nKBeKBvAUFLUDWBLAOwBMAuKAInjnIBpNsA3AQwBsBXCMgtgWwCMIAJ3QBfANzpQkKACEmg5GnpZ8xMuTmDayqM3aco3fkLoj0AMzYEAxsDxwCUawAsI1nFQAUADzJw+AFZuwACUZEwAzhFCwBFQ3lB4cVRK2InmUJ4AhJ4A5KpEuYmOCQBkpfEAdAXISCiUCOQhIalp2MDOgnAA7oYQvQCigl2CnuRWEN6QthBETTpmZhZWtvaOPEyEPmQpAD6y8jRODqRQfAgsEEwEYbAIrVh4GZ7WJy0Ybdgubh4IPiEST5YQQQYBsQQlQHYMxpEFgiHxCQiIA
 */
function useFoo(t0) {
  const $ = _c(5);
  const { cond, value } = t0;
  let x;
  if ($[0] !== cond) {
    x = { value: cond ? CONST_NUMBER0 : [] };
    mutate(x);
    $[0] = cond;
    $[1] = x;
  } else {
    x = $[1];
  }

  const xValue = x.value;
  let result;
  if (typeof xValue === "number") {
    result = xValue + 1;
  } else {
    let t1;
    if ($[2] !== value || $[3] !== xValue) {
      t1 = arrayPush(xValue, value);
      $[2] = value;
      $[3] = xValue;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    result = t1;
  }
  return result;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ cond: true }],
  sequentialRenders: [
    { cond: false, value: 2 },
    { cond: false, value: 3 },
  ],
};
```

----------------------------------------

TITLE: React Fixture Entrypoint Configuration
DESCRIPTION: A configuration object defining the function, parameters, and component type for testing or compilation purposes. Provides metadata about the React component for external tooling or test environments.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-scopes.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: ["TodoAdd"],
  isComponent: "TodoAdd"
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization Optimizations
DESCRIPTION: Compiled version of the React component showing how the compiler implements memoization optimizations. It uses Symbol.for("react.memo_cache_sentinel") to track memoized values and includes compiler-specific runtime helpers.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useCallback-set-ref-value-dont-preserve-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees
import { useCallback, useRef } from "react";

function Component(props) {
  const $ = _c(2);
  const ref = useRef(null);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (event) => {
      ref.current = event.target.value;
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onChange = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = <input onChange={onChange} />;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Optimized React Component Implementation
DESCRIPTION: Compiled version with optimization logic including both optimized and unoptimized paths. Uses compiler runtime utilities and feature flags to conditionally apply optimizations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/gating-use-before-decl.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { isForgetEnabled_Fixtures } from "ReactForgetFeatureFlag"; // @gating
import { memo } from "react";
import { Stringify } from "shared-runtime";

export default memo(Foo);
const isForgetEnabled_Fixtures_result = isForgetEnabled_Fixtures();
function Foo_optimized(t0) {
  "use memo";
  const $ = _c(3);
  const { prop1, prop2 } = t0;
  let t1;
  if ($[0] !== prop1 || $[1] !== prop2) {
    t1 = <Stringify prop1={prop1} prop2={prop2} />;
    $[0] = prop1;
    $[1] = prop2;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
function Foo_unoptimized({ prop1, prop2 }) {
  "use memo";
  return <Stringify prop1={prop1} prop2={prop2} />;
}
function Foo(arg0) {
  if (isForgetEnabled_Fixtures_result) return Foo_optimized(arg0);
  else return Foo_unoptimized(arg0);
}

export const FIXTURE_ENTRYPOINT = {
  fn: eval("Foo"),
  params: [{ prop1: 1, prop2: 2 }],
};
```

----------------------------------------

TITLE: Optimized React Component with Memoization
DESCRIPTION: Transformed component with React compiler runtime optimization. Implements memoization using Symbol.for() sentinel and conditional caching logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-polymorphic.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component() {
  const $ = _c(1);
  const p = makePrimitive();
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const o = {};

    x = {};

    x.t = p;

    x.t = o;
    $[0] = x;
  } else {
    x = $[0];
  }
  const y = x.t;
  return y;
}
```

----------------------------------------

TITLE: Defining a function in Javascript
DESCRIPTION: This code snippet defines a simple Javascript function named `foo` that takes four arguments but has an empty body. This likely serves as a placeholder or a minimal definition for a more complex implementation elsewhere.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-sibling-phis.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {}
```

----------------------------------------

TITLE: Compiled React Component with Mutation
DESCRIPTION: This JavaScript code represents the compiled version of the React component. It utilizes React's compiler runtime ('react/compiler-runtime') and the 'shared-runtime' to achieve the mutation. The compiled component memoizes the result using _c, re-computing only when 'a' changes. It calls mutate(y) to perform the mutation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-simple-alias-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
const { mutate } = require("shared-runtime");

function component(a) {
  const $ = _c(2);
  let y;
  if ($[0] !== a) {
    const x = { a };
    y = {};

    y = x;

    mutate(y);
    $[0] = a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["foo"],
};

```

----------------------------------------

TITLE: Compiled React Component with Caching
DESCRIPTION: Shows the compiled version of the component with React's compiler-runtime optimization. Implements caching mechanism using array $ to store and retrieve previously computed values based on props.a.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/merge-nested-scopes-with-same-inputs.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { setProperty } from "shared-runtime";

function Component(props) {
  const $ = _c(2);
  let y;
  if ($[0] !== props.a) {
    y = {};

    const x = {};
    setProperty(x, props.a);

    y.a = props.a;
    y.x = x;
    $[0] = props.a;
    $[1] = y;
  } else {
    y = $[1];
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ a: 42 }],
};
```

----------------------------------------

TITLE: Compiler-Transformed Component
DESCRIPTION: This snippet shows the compiler-transformed version of the React component. The compiler introduces memoization using `_c` from `react/compiler-runtime` to optimize rendering. It checks if the input 'a' has changed since the last render and reuses the previously computed value if it hasn't, avoiding unnecessary re-computations. This optimizes performance by caching results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capture_mutate-across-fns-iife.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(2);
  let z;
  if ($[0] !== a) {
    z = { a };

    (function () {
      z.b = 1;
    })();
    $[0] = a;
    $[1] = z;
  } else {
    z = $[1];
  }
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [2],
};

```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: Compiled version of the React component with added memoization logic using the compiler runtime. Includes caching mechanisms to optimize performance by avoiding unnecessary recomputation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-annotations/type-annotation-var-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enableUseTypeAnnotations
function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.id) {
    t0 = makeArray(props.id);
    $[0] = props.id;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  let t1;
  if ($[2] !== x) {
    t1 = x.at(0);
    $[2] = x;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const y = t1;
  return y;
}

function makeArray(x) {
  const $ = _c(2);
  let t0;
  if ($[0] !== x) {
    t0 = [x];
    $[0] = x;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ id: 42 }],
};
```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This is the transformed React component that leverages the React compiler runtime (`_c`) for memoization. It checks if `props.p0`, `props.p2`, and `props.p3` have changed using the cache `$`. If the props are unchanged, it reuses previously rendered elements from the cache. Otherwise, the component re-renders and updates the cache.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(8);
  let t0;
  let y;
  if ($[0] !== props.p0 || $[1] !== props.p2 || $[2] !== props.p3) {
    const x = [];
    switch (props.p0) {
      case true: {
        x.push(props.p2);
        x.push(props.p3);
      }
      case false: {
        y = x;
      }
    }

    t0 = <Component data={x} />;
    $[0] = props.p0;
    $[1] = props.p2;
    $[2] = props.p3;
    $[3] = t0;
    $[4] = y;
  } else {
    t0 = $[3];
    y = $[4];
  }
  const child = t0;
  y.push(props.p4);
  let t1;
  if ($[5] !== child || $[6] !== y) {
    t1 = <Component data={y}>{child}</Component>;
    $[5] = child;
    $[6] = y;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  return t1;
}
```

----------------------------------------

TITLE: Compiled Component with React Compiler Optimizations
DESCRIPTION: The React Compiler transformed version of the component with memoization for rendering optimizations. It uses the _c function to create and maintain a local state array that tracks changes to props and avoids unnecessary re-renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-call-complex-param-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";
import { identity } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.name) {
    t0 = fbt._(
      "Hello, {(key) name}!",
      [fbt._param("(key) name", identity(props.name))],
      { hk: "2sOsn5" },
    );
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const text = t0;
  let t1;
  if ($[2] !== text) {
    t1 = <div>{text}</div>;
    $[2] = text;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
```

----------------------------------------

TITLE: Defining Fixture for Component Testing
DESCRIPTION: This snippet defines a fixture for testing the Component. It specifies the component function, initial parameters, and a sequence of renders with different prop combinations to test the component's behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-provider-store-capture-namespace-import.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{a: 0, b: 0}],
  sequentialRenders: [
    {a: 0, b: 0},
    {a: 1, b: 0},
    {a: 1, b: 1},
    {a: 1, b: 2},
    {a: 2, b: 2},
    {a: 3, b: 2},
    {a: 0, b: 0},
  ],
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization Optimizations
DESCRIPTION: The React compiler-transformed version of the useFoo hook with memoization for performance. The compiled code adds a caching mechanism to avoid recalculating values that haven't changed between renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/jump-poisoned/reduce-if-nonexhaustive-poisoned-deps.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { identity } from "shared-runtime";

function useFoo(t0) {
  const $ = _c(9);
  const { input, cond, hasAB } = t0;
  let t1;
  let x;
  if ($[0] !== cond || $[1] !== hasAB || $[2] !== input) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      x = [];
      if (cond) {
        if (!hasAB) {
          t1 = null;
          break bb0;
        }
        let t2;
        if ($[5] !== input.a.b) {
          t2 = identity(input.a.b);
          $[5] = input.a.b;
          $[6] = t2;
        } else {
          t2 = $[6];
        }
        x.push(t2);
      } else {
        let t2;
        if ($[7] !== input.a.b) {
          t2 = identity(input.a.b);
          $[7] = input.a.b;
          $[8] = t2;
        } else {
          t2 = $[8];
        }
        x.push(t2);
      }
    }
    $[0] = cond;
    $[1] = hasAB;
    $[2] = input;
    $[3] = t1;
    $[4] = x;
  } else {
    t1 = $[3];
    x = $[4];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ input: { b: 1 }, cond: true, hasAB: false }],
  sequentialRenders: [
    { input: { a: { b: 1 } }, cond: true, hasAB: true },
    { input: null, cond: true, hasAB: false },
    // preserve nullthrows
    { input: { a: { b: undefined } }, cond: true, hasAB: true },
    { input: { a: undefined }, cond: true, hasAB: true },
    { input: { a: { b: undefined } }, cond: true, hasAB: true },
    { input: undefined, cond: true, hasAB: true },
  ],
};
```

----------------------------------------

TITLE: Compiled React Hook with Memoization Logic
DESCRIPTION: Shows the compiled version of the custom hook with explicit memoization checks and caching implementation. Uses React compiler runtime to manage memoized values and implement dependency comparison logic.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-infer-more-specific.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @validatePreserveExistingMemoizationGuarantees

import { useMemo } from "react";

// More specific memoization always results in fewer memo block
// executions.
// Precisely:
//  x_new != x_prev does NOT imply x.y.z_new != x.y.z_prev
//  x.y.z_new != x.y.z_prev does imply x_new != x_prev
function useHook(x) {
  const $ = _c(2);
  let t0;
  let t1;
  if ($[0] !== x.y.z) {
    t1 = [x.y.z];
    $[0] = x.y.z;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useHook,
  params: [{ y: { z: 2 } }],
};
```

----------------------------------------

TITLE: Simplified React Test Fixture with Empty Function
DESCRIPTION: A minimalist version of the test fixture with an empty 'foo' function and the same FIXTURE_ENTRYPOINT export structure, likely representing a boilerplate or starter template for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-simple-phi.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: The compiled version of the React component using compiler runtime optimizations. Implements memoization and caching strategies through Symbol sentinels and temporary variables to improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-memoize-array-with-immutable-map-after-hook.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { useEffect, useState } from "react";

function Component(props) {
  const $ = _c(10);
  let t0;
  if ($[0] !== props.value) {
    t0 = [props.value];
    $[0] = props.value;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  let t1;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  useEffect(_temp, t1);
  let t2;
  if ($[3] !== x.length) {
    t2 = () => {
      console.log(x.length);
    };
    $[3] = x.length;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const onClick = t2;
  let t3;
  if ($[5] !== x) {
    t3 = x.map(_temp2);
    $[5] = x;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  let t4;
  if ($[7] !== onClick || $[8] !== t3) {
    t4 = <div onClick={onClick}>{t3}</div>;
    $[7] = onClick;
    $[8] = t3;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  return t4;
}
function _temp2(item) {
  return <span key={item}>{item}</span>;
}
function _temp() {}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
  isComponent: true,
};
```

----------------------------------------

TITLE: Optimized React Component Function Implementation in JavaScript
DESCRIPTION: This snippet presents an optimized version of the React component function. It improves variable declarations and assignments, removing unnecessary initializations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-alias-mutate.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function component(a) {
  let x;
  if (a) {
    x = "bar";
  } else {
    x = "baz";
  }

  const y = x;
  mutate(y);
  return y;
}
```

----------------------------------------

TITLE: Compiled React Component
DESCRIPTION: This is the transformed React component after compilation. It uses the `_c` function from `react/compiler-runtime` for memoization. The transformed component checks if the props.value has changed and updates the cached values accordingly, optimizing re-renders. The function returns an array containing the cached values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/temporary-property-load-accessed-outside-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component(props) {
  const $ = _c(6);
  let t0;
  let t1;
  if ($[0] !== props.value) {
    const maybeMutable = new MaybeMutable();
    const x = props.value;
    t0 = x;
    t1 = maybeMutate(maybeMutable);
    $[0] = props.value;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t0 || $[4] !== t1) {
    t2 = [t0, t1];
    $[3] = t0;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
```

----------------------------------------

TITLE: Exporting a React fixture entry point in Javascript
DESCRIPTION: This code snippet exports a constant named `FIXTURE_ENTRYPOINT`, which is an object that defines a React fixture. It specifies the function to be used (`foo`), the parameters to be passed to the function, and whether the function is a component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-sibling-phis.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Compiler-Optimized JavaScript with Memoization
DESCRIPTION: The optimized version of the function produced by React's compiler. It replaces the conditional logic with a memoization cache using React's compiler runtime, resulting in more efficient execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-objectexpression-phi.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = { x: 1, y: 3 };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const t = t0;
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized React Component Using React Compiler Runtime in JavaScript
DESCRIPTION: This JavaScript snippet optimizes the 'component' function with the help of React's compiler runtime. It uses the '_c' function to create compiler-specific optimizations by managing state changes efficiently with a tuple '$'. The code exports the component using a consistent fixture entry point object suitable for adding to a React project. This snippet requires the React compiler runtime for its execution.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-within-block.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function component(a) {
  const $ = _c(4);
  let t0;
  if ($[0] !== a) {
    t0 = { a };
    $[0] = a;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const z = t0;
  let x;
  let t1;
  if ($[2] !== z) {
    t1 = function () {
      console.log(z);
    };
    $[2] = z;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  x = t1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Compiled Output of FBT Internationalized React Component
DESCRIPTION: This snippet shows the compiled output of the FBT-based React component. It includes optimizations for memoization and demonstrates how FBT transforms the internationalized strings.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-to-string.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.name) {
    t0 = fbt._("Hello {user name}", [fbt._param("user name", props.name)], {
      hk: "2zEDKF",
    });
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const element = t0;
  let t1;
  if ($[2] !== element) {
    t1 = element.toString();
    $[2] = element;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Jason" }],
};
```

----------------------------------------

TITLE: Using React Hook to Mutate State in JavaScript
DESCRIPTION: This snippet demonstrates the use of a React-like hook to handle state changes with mutation capabilities. It uses the `mutate` function from 'shared-runtime' to manage changes to an array based on the properties `bar`, `foo`, and `cond`. The function `useFoo` returns the mutated state, and the `FIXTURE_ENTRYPOINT` object sets up test parameters for sequential rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-renaming-ternary-with-mutation.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function useFoo(props) {
  let x = [];
  x.push(props.bar);
  props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;
  mutate(x);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{cond: false, foo: 2, bar: 55}],
  sequentialRenders: [
    {cond: false, foo: 2, bar: 55},
    {cond: false, foo: 3, bar: 55},
    {cond: true, foo: 3, bar: 55},
  ],
};

```

----------------------------------------

TITLE: Implementing a Counter Function with += Operator in JavaScript
DESCRIPTION: Defines a function 'foo' that initializes a variable to 1, increments it 10 times using the += operator, and returns the final value. The function is exported as part of a fixture entrypoint configuration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  for (let i = 0; i < 10; i++) {
    x += 1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining Component Function with State Mutation - JavaScript
DESCRIPTION: This snippet defines a function named 'component' that mutates an object based on inputs 'foo' and 'bar'. It uses shared-runtime for mutation and returns an object containing 'foo'. The dependency on 'shared-runtime' is essential for the mutate function to work correctly. The function expects two parameters and outputs an object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-arr-2-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {mutate} = require('shared-runtime');

function component(foo, bar) {
  let x = {foo};
  let y = {bar};
  (function () {
    let a = [y];
    let b = x;
    a.x = b;
  })();
  mutate(y);
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['foo', 'bar'],
};
```

----------------------------------------

TITLE: React Component with Object Mutation and Memoization
DESCRIPTION: A React component that creates and mutates objects, demonstrating advanced state management techniques using compiler runtime and shared runtime
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-fun-alias-captured-mutate-arr-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function Component({foo, bar}) {
  let x = {foo};
  let y = {bar};
  const f0 = function () {
    let a = [y];
    let b = x;
    a.x = b;
  };
  f0();
  mutate(y);
  return x;
}
```

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { mutate } from "shared-runtime";

function Component(t0) {
  const $ = _c(3);
  const { foo, bar } = t0;
  let x;
  if ($[0] !== bar || $[1] !== foo) {
    x = { foo };
    const y = { bar };
    const f0 = function () {
      const a = [y];
      const b = x;
      a.x = b;
    };

    f0();
    mutate(y);
    $[0] = bar;
    $[1] = foo;
    $[2] = x;
  } else {
    x = $[2];
  }
  return x;
}
```

----------------------------------------

TITLE: React Component with Input Mutation and Shared Runtime
DESCRIPTION: A React functional component that demonstrates object mutation, nested object assignment, and dynamic state manipulation using shared runtime mutation techniques
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {mutate} from 'shared-runtime';

function Component({foo, bar}) {
  let x = {foo};
  let y = {bar};
  const f0 = function () {
    let a = [y];
    let b = x;
    // this writes y.x = x
    a[0].x = b;
  };
  f0();
  mutate(y.x);
  return y;
}
```

----------------------------------------

TITLE: Unsupported Throw Statement in Try/Catch Block in React Component
DESCRIPTION: A React component function that attempts to throw an array in a try/catch block and then access the caught exception. This pattern triggers a build-time error in React's compiler that indicates throwing arrays inside try/catch blocks is not supported.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo.try-catch-with-throw.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  try {
    throw [];
  } catch (e) {
    x.push(e);
  }
  return x;
}
```

----------------------------------------

TITLE: Compilation Error for Fire Event Dependency
DESCRIPTION: Highlights a compilation error related to improper use of the fire() method and effect dependencies. The error suggests using an array literal for effect dependencies when fire() is used.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-rewrite-deps-no-array-literal.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  11 |   useEffect(() => {
  12 |     fire(foo(props));
> 13 |   }, deps);
     |      ^^^^ Invariant: Cannot compile `fire`. You must use an array literal for an effect dependency array when that effect uses `fire()` (13:13)
  14 |
  15 |   return null;
  16 | }
```

----------------------------------------

TITLE: Executing fire in a React Component - JavaScript
DESCRIPTION: This snippet defines a React component that imports the 'fire' function from 'react' and attempts to use it within an effect hook. The component accepts props and logs them to the console. The 'nested' function calls 'fire' with the 'foo' function and subsequently calls 'foo', leading to a compilation error due to inconsistent usage of 'fire'. Dependencies include 'react'. Key parameters are the component props. The primary output is a null return and console logs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-mix-fire-and-no-fire.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @enableFire
import {fire} from 'react';

function Component(props) {
  const foo = props => {
    console.log(props);
  };
  useEffect(() => {
    function nested() {
      fire(foo(props));
      foo(props);
    }

    nested();
  });

  return null;
}

```

----------------------------------------

TITLE: Original Input Function with Non-Overlapping Dependency Paths
DESCRIPTION: A test function that demonstrates how different property paths can be tracked separately. It accesses multiple nested properties from the props object and combines them into a new object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-nonoverlap-descendant.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Test that we can track non-overlapping dependencies separately.
// (not needed for correctness but for dependency granularity)
function TestNonOverlappingDescendantTracked(props) {
  let x = {};
  x.a = props.a.x.y;
  x.b = props.b;
  x.c = props.a.c.x.y.z;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: TestNonOverlappingDescendantTracked,
  params: [{a: {x: {}, c: {x: {y: {z: 3}}}}}],
};
```

----------------------------------------

TITLE: Input: Testing Non-Overlapping Dependency Tracking in React
DESCRIPTION: Original function that creates an object with properties from props.a. This tests React Compiler's ability to separately track non-overlapping dependencies for better granularity.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-deps/uncond-nonoverlap-direct.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Test that we can track non-overlapping dependencies separately.
// (not needed for correctness but for dependency granularity)
function TestNonOverlappingTracked(props) {
  let x = {};
  x.b = props.a.b;
  x.c = props.a.c;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: TestNonOverlappingTracked,
  params: [{a: {b: 2, c: 3}}],
};
```

----------------------------------------

TITLE: Implementing React Component with Setter Function
DESCRIPTION: A React component that declares an object with a setter function to update a local variable. The component renders a div displaying the value set via the object's setter. The issue is that the build system cannot handle the setter function syntax.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-set-syntax.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let value;
  const object = {
    set value(v) {
      value = v;
    },
  };
  object.value = props.value;
  return <div>{value}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [{value: 0}],
  sequentialRenders: [{value: 1}, {value: 2}],
};
```

----------------------------------------

TITLE: Initializing Global Variable and React Component
DESCRIPTION: Defines a global variable and a React component that modifies and renders the global state. Uses compilation mode inference and no panic threshold.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/should-bailout-without-compilation-infer-mode.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
let someGlobal = 'joe';

function Component() {
  someGlobal = 'wat';
  return <div>{someGlobal}</div>;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Exporting React Component as FIXTURE_ENTRYPOINT
DESCRIPTION: This code exports the 'Foo' component as part of an object assigned to 'FIXTURE_ENTRYPOINT'. This object configures the component for use in a fixture or testing setup. It includes the component function itself, the component's parameters, and the component's name.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-object-element.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: Simple React component implementation with an ErrorView component that renders errors using Stringify, wrapped in Foo and Bar components.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/gating/multi-arrow-expr-export-default-gating-test.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating
import {Stringify} from 'shared-runtime';

const ErrorView = (error, _retry) => <Stringify error={error}></Stringify>;

export default props => (
  <Foo>
    <Bar></Bar>
    <ErrorView></ErrorView>
  </Foo>
);
```

----------------------------------------

TITLE: Building and Testing Release Script - Shell
DESCRIPTION: This script is responsible for building and testing the React DevTools release. It should be executed in a terminal to ensure everything functions correctly before publishing.
SOURCE: https://github.com/facebook/react/blob/main/scripts/devtools/README.md#2025-04-21_snippet_1

LANGUAGE: sh
CODE:
```
./build-and-test.js
```

----------------------------------------

TITLE: React Component Fixture Entrypoint
DESCRIPTION: Defines a test fixture for the Component with predefined parameters, used for testing or evaluation purposes
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unmemoized-nonreactive-dependency-is-pruned-as-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: 42 }],
};
```

----------------------------------------

TITLE: Skip Build React Benchmarks
DESCRIPTION: Runs benchmarks without rebuilding bundles, useful for local performance tweaking when remote bundles are already built
SOURCE: https://github.com/facebook/react/blob/main/scripts/bench/README.md#2025-04-21_snippet_1

LANGUAGE: bash
CODE:
```
yarn --cwd=../../ build react/index,react-dom/index --type=UMD_PROD && yarn start --skip-build
```

----------------------------------------

TITLE: React Hermes Compiler Error Output
DESCRIPTION: The error output from the React Hermes compiler when encountering value blocks (such as conditional operators, logical expressions, optional chaining) within a try/catch statement. The error specifically points to the comparison operation in the for loop condition.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-declaration-for-all-identifiers.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  3 |     // NOTE: this fixture previously failed during LeaveSSA;
  4 |     // double-check this code when supporting value blocks in try/catch
> 5 |     for (let i = 0; i < 2; i++) {}
    |                     ^ Todo: Support value blocks (conditional, logical, optional chaining, etc) within a try/catch statement (5:5)
  6 |   } catch {}
  7 | }
  8 |
```

----------------------------------------

TITLE: Implementing React Function with Empty Infinite Loop
DESCRIPTION: This code snippet defines a React function 'useFoo' that contains an infinite while loop with an empty body. The function will never terminate due to the constant true condition and performs no operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/loop-unused-let.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function useFoo() {
  while (1) {}
}
```

----------------------------------------

TITLE: Handling Errors in JavaScript Execution
DESCRIPTION: This snippet captures an error related to an update expression inside a lambda function. It indicates that there are issues in handling variables modified as closure references, potentially pointing towards improvements needed in the handling of side effects in functional contexts.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-handle-update-context-identifiers.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```
  2 |   let counter = 2;
  3 |   const fn = () => {
> 4 |     return counter++;
    |            ^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Handle UpdateExpression to variables captured within lambdas. (4:4)
  5 |   };
  6 |
  7 |   return fn();
```
```

----------------------------------------

TITLE: Testing Callback Relaxation in React JavaScript
DESCRIPTION: The snippet demonstrates a regression test for internal code in React, showcasing how the callback rule is designed to be more relaxed unless it's certain that the code is within a component or a hook. This utilizes inferred events and extends selector functionality with specific conditions to trigger a function call. Dependencies include the functions 'each', 'useExtendedSelector', 'extendedButton', and 'foo'. It requires pixel data for operation and doesn't apply the callback unless the conditions are satisfied.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-0592bd574811.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @compilationMode(infer)
// Regression test for some internal code.
// This shows how the "callback rule" is more relaxed,
// and doesn't kick in unless we're confident we're in
// a component or a hook.
function makeListener(instance) {
  each(pixelsWithInferredEvents, (pixel) => {
    if (useExtendedSelector(pixel.id) && extendedButton) {
      foo();
    }
  });
}
```

----------------------------------------

TITLE: Defining a Simple Function in JavaScript
DESCRIPTION: This snippet defines a simple function 'g' that initializes an object and manipulates its properties by incrementing and then doubling a value. The result is returned from the function. There are no external dependencies for this function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations-complex-lvalue.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function g() {
  const x = {y: {z: 1}};
  x.y.z = x.y.z + 1;
  x.y.z *= 2;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: g,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Transformed React Component Code
DESCRIPTION: Transformed version of the component where array destructuring is broken down into explicit variable assignments. Shows how the default value logic is separated into distinct operations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring-with-conditional-as-default-value.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  const [t0] = props.y;
  const x = t0 === undefined ? (true ? 1 : 0) : t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ y: [] }],
};
```

----------------------------------------

TITLE: Simplified Function Implementation in JavaScript
DESCRIPTION: A simplified version of the function that directly assigns and returns the first parameter, with a consistent fixture entrypoint export
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-multiple-phis.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  let x;

  x = a;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Compiled Custom React Hook Definition
DESCRIPTION: This code shows the compiled version of the `useCustomHook` after it has been processed by the React compiler.  It uses `_c` from `react/compiler-runtime` to create and manage a cache.  The compiled code efficiently updates the event handler and manages side effects using the memoization and caching capabilities provided by the React compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import {
  useEffect,
  useRef,
  // @ts-expect-error
  experimental_useEffectEvent as useEffectEvent,
} from "react";

let id = 0;
function uniqueId() {
  "use no memo";
  return id++;
}

export function useCustomHook(src) {
  const $ = _c(6);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = uniqueId();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const uidRef = useRef(t0);
  const destroyed = useRef(false);
  const getItem = _temp;
  let t1;
  if ($[1] !== src) {
    t1 = () => {
      if (destroyed.current) {
        return;
      }

      getItem(src, uidRef.current);
    };
    $[1] = src;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const getItemEvent = useEffectEvent(t1);
  let t2;
  if ($[3] !== getItemEvent) {
    t2 = () => {
      destroyed.current = false;
      getItemEvent();
    };
    $[3] = getItemEvent;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = [];
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  useEffect(t2, t3);
}
```

----------------------------------------

TITLE: Compiled React Component with Memoization
DESCRIPTION: This snippet represents the compiled version of the `Foo` component. It uses `react/compiler-runtime` to access a memoization cache (`_c`). It checks if the cache contains a sentinel value, and if so, calculates the value using the same logic as the original component (array `x`, function `foo`, and `invoke`). The result is stored in the cache for subsequent calls. If the cache contains a value, it's returned directly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/lambda-array-access-member-expr-param.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```javascript
import { c as _c } from "react/compiler-runtime";
import { invoke } from "shared-runtime";

function Foo() {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = [{ value: 0 }, { value: 1 }, { value: 2 }];
    const foo = (param) => x[param].value;

    t0 = invoke(foo, 1);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}]
};

```
```

----------------------------------------

TITLE: Defining a Component with State Operations in React (JavaScript)
DESCRIPTION: This snippet defines a React component using variable increment and decrement operations to manage state. It returns an object with state values and exports a fixture entry point pointing to the component. Dependencies include JavaScript ES6 for variable handling, with no external libraries required. The parameters are empty, and it outputs an object with updated state values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-constant-propagation.expect.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
function Component() {
  let a = 0;
  const b = a++;
  const c = ++a;
  const d = a--;
  const e = --a;
  return {a, b, c, d, e};
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Building React from Source
DESCRIPTION: Build React from source if local changes are made to the DevTools.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_3

LANGUAGE: sh
CODE:
```
cd <react-repo>
yarn build-for-devtools
```

----------------------------------------

TITLE: Compiled React Component with Optimization
DESCRIPTION: Optimized version of the component with memoization using compiler-runtime. Implements caching mechanism to avoid redundant calculations when props haven't changed.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/align-scopes-iife-return-modified-later-logical.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { getNull } from "shared-runtime";

function Component(props) {
  const $ = _c(3);
  let t0;
  let items;
  if ($[0] !== props.a) {
    t0 = getNull() ?? [];
    items = t0;

    items.push(props.a);
    $[0] = props.a;
    $[1] = items;
    $[2] = t0;
  } else {
    items = $[1];
    t0 = $[2];
  }
  return items;
}
```

----------------------------------------

TITLE: React Component with direct assignment
DESCRIPTION: This React component takes props as input and directly assigns a value `x` based on the conditional `props.a && props.b`.  It returns the computed value.  A fixture entrypoint is defined to specify the component and its parameters, facilitating testing or demonstration.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-logical.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let t0;
  t0 = props.a && props.b;
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};

```

----------------------------------------

TITLE: Setting Subtree Mode Operation in React DevTools
DESCRIPTION: Example showing the operation payload for setting the mode for a component subtree. It includes the operation type, subtree root fiber id, and a bitmask representing the mode.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_8

LANGUAGE: javascript
CODE:
```
[
  7,   // set subtree mode
  1,   // subtree root fiber id
  0b01 // mode bitmask
]
```

----------------------------------------

TITLE: Defining Function 'bar' in JavaScript
DESCRIPTION: This snippet defines a simple function named 'bar' that takes an argument 'a', initializes an array and an object, and immediately invokes a function to assign a value to 'y'. The function returns 'y', which is expected to be the value of the first element of the array created from the input parameter.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function bar(a) {
  let x = [a];
  let y = {};
  (function () {
    y = x[0];
  })();

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: ['TodoAdd'],
};
```

----------------------------------------

TITLE: React Regression Test with Conditional Expression and useState
DESCRIPTION: This snippet demonstrates a regression test in React for a conditional expression. The test includes the useState hook and a conditional ternary operator, ensuring that valid code involving these features is not falsely flagged.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-c5d1f3143c4c.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// Regression test for incorrectly flagged valid code.
function RegressionTest() {
  cond ? a : b;
  useState();
}

```

----------------------------------------

TITLE: Optimized React Component with Compiler Runtime
DESCRIPTION: This code represents the compiled and optimized version of the `PrimitiveAsDep` component, utilizing React's compiler runtime. The `_c` function manages memoization, checking if `props.b + 1` has changed. If it has, `foo(props.b + 1)` is recomputed, and the result is stored; otherwise, the cached result is used. The optimized component efficiently handles the primitive dependency.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/primitive-as-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // props.b + 1 is an non-allocating expression, which means Forget can
// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1
// separately from props.b)
// Correctness:
//   y depends on either props.b or props.b + 1
function PrimitiveAsDep(props) {
  const $ = _c(2);
  const t0 = props.b + 1;
  let t1;
  if ($[0] !== t0) {
    t1 = foo(t0);
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const y = t1;
  return y;
}

```

----------------------------------------

TITLE: Defining and Exporting Function in JavaScript
DESCRIPTION: This snippet defines a function 'f' that performs simple arithmetic operations on a variable 'x', and an object 'FIXTURE_ENTRYPOINT' that exports this function. The function manipulates the value of 'x' using increment and bitwise operations. It doesn\'t take any parameters and returns an integer value. The snippet is part of the file that handles simple function definitions and exporting in JavaScript.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/assignment-variations.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function f() {
  let x = 1;
  x = x + 1;
  x += 1;
  x >>>= 1;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Build Error for Setter Function in React Component
DESCRIPTION: The error output from the build system showing that it cannot handle setter functions in an object expression. The error points to the setter function definition and indicates a TODO item in the BuildHIR system.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-set-syntax.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  2 |   let value;
  3 |   const object = {
> 4 |     set value(v) {
    |     ^^^^^^^^^^^^^^
> 5 |       value = v;
    | ^^^^^^^^^^^^^^^^
> 6 |     },
    | ^^^^^^ Todo: (BuildHIR::lowerExpression) Handle set functions in ObjectExpression (4:6)
  7 |   };
  8 |   object.value = props.value;
  9 |   return <div>{value}</div>;
```

----------------------------------------

TITLE: Transforming a Function with React Compiler
DESCRIPTION: This code transforms the original JavaScript function `foo` using `react/compiler-runtime`.  It introduces a `_c` function (aliased as `_c`) to potentially optimize the function's execution. The transformed function uses memoization to store the result of `a.b` for potential reuse, improving performance if `a.b` doesn't change frequently.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/simple-scope.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a) {
  const $ = _c(2);
  let t0;
  if ($[0] !== a.b) {
    t0 = [a.b];
    $[0] = a.b;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const x = t0;
  return x;
}
```

----------------------------------------

TITLE: Compiled FBT React Component with Compiler Runtime
DESCRIPTION: This snippet shows the compiled version of the FBT React component. It uses React's compiler runtime for optimization and transforms the FBT syntax into efficient JavaScript code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbtparam-text-must-use-expression-container.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <Foo
        value={fbt._("{ value}%", [fbt._param("value", "0")], { hk: "10F5Cc" })}
      />
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
```

----------------------------------------

TITLE: Modified Test Function with Fixed Return Value for 'TodoAdd' Component
DESCRIPTION: This snippet is a variation of the first function where the return statement has been modified to use a literal '2' instead of the variable 'x' in the last term. It maintains the same fixture entrypoint structure for the 'TodoAdd' component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/expression-with-assignment-dynamic.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function f(y) {
  let x = y;
  return x + (x = 2) + 2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining React Component (Input)
DESCRIPTION: This code defines a simple React component named `Component` that receives an object with a property `c`. It increments `c` to create `h`, decrements `c` to create `i`, and returns an array containing `c`, `h`, and `i`. The `FIXTURE_ENTRYPOINT` object configures the component for testing or demonstration purposes with initial parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-3.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component({c}) {
  let h = c++;
  let i = --c;
  return [c, h, i];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{c: 4}],
  isComponent: false,
};
```

----------------------------------------

TITLE: Finding Element at Index N Algorithm in React DevTools
DESCRIPTION: Algorithm for finding the Nth element in the component tree using the weight attribute. First it finds which root contains the index by iterating through roots and checking their weights.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_9

LANGUAGE: javascript
CODE:
```
let rootID;
let root;
let rootWeight = 0;
for (let i = 0; i < this._roots.length; i++) {
  rootID = this._roots[i];
  root = this._idToElement.get(rootID);
  if (root.children.length === 0) {
    continue;
  } else if (rootWeight + root.weight > index) {
    break;
  } else {
    rootWeight += root.weight;
  }
}
```

----------------------------------------

TITLE: Implementing Simplified React Test Fixture
DESCRIPTION: Provides a simplified version of the test fixture function that directly adds 1 to the input parameter. Exports the same fixture entrypoint configuration structure.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unconditional-break-label.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(a) {
  return a + 1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Optimized Compiler Output with Memoization
DESCRIPTION: Transformed version of the function using React's compiler runtime for memoization. Implements caching using an array ($) to store previous values and avoid unnecessary re-computations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructuring.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function foo(a, b, c) {
  const $ = _c(18);
  let d;
  let h;
  let t0;
  if ($[0] !== a) {
    [d, t0, ...h] = a;
    $[0] = a;
    $[1] = d;
    $[2] = h;
    $[3] = t0;
  } else {
    d = $[1];
    h = $[2];
    t0 = $[3];
  }
  const [t1] = t0;
  let g;
  let t2;
  if ($[4] !== t1) {
    ({ e: t2, ...g } = t1);
    $[4] = t1;
    $[5] = g;
    $[6] = t2;
  } else {
    g = $[5];
    t2 = $[6];
  }
  const { f } = t2;
  const { l: t3, p } = b;
  const { m: t4 } = t3;
  let o;
  let t5;
  if ($[7] !== t4) {
    [t5, ...o] = t4;
    $[7] = t4;
    $[8] = o;
    $[9] = t5;
  } else {
    o = $[8];
    t5 = $[9];
  }
  const [n] = t5;
  let t6;
  if (
    $[10] !== d ||
    $[11] !== f ||
    $[12] !== g ||
    $[13] !== h ||
    $[14] !== n ||
    $[15] !== o ||
    $[16] !== p
  ) {
    t6 = [d, f, g, h, n, o, p];
    $[10] = d;
    $[11] = f;
    $[12] = g;
    $[13] = h;
    $[14] = n;
    $[15] = o;
    $[16] = p;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  return t6;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Original React Function Component with Dynamic Scoping
DESCRIPTION: Initial implementation of a React component demonstrating scope dependencies, state mutations, and conditional rendering
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/same-variable-as-dep-and-redeclare-maybe-frozen.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(props) {
  // scope 0: deps=[props.a] decl=[x] reassign=none
  let x = [];
  x.push(props.a);

  // scope 1: deps=[x] decl=[header] reassign=none
  const header = props.showHeader ? <div>{x}</div> : null;

  // scope 2:
  // deps=[x, props.b, props.c]
  // decl=none
  // reassign=[x]
  const y = [x]; // y depends on the earlier x
  x = []; // x reassigned
  y.push(props.b); // interleaved mutation of x/y
  x.push(props.c); // interleaved mutation

  // scope 3 ...
  const content = (
    <div>
      {x}
      {y}
    </div>
  );

  // scope 4 ...
  return (
    <>
      {header}
      {content}
    </>
  );
}
```

----------------------------------------

TITLE: Implementing Closure in JavaScript with React
DESCRIPTION: This snippet defines a function 'foo' that creates a closure. It declares a constant 'x', creates an inner function that logs 'x', calls the inner function, and returns 'x'. It also exports a fixture entry point for testing.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/const-propagation-into-function-expression-primitive.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const x = 42;
  const f = () => {
    console.log(x);
  };
  f();
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Managing Object Mutation JavaScript
DESCRIPTION: This function initializes arrays and objects, modifies an array, and returns an object containing the modified array. It relies on a mutate function which is not defined here. Accepts no parameters and returns an object containing a potentially mutated array. The main focus is on array and object manipulation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-mutate-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const x = [];
  const y = {};
  y.x = x;
  mutate(x);
  return y;
}

```

----------------------------------------

TITLE: Installing react-is package with Yarn and NPM
DESCRIPTION: Commands to install the react-is package using either Yarn or NPM package managers.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-is/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
# Yarn
yarn add react-is

# NPM
npm install react-is
```

----------------------------------------

TITLE: Optimized React Component Rendering Using Compiler Runtime - JavaScript
DESCRIPTION: This snippet elaborates an optimized rendering of a React component using 'react/compiler-runtime'. It employs a caching mechanism to optimize performance by storing previously computed results. The 'Component' function checks for updates in 'items' and reuses cached values when no changes are detected. It depends on 'react/compiler-runtime' for managing component states efficiently. Inputs are 'items' as props, and the component outputs a div wrapping the rendered items via 'Stringify'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/outlined-helper.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.items) {
    t0 = props.items.map(_temp);
    $[0] = props.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = <div>{t0}</div>;
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
function _temp(item) {
  return <Stringify key={item.id} item={item.name} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ items: [{ id: 1, name: "one" }] }],
};

```

----------------------------------------

TITLE: Reordering Children Operation in React DevTools
DESCRIPTION: Example showing the operation payload for reordering children of a component. It includes the operation type, parent fiber id, count of children, and the ordered list of child fiber ids.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_4

LANGUAGE: javascript
CODE:
```
[
  3,  // re-order operation
  15, // fiber id
  2,  // number of children
  35, // first child id
  21, // second child id
]
```

----------------------------------------

TITLE: Defining Function That Calls Another Function - JavaScript
DESCRIPTION: This snippet defines a JavaScript function that, despite not being a hook, can call another function named 'userFetch'. It highlights a key aspect of JavaScript where functions are first-class citizens and can be invoked based on conditional logic. The snippet serves as an example of valid function usage within the JavaScript programming paradigm.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/rules-of-hooks-485bf041f55f.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Valid because functions can call functions.
function functionThatStartsWithUseButIsntAHook() {
  if (cond) {
    userFetch();
  }
}

```

----------------------------------------

TITLE: Creating a JavaScript Function with Deliberate Infinite Loop
DESCRIPTION: A JavaScript function 'foo' containing an explicit infinite loop using 'while(true)'. The return statement after the loop will never be reached. This function is exported as part of a test fixture object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-while-no-reassign.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  while (true) {}
  return 1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component with FBT Translation - Compiled Version
DESCRIPTION: Compiled and optimized version of the FBT component with caching logic for performance. This version includes memoization using array-based caching to prevent unnecessary re-renders and string conversions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/fbt-param-with-quotes.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

function Component(props) {
  const $ = _c(4);
  let t0;
  if ($[0] !== props.name) {
    t0 = fbt._('Hello {"user" name}', [fbt._param('"user" name', props.name)], {
      hk: "S0vMe",
    });
    $[0] = props.name;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const element = t0;
  let t1;
  if ($[2] !== element) {
    t1 = element.toString();
    $[2] = element;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ name: "Jason" }],
};
```

----------------------------------------

TITLE: Implementing Memoized React Component with Compiler Runtime
DESCRIPTION: A React component that uses compiler runtime memoization to cache and reuse rendered Button components based on prop changes. The component implements a manual memoization check using an array to store previous prop values and rendered results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/module-scope-use-memo-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
"use memo";
import { c as _c } from "react/compiler-runtime";
export default function TestComponent(t0) {
  const $ = _c(2);
  const { x } = t0;
  let t1;
  if ($[0] !== x) {
    t1 = <Button>{x}</Button>;
    $[0] = x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
}
```

----------------------------------------

TITLE: Simplified React Component Definition and Export
DESCRIPTION: This snippet shows a simplified version of the component function that directly returns a value of 2. It exports the component as a fixture entrypoint with the same properties as the input version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/type-test-primitive.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function component() {
  return 2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining a Simple Function for Data Manipulation - JavaScript
DESCRIPTION: This snippet defines a simple function 'bar' that takes an argument 'a', initializes an array with it, and assigns it to a variable 'y' through an inner function. The function is then exported as part of a fixture entry point with specified parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-alias-computed-load.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function bar(a) {
  let x = [a];
  let y = {};
  const f0 = function () {
    y = x[0];
  };
  f0();

  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: bar,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Exporting Component Fixture Entry Point in React JavaScript
DESCRIPTION: This code snippet initializes a global variable 'someGlobal', defines a React component 'Component' that modifies this global variable, and associates the component with a fixture entry point. It focuses on setting up a component structure to be potentially used as part of a React application setup. The snippet has no parameters or significant external dependencies and returns null from the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/should-bailout-without-compilation-annotation-mode.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @gating @panicThreshold(none) @compilationMode(annotation)
let someGlobal = \"joe\";

function Component() {
  \"use forget\";
  someGlobal = \"wat\";
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
};
```

----------------------------------------

TITLE: Removing Root Operation in React DevTools
DESCRIPTION: Example showing the operation payload for removing an entire root including its descendants. This specialized message is used when updating component filters to preserve fiber ids.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_7

LANGUAGE: javascript
CODE:
```
[
  6, // remove root operation
]
```

----------------------------------------

TITLE: Compiled: FBT Pluralization with Memoization
DESCRIPTION: The compiled version of the FBT pluralization component, showing how React's compiler transforms the FBT calls. It includes memoization logic to optimize rendering performance and the table structure used for handling pluralization rules.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/bug-fbt-plural-multiple-function-calls.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import fbt from "fbt";

/**
 * Similar to error.todo-multiple-fbt-plural
 *
 * Evaluator error:
 *   Found differences in evaluator results
 *   Non-forget (expected):
 *   (kind: ok) <div>1 apple and 2 bananas</div>
 *   Forget:
 *   (kind: ok) <div>1 apples and 2 bananas</div>
 */

function useFoo(t0) {
  const $ = _c(3);
  const { apples, bananas } = t0;
  let t1;
  if ($[0] !== apples || $[1] !== bananas) {
    t1 = fbt._(
      {
        "*": {
          "*": "{number of apples} apples and {number of bananas} bananas",
        },
        _1: { _1: "{number of apples} apple and {number of bananas} banana" },
      },
      [
        fbt._plural(apples),
        fbt._plural(bananas),
        fbt._param("number of apples", apples),
        fbt._param("number of bananas", bananas),
      ],
      { hk: "3vKunl" },
    );
    $[0] = apples;
    $[1] = bananas;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ apples: 1, bananas: 2 }],
};
```

----------------------------------------

TITLE: Compiled React Component with Memoization (Compiled Output)
DESCRIPTION: This is the compiled version of the React component, utilizing React's compiler-runtime. It implements memoization using a symbol-based caching mechanism and preserves the mutation functionality from the input version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transitive-freeze-array.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @enablePreserveExistingMemoizationGuarantees
const { mutate } = require("shared-runtime");

function Component(props) {
  const $ = _c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    const x = {};
    const y = {};
    const items = [x, y];
    items.pop();

    mutate(y);
    t0 = [x, y, items];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: Compiled React Component with Cache Implementation
DESCRIPTION: Compiled version of the component that includes React's memoization logic using a cache sentinel. The transformation adds caching mechanism while maintaining the original component's functionality.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-of-conditional-break.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
function Component() {
  const $ = _c(1);
  let x;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    x = [];
    for (const item of [1, 2]) {
      if (item === 1) {
        break;
      }

      x.push(item);
    }
    $[0] = x;
  } else {
    x = $[0];
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Error: Unsafe Expression Reordering (JavaScript)
DESCRIPTION: This snippet showcases an error message related to the potential unsafe reordering of expressions within an arrow function. Specifically, it indicates that an `ArrowFunctionExpression` cannot be safely reordered at the given location. This error typically arises during compilation or optimization processes where the order of execution might impact the final result.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.default-param-accesses-local.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Component(
  2 |   x,
> 3 |   y = () => {
    |       ^^^^^^^
> 4 |     return x;
    | ^^^^^^^^^^^^^
> 5 |   }
    | ^^^^ Todo: (BuildHIR::node.lowerReorderableExpression) Expression type `ArrowFunctionExpression` cannot be safely reordered (3:5)
  6 | ) {
  7 |   return y();
  8 | }

```

----------------------------------------

TITLE: Handling ReactiveScope with Shared Runtime in JavaScript
DESCRIPTION: This snippet creates a React component and shows an edge case for how ReactiveScope propagates variables. Dependencies include 'shared-runtime'. It illustrates a potential invariant violation due to differences in evaluator results, and includes logic to render a component using a Stringify function. This snippet expects inputs from shared constants and utilities, and outputs JSX with a component's serialized state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-invalid-phi-as-dependency.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {CONST_TRUE, Stringify, mutate, useIdentity} from 'shared-runtime';

/**
 * Fixture showing an edge case for ReactiveScope variable propagation.
 *
 * Found differences in evaluator results
 *   Non-forget (expected):
 *   <div>{"obj":{"inner":{"value":"hello"},"wat0":"joe"},"inner":["[[ cyclic ref *2 ]]"]}</div>
 *   <div>{"obj":{"inner":{"value":"hello"},"wat0":"joe"},"inner":["[[ cyclic ref *2 ]]"]}</div>
 *   Forget:
 *   <div>{"obj":{"inner":{"value":"hello"},"wat0":"joe"},"inner":["[[ cyclic ref *2 ]]"]}</div>
 *   [[ (exception in render) Error: invariant broken ]]
 *
 */
function Component() {
  const obj = CONST_TRUE ? {inner: {value: 'hello'}} : null;
  const boxedInner = [obj?.inner];
  useIdentity(null);
  mutate(obj);
  if (boxedInner[0] !== obj?.inner) {
    throw new Error('invariant broken');
  }
  return <Stringify obj={obj} inner={boxedInner} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arg: 0}],
  sequentialRenders: [{arg: 0}, {arg: 1}],
};

```

----------------------------------------

TITLE: Error Message for Invalid React State Update
DESCRIPTION: This error message is generated when the React component attempts to unconditionally set state during render. It points to the specific line causing the issue and provides a link to the React documentation for further information.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.unconditional-set-state-in-render-after-loop-break.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
   9 |     }
  10 |   }
> 11 |   setState(true);
     |   ^^^^^^^^ InvalidReact: This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState) (11:11)
  12 |   return state;
  13 | }
  14 |
```

----------------------------------------

TITLE: Error Handling for Async Component
DESCRIPTION: The code includes a syntax error message for unhandled cases in the 'for await' loop, indicating that the loop needs proper handling to work correctly within the component's context. This is crucial for improving error management and code robustness.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-for-await-loops.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | async function Component({items}) {
  2 |   const x = [];
> 3 |   for await (const item of items) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 4 |     x.push(item);
    | ^^^^^^^^^^^^^^^^^
  5 |   }
    | ^^^^ Todo: (BuildHIR::lowerStatement) Handle for-await loops (3:5)
  6 |   return x;
  7 | }
  8 |

```

----------------------------------------

TITLE: React Error Messaging for Invalid Ref Access - JavaScript
DESCRIPTION: This section captures the error output generated by React when attempting to access the `current` property of a ref during render. It provides a line-by-line breakdown of where the error occurs and the accompanying message that advises against such usage, including a link to the React documentation for reference.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-set-and-read-ref-during-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 | function Component(props) {
  3 |   const ref = useRef(null);
> 4 |   ref.current = props.value;
    |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (4:4)

InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (5:5)
  5 |   return ref.current;
  6 | }
  7 |

```

----------------------------------------

TITLE: Cloning the React Repository
DESCRIPTION: Clone the React repository from GitHub to get started with the DevTools project.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CONTRIBUTING.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
git clone git@github.com:facebook/react.git
```

----------------------------------------

TITLE: Conditional Parameter Assignment Function
DESCRIPTION: A JavaScript function that conditionally assigns a value based on multiple input parameters. The function takes three parameters and returns a value depending on the truthiness of parameters b and c.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-nested-partial-phi.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let x = a;
  if (b) {
    if (c) {
      x = c;
    }
    return x;
  }
}
```

----------------------------------------

TITLE: Optimized React Component with Labeled Statements
DESCRIPTION: This is an optimized version of the Component function. It uses labeled statements (bb0, bb1, bb2) for control flow, removes some unnecessary code, and simplifies the switch statement. The core functionality remains the same as the original version.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/dominator.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x = 0;
  bb0: if (props.a) {
    x = 1;
  } else {
    if (props.b) {
    } else {
      break bb0;
    }

    x = 3;
  }
  bb1: bb2: switch (props.c) {
    case "a": {
      x = 4;
      break bb2;
    }
    case "b": {
      break bb1;
    }
    case "c": {
    }
    default: {
      x = 6;
    }
  }
  if (props.d) {
    return null;
  }
  return x;
}
```

----------------------------------------

TITLE: Defining React Compiler Fixture Entrypoint
DESCRIPTION: Configuration for testing the compiler transformation with sequential render scenarios
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/propagate-scope-deps-hir-fork/reduce-reactive-deps/infer-function-uncond-access-local-var.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: null}],
  sequentialRenders: [{a: null}, {a: {b: {c: 4}}}],
};
```

----------------------------------------

TITLE: Defining FixtureEntrypoint Type in TypeScript
DESCRIPTION: Type definition for FIXTURE_ENTRYPOINT that Sprout requires for test execution. This type specifies the function to be tested and the parameters to pass to it.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/snap/src/sprout/README.md#2025-04-21_snippet_0

LANGUAGE: typescript
CODE:
```
type FixtureEntrypoint<T> = {
  // function to be invoked
  fn: ((...params: Array<T>) => any),
  // params to pass to fn
  // (if `fn` is a react component, this should be an array
  // with exactly one element -- props)
  params: Array<T>,
}
```

----------------------------------------

TITLE: React Component Definition
DESCRIPTION: This code defines a React component that takes a single argument 'a'. Inside the component, it creates an object 'z' with 'a' as a property and a function 'x' that logs the value of 'z'. The component then returns the function 'x'.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-1.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a};
  let x = function () {
    console.log(z);
  };
  return x;
}
```

----------------------------------------

TITLE: Fixture Entrypoint Configuration
DESCRIPTION: Test configuration for the useFoo function, defining input parameters and sequential render scenarios
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reduce-reactive-cond-deps-return-in-scope.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{ obj: null, objIsNull: true }],
  sequentialRenders: [
    { obj: null, objIsNull: true },
    { obj: { a: 2 }, objIsNull: false },
  ]
};
```

----------------------------------------

TITLE: Defining Foo Functionality with Conditional Logic - JavaScript
DESCRIPTION: This snippet defines a function 'foo' that initializes a variable 'x' to 1 and changes its value to 2 if a conditional check passes. The function returns the final value of 'x'. It serves as an example of basic variable manipulation and condition handling in JavaScript. The 'FIXTURE_ENTRYPOINT' constant exports this function as part of an object, providing its callable reference.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-return.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  if (x === 1) {
    x = 2;
  }

  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Running a Local Server
DESCRIPTION: This snippet shows how to run a local server to serve the fixtures. It uses `npx pushstate-server .` to start a server in the current directory, making the fixtures accessible through a browser.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/packaging/README.md#2025-04-21_snippet_1

LANGUAGE: shell
CODE:
```
npx pushstate-server .
```

----------------------------------------

TITLE: Complex React Component Handler with Conditional Logic
DESCRIPTION: Defines a handler function with multiple conditional branches and exports a test fixture configuration. The function evaluates conditions to return different parameters based on input value and computed results.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-phi.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  let x;
  if (a) {
    x = 2 - 1;
  } else {
    x = 0 + 1;
  }
  if (x === 1) {
    return b;
  } else {
    return c;
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Optimized Calculation Function with Fixture Entrypoint in JavaScript
DESCRIPTION: This is an optimized version of the 'foo' function, with slight modifications in the loop update statement. It also exports a FIXTURE_ENTRYPOINT object for a 'TodoAdd' component, specifying the function, params, and component name.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-logical.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(props) {
  let y = 0;
  for (
    let x = 0;
    x > props.min && x < props.max;
    x = x + (props.cond ? props.increment : 2), x
  ) {
    x = x * 2;
    y = y + x;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Updating Error and Warning Counts in React DevTools
DESCRIPTION: Example showing the operation payload for updating error and warning counts for a component. It includes the operation type, fiber id, and the number of error and warning calls.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_6

LANGUAGE: javascript
CODE:
```
[
  5, // update error/warning counts operation
  4, // fiber id
  0, // number of calls to console.error from that fiber
  3, // number of calls to console.warn from that fiber
]
```

----------------------------------------

TITLE: React Component Definition with JSX Outlining
DESCRIPTION: This code defines a React component named `Component` which takes an array `arr` as a prop. It maps over this array twice, creating a nested structure of `Bar` and `Baz` components wrapped in JSX. The `@enableJsxOutlining` directive likely enables specific JSX outlining features in the environment.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/jsx-outlining-child-stored-in-id.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableJsxOutlining
function Component({arr}) {
  const x = useX();
  return arr.map(i => {
    <>
      {arr.map((i, id) => {
        let child = (
          <Bar x={x}>
            <Baz i={i}></Baz>
          </Bar>
        );

        let jsx = <div>{child}</div>;
        return jsx;
      })}
    </>;
  });
}

function Bar({x, children}) {
  return (
    <>
      {x}
      {children}
    </>
  );
}

function Baz({i}) {
  return <>{i}</>;
}

function useX() {
  return 'x';
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{arr: ['foo', 'bar']}],
};
```

----------------------------------------

TITLE: Defining a React Component Function in JavaScript
DESCRIPTION: The JavaScript code defines a function named 'component' that creates a closure capturing a variable 'z'. It then exports an object named FIXTURE_ENTRYPOINT that includes the function as a property. This exported object represents a module entry point for using 'component' with the 'TodoAdd' parameter. This snippet operates within a JavaScript environment and does not rely on external libraries.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-function-within-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function component(a) {
  let z = {a};
  let x;
  {
    x = function () {
      console.log(z);
    };
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};

```

----------------------------------------

TITLE: Removing Nodes Operation in React DevTools
DESCRIPTION: Example showing the operation payload for removing fibers from the component tree. It includes the operation type, count of removed fibers, and the ids of each removed fiber.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
[
  2, // remove operation
  2, // number of removed fibers
  35, // first removed id
  21, // second removed id
]
```

----------------------------------------

TITLE: Optimizing React Component with Compiler Runtime (JavaScript)
DESCRIPTION: This snippet demonstrates an optimized React component using 'react/compiler-runtime'. It includes conditional logic checks to memoize computed values and avoid unnecessary re-evaluations. It showcases potential improvements in handling object properties, with 'Stringify' as a dependency, expecting the same inputs as the previous version. The memoization enhances performance but requires managing the cache state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/hoisting-functionexpr-conditional-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { Stringify } from "shared-runtime";

/**
 * We currently hoist the accessed properties of function expressions,
 * regardless of control flow. This is simply because we wrote support for
 * function expressions before doing a lot of work in PropagateScopeDeps
 * to handle conditionally accessed dependencies.
 *
 * Current evaluator error:
 *  Found differences in evaluator results
 *  Non-forget (expected):
 *  (kind: ok) <div>{"shouldInvokeFns":true,"callback":{"kind":"Function","result":null}}</div>
 *  Forget:
 *  (kind: exception) Cannot read properties of null (reading 'prop')
 */
function Component(t0) {
  const $ = _c(5);
  const { obj, isObjNull } = t0;
  let t1;
  if ($[0] !== isObjNull || $[1] !== obj) {
    t1 = () => {
      if (!isObjNull) {
        return obj.prop;
      } else {
        return null;
      }
    };
    $[0] = isObjNull;
    $[1] = obj;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const callback = t1;
  let t2;
  if ($[3] !== callback) {
    t2 = <Stringify shouldInvokeFns={true} callback={callback} />;
    $[3] = callback;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ obj: null, isObjNull: true }],
};

```

----------------------------------------

TITLE: Original JavaScript function foo
DESCRIPTION: This code defines the original `foo` function.  It takes a boolean `a` as input. It creates an object `x`, and based on the value of `a`, it adds either a property `y` or `z` to `x`. Finally, it calls `mutate(x)` and returns `x`. The `mutate` function is assumed to be defined elsewhere and modifies the object `x` in place.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-property-alias-mutate-if.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a) {
  const x = {};
  if (a) {
    let y = {};
    x.y = y;
  } else {
    let z = {};
    x.z = z;
  }
  mutate(x);
  return x;
}
```

----------------------------------------

TITLE: Defining a Function and Exporting in JavaScript
DESCRIPTION: This snippet defines a function 'foo' that accepts two parameters 'a' and 'b', initializes two empty arrays, and adds the parameters to those arrays. It also exports a constant 'FIXTURE_ENTRYPOINT' which contains a reference to the function and additional metadata for its use in a React component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-shadowed.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b) {\n  let x = [];\n  let y = [];\n  y.push(b);\n  x.push(a);\n}\n\nexport const FIXTURE_ENTRYPOINT = {\n  fn: foo,\n  params: ['TodoAdd'],\n  isComponent: 'TodoAdd',\n};\n
```

----------------------------------------

TITLE: Error Handling for Invalid useEffect Argument in React
DESCRIPTION: This snippet shows the error generated when attempting to use the 'fire' function with a spread argument in a React component. The error message clarifies that 'fire' should receive a single call expression only.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.invalid-spread.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
```
   7 |   };
   8 |   useEffect(() => {
>  9 |     fire(...foo);
     |     ^^^^^^^^^^^^ InvalidReact: Cannot compile `fire`. fire() can only take in a single call expression as an argument but received a spread argument (9:9)
  10 |   });
  11 |
  12 |   return null;
```

```

----------------------------------------

TITLE: Updating Dependencies After React Changes
DESCRIPTION: Command to update the SSR fixture dependencies after making changes to React. This step is required whenever the React codebase is modified and rebuilt.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr/README.md#2025-04-21_snippet_1

LANGUAGE: bash
CODE:
```
yarn
```

----------------------------------------

TITLE: Transformed JavaScript Switch Statement with Labeled Breaks
DESCRIPTION: A transformed version of the same switch statement function, now using labeled breaks (bb0) and empty case blocks. This transformation likely represents an intermediate state in React's compilation or optimization process.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/switch-with-fallthrough.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(x) {
  bb0: switch (x) {
    case 0: {
    }
    case 1: {
    }
    case 2: {
      break bb0;
    }
    case 3: {
      break bb0;
    }
    case 4: {
    }
    case 5: {
    }
    default: {
    }
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Evaluating React Component with Sequential Renders in JavaScript
DESCRIPTION: This JavaScript snippet defines a function `Component` that processes `props.values` and assigns values to `x` based on conditions. The component is associated with `FIXTURE_ENTRYPOINT`, allowing sequential renders to evaluate the component behavior when different prop values are passed. The focus is on how `x` is computed reactively through multiple renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/reactive-control-dependency-forin-collection.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(props) {
  let x;
  for (const key in props.values) {
    const i = parseInt(key, 10);
    if (i > 10) {
      x = 10;
    } else {
      x = 1;
    }
  }
  // The values assigned to `x` are non-reactive, but the value of `x`
  // depends on the "control" variable `i`, whose value is derived from
  // `props.values` which is reactive.
  // Therefore x should be treated as reactive too.
  return [x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [],
  sequentialRenders: [
    {values: {'12': true}},
    {values: {'12': true}},
    {values: {'1': true}},
    {values: {'1': true}},
    {values: {'12': true}},
    {values: {'1': true}},
    {values: {'12': true}},
    {values: {'1': true}},
  ],
};
```

----------------------------------------

TITLE: Compiled Fixture Entrypoint Definition
DESCRIPTION: This code defines the same `FIXTURE_ENTRYPOINT` as the original file.  It specifies the component function, indicates that it is a component, and provides parameters for the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_6

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  isComponent: true,
  params: [{ x: 1 }],
};
```

----------------------------------------

TITLE: Running React Async Demo from Source Code
DESCRIPTION: Steps to build React from source code, install fixture dependencies, copy the React source to the fixture, and run the demo application. This approach allows testing with a custom build of React.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/concurrent/time-slicing/README.md#2025-04-21_snippet_1

LANGUAGE: shell
CODE:
```
# 1: Build react from source
cd /path/to/react
yarn
yarn build react-dom/index,react/index,react-cache,scheduler --type=NODE

# 2: Install fixture dependencies
cd fixtures/unstable-async/time-slicing/
yarn

# 3: Copy React source code over
yarn copy-source

# 3: Run the app
yarn start
```

----------------------------------------

TITLE: Optimized JavaScript Function with Non-Executing Loop
DESCRIPTION: This snippet shows an optimized version of the 'foo' function where the loop condition is explicitly set to false, ensuring it never executes. It also exports the same fixture object for testing or analysis purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/constant-propagation-for.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  let y = 0;
  for (const x = 100; false; 100) {
    y = y + 1;
  }
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Compiled React Component with Optimized FBT Translations
DESCRIPTION: This snippet shows the compiled version of the React component. It demonstrates how FBT translations are optimized and converted to efficient runtime code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/fbt/lambda-with-fbt.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime";
import { fbt } from "fbt";

function Component() {
  const $ = _c(1);
  const buttonLabel = _temp;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (
      <View>
        <Button text={buttonLabel()} />
      </View>
    );
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function _temp() {
  if (!someCondition) {
    return fbt._("Purchase as a gift", null, { hk: "1gHj4g" });
  } else {
    if (
      !iconOnly &&
      showPrice &&
      item?.current_gift_offer?.price?.formatted != null
    ) {
      return fbt._(
        "Gift | {price}",
        [fbt._param("price", item?.current_gift_offer?.price?.formatted)],
        { hk: "3GTnGE" },
      );
    } else {
      if (!iconOnly && !showPrice) {
        return fbt._("Gift", null, { hk: "3fqfrk" });
      }
    }
  }
}
```

----------------------------------------

TITLE: Defining Original React Component with Variable References
DESCRIPTION: The original component defines variables with references, calls a function that modifies one of the references, and returns an array containing both variables. This example demonstrates a pattern that would typically cause re-renders in React.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/chained-assignment-context-variable.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {makeArray} from 'shared-runtime';

function Component() {
  let x,
    y = (x = {});
  const foo = () => {
    x = makeArray();
  };
  foo();
  return [y, x];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{}],
};
```

----------------------------------------

TITLE: React Compiler Error: Cannot Preserve Memoization
DESCRIPTION: The error message produced by the React Compiler when it detects a mismatch between inferred dependencies and manually specified dependencies in a useMemo call, which could lead to unexpected behavior in component rendering.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.maybe-invalid-useMemo-read-maybeRef.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  3 |
  4 | function useHook(maybeRef, shouldRead) {
> 5 |   return useMemo(() => {
    |                  ^^^^^^^
> 6 |     return () => [maybeRef.current];
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 7 |   }, [shouldRead, maybeRef]);
    | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:7)
  8 | }
  9 |

```

----------------------------------------

TITLE: Compilation Error for Invalid Fire Method Usage
DESCRIPTION: An error message explaining that the `fire()` method can only receive a direct function call, not method calls or other complex expressions. This highlights the strict syntax requirements for using the `fire()` method.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/error.todo-method.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   7 |   };
   8 |   useEffect(() => {
>  9 |     fire(props.foo());
     |     ^^^^^^^^^^^^^^^^^ InvalidReact: Cannot compile `fire`. `fire()` can only receive a function call such as `fire(fn(a,b)). Method calls and other expressions are not allowed (9:9)
  10 |   });
  11 |
  12 |   return null;
```

----------------------------------------

TITLE: Running Default React Benchmarks
DESCRIPTION: Runs benchmarks with default settings, building local and remote React and ReactDOM UMD bundles and executing all benchmark tests
SOURCE: https://github.com/facebook/react/blob/main/scripts/bench/README.md#2025-04-21_snippet_0

LANGUAGE: bash
CODE:
```
yarn start
```

----------------------------------------

TITLE: Defining a Simple React Component Function
DESCRIPTION: This snippet defines a JavaScript function using destructuring to extract values from an object, and exposes it via an export. It requires no external dependencies and outputs a constant value extracted from the input. Parameters are fixed and the function is not designed as a React component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-string-literal-invalid-identifier-property-key.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const {'data-foo-bar': t} = {'data-foo-bar': 1};
  return t;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Implementing React Test Fixture with Block Label
DESCRIPTION: Implements a test fixture function using a labeled block statement to set a variable before returning. Exports a fixture entrypoint configuration for a TodoAdd component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unconditional-break-label.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a) {
  let x = 0;
  bar: {
    x = 1;
    break bar;
  }
  return a + x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: Starting React DevTools Shell Harness (sh)
DESCRIPTION: These commands navigate into the `react-devtools-shell` package directory and then execute the `yarn start` command to launch the test harness. This process is intended to be run alongside the local development instance of the `react-devtools-inline` package for concurrent testing.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-shell/README.md#_snippet_0

LANGUAGE: sh
CODE:
```
cd packages/react-devtools-shell

yarn start
```

----------------------------------------

TITLE: Checking Bridge Protocol Version Compatibility in React DevTools
DESCRIPTION: During initialization, DevTools checks if it's compatible with the backend embedded in renderers like React Native. If incompatible, upgrade instructions are shown.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// Example usage:
DevTools.initialize({
  // ...
  checkBridgeProtocolVersion: true
});
```

----------------------------------------

TITLE: Starting SSR Fixtures in Production Mode
DESCRIPTION: Command to run the SSR fixtures in production mode. This pre-builds all static resources and starts a server-side rendering HTTP server without hot reloading.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr/README.md#2025-04-21_snippet_2

LANGUAGE: bash
CODE:
```
yarn start:prod
```

----------------------------------------

TITLE: Simplified Function Throwing a Value and Exporting in JavaScript
DESCRIPTION: This snippet defines a minimal JavaScript function named foo that immediately throws the value 2. It is then exported in an object named FIXTURE_ENTRYPOINT, similar to the previous example. The function lacks inputs and uses a hardcoded throw statement, simplifying its logic. This export maintains the same structure with a params array and a boolean flagging it as not a component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-throw.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {
  throw 2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Component Using Computed Property Keys
DESCRIPTION: This code defines a React component that creates an object with a computed property key using mutateAndReturn. The component imports utility functions from 'shared-runtime' and exports a FIXTURE_ENTRYPOINT for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-modified-during-after-construction.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {identity, mutate, mutateAndReturn} from 'shared-runtime';

function Component(props) {
  const key = {};
  const context = {
    [mutateAndReturn(key)]: identity([props.value]),
  };
  mutate(key);
  return context;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: React Compiler Error: Cannot Preserve Memoization
DESCRIPTION: The error output from React Compiler showing it has skipped optimizing the component because the existing manual memoization could not be preserved. The compiler detected that inferred dependencies didn't match the manually specified ones in useCallback.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.hoist-useCallback-conditional-access-own-scope.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   3 |
   4 | function Component({propA, propB}) {
>  5 |   return useCallback(() => {
     |                      ^^^^^^^
>  6 |     if (propA) {
     | ^^^^^^^^^^^^^^^^
>  7 |       return {
     | ^^^^^^^^^^^^^^^^
>  8 |         value: propB.x.y,
     | ^^^^^^^^^^^^^^^^
>  9 |       };
     | ^^^^^^^^^^^^^^^^
> 10 |     }
     | ^^^^^^^^^^^^^^^^
> 11 |   }, [propA, propB.x.y]);
     | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:11)
  12 | }
  13 |
  14 | export const FIXTURE_ENTRYPOINT = {
```

----------------------------------------

TITLE: Defining Object Destructuring and Array Creation in JavaScript
DESCRIPTION: This snippet defines a function 'foo' that performs object destructuring with renaming and creates an array. It also exports a FIXTURE_ENTRYPOINT object for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/destructure-mixed-property-key-types.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const {'data-foo-bar': x, a: y, data: z} = {'data-foo-bar': 1, a: 2, data: 3};
  return [x, y, z];
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Defining React Component Fixture with Array Manipulation in JavaScript
DESCRIPTION: Defines a function 'foo' that creates and populates two arrays, followed by exporting a FIXTURE_ENTRYPOINT object that specifies the function, its parameters, and identifies it as a 'TodoAdd' component for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-interleaved.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b) {
  let x = [];
  let y = [];
  x.push(a);
  y.push(b);
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React Component Definition with Mutation
DESCRIPTION: This snippet defines a React component that takes 'foo' and 'bar' as parameters, creates local objects x and y, and mutates the 'y' object within a function scope. It uses `shared-runtime`'s `mutate` function.  The component then returns the mutated 'y' object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/capturing-func-alias-captured-mutate-arr-iife.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
const {mutate} = require('shared-runtime');

function component(foo, bar) {
  let x = {foo};
  let y = {bar};
  (function () {
    let a = [y];
    let b = x;
    a.x = b;
  })();
  mutate(y);
  return y;
}

export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['foo', 'bar'],
};

```

----------------------------------------

TITLE: Simplified Function Implementation in React Fixture
DESCRIPTION: A simplified implementation of the function that directly returns a fixed value of 5. This appears to be the expected result of the more complex sequence point evaluation in the input section.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/expression-with-assignment.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function f() {
  return 5;
}

export const FIXTURE_ENTRYPOINT = {
  fn: f,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Optimized Component Rendering with Compiler Runtime in React
DESCRIPTION: This second snippet offers a low-level representation of a React component that manually optimizes rendering using a compiler runtime (`_c`). Instead of relying on useMemo directly, it implements a series of checks and state updates to conditionally render output. This demonstrates advanced techniques in React for handling props and memoization, providing another layer of optimization specific to the lifecycle of the component.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/props-method-dependency.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { c as _c } from "react/compiler-runtime"; // @compilationMode(infer)
import { useMemo } from "react";
import { ValidateMemoization } from "shared-runtime";

function Component(props) {
  const $ = _c(7);
  let t0;
  let t1;
  if ($[0] !== props.x) {
    t1 = props.x();
    $[0] = props.x;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const x = t0;
  let t2;
  if ($[2] !== props.x) {
    t2 = [props.x];
    $[2] = props.x;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t2 || $[5] !== x) {
    t3 = <ValidateMemoization inputs={t2} output={x} />;
    $[4] = t2;
    $[5] = x;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

const f = () => ["React"];
const g = () => ["Compiler"];
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ x: () => ["React"] }],
  sequentialRenders: [{ x: f }, { x: g }, { x: g }, { x: f }],
};

```

----------------------------------------

TITLE: Defining Input Test Function with Intentional Loop Issue in JavaScript
DESCRIPTION: Defines a function 'foo' that initializes a variable and contains a for loop with an intentionally missing update expression. The function is exported as a fixture entry point for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-for-trivial-update.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  for (let i = 0; i < 10; /* update is intentally a single identifier */ i) {
    x += 1;
  }
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Downloading React DevTools Dependencies from CI
DESCRIPTION: These commands download the latest experimental build of React DevTools dependencies from CI. They should be run from the scripts/release/ directory.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_11

LANGUAGE: sh
CODE:
```
yarn
./download-experimental-build.js --commit=main
```

----------------------------------------

TITLE: Running React SSR fixtures in production mode
DESCRIPTION: Command to run the server-side rendering fixtures in production mode, which pre-builds static resources and starts an HTTP server without hot reloading.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr2/README.md#2025-04-21_snippet_2

LANGUAGE: shell
CODE:
```
yarn start:prod
```

----------------------------------------

TITLE: Starting React DevTools Development Server
DESCRIPTION: This command starts a development server that watches for changes in the source code and automatically rebuilds the package.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-inline/README.md#2025-04-21_snippet_12

LANGUAGE: sh
CODE:
```
yarn start
```

----------------------------------------

TITLE: React Compiler Error Message for Memoization Preservation Failure
DESCRIPTION: This error message shows the React Compiler's diagnostic output when it fails to preserve existing memoization guarantees. It points to line 11 where useMemo is used within a mutable range created by a context variable.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-unmemoized-callback-captured-in-context-variable.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   9 |   const a = useHook();
  10 |   // Because b is also part of that same mutable range, it can't be memoized either
> 11 |   const b = useMemo(() => ({}), []);
     |             ^^^^^^^^^^^^^^^^^^^^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. (11:11)
  12 |
  13 |   // Conditional assignment without a subsequent mutation normally doesn't create a mutable
  14 |   // range, but in this case we're reassigning a context variable
```

----------------------------------------

TITLE: React Compiler Memoization Error
DESCRIPTION: This error message indicates that the React Compiler skipped optimizing the component because the inferred dependencies for `useMemo` did not match the manually specified dependencies (`[propA?.a, propB.x.y]`). This mismatch could cause the memoized value to change more or less frequently than expected.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-infer-less-specific-conditional-access.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   4 |
   5 | function Component({propA, propB}) {
>  6 |   return useMemo(() => {
     |                  ^^^^^^^
>  7 |     const x = {};
     | ^^^^^^^^^^^^^^^^^
>  8 |     if (propA?.a) {
     | ^^^^^^^^^^^^^^^^^
>  9 |       mutate(x);
     | ^^^^^^^^^^^^^^^^^
> 10 |       return {
     | ^^^^^^^^^^^^^^^^^
> 11 |         value: propB.x.y,
     | ^^^^^^^^^^^^^^^^^
> 12 |       };
     | ^^^^^^^^^^^^^^^^^
> 13 |     }
     | ^^^^^^^^^^^^^^^^^
> 14 |   }, [propA?.a, propB.x.y]);
     | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (6:14)
  15 | }
  16 |

```

----------------------------------------

TITLE: React Compiler Memoization Error
DESCRIPTION: This error message from the React Compiler indicates that it could not preserve the existing manual memoization when optimizing the component. The mismatch between inferred and manually specified dependencies in the `useMemo` hook is the cause.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.useMemo-property-call-dep.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  3 |
  4 | function Component({propA}) {
> 5 |   return useMemo(() => {
    |                  ^^^^^^^
> 6 |     return propA.x();
    | ^^^^^^^^^^^^^^^^^^^^^
> 7 |   }, [propA.x]);
    | ^^^^ CannotPreserveMemoization: React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected (5:7)
  8 | }
  9 |

```

----------------------------------------

TITLE: Prepare Experimental Release from CI Script
DESCRIPTION: This script prepares an experimental release by downloading build artifacts from CI. It's similar to preparing a 'next' release, but uses the `-r experimental` flag to specify the experimental release channel. This ensures that the correct build artifacts with experimental features enabled are used.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_2

LANGUAGE: shell
CODE:
```
scripts/release/prepare-release-from-ci.js -r experimental --commit=0e526bc
```

----------------------------------------

TITLE: Preparing Release Script - Shell
DESCRIPTION: This script increments version numbers and updates the CHANGELOG for the React DevTools. It is expected to be run in the terminal to prepare for a new release.
SOURCE: https://github.com/facebook/react/blob/main/scripts/devtools/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
./prepare-release.js
```

----------------------------------------

TITLE: Creating a React Component Test Fixture in JavaScript
DESCRIPTION: Defines a simple function 'foo' that manipulates arrays and exports a fixture entrypoint configuration for testing a 'TodoAdd' component. The fixture specifies the function, parameters, and component identification.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/overlapping-scopes-interleaved-by-terminal.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const x = [];
  const y = [];

  if (x) {
  }

  y.push(a);
  x.push(b);
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

LANGUAGE: javascript
CODE:
```
function foo(a, b, c) {
  const x = [];
  const y = [];
  if (x) {
  }

  y.push(a);
  x.push(b);
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Building React and Fixtures
DESCRIPTION: This snippet provides instructions on how to build React and the manual testing fixtures. It uses `npm run build` to build React and `node fixtures/packaging/build-all.js` to build the fixtures.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/packaging/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
cd react
npm run build
node fixtures/packaging/build-all.js
```

----------------------------------------

TITLE: Fixture Entrypoint Export
DESCRIPTION: Exports a fixture configuration object containing the component function, parameters, and component identifier for testing or compilation purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/prop-capturing-function-1.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd"
};
```

----------------------------------------

TITLE: Function with For Loop in Try/Catch Block (JavaScript)
DESCRIPTION: A JavaScript function that demonstrates a compiler error case where a for loop with comparison operations is placed within a try/catch block. This specific code pattern previously failed during the LeaveSSA phase of compilation and is identified as an unsupported feature in the Hermes compiler.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-repro-declaration-for-all-identifiers.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Foo() {
  try {
    // NOTE: this fixture previously failed during LeaveSSA;
    // double-check this code when supporting value blocks in try/catch
    for (let i = 0; i < 2; i++) {}
  } catch {}
}
```

----------------------------------------

TITLE: Git Checkout for Patch Release
DESCRIPTION: This command creates a new branch for a patch release, branching off from the previous release tag. This isolates the patch release work from ongoing development. For example, creating branch `16.8.3` from tag `v16.8.2`.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_6

LANGUAGE: shell
CODE:
```
git checkout -b 16.8.3 v16.8.2
```

----------------------------------------

TITLE: Original Function Implementation
DESCRIPTION: Original JavaScript function that performs object property mutations through compound assignment operators. Creates three objects and performs chained mutations on their properties.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/chained-assignment-expressions.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  const x = {x: 0};
  const y = {z: 0};
  const z = {z: 0};
  x.x += y.y *= 1;
  z.z += y.y *= x.x &= 3;
  return z;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Reproducing React Compiler Bug with useFoo Function
DESCRIPTION: This JavaScript code defines a React component `useFoo` that demonstrates a bug in the React compiler related to mutable ranges. The component initializes an array `x` and an object `y`, pushes `y` into `x`, and then modifies a property of the object within `x`. The issue arises when the compiler incorrectly infers mutable ranges, leading to incorrect memoization and potential mutation issues in specific scenarios such as function expressions with `enableTransitivelyFreezeFunctionExpressions:false`.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/bug-aliased-capture-aliased-mutate.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @flow @enableTransitivelyFreezeFunctionExpressions:false
import {arrayPush, setPropertyByKey, Stringify} from 'shared-runtime';

/**
 * 1. `InferMutableRanges` derives the mutable range of identifiers and their
 *     aliases from `LoadLocal`, `PropertyLoad`, etc
 *   - After this pass, y's mutable range only extends to `arrayPush(x, y)`
 *   - We avoid assigning mutable ranges to loads after y's mutable range, as
 *     these are working with an immutable value. As a result, `LoadLocal y` and
 *     `PropertyLoad y` do not get mutable ranges
 * 2. `InferReactiveScopeVariables` extends mutable ranges and creates scopes,
 *    as according to the 'co-mutation' of different values
 *   - Here, we infer that
 *     - `arrayPush(y, x)` might alias `x` and `y` to each other
 *     - `setPropertyKey(x, ...)` may mutate both `x` and `y`
 *   - This pass correctly extends the mutable range of `y`
 *   - Since we didn't run `InferMutableRange` logic again, the LoadLocal /
 *     PropertyLoads still don't have a mutable range
 *
 * Note that the this bug is an edge case. Compiler output is only invalid for:
 *  - function expressions with
 *    `enableTransitivelyFreezeFunctionExpressions:false`
 *  - functions that throw and get retried without clearing the memocache
 *
 * Found differences in evaluator results
 * Non-forget (expected):
 *   (kind: ok)
 *   <div>{"cb":{"kind":"Function","result":10},"shouldInvokeFns":true}</div>
 *   <div>{"cb":{"kind":"Function","result":11},"shouldInvokeFns":true}</div>
 * Forget:
 *   (kind: ok)
 *   <div>{"cb":{"kind":"Function","result":10},"shouldInvokeFns":true}</div>
 *   <div>{"cb":{"kind":"Function","result":10},"shouldInvokeFns":true}</div>
 */
function useFoo({a, b}: {a: number, b: number}) {
  const x = [];
  const y = {value: a};

  arrayPush(x, y); // x and y co-mutate
  const y_alias = y;
  const cb = () => y_alias.value;
  setPropertyByKey(x[0], 'value', b); // might overwrite y.value
  return <Stringify cb={cb} shouldInvokeFns={true} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{a: 2, b: 10}],
  sequentialRenders: [
    {a: 2, b: 10},
    {a: 2, b: 11},
  ],
};

```

----------------------------------------

TITLE: Handling Invalid React Component Configuration Error
DESCRIPTION: This snippet shows the error message generated when attempting to use `disableMemoizationForDebugging` and `enableChangeDetectionForDebugging` options together in a React component configuration. This indicates that the options are incompatible and cannot be used simultaneously.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.nomemo-and-change-detect.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
InvalidConfig: Invalid environment config: the 'disableMemoizationForDebugging' and 'enableChangeDetectionForDebugging' options cannot be used together
```

----------------------------------------

TITLE: Exporting Fixture Entry Point - JavaScript
DESCRIPTION: This snippet exports a constant that contains the function reference of the component along with predefined parameters to be used for testing or rendering the component in isolation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/non-null-assertion.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{name: 'Alice'}],
};

```

----------------------------------------

TITLE: Compiled React Component with Change Detection Instrumentation
DESCRIPTION: The compiled version of the component with React Compiler's change detection instrumentation added. It imports necessary runtime functions and adds structural comparison checks to detect and debug changes in the component's state.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/change-detect-reassign.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
import { $structuralCheck } from "react-compiler-runtime";
import { c as _c } from "react/compiler-runtime"; // @enableChangeDetectionForDebugging
function Component(props) {
  const $ = _c(2);
  let x = null;
  if (props.cond) {
    {
      x = [];
      x.push(props.value);
      let condition = $[0] !== props.value;
      if (!condition) {
        let old$x = $[1];
        $structuralCheck(old$x, x, "x", "Component", "cached", "(3:6)");
      }
      $[0] = props.value;
      $[1] = x;
      if (condition) {
        x = [];
        x.push(props.value);
        $structuralCheck($[1], x, "x", "Component", "recomputed", "(3:6)");
        x = $[1];
      }
    }
  }
  return x;
}
```

----------------------------------------

TITLE: Defining Minimal React Test Fixture in JavaScript
DESCRIPTION: A minimal JavaScript test fixture with an empty 'foo' function and FIXTURE_ENTRYPOINT export for React testing. This simplified version contains just the function structure with no implementation details.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-single-if.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Error Handling for React Hook Usage - JavaScript
DESCRIPTION: This section presents an error output indicating that Hooks cannot be referenced as normal values but must be invoked. It shows the specific line where the issue occurs and provides a link to the relevant React documentation for further guidance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-assign-hook-to-local.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  1 | function Component(props) {
> 2 |   const x = useState;
    |             ^^^^^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)
  3 |   const state = x(null);
  4 |   return state[0];
  5 | }
```

----------------------------------------

TITLE: Preparing Release from NPM in Shell
DESCRIPTION: This script promotes a specific commit version to stable in the NPM registry. It requires a version tag as an argument, which represents the commit ID and date. The expected input is a version string, and upon execution, it prepares the release for publication.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_11

LANGUAGE: sh
CODE:
```
scripts/release/prepare-release-from-npm.js --version=0.0.0-241c4467e-20200129
```

----------------------------------------

TITLE: Compilation Success Logs
DESCRIPTION: Compilation logs showing memoization statistics for both Component and Wrapper functions, including memo slots, blocks and pruned values.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/log-pruned-memoization.expect.md#2025-04-21_snippet_2

LANGUAGE: json
CODE:
```
{"kind":"CompileSuccess","fnLoc":{"start":{"line":10,"column":0,"index":159},"end":{"line":33,"column":1,"index":903},"filename":"log-pruned-memoization.ts"},"fnName":"Component","memoSlots":6,"memoBlocks":2,"memoValues":2,"prunedMemoBlocks":2,"prunedMemoValues":3}
{"kind":"CompileSuccess","fnLoc":{"start":{"line":37,"column":0,"index":939},"end":{"line":43,"column":1,"index":1037},"filename":"log-pruned-memoization.ts"},"fnName":"Wrapper","memoSlots":1,"memoBlocks":1,"memoValues":1,"prunedMemoBlocks":0,"prunedMemoValues":0}
```

----------------------------------------

TITLE: Building React and Setting Up SSR Fixtures
DESCRIPTION: Instructions for building React locally and setting up the SSR fixtures environment. This requires running the build command in the React root directory followed by installing dependencies in the fixtures folder.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/ssr/README.md#2025-04-21_snippet_0

LANGUAGE: bash
CODE:
```
cd fixtures/ssr
yarn
yarn start
```

----------------------------------------

TITLE: Defining FIXTURE_ENTRYPOINT for React Component Testing
DESCRIPTION: This snippet exports a FIXTURE_ENTRYPOINT object used for testing the React component. It includes the component function, initial parameters, and an array of sequential renders with different prop combinations to test various scenarios.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-mutable-range-extending-into-ternary.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ cond: false, items: [{ id: 0, name: "Alice" }] }],
  sequentialRenders: [
    { cond: false, items: [{ id: 0, name: "Alice" }] },
    {
      cond: false,
      items: [
        { id: 0, name: "Alice" },
        { id: 1, name: "Bob" },
      ],
    },
    {
      cond: true,
      items: [
        { id: 0, name: "Alice" },
        { id: 1, name: "Bob" },
      ],
    },
    {
      cond: false,
      items: [
        { id: 1, name: "Bob" },
        { id: 2, name: "Claire" },
      ],
    },
  ],
};
```

----------------------------------------

TITLE: React Build Error for Unsupported Throw Statement
DESCRIPTION: The build error output from React's compiler highlighting that throw statements inside of try/catch blocks are not currently supported, specifically when throwing an array. The error points to the exact line where the issue occurs.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo.try-catch-with-throw.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  2 |   let x;
  3 |   try {
> 4 |     throw [];
    |     ^^^^^^^^^ Todo: (BuildHIR::lowerStatement) Support ThrowStatement inside of try/catch (4:4)
  5 |   } catch (e) {
  6 |     x.push(e);
  7 |   }
```

----------------------------------------

TITLE: Defining and Evaluating a Complex JavaScript Function
DESCRIPTION: This JavaScript function exemplifies different aspects of the language, including destructuring, default parameters, class declarations and private fields, object methods, JSX elements, tagged template literals, and various loop constructs. It also contains multiple for-loops with early termination, switch cases, and comments indicating areas needing further implementation support. There are error comments related to unhandled parsing scenarios such as variable declarations and class handling.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-kitchensink.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo([a, b], {c, d, e = 'e'}, f = 'f', ...args) {
  let i = 0;
  var x = [];

  class Bar {
    #secretSauce = 42;
    constructor() {
      console.log(this.#secretSauce);
    }
  }

  const g = {b() {}, c: () => {}};
  const {z, aa = 'aa'} = useCustom();

  <Button haha={1}></Button>;
  <Button>{/** empty */}</Button>;

  const j = function bar([quz, qux], ...args) {};

  for (; i < 3; i += 1) {
    x.push(i);
  }
  for (; i < 3; ) {
    break;
  }
  for (;;) {
    break;
  }

  graphql`
    ${g}
  `;

  graphql`\t\n`;

  for (c of [1, 2]) {
  }
  for ([v] of [[1], [2]]) {
  }
  for ({v} of [{v: 1}, {v: 2}]) {
  }

  for (let x in {a: 1}) {
  }

  let updateIdentifier = 0;
  --updateIdentifier;
  ++updateIdentifier;
  updateIdentifier.y++;
  updateIdentifier.y--;

  switch (i) {
    case 1 + 1: {
    }
    case foo(): {
    }
    case x.y: {
    }
    default: {
    }
  }

  function component(a) {
    // Add support for function declarations once we support `var` hoisting.
    function t() {}
    t();
  }
}

let moduleLocal = false;

```

----------------------------------------

TITLE: Exporting Fixture Entry Point with Updated Component - JavaScript
DESCRIPTION: This snippet exports a constant 'FIXTURE_ENTRYPOINT' similar to the previous snippet but is associated with the new implementation of the 'Component'. It maintains the structure for testing or demonstration purposes, ensuring consistency across different component implementations.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/unused-conditional.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Defining Non-React Function in JavaScript
DESCRIPTION: This snippet defines a function named 'nonReactFn' that returns an empty object. The function is preceded by a compilation mode directive that suggests inference should be used.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/__tests__/e2e/__snapshots__/page.spec.ts/compilationMode-infer-output.txt#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @compilationMode(infer)
function nonReactFn() {
  return {};
}
```

----------------------------------------

TITLE: FIXTURE_ENTRYPOINT Configuration for Testing
DESCRIPTION: Exports a test fixture with a function and predefined parameters to validate the useFoo hook's behavior under specific conditions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/maybe-invalid-useMemo-no-memoblock-sideeffect.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [{minWidth: 2, styles: {width: 1}, setStyles: () => {}}]
};
```

----------------------------------------

TITLE: Fixture Entrypoint Definition
DESCRIPTION: This code defines a constant called `FIXTURE_ENTRYPOINT` that specifies the component to be used as the entry point for a fixture. It includes the component function (`Component`), a flag indicating that it is a component (`isComponent: true`), and parameters for the component (`params: [{x: 1}]`). This is likely used for testing or demonstration purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/import-as-local.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  isComponent: true,
  params: [{x: 1}],
};
```

----------------------------------------

TITLE: Error Message for Invalid Ref Access in React - JavaScript
DESCRIPTION: This snippet includes the error message generated due to invalid access of the 'current' property on a ref during the render of a React component. It specifies the line number and provides a link to the React documentation for further information.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-write-ref-prop-in-render.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  2 | function Component(props) {
  3 |   const ref = props.ref;
> 4 |   ref.current = true;
    |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (4:4)
  5 |   return <div>{value}</div>;
  6 | }
  7 |

```

----------------------------------------

TITLE: Minimal JavaScript Function Test Fixture
DESCRIPTION: A simplified JavaScript function example that contains an empty foo function and exports it as part of a FIXTURE_ENTRYPOINT object. This pattern appears to be used for testing function behavior in the React codebase.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-if-else.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo() {}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Configuring Web Crawler Access in robots.txt
DESCRIPTION: This robots.txt configuration allows all web crawlers to access the entire website without restrictions. It specifies the User-agent wildcard (*) to target all crawlers and includes an empty Disallow directive.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/owner-stacks/public/robots.txt#2025-04-21_snippet_0

LANGUAGE: robotstxt
CODE:
```
User-agent: *
Disallow:
```

----------------------------------------

TITLE: React Compiler Error Logs
DESCRIPTION: Compiler logs showing the detection of an invalid JSX element within a try statement, along with compilation statistics including memoization slots and blocks used. The error directs developers to use proper error boundaries instead.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/invalid-jsx-in-catch-in-outer-try-with-catch.expect.md#2025-04-21_snippet_2

LANGUAGE: json
CODE:
```
{"kind":"CompileError","detail":{"options":{"reason":"Unexpected JSX element within a try statement. To catch errors in rendering a given component, wrap that component in an error boundary. (https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)","description":null,"severity":"InvalidReact","loc":{"start":{"line":11,"column":11,"index":214},"end":{"line":11,"column":32,"index":235},"filename":"invalid-jsx-in-catch-in-outer-try-with-catch.ts"}}}},"fnLoc":null}
{"kind":"CompileSuccess","fnLoc":{"start":{"line":4,"column":0,"index":83},"end":{"line":17,"column":1,"index":290},"filename":"invalid-jsx-in-catch-in-outer-try-with-catch.ts"},"fnName":"Component","memoSlots":4,"memoBlocks":2,"memoValues":2,"prunedMemoBlocks":0,"prunedMemoValues":0}
```

----------------------------------------

TITLE: React Compiler Dependency Inference Error
DESCRIPTION: Error message indicating that the React Compiler cannot infer effect dependencies, which will break the build
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/infer-effect-dependencies/bailout-retry/error.use-no-memo.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
  4 | function Component({propVal}) {
  5 |   'use no memo';
> 6 |   useEffect(() => [propVal]);
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ InvalidReact: [InferEffectDependencies] React Compiler is unable to infer dependencies of this effect. This will break your build! To resolve, either pass your own dependency array or fix reported compiler bailout diagnostics. (6:6)
  7 | }
  8 |
```

----------------------------------------

TITLE: Prepare Stable Release from NPM Script
DESCRIPTION: This script prepares a stable release by checking out a 'next' release from NPM. It prompts the user to select stable version numbers and updates the package contents. This process is typically done to promote a tested 'next' release to a stable version.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_4

LANGUAGE: shell
CODE:
```
scripts/release/prepare-release-from-npm.js --version=0.0.0-241c4467e-20200129
```

----------------------------------------

TITLE: Updating Tree Base Duration Operation in React DevTools
DESCRIPTION: Example showing the operation payload for updating the base duration of a fiber, which is used by the Profiler UI. It includes the operation type, fiber id, and the new duration value.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/OVERVIEW.md#2025-04-21_snippet_5

LANGUAGE: javascript
CODE:
```
[
  4,  // update tree base duration operation
  4,  // tree base duration operation
  1,  // fiber id
  32, // new tree base duration value
]
```

----------------------------------------

TITLE: React Component Implementation
DESCRIPTION: Identical implementation of the React component showing the same functionality with slightly different formatting in the fixture object.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/for-in-statement-body-always-returns.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function Component(props) {
  for (const x in props.value) {
    return x;
  }
  return null;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{ value: { a: "A!" } }],
};
```

----------------------------------------

TITLE: Git Cherry Pick for Patch Release
DESCRIPTION: This command cherry-picks specific commits from the main branch into the patch release branch. This allows specific bug fixes or improvements to be included in the patch release. The `<commit-hash>` should be replaced with the actual commit hash to be included.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_7

LANGUAGE: shell
CODE:
```
git cherry-pick <commit-hash>
```

----------------------------------------

TITLE: Conditional Component Logic using Labeled Code Blocks in React JavaScript
DESCRIPTION: This snippet demonstrates an alternative approach to conditional logic in a React component, using labeled code blocks to determine which prop to return based on a condition. This approach relies solely on native JavaScript without any React-specific hooks. The result is determined by the `props.cond` condition, returning `props.a` or `props.b` accordingly.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/useMemo-inverted-if.expect.md#2025-04-21_snippet_1

LANGUAGE: JavaScript
CODE:
```
function Component(props) {
  let t0;
  bb0: {
    bb1: {
      if (props.cond) {
        break bb1;
      }

      t0 = props.a;
      break bb0;
    }

    t0 = props.b;
  }
  const x = t0;
  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Original React Component with Hook Calls
DESCRIPTION: Input React component demonstrating object memoization with useNoAlias hook. Tests handling of non-reactive objects spanning hook calls and their impact on dependencies.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/repro-invalid-reactivity-value-block.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {
  CONST_TRUE,
  identity,
  makeObject_Primitives,
  useNoAlias,
} from 'shared-runtime';

/**
 * Here the scope for `obj` is pruned because it spans the `useNoAlias()` hook call.
 * Because `obj` is non-reactive, it would by default be excluded as dependency for
 * `result = [...identity(obj)..., obj]`, but this could then cause the values in
 * `result` to be out of sync with `obj`.
 *
 * The fix is to consider pruned memo block outputs as reactive, since they will
 * recreate on every render. This means `thing` depends on both y and z.
 */
function Foo() {
  const obj = makeObject_Primitives();
  // hook calls keeps the next two lines as its own reactive scope
  useNoAlias();

  const shouldCaptureObj = obj != null && CONST_TRUE;
  const result = [shouldCaptureObj ? identity(obj) : null, obj];

  useNoAlias(result, obj);

  if (shouldCaptureObj && result[0] !== obj) {
    throw new Error('Unexpected');
  }
  return result;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{}],
  sequentialRenders: [{}, {}],
};
```

----------------------------------------

TITLE: Building the React DevTools Firefox Extension
DESCRIPTION: Commands for building the React DevTools Firefox extension from either the extension directory or project root.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/firefox/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
node build
```

LANGUAGE: shell
CODE:
```
yarn run build:firefox
```

----------------------------------------

TITLE: Running ESLint v9 Test Fixture for React Hooks
DESCRIPTION: Shell commands to set up and test the eslint-plugin-react-hooks with ESLint version 9. The commands navigate to the fixture directory, install dependencies, build the project, and run linting.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/eslint-v9/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
cd fixtures/eslint-v9
yarn
yarn build
yarn lint
```

----------------------------------------

TITLE: Demonstrating React Compiler Memoization Preservation Error
DESCRIPTION: This code snippet demonstrates a situation where React Compiler refuses to optimize a component due to an issue with preserving memoization guarantees. The useFoo function contains a useMemo call with an array dependency that might be mutated, causing the compiler to skip optimization.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.false-positive-useMemo-infer-mutate-deps.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {identity} from 'shared-runtime';

// This is a false positive as Forget's inferred memoization
// invalidates strictly less than source. We currently do not
// track transitive deps / invalidations of manual memo deps
// because of implementation complexity
function useFoo() {
  const val = [1, 2, 3];

  return useMemo(() => {
    return identity(val);
  }, [val]);
}

export const FIXTURE_ENTRYPOINT = {
  fn: useFoo,
  params: [],
};
```

----------------------------------------

TITLE: React Hook Error Message
DESCRIPTION: Error output highlighting the invalid hook call, specifically pointing out that hooks must be called consistently and not conditionally
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/todo.error.rules-of-hooks-e29c874aa913.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
7 |   try {
8 |     f();
> 9 |     useState();
   |     ^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (9:9)
10 |   } catch {}
11 | }
12 |
```

----------------------------------------

TITLE: Defining Conditional Array Initialization Function in JavaScript
DESCRIPTION: Original input code that defines a function which conditionally initializes an array and adds an element to it. This function is exported as part of a FIXTURE_ENTRYPOINT object for testing sequential renders.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/phi-reference-effects.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {arrayPush} from 'shared-runtime';

function Foo(cond) {
  let x = null;
  if (cond) {
    x = [];
  } else {
  }
  // Here, x = phi(x$null, x$[]) should receive a ValueKind of Mutable
  arrayPush(x, 2);

  return x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{cond: true}],
  sequentialRenders: [{cond: true}, {cond: true}],
};
```

----------------------------------------

TITLE: Publishing Release Script - Shell
DESCRIPTION: This script publishes the React DevTools release to NPM. It needs to be executed in a terminal and includes additional instructions for uploading to browser extension stores.
SOURCE: https://github.com/facebook/react/blob/main/scripts/devtools/README.md#2025-04-21_snippet_2

LANGUAGE: sh
CODE:
```
./publish-release.js
```

----------------------------------------

TITLE: Running React View Transition test in production mode
DESCRIPTION: Command to start the View Transition test in production mode with pre-built static resources and server-side rendering without hot reloading.
SOURCE: https://github.com/facebook/react/blob/main/fixtures/view-transition/README.md#2025-04-21_snippet_2

LANGUAGE: bash
CODE:
```
yarn start:prod
```

----------------------------------------

TITLE: Logging Fire Usage in React - JavaScript
DESCRIPTION: This snippet demonstrates an attempt to log the 'fire' function from the 'react' library, which is conditionally imported. Dependencies include the React library itself. The main issue is an untransformed reference, causing a compiler error, indicating the need for proper transformation of the 'fire' call. Critical parameters are the '@enableFire' annotation and '@panicThreshold(none)', which seem to influence code transformation behavior. Outputs are logged to the console, but a compiler error is likely unless resolved.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/transform-fire/bailout-retry/error.untransformed-fire-reference.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
// @enableFire @panicThreshold(none)
import {fire} from 'react';

console.log(fire == null);

```

----------------------------------------

TITLE: Implementing React Fixture with Function Implementation
DESCRIPTION: Defines a simple function 'foo' with variable assignments and exports it as a fixture entrypoint. The configuration specifies it's not a React component and has no parameters.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-simple.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;
  let y = 2;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: Build Error for Computed Property Key
DESCRIPTION: The error message from the build process indicates that the computed property key [mutateAndReturn(key)] is causing a problem. The build system expected an Identifier but received a CallExpression in the object key position.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-mutate-key-while-constructing-object.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  4 |   const key = {};
  5 |   const context = {
> 6 |     [mutateAndReturn(key)]: identity([props.value]),
    |      ^^^^^^^^^^^^^^^^^^^^ Todo: (BuildHIR::lowerExpression) Expected Identifier, got CallExpression key in ObjectExpression (6:6)
  7 |   };
  8 |   return context;
  9 | }
```

----------------------------------------

TITLE: Original JavaScript Function with Increment Operations
DESCRIPTION: Simple function demonstrating pre and post-increment operations on input parameter, returning an array of modified values
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/update-expression-on-function-parameter-2.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function Component(a) {
  let d = a++;
  let e = ++a;
  return [a, d, e];
}

export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [2],
  isComponent: false
};
```

----------------------------------------

TITLE: Updated Fixture Entrypoint with String Literals in JavaScript
DESCRIPTION: This snippet shows an updated version of the FIXTURE_ENTRYPOINT object. It uses double quotes for string literals instead of single quotes, adhering to a consistent string notation style.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression.expect.md#2025-04-21_snippet_3

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ["TodoAdd"],
  isComponent: "TodoAdd",
};
```

----------------------------------------

TITLE: Running ESLint v8 React Hooks Fixture
DESCRIPTION: CLI commands to set up, build, and lint the React Hooks ESLint fixture project using Yarn package manager
SOURCE: https://github.com/facebook/react/blob/main/fixtures/eslint-v8/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
cd fixtures/eslint-v8
yarn
yarn build
yarn lint
```

----------------------------------------

TITLE: React Component Entrypoint Fixture
DESCRIPTION: Test fixture defining the component function, initial parameters, and sequential render scenarios for testing
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/array-from-maybemutates-arg0.expect.md#2025-04-21_snippet_2

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 5}],
  sequentialRenders: [{value: 5}, {value: 6}, {value: 6}, {value: 7}],
};
```

----------------------------------------

TITLE: Displaying Improved DevTools Editing Interface in Markdown
DESCRIPTION: Demonstrates the improved parsing and editing capabilities for arrays and objects in React DevTools using GIF images.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md#2025-04-21_snippet_2

LANGUAGE: markdown
CODE:
```
###### Improved DevTools editing interface

**Improved parsing**
Value parsing logic has been relaxed so as to no longer require quotes around strings or double quotes:
![looser parsing logic](https://user-images.githubusercontent.com/29597/93407442-36504300-f860-11ea-90e8-5ad54c9b8b34.gif)

**Modifying arrays**
New values can be added to array props/state/hooks now. Existing values can also be deleted:
![adding and removing values from an array](https://user-images.githubusercontent.com/29597/93407457-3ea87e00-f860-11ea-8b85-a41904e6c25f.gif)

**Modifying objects**
New keys can be added to object props/state/hooks now. Existing keys can be renamed or deleted entirely:
![adding/renaming/removing object properties](https://user-images.githubusercontent.com/29597/93407464-449e5f00-f860-11ea-909b-49dafb56f6c5.gif)
```

----------------------------------------

TITLE: Defining a function with conditional logic in Javascript
DESCRIPTION: This code snippet defines a Javascript function named `foo` that takes four arguments and uses nested `if` statements to assign a value to `x` based on these arguments. The function is structured to intentionally avoid a phi node and create two distinct phis.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-sibling-phis.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo(a, b, c, d) {
  let x = 0;
  if (true) {
    if (true) {
      x = a;
    } else {
      x = b;
    }    
  } else {
    if (true) {
      x = c;
    } else {
      x = d;
    }
  }
  // note: intentionally no phi here so that there are two distinct phis above
}
```

----------------------------------------

TITLE: Optimizing a Recursive Function in JavaScript
DESCRIPTION: This optimized version of 'foo' replaces the immediately invoked function expression with a variable assignment. It stores the result of foo(x - 2) in variable t0 to avoid redundant calculations and improve performance.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/recursive-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
function foo(x) {
  if (x <= 0) {
    return 0;
  }
  let t0;
  t0 = foo(x - 2);
  return x + foo(x - 1) + t0;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [10],
};
```

----------------------------------------

TITLE: React Error: Invalid Hook Usage
DESCRIPTION: This error message indicates that a React hook is being referenced as a normal value rather than being called directly. It highlights line 2 of the component where the hook `useA` or `useB` is conditionally assigned to the variable `x`. The error suggests consulting the React documentation regarding rules for calling components and hooks.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-ternary-with-hook-values.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
1 | function Component(props) {
> 2 |   const x = props.cond ? useA : useB;
    |                          ^^^^ InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)

InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)

InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (2:2)

InvalidReact: Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values (3:3)
  3 |   return x();
  4 | }
  5 |
```

----------------------------------------

TITLE: Error reporting conflicting global variable
DESCRIPTION: This error message indicates that there is a naming conflict between a local variable named `__DEV__` defined within the `useFoo` function and a global variable with the same name. The error message specifies the line number and column where the conflict occurs and indicates that the local binding of `__DEV__` is causing the problem. This type of error is important to identify and resolve to avoid unexpected behavior during development and production.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.emit-freeze-conflicting-global.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  1 | // @enableEmitFreeze @instrumentForget
  2 | function useFoo(props) {
> 3 |   const __DEV__ = 'conflicting global';
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Todo: Encountered conflicting global in generated program. Conflict from local binding __DEV__ (3:3)
  4 |   console.log(__DEV__);
  5 |   return foo(props.x);
  6 | }

```

----------------------------------------

TITLE: React Error Message for Invalid Hook Call
DESCRIPTION: This snippet shows the error message produced by React when a Hook is called conditionally, violating the Rules of Hooks. The error indicates that Hooks must always be called in a consistent order. The message also provides a link to the React documentation explaining the Rules of Hooks in more detail.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/rules-of-hooks/error.invalid-rules-of-hooks-ea7c2fb545a9.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
   5 | function useHookWithConditionalHook() {
   6 |   if (cond) {
>  7 |     useConditionalHook();
     |     ^^^^^^^^^^^^^^^^^^ InvalidReact: Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning) (7:7)
   8 |   }
   9 | }
  10 |
```

----------------------------------------

TITLE: Extracting Error Codes with Node.js Script
DESCRIPTION: Node.js script that traverses React codebase and updates error codes JSON file. Requires build artifacts and supports partial builds.
SOURCE: https://github.com/facebook/react/blob/main/scripts/error-codes/README.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
// extract-errors.js
const traverseCodebase = () => {
  // Crawl build artifacts
  // Update codes.json
}
```

----------------------------------------

TITLE: Publish Experimental Release Script
DESCRIPTION: This script publishes an experimental release to NPM with the `experimental` tag. It's used after the experimental release has been prepared using `prepare-release-from-ci`. The `experimental` tag ensures that consumers can specifically opt into using the experimental release.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_3

LANGUAGE: shell
CODE:
```
scripts/release/publish.js --tags experimental
```

----------------------------------------

TITLE: Original React Component Implementation
DESCRIPTION: React component that uses useMemo to cache computed values and handle array operations. Takes array props and a boolean flag to determine concatenation behavior.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/useMemo-reordering-depslist-controlflow.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import {useMemo} from 'react';
import {Stringify} from 'shared-runtime';

function Foo({arr1, arr2, foo}) {
  const x = [arr1];

  let y = [];

  const val1 = useMemo(() => {
    return {x: 2};
  }, []);

  const val2 = useMemo(() => {
    return [y];
  }, [foo ? (y = x.concat(arr2)) : y]);

  return <Stringify val1={val1} val2={val2} />;
}

export const FIXTURE_ENTRYPOINT = {
  fn: Foo,
  params: [{arr1: [1, 2], arr2: [3, 4], foo: true}],
  sequentialRenders: [
    {arr1: [1, 2], arr2: [3, 4], foo: true},
    {arr1: [1, 2], arr2: [3, 4], foo: false},
  ],
};
```

----------------------------------------

TITLE: Prepare Release from CI Script
DESCRIPTION: This script downloads pre-built release artifacts from CI (e.g., CircleCI) for a specific commit. It is used in the process of publishing either a 'next' or 'experimental' release.  Before publishing, manual testing is recommended after running this script to verify the build.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_0

LANGUAGE: shell
CODE:
```
scripts/release/prepare-release-from-ci.js -r stable --commit=0e526bc
```

----------------------------------------

TITLE: Demonstrating Function Hoisting in JavaScript
DESCRIPTION: This snippet showcases hoisting with nested functions in JavaScript. It includes a main function 'hoisting' which demonstrates how nested functions like 'bar' and 'baz' have their declarations and values hoisted. The snippet also includes an export for use as a module entry point. It requires a JavaScript runtime to execute, with no specific version dependencies. Parameters and inputs are nil, while output is governed by hoisting mechanics.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.hoisting-simple-function-declaration.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function hoisting() {
  function bar() {
    return x;
  }
  return baz(); // OK: FuncDecls are HoistableDeclarations that have both declaration and value hoisting
  function baz() {
    return bar();
  }
}

export const FIXTURE_ENTRYPOINT = {
  fn: hoisting,
  params: [],
  isComponent: false,
};

```

----------------------------------------

TITLE: Switch Statement Implementation in JavaScript
DESCRIPTION: This JavaScript code defines a function 'foo' that uses a switch statement to modify the value of a variable 'x'. The switch statement evaluates the value of 'x' and increments it based on the matching case.  The 'FIXTURE_ENTRYPOINT' exports the 'foo' function.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/ssa-switch.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
function foo() {
  let x = 1;

  switch (x) {
    case 1: {
      x = x + 1;
      break;
    }
    case 2: {
      x = x + 2;
      break;
    }
    default: {
      x = x + 3;
    }
  }

  let y = x;
}

export const FIXTURE_ENTRYPOINT = {
  fn: foo,
  params: [],
  isComponent: false,
};
```

----------------------------------------

TITLE: React Error for Accessing Ref During Render
DESCRIPTION: The error message generated when trying to access and modify a ref value during the render phase. React prohibits accessing ref.current during render as it violates the principles of pure rendering functions.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-useCallback-set-ref-nested-property-ref-modified-later-preserve-memoization.expect.md#2025-04-21_snippet_1

LANGUAGE: plaintext
CODE:
```
  12 |
  13 |   // The ref is modified later, extending its range and preventing memoization of onChange
> 14 |   ref.current.inner = null;
     |   ^^^^^^^^^^^ InvalidReact: Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef) (14:14)
  15 |
  16 |   return <input onChange={onChange} />;
  17 | }
```

----------------------------------------

TITLE: Installing React Compiler Playground Dependencies
DESCRIPTION: Commands for building React Compiler from source and installing Playground dependencies using either yarn or npm package managers.
SOURCE: https://github.com/facebook/react/blob/main/compiler/apps/playground/README.md#2025-04-21_snippet_0

LANGUAGE: sh
CODE:
```
# Build React Compiler from source and install Playground dependencies.
$ yarn

# Or similarly
$ npm install
```

----------------------------------------

TITLE: Git Push for Patch Release
DESCRIPTION: This command pushes the patch release branch to the remote repository. This allows CI systems to build the release. `origin 16.8.3` pushes branch `16.8.3` to remote `origin`.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_8

LANGUAGE: shell
CODE:
```
git push origin 16.8.3
```

----------------------------------------

TITLE: Prepare Release from CI Example
DESCRIPTION: This command downloads the artifacts from Circle CI for the commit `0e526bc`. It is preparing a stable release, as specified by the `-r stable` flag. This will download artifacts to prepare for a publish.
SOURCE: https://github.com/facebook/react/blob/main/scripts/release/README.md#2025-04-21_snippet_10

LANGUAGE: shell
CODE:
```
scripts/release/prepare-release-from-ci.js --commit=0e526bc -r stable
```

----------------------------------------

TITLE: FIXTURE_ENTRYPOINT Configuration for Component Test
DESCRIPTION: Defines a test fixture for the React component, specifying the component function and test parameters with a sample value of 42.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-computed-key-modified-during-after-construction-sequence-expr.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: Component,
  params: [{value: 42}],
};
```

----------------------------------------

TITLE: Using React Compiler Test Hook in JavaScript
DESCRIPTION: This snippet demonstrates how to import and use a specific hook from the ReactCompilerTest library within a functional React component. It exhibits an invalid type configuration for the intended hook usage, highlighting a mismatch between expected and actual types.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.invalid-type-provider-hook-name-not-typed-as-hook-namespace.expect.md#2025-04-21_snippet_0

LANGUAGE: javascript
CODE:
```
import ReactCompilerTest from 'ReactCompilerTest';

function Component() {
  return ReactCompilerTest.useHookNotTypedAsHook();
}

```

LANGUAGE: javascript
CODE:
```
```
  2 |
  3 | function Component() {
> 4 |   return ReactCompilerTest.useHookNotTypedAsHook();
    |          ^^^^^^^^^^^^^^^^^ InvalidConfig: Invalid type configuration for module. Expected type for object property 'useHookNotTypedAsHook' from module 'ReactCompilerTest' to be a hook based on the property name (4:4)
  5 | }
  6 |
```

----------------------------------------

TITLE: Compiler Error with Object Getter Functions
DESCRIPTION: An error message from the React compiler showing that it's unable to handle getter functions in ObjectExpression. The error points to the getter definition in the component code.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/error.todo-object-expression-get-syntax.expect.md#2025-04-21_snippet_1

LANGUAGE: text
CODE:
```
  1 | function Component({value}) {
  2 |   const object = {
> 3 |     get value() {
    |     ^^^^^^^^^^^^^
> 4 |       return value;
    | ^^^^^^^^^^^^^^^^^^^
> 5 |     },
    | ^^^^^^ Todo: (BuildHIR::lowerExpression) Handle get functions in ObjectExpression (3:5)
  6 |   };
  7 |   return <div>{object.value}</div>;
  8 | }
```

----------------------------------------

TITLE: Deprecated React API Removal
DESCRIPTION: This snippet highlights the removal of the `React.autoBind` API in React version 0.5.0. The API was previously deprecated in version 0.4, and this change ensures its complete removal from the codebase, maintaining API consistency.
SOURCE: https://github.com/facebook/react/blob/main/CHANGELOG.md#2025-04-21_snippet_23

LANGUAGE: none
CODE:
```
"Removed `React.autoBind` - This was deprecated in v0.4 and now properly removed."
```

----------------------------------------

TITLE: Exporting Fixture Entrypoint for React Component Testing in JavaScript
DESCRIPTION: This snippet exports a constant FIXTURE_ENTRYPOINT object that defines a test fixture for the component. It includes the component function, parameters, and specifies the component name for testing purposes.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/logical-expression.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
export const FIXTURE_ENTRYPOINT = {
  fn: component,
  params: ['TodoAdd'],
  isComponent: 'TodoAdd',
};
```

----------------------------------------

TITLE: React useMemo Error Message
DESCRIPTION: Error message indicating an invalid usage of useMemo hook. The error suggests that the first argument must be an inline function expression, which is not present in the current implementation.
SOURCE: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/__tests__/fixtures/compiler/preserve-memo-validation/error.validate-useMemo-named-function.expect.md#2025-04-21_snippet_1

LANGUAGE: javascript
CODE:
```
InvalidReact: Expected the first argument to be an inline function expression (9:9)
```

----------------------------------------

TITLE: Basic Markdown Link to React Contribution Guide
DESCRIPTION: A Markdown link that directs users to React's comprehensive contribution documentation.
SOURCE: https://github.com/facebook/react/blob/main/CONTRIBUTING.md#2025-04-21_snippet_0

LANGUAGE: markdown
CODE:
```
[contribution guide](https://reactjs.org/docs/how-to-contribute.html)
```

----------------------------------------

TITLE: Building the Extension Using Node.js
DESCRIPTION: This snippet describes the command used to build the Microsoft Edge extension from its source code. Required dependencies include Node.js and a proper environment setup for building JavaScript projects.
SOURCE: https://github.com/facebook/react/blob/main/packages/react-devtools-extensions/edge/README.md#2025-04-21_snippet_0

LANGUAGE: bash
CODE:
```
node build
```

----------------------------------------

TITLE: Getting Performance Metrics with PerfCounters in Node.js
DESCRIPTION: This snippet initializes the PerfCounters library and captures performance metrics at the start and end of a test. It logs the performance data to the console for analysis. The expected outputs include counts of instructions, loads, and stores before and after executing certain operations, which can help in performance evaluation.
SOURCE: https://github.com/facebook/react/blob/main/scripts/perf-counters/README.md#2025-04-21_snippet_0

LANGUAGE: JavaScript
CODE:
```
$ node
> var PerfCounters = require('perf-counters');
> PerfCounters.init();
> var start = PerfCounters.getCounters(); console.log('test'); var end = PerfCounters.getCounters();
test
> start
{ instructions: 1382, loads: 421, stores: 309 }
> end
{ instructions: 647633, loads: 195771, stores: 133246 }
>
```